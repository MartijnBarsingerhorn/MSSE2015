/*
	M.Barsingerhorn - Master Project UVA SE 2015

	Delphi Grammar Tests - Diverse Constructs (parse & implode)

*/

module TestCases_1

// --------------------------------------------------

import DelphiGrammar;
import DelphiAst;
import IO;
import ParseTree;
import Set;

// --------------------------------------------------

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Comment_000()
{
    return parse(#DelphiGrammar::Comment, "// the quick brown fox jumps over the lazy dog.");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Comment_001()
{
    return parse(#DelphiGrammar::Comment, "// )(*&^%$#@!{(*");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Comment_002()
{
    return parse(#DelphiGrammar::Comment, "(* the quick brown fox jumps over the lazy dog. *)");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Comment_003()
{
    return parse(#DelphiGrammar::Comment, "(* (* (* * ) { } the quick brown fox jumps over the lazy dog *)");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Comment_004()
{
    return parse(#DelphiGrammar::Comment, "{ the quick brown fox jumps over the lazy dog }");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Comment_005()
{
    return parse(#DelphiGrammar::Comment, "{ { (* *) the quick brown fox }");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Comment_000()
{
    return parse(#DelphjiGrammar::Comment, "(* the quick brown fox jumps over the lazy *) dog");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Comment_001()
{
    return parse(#DelphjiGrammar::Comment, "(* the quick brown fox jumps over the lazy dog");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Comment_002()
{
    return parse(#DelphjiGrammar::Comment, "{ the quick brown fox jumps over } the lazy dog");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Comment_003()
{
    return parse(#DelphjiGrammar::Comment, "{ the quick brown fox jumps over the lazy dog");
}

test bool Test_TestCases_1_Comment()
{
    print("Running 10 tests for construction \'Comment\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "// the quick brown fox jumps over the lazy dog.",
// Sentence 001
                  "// )(*&^%$#@!{(*",
// Sentence 002
                  "(* the quick brown fox jumps over the lazy dog. *)",
// Sentence 003
                  "(* (* (* * ) { } the quick brown fox jumps over the lazy dog *)",
// Sentence 004
                  "{ the quick brown fox jumps over the lazy dog }",
// Sentence 005
                  "{ { (* *) the quick brown fox }"
                 ];

    // Patterns that must fail
    failSet = [
// Sentence 000
                  "(* the quick brown fox jumps over the lazy *) dog",
// Sentence 001
                  "(* the quick brown fox jumps over the lazy dog",
// Sentence 002
                  "{ the quick brown fox jumps over } the lazy dog",
// Sentence 003
                  "{ the quick brown fox jumps over the lazy dog"
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..6])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::Comment, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..4])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::Comment, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_EndOfFile_000()
{
    return parse(#DelphiGrammar::EndOfFile, "");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_EndOfFile_000()
{
    return parse(#DelphjiGrammar::EndOfFile, "![]");
}

test bool Test_TestCases_1_EndOfFile()
{
    print("Running 2 tests for construction \'EndOfFile\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  ""
                 ];

    // Patterns that must fail
    failSet = [
// Sentence 000
                  "![]"
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..1])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::EndOfFile, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..1])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::EndOfFile, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Ident_000()
{
    return parse(#DelphiGrammar::Ident, "variable1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Ident_001()
{
    return parse(#DelphiGrammar::Ident, "variable1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Ident_002()
{
    return parse(#DelphiGrammar::Ident, "var_1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Ident_003()
{
    return parse(#DelphiGrammar::Ident, "var_1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Ident_004()
{
    return parse(#DelphiGrammar::Ident, "variable1234567890____a");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_000()
{
    return parse(#DelphjiGrammar::Ident, "var-1");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_001()
{
    return parse(#DelphjiGrammar::Ident, "var/1");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_002()
{
    return parse(#DelphjiGrammar::Ident, "var*1_");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_003()
{
    return parse(#DelphjiGrammar::Ident, "absolute");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_004()
{
    return parse(#DelphjiGrammar::Ident, "and");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_005()
{
    return parse(#DelphjiGrammar::Ident, "ansistring");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_006()
{
    return parse(#DelphjiGrammar::Ident, "array");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_007()
{
    return parse(#DelphjiGrammar::Ident, "as");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_008()
{
    return parse(#DelphjiGrammar::Ident, "asm");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_009()
{
    return parse(#DelphjiGrammar::Ident, "begin");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_010()
{
    return parse(#DelphjiGrammar::Ident, "case");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_011()
{
    return parse(#DelphjiGrammar::Ident, "class");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_012()
{
    return parse(#DelphjiGrammar::Ident, "const");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_013()
{
    return parse(#DelphjiGrammar::Ident, "constructor");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_014()
{
    return parse(#DelphjiGrammar::Ident, "destructor");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_015()
{
    return parse(#DelphjiGrammar::Ident, "dispinterface");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_016()
{
    return parse(#DelphjiGrammar::Ident, "div");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_017()
{
    return parse(#DelphjiGrammar::Ident, "do");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_018()
{
    return parse(#DelphjiGrammar::Ident, "downto");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_019()
{
    return parse(#DelphjiGrammar::Ident, "else");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_020()
{
    return parse(#DelphjiGrammar::Ident, "end");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_021()
{
    return parse(#DelphjiGrammar::Ident, "except");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_022()
{
    return parse(#DelphjiGrammar::Ident, "exports");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_023()
{
    return parse(#DelphjiGrammar::Ident, "file");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_024()
{
    return parse(#DelphjiGrammar::Ident, "for");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_025()
{
    return parse(#DelphjiGrammar::Ident, "finalization");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_026()
{
    return parse(#DelphjiGrammar::Ident, "finally");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_027()
{
    return parse(#DelphjiGrammar::Ident, "function");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_028()
{
    return parse(#DelphjiGrammar::Ident, "goto");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_029()
{
    return parse(#DelphjiGrammar::Ident, "if");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_030()
{
    return parse(#DelphjiGrammar::Ident, "implementation");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_031()
{
    return parse(#DelphjiGrammar::Ident, "in");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_032()
{
    return parse(#DelphjiGrammar::Ident, "inherited");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_033()
{
    return parse(#DelphjiGrammar::Ident, "inline");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_034()
{
    return parse(#DelphjiGrammar::Ident, "initialization");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_035()
{
    return parse(#DelphjiGrammar::Ident, "interface");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_036()
{
    return parse(#DelphjiGrammar::Ident, "is");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_037()
{
    return parse(#DelphjiGrammar::Ident, "label");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_038()
{
    return parse(#DelphjiGrammar::Ident, "library");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_039()
{
    return parse(#DelphjiGrammar::Ident, "mod");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_040()
{
    return parse(#DelphjiGrammar::Ident, "nil");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_041()
{
    return parse(#DelphjiGrammar::Ident, "not");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_042()
{
    return parse(#DelphjiGrammar::Ident, "object");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_043()
{
    return parse(#DelphjiGrammar::Ident, "of");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_044()
{
    return parse(#DelphjiGrammar::Ident, "on");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_045()
{
    return parse(#DelphjiGrammar::Ident, "operator");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_046()
{
    return parse(#DelphjiGrammar::Ident, "or");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_047()
{
    return parse(#DelphjiGrammar::Ident, "out");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_048()
{
    return parse(#DelphjiGrammar::Ident, "packed");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_049()
{
    return parse(#DelphjiGrammar::Ident, "procedure");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_050()
{
    return parse(#DelphjiGrammar::Ident, "program");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_051()
{
    return parse(#DelphjiGrammar::Ident, "property");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_052()
{
    return parse(#DelphjiGrammar::Ident, "raise");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_053()
{
    return parse(#DelphjiGrammar::Ident, "record");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_054()
{
    return parse(#DelphjiGrammar::Ident, "resourcestring");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_055()
{
    return parse(#DelphjiGrammar::Ident, "reintroduce");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_056()
{
    return parse(#DelphjiGrammar::Ident, "repeat");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_057()
{
    return parse(#DelphjiGrammar::Ident, "self");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_058()
{
    return parse(#DelphjiGrammar::Ident, "set");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_059()
{
    return parse(#DelphjiGrammar::Ident, "shl");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_060()
{
    return parse(#DelphjiGrammar::Ident, "shr");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_061()
{
    return parse(#DelphjiGrammar::Ident, "string");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_062()
{
    return parse(#DelphjiGrammar::Ident, "then");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_063()
{
    return parse(#DelphjiGrammar::Ident, "to");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_064()
{
    return parse(#DelphjiGrammar::Ident, "type");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_065()
{
    return parse(#DelphjiGrammar::Ident, "threadvar");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_066()
{
    return parse(#DelphjiGrammar::Ident, "try");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_067()
{
    return parse(#DelphjiGrammar::Ident, "unit");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_068()
{
    return parse(#DelphjiGrammar::Ident, "until");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_069()
{
    return parse(#DelphjiGrammar::Ident, "uses");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_070()
{
    return parse(#DelphjiGrammar::Ident, "var");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_071()
{
    return parse(#DelphjiGrammar::Ident, "while");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_072()
{
    return parse(#DelphjiGrammar::Ident, "widestring");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_073()
{
    return parse(#DelphjiGrammar::Ident, "with");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_Ident_074()
{
    return parse(#DelphjiGrammar::Ident, "xor");
}

test bool Test_TestCases_1_Ident()
{
    print("Running 80 tests for construction \'Ident\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "variable1",
// Sentence 001
                  "variable1",
// Sentence 002
                  "var_1",
// Sentence 003
                  "var_1",
// Sentence 004
                  "variable1234567890____a"
                 ];

    // Patterns that must fail
    failSet = [
// Sentence 000
                  "var-1",
// Sentence 001
                  "var/1",
// Sentence 002
                  "var*1_",
// Sentence 003
                  "absolute",
// Sentence 004
                  "and",
// Sentence 005
                  "ansistring",
// Sentence 006
                  "array",
// Sentence 007
                  "as",
// Sentence 008
                  "asm",
// Sentence 009
                  "begin",
// Sentence 010
                  "case",
// Sentence 011
                  "class",
// Sentence 012
                  "const",
// Sentence 013
                  "constructor",
// Sentence 014
                  "destructor",
// Sentence 015
                  "dispinterface",
// Sentence 016
                  "div",
// Sentence 017
                  "do",
// Sentence 018
                  "downto",
// Sentence 019
                  "else",
// Sentence 020
                  "end",
// Sentence 021
                  "except",
// Sentence 022
                  "exports",
// Sentence 023
                  "file",
// Sentence 024
                  "for",
// Sentence 025
                  "finalization",
// Sentence 026
                  "finally",
// Sentence 027
                  "function",
// Sentence 028
                  "goto",
// Sentence 029
                  "if",
// Sentence 030
                  "implementation",
// Sentence 031
                  "in",
// Sentence 032
                  "inherited",
// Sentence 033
                  "inline",
// Sentence 034
                  "initialization",
// Sentence 035
                  "interface",
// Sentence 036
                  "is",
// Sentence 037
                  "label",
// Sentence 038
                  "library",
// Sentence 039
                  "mod",
// Sentence 040
                  "nil",
// Sentence 041
                  "not",
// Sentence 042
                  "object",
// Sentence 043
                  "of",
// Sentence 044
                  "on",
// Sentence 045
                  "operator",
// Sentence 046
                  "or",
// Sentence 047
                  "out",
// Sentence 048
                  "packed",
// Sentence 049
                  "procedure",
// Sentence 050
                  "program",
// Sentence 051
                  "property",
// Sentence 052
                  "raise",
// Sentence 053
                  "record",
// Sentence 054
                  "resourcestring",
// Sentence 055
                  "reintroduce",
// Sentence 056
                  "repeat",
// Sentence 057
                  "self",
// Sentence 058
                  "set",
// Sentence 059
                  "shl",
// Sentence 060
                  "shr",
// Sentence 061
                  "string",
// Sentence 062
                  "then",
// Sentence 063
                  "to",
// Sentence 064
                  "type",
// Sentence 065
                  "threadvar",
// Sentence 066
                  "try",
// Sentence 067
                  "unit",
// Sentence 068
                  "until",
// Sentence 069
                  "uses",
// Sentence 070
                  "var",
// Sentence 071
                  "while",
// Sentence 072
                  "widestring",
// Sentence 073
                  "with",
// Sentence 074
                  "xor"
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..5])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::Ident, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..75])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::Ident, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_LayoutLexical_000()
{
    return parse(#DelphiGrammar::LayoutLexical, "");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_LayoutLexical_001()
{
    return parse(#DelphiGrammar::LayoutLexical, "	  {the quick brown fox} (*the quick brown fox *) // the quick brown fox   ");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_LayoutLexical_002()
{
    return parse(#DelphiGrammar::LayoutLexical, "	{the quick brown fox}(*jumps over*)//the lazy dog");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_LayoutLexical_003()
{
    return parse(#DelphiGrammar::LayoutLexical, "		   	{the quick brown f	ox jumps over the lazy dog	} ");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_LayoutLexical_004()
{
    return parse(#DelphiGrammar::LayoutLexical, "      // ar : integer ");
}

test bool Test_TestCases_1_LayoutLexical()
{
    print("Running 5 tests for construction \'LayoutLexical\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "",
// Sentence 001
                  "	  {the quick brown fox} (*the quick brown fox *) // the quick brown fox   ",
// Sentence 002
                  "	{the quick brown fox}(*jumps over*)//the lazy dog",
// Sentence 003
                  "		   	{the quick brown f	ox jumps over the lazy dog	} ",
// Sentence 004
                  "      // ar : integer "
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..5])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::LayoutLexical, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::LayoutLexical, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_000()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_001()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_002()
{
    return parse(#DelphiGrammar::QualifiedIdent, "var_1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_003()
{
    return parse(#DelphiGrammar::QualifiedIdent, "var_1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_004()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable1234567890____a");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_005()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.absolute");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_006()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.and");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_007()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.ansistring");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_008()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.array");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_009()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.as");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_010()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.asm");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_011()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.begin");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_012()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.case");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_013()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.class");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_014()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.const");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_015()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.constructor");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_016()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.destructor");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_017()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.dispinterface");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_018()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.div");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_019()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.do");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_020()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.downto");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_021()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.else");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_022()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_023()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.except");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_024()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.exports");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_025()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.file");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_026()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.for");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_027()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.finalization");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_028()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.finally");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_029()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.function");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_030()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.goto");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_031()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.if");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_032()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.implementation");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_033()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.in");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_034()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.inherited");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_035()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.inline");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_036()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.initialization");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_037()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.interface");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_038()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.is");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_039()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.label");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_040()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.library");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_041()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.mod");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_042()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.nil");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_043()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.not");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_044()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.object");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_045()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.of");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_046()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.on");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_047()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.operator");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_048()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.or");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_049()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.out");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_050()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.packed");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_051()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.procedure");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_052()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.program");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_053()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.property");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_054()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.raise");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_055()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.record");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_056()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.resourcestring");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_057()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.reintroduce");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_058()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.repeat");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_059()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.self");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_060()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.set");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_061()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.shl");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_062()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.shr");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_063()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.string");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_064()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.then");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_065()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.to");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_066()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.type");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_067()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.threadvar");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_068()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.try");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_069()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.unit");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_070()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.until");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_071()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.uses");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_072()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.var");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_073()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.while");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_074()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.widestring");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_075()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.with");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_QualifiedIdent_076()
{
    return parse(#DelphiGrammar::QualifiedIdent, "variable_13.xor");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_QualifiedIdent_000()
{
    return parse(#DelphjiGrammar::QualifiedIdent, "variable_13.var-1");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_QualifiedIdent_001()
{
    return parse(#DelphjiGrammar::QualifiedIdent, "variable_13.var/1");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_QualifiedIdent_002()
{
    return parse(#DelphjiGrammar::QualifiedIdent, "variable_13.var*1_");
}

test bool Test_TestCases_1_QualifiedIdent()
{
    print("Running 80 tests for construction \'QualifiedIdent\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "variable1",
// Sentence 001
                  "variable1",
// Sentence 002
                  "var_1",
// Sentence 003
                  "var_1",
// Sentence 004
                  "variable1234567890____a",
// Sentence 005
                  "variable_13.absolute",
// Sentence 006
                  "variable_13.and",
// Sentence 007
                  "variable_13.ansistring",
// Sentence 008
                  "variable_13.array",
// Sentence 009
                  "variable_13.as",
// Sentence 010
                  "variable_13.asm",
// Sentence 011
                  "variable_13.begin",
// Sentence 012
                  "variable_13.case",
// Sentence 013
                  "variable_13.class",
// Sentence 014
                  "variable_13.const",
// Sentence 015
                  "variable_13.constructor",
// Sentence 016
                  "variable_13.destructor",
// Sentence 017
                  "variable_13.dispinterface",
// Sentence 018
                  "variable_13.div",
// Sentence 019
                  "variable_13.do",
// Sentence 020
                  "variable_13.downto",
// Sentence 021
                  "variable_13.else",
// Sentence 022
                  "variable_13.end",
// Sentence 023
                  "variable_13.except",
// Sentence 024
                  "variable_13.exports",
// Sentence 025
                  "variable_13.file",
// Sentence 026
                  "variable_13.for",
// Sentence 027
                  "variable_13.finalization",
// Sentence 028
                  "variable_13.finally",
// Sentence 029
                  "variable_13.function",
// Sentence 030
                  "variable_13.goto",
// Sentence 031
                  "variable_13.if",
// Sentence 032
                  "variable_13.implementation",
// Sentence 033
                  "variable_13.in",
// Sentence 034
                  "variable_13.inherited",
// Sentence 035
                  "variable_13.inline",
// Sentence 036
                  "variable_13.initialization",
// Sentence 037
                  "variable_13.interface",
// Sentence 038
                  "variable_13.is",
// Sentence 039
                  "variable_13.label",
// Sentence 040
                  "variable_13.library",
// Sentence 041
                  "variable_13.mod",
// Sentence 042
                  "variable_13.nil",
// Sentence 043
                  "variable_13.not",
// Sentence 044
                  "variable_13.object",
// Sentence 045
                  "variable_13.of",
// Sentence 046
                  "variable_13.on",
// Sentence 047
                  "variable_13.operator",
// Sentence 048
                  "variable_13.or",
// Sentence 049
                  "variable_13.out",
// Sentence 050
                  "variable_13.packed",
// Sentence 051
                  "variable_13.procedure",
// Sentence 052
                  "variable_13.program",
// Sentence 053
                  "variable_13.property",
// Sentence 054
                  "variable_13.raise",
// Sentence 055
                  "variable_13.record",
// Sentence 056
                  "variable_13.resourcestring",
// Sentence 057
                  "variable_13.reintroduce",
// Sentence 058
                  "variable_13.repeat",
// Sentence 059
                  "variable_13.self",
// Sentence 060
                  "variable_13.set",
// Sentence 061
                  "variable_13.shl",
// Sentence 062
                  "variable_13.shr",
// Sentence 063
                  "variable_13.string",
// Sentence 064
                  "variable_13.then",
// Sentence 065
                  "variable_13.to",
// Sentence 066
                  "variable_13.type",
// Sentence 067
                  "variable_13.threadvar",
// Sentence 068
                  "variable_13.try",
// Sentence 069
                  "variable_13.unit",
// Sentence 070
                  "variable_13.until",
// Sentence 071
                  "variable_13.uses",
// Sentence 072
                  "variable_13.var",
// Sentence 073
                  "variable_13.while",
// Sentence 074
                  "variable_13.widestring",
// Sentence 075
                  "variable_13.with",
// Sentence 076
                  "variable_13.xor"
                 ];

    // Patterns that must fail
    failSet = [
// Sentence 000
                  "variable_13.var-1",
// Sentence 001
                  "variable_13.var/1",
// Sentence 002
                  "variable_13.var*1_"
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..77])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::QualifiedIdent, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..3])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::QualifiedIdent, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_String_000()
{
    return parse(#DelphiGrammar::String, "\'testa\'#201#13#1\'testb\'");
}

test bool Test_TestCases_1_String()
{
    print("Running 1 tests for construction \'String\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "\'testa\'#201#13#1\'testb\'"
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..1])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::String, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::String, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_ClassType_000()
{
    return parse(#DelphiGrammar::ClassType, "class public a : integer; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_ClassType_001()
{
    return parse(#DelphiGrammar::ClassType, "class a : integer; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_ClassType_002()
{
    return parse(#DelphiGrammar::ClassType, "class public  end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_ClassType_003()
{
    return parse(#DelphiGrammar::ClassType, "class end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_ClassType_004()
{
    return parse(#DelphiGrammar::ClassType, "class public public private protected published a : integer; end");
}

test bool Test_TestCases_1_ClassType()
{
    print("Running 5 tests for construction \'ClassType\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "class public a : integer; end",
// Sentence 001
                  "class a : integer; end",
// Sentence 002
                  "class public  end",
// Sentence 003
                  "class end",
// Sentence 004
                  "class public public private protected published a : integer; end"
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..5])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::ClassType, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::ClassType, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::ClassType, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Expression_000()
{
    return parse(#DelphiGrammar::Expression, "(sender as tmenuitem).checked");
}

test bool Test_TestCases_1_Expression()
{
    print("Running 1 tests for construction \'Expression\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "(sender as tmenuitem).checked"
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..1])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::Expression, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::Expression, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::Expression, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_000()
{
    return parse(#DelphiGrammar::MethodImplementation, "function fixscanurl (orgurl: string) : string;
                  var
                    newurl : string;
                  begin
                    newurl := orgurl;
                    result := newurl;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_001()
{
    return parse(#DelphiGrammar::MethodImplementation, "function rightdelimitedstr (s: string; delimitors: string): string;
                  begin
                    result := rightstr(s, length(s)-lastdelimiter(delimitors, s));
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_002()
{
    return parse(#DelphiGrammar::MethodImplementation, "function safestrtofloat(s: string; fdef: single): single;
                  begin
                    if (s = \'\') or (s = \'-\') then
                      result := fdef
                    else
                      try
                        result := strtofloat(s);
                      except
                        result := fdef;
                      end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_003()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure transformtostring(t : ttransform; var s: string);
                  var i,j : integer;
                  begin
                    s := \'\';
                    for i:=0 to t.dimensions[0]-1 do
                    begin
                      for j:=0 to t.dimensions[1]-1 do
                      begin
                        s := s + format(\'%9.4f\', [t.getvalue([i,j])]);
                        if (i\<\> t.dimensions[0]-1) or (j \<\> t.dimensions[1]-1) then s := s + \',\';
                      end;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_004()
{
    return parse(#DelphiGrammar::MethodImplementation, "function stringtotransform(s : string; var t : ttransform): boolean;
                  var i,j : integer;
                  begin
                    for i:=0 to t.dimensions[0]-1 do
                    begin
                      for j:=0 to t.dimensions[1]-1 do
                      begin
                        t.setvalue([i,j], valuefromstr(s,i*4+j+1));
                      end;
                    end;
                    result := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_005()
{
    return parse(#DelphiGrammar::MethodImplementation, "function writematrix(t: tavsfield; points: boolean): string;
                  var i, j: integer;
                  begin
                    result := \'\';
                    if points then
                    begin
                      for i:=0 to t.dimensions[0]-1 do
                      begin
                        for j:=0 to t.nspace-1 do
                        begin
                          result := result + format(\'%9.4f\', [t.coordinate[j, i]]);
                          if j \<\> t.nspace-1 then result := result + \'  \'
                          else                    result := result + #13 + #10;
                        end;
                      end;
                      exit;
                    end;
                    if t.ndim=2 then
                    begin
                      for i:=0 to t.dimensions[1]-1 do
                      begin
                        for j:=0 to t.dimensions[0]-1 do
                        begin
                          if (t.datatype=3) or (t.datatype=4) then
                            result := result + format(\'%9.4f\', [t.getvalue([i,j])])
                          else
                            result := result + format(\'%9d\', [round(t.getvalue([i,j]))]);
                          if j \<\> t.dimensions[0]-1 then result := result + \'  \'
                          else                           result := result + #13 + #10;
                        end;
                      end;
                    end
                    else if t.ndim=1 then
                    begin
                      for i:=0 to t.dimensions[0]-1 do
                      begin
                        if (t.datatype=3) or (t.datatype=4) then
                          result := result + format(\'%9.4f\', [t.getvalue([i])])
                        else
                          result := result + format(\'%9d\', [round(t.getvalue([i]))]);
                        if i \<\> t.dimensions[0]-1 then result := result + \'  \'
                        else                           result := result + #13 + #10;
                      end;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_006()
{
    return parse(#DelphiGrammar::MethodImplementation, "function valuefromstr(str: string; n: integer; fdef: single=0.0) : single;
                  var
                    i,j,k : integer;
                  begin
                    j := 1;
                    while (j \<= length(str)) and (not (ansichar(str[j]) in [\'0\'..\'9\',\'+\',\'-\',\'.\'])) do j := j+1;
                    result := fdef;
                    for i:=1 to n do
                      begin
                        k := j;
                        while (k \<= length(str)) and ((ansichar(str[k]) in [\'0\'..\'9\',\'+\',\'-\',\'.\',\'e\',\'e\'])) do k := k+1;
                        result := safestrtofloat(copy(str, j, k-j), fdef);
                        j := k+1;
                        while (j \<= length(str)) and (not (ansichar(str[j]) in [\'0\'..\'9\',\'+\',\'-\',\'.\'])) do j := j+1;
                      end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_007()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure setstrictdelimitedtext(const value: string; delimiter: char;
                    quotechar: char; strings: tstrings);
                  var
                    p, p1: pchar;
                    s: string;
                  begin
                    try
                      strings.clear;
                      p := pchar(value);
                      while p^ \<\> #0 do
                      begin
                        if p^ = quotechar then
                          s := ansiextractquotedstr(p, quotechar)
                        else
                        begin
                          p1 := p;
                          while (p^ \<\> #0) and (p^ \<\> delimiter) do
                            p := charnext(p);
                          setstring(s, p1, p - p1);
                        end;
                        strings.add(s);
                        if p^ = delimiter then
                        begin
                          p1 := p;
                          if charnext(p1)^ = #0 then
                            strings.add(\'\');
                          p := charnext(p);
                        end;
                      end;
                    finally
                      strings.endupdate;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_008()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure applyfilter(dataset: tabstractdataset; tablename: string;
                    fieldnames: string; fieldvalues: string);
                  var
                    table: tabstracttable;
                    query: tabstractquery;
                    slnames: tstringlist;
                    slvalues: tstringlist;
                    i: integer;
                    whereclause: string;
                    newquery: string;
                  begin
                    if pos(\';\', fieldnames)\>0 then
                    begin
                      slnames := tstringlist.create;
                      slvalues := tstringlist.create;
                      try
                        slnames.delimiter := \';\';
                        slnames.strictdelimiter := true;
                        slvalues.delimiter := chr(256);
                        slvalues.strictdelimiter := true;
                        slnames.delimitedtext := fieldnames;
                        slvalues.delimitedtext := fieldvalues;
                        if slnames.count\<\>slvalues.count then
                          raise exception.create(\'mismatch between field names and values\');
                      whereclause := \'\';
                        for i := 0 to slnames.count-1 do
                        begin
                          if length(trim(slvalues[i]))=0 then
                            exit;
                          whereclause := whereclause + slnames[i] + \'=\' + slvalues[i];
                          if i\<slnames.count-1 then
                            whereclause := whereclause + \' and \'
                        end;
                      finally
                        slnames.free;
                        slvalues.free;
                      end;
                    end
                    else
                    begin
                      if length(trim(fieldvalues))=0 then
                        exit;
                      whereclause := fieldnames + \' = \' + fieldvalues;
                    end;
                     if dataset is tabstractquery then
                    begin
                      query := (dataset as tabstractquery);
                      end
                    else
                      query := nil;
                    if assigned(query) then
                    begin
                      newquery := \'select * from \' + tablename + \' where \' + whereclause;
                      if uppercase(trim(newquery))\<\>uppercase(trim(query.sql.text)) then
                      begin
                        query.active := false;
                        query.sql.text := newquery;
                      end;
                    end
                    else
                    begin
                      table := (dataset as tabstracttable);
                      if pos(tablename, table.tablename)=0 then
                      begin
                        table.active := false;
                        table.tablename := changefileext(tablename, \'.dbf\');
                      end;
                      table.filtered := true;
                      table.filter := whereclause;
                    end;
                    if not dataset.active then
                      dataset.active := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_009()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure cleanupsectionsstring(var s: string);
                  begin
                    while pos(\',,\', s)\>0 do
                      s := stringreplace(s, \',,\', \',\', [rfreplaceall]);
                    if isdelimiter(\',\', s, 1) then
                      delete(s, 1, 1);
                    if isdelimiter(\',\', s, length(s)) then
                      delete(s, length(s), 1);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_010()
{
    return parse(#DelphiGrammar::MethodImplementation, "function nstrings (s : string) : integer;
                  var
                    i : integer;
                  begin
                    result := 1;
                    for i := 1 to length(s) do
                      if s[i]=\',\' then inc(result);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_011()
{
    return parse(#DelphiGrammar::MethodImplementation, "function stringn (s : string; n : integer): string;
                  var
                    i, k, start, stop : integer;
                  begin
                    if (n \< 1) or (n \> nstrings(s)) then
                    begin
                      result := \'\';
                    end
                    else
                    begin
                      k := 0;
                      start := 1;
                      stop := length(s);
                      for i := 1 to length(s) do
                      begin
                        if s[i]=\',\' then
                        begin
                          inc(k);
                          if k=n then
                            break
                          else
                            start := i+1;
                        end;
                        stop := i+1;
                      end;
                      result := copy(s,start,stop-start);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_012()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tinifiles.addinifile(const sfilename: string; insertlocation: tinsertlocation=ilbegin);
                  var
                    i: integer;
                    ifound: integer;
                    icount: integer;
                    bfound: boolean;
                    inis: tstringlist;
                  begin
                    if not fileexists(sfilename) then
                      exit;
                    inis := tstringlist.create;
                    inis.sorted := false;
                    bfound := false;
                    ifound := -1;
                    icount := 0;
                    for i:=0 to nini do
                    begin
                      if assigned(inifile[i]) then
                      begin
                        inc(icount);
                        inis.addobject(inifile[i].filename, inifile[i]);
                        if sametext(inifile[i].filename, sfilename) then
                        begin
                          ifound := i;
                          bfound := true;
                        end;
                      end
                    end;
                    if icount+1\>=nini then
                    begin
                      showmessage(error_inifile);
                      inis.free;
                      exit;
                    end;
                    if bfound then
                    begin
                      if (insertlocation=ilbegin) and (ifound\<\>0) then
                      begin
                        inis.insertobject(0, sfilename, inifile[ifound]);
                        inis.delete(ifound+1);
                      end
                      else if (insertlocation=ilend) and (ifound\<\>icount-1) then
                      begin
                        inis.addobject(sfilename, inifile[ifound]);
                        inis.delete(ifound);
                      end
                    end
                    else
                    begin
                      if insertlocation=ilbegin then
                        inis.insertobject(0, sfilename, tqinifile.create(sfilename))
                      else
                        inis.addobject(sfilename, tqinifile.create(sfilename));
                    end;
                    for i:=0 to inis.count-1 do
                      inifile[i] := tqinifile(inis.objects[i]);
                    inis.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_013()
{
    return parse(#DelphiGrammar::MethodImplementation, "constructor tinifiles.create(files: array of string);
                  var i: integer;
                  begin
                    for i:=0 to high(files) do
                      if fileexists(files[i]) then
                        inifile[i] := tqinifile.create(expandfilename(files[i]));
                    fqueries := tstringlist.create;
                    fqueries.sorted := true;
                    fqueries.duplicates := dupaccept;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_014()
{
    return parse(#DelphiGrammar::MethodImplementation, "destructor tinifiles.destroy;
                  var
                    i: integer;
                  begin
                    for i:=0 to fqueries.count-1 do
                      fqueries.objects[i].free;
                    fqueries.free;
                    for i:=0 to nini do
                      inifile[i].free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_015()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tinifiles.readstring(const sections, ident, default: string): string;
                  var i, j       : integer;
                      s          : string;
                      sc         : tinidetails;
                      sec, val,
                      src        : string;
                      str        : string;
                      files      : string;
                  begin
                    s := default;
                    sec := ident;
                    if length(default)=0 then
                      val := \'\<empty\> (default)\'
                    else
                      val := default + \' (default)\';
                    src := \'-\';
                    files := \'\';
                    for i:=0 to nini do
                      if assigned(inifile[i]) then
                      begin
                        files := files + \',\' + inifile[i].filename;
                        for j:= 1 to nstrings(sections) do
                        begin
                          str := inifile[i].readstring(stringn(sections,j), ident, #$0a);
                          if str\<\>#$0a then
                          begin
                            s := str;
                            sec := stringn(sections, j) + \',\' + ident;
                            val := str;
                            src := inifile[i].filename;
                          end
                        end;
                      end;
                    if enabletestmode then
                    begin
                      i := fqueries.indexof(sec);
                      if i\<0 then
                        sc := tinidetails.create
                      else
                        sc := tinidetails(fqueries.objects[i]);
                      sc.value := val;
                      sc.source := src;
                      sc.datatype := \'string\';
                      sc.candidates := sections;
                      sc.files := copy(files, 2, maxint);
                      if i\<0 then
                        fqueries.addobject(sec, sc);
                    end;
                    result := s;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_016()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tinifiles.readbool(const sections, ident: string; default: boolean): boolean;
                  var i, j    : integer;
                      s       : boolean;
                      sc      : tinidetails;
                      sec, val,
                      src     : string;
                      str     : string;
                      files   : string;
                  begin
                    s := default;
                    sec := ident;
                    val := booltostr(default, true) + \' (default)\';
                    src := \'-\';
                    files := \'\';
                    for i:=0 to nini do
                      if assigned(inifile[i]) then
                      begin
                        files := files + \',\' + inifile[i].filename;
                        for j:= 1 to nstrings(sections) do
                        begin
                          str := inifile[i].readstring(stringn(sections,j), ident, #$0a);
                          if str\<\>#$0a then
                          begin
                            if (length(str) \> 2) and (str[1] = \'0\') and
                               ((str[2] = \'x\') or (str[2] = \'x\')) then
                              str := \'$\' + copy(str, 3, maxint);
                            s := strtointdef(str, ord(default))\<\>0;
                            sec := stringn(sections, j) + \',\' + ident;
                            if strtointdef(str, 0)=strtointdef(str, 1) then
                              val := booltostr(s, true)
                            else
                              val := str + \' (using default: \' + booltostr(default, true) + \')\';
                            src := inifile[i].filename;
                          end
                        end;
                      end;
                    if enabletestmode then
                    begin
                      i := fqueries.indexof(sec);
                      if i\<0 then
                        sc := tinidetails.create
                      else
                        sc := tinidetails(fqueries.objects[i]);
                      sc.value := val;
                      sc.source := src;
                      sc.datatype := \'boolean\';
                      sc.candidates := sections;
                      sc.files := copy(files, 2, maxint);
                      if i\<0 then
                        fqueries.addobject(sec, sc);
                    end;
                    result := s;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_017()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tinifiles.readfloat(const sections, ident: string;  default: double): double;
                  var i, j    : integer;
                      s       : double;
                      sc      : tinidetails;
                      sec, val,
                      src     : string;
                      str     : string;
                      files   : string;
                  begin
                    s := default;
                    sec := ident;
                    val := floattostr(default) + \' (default)\';
                    src := \'-\';
                    files := \'\';
                    for i:=0 to nini do
                      if assigned(inifile[i]) then
                      begin
                        files := files + \',\' + inifile[i].filename;
                        for j:= 1 to nstrings(sections) do
                        begin
                          str := inifile[i].readstring(stringn(sections,j), ident, #$0a);
                          if str\<\>#$0a then
                          begin
                            s := strtofloatdef(str, default);
                            sec := stringn(sections, j) + \',\' + ident;
                            if (strtofloatdef(str, 1.1)-strtofloatdef(str, 0.0))\<1.0 then
                              val := str
                            else
                              val := str + \' (using default: \' + floattostr(default) + \')\';
                            src := inifile[i].filename;
                          end
                        end;
                      end;
                    if enabletestmode then
                    begin
                      i := fqueries.indexof(sec);
                      if i\<0 then
                        sc := tinidetails.create
                      else
                        sc := tinidetails(fqueries.objects[i]);
                      sc.value := val;
                      sc.source := src;
                      sc.datatype := \'float\';
                      sc.candidates := sections;
                      sc.files := copy(files, 2, maxint);
                      if i\<0 then
                        fqueries.addobject(sec, sc);
                    end;
                    result := s;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_018()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tinifiles.readinteger(const sections, ident: string; default: integer): longint;
                  var i, j    : integer;
                      s       : longint;
                      sc      : tinidetails;
                      sec, val,
                      src     : string;
                      str     : string;
                      files   : string;
                  begin
                    s := default;
                    sec := ident;
                    val := inttostr(default) + \' (default)\';
                    src := \'-\';
                    files := \'\';
                    for i:=0 to nini do
                      if assigned(inifile[i]) then
                      begin
                        files := files + \',\' + inifile[i].filename;
                        for j:= 1 to nstrings(sections) do
                        begin
                          str := inifile[i].readstring(stringn(sections,j), ident, #$0a);
                          if str\<\>#$0a then
                          begin
                            if (length(str) \> 2) and (str[1] = \'0\') and
                               ((str[2] = \'x\') or (str[2] = \'x\')) then
                              str := \'$\' + copy(str, 3, maxint);
                            s := strtointdef(str, default);
                            sec := stringn(sections, j) + \',\' + ident;
                            if strtointdef(str, 0)=strtointdef(str, 1) then
                              val := str
                            else
                              val := str + \' (using default: \' + inttostr(default) + \')\';
                            src := inifile[i].filename;
                          end
                        end;
                      end;
                    if enabletestmode then
                    begin
                      i := fqueries.indexof(sec);
                      if i\<0 then
                        sc := tinidetails.create
                      else
                        sc := tinidetails(fqueries.objects[i]);
                      sc.value := val;
                      sc.source := src;
                      sc.datatype := \'integer\';
                      sc.candidates := sections;
                      sc.files := copy(files, 2, maxint);
                      if i\<0 then
                        fqueries.addobject(sec, sc);
                    end;
                    result := s;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_019()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tinifiles.readsections(strings: tstrings; allinifiles: boolean = false);
                  var
                    tmpstrings : tstringlist;
                    i, j       : integer;
                  begin
                    if allinifiles then
                    begin
                      tmpstrings := tstringlist.create;
                      for i:=0 to nini do
                      begin
                        if assigned(inifile[i]) then
                        begin
                          inifile[i].readsections(tmpstrings);
                          for j:= 0 to tmpstrings.count - 1 do
                            if (strings.indexof(tmpstrings[j]) \< 0) then strings.add(tmpstrings[j])
                        end;
                      end;
                      tmpstrings.free;
                    end
                    else
                    begin
                    if assigned(inifile[0]) then
                      inifile[0].readsections(strings);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_020()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tinifiles.sectionexists(const section: string): boolean;
                  var i:integer;
                  begin
                    result := false;
                    for i:=0 to nini do
                      if assigned(inifile[i]) then
                      begin
                        result := inifile[i].sectionexists(section);
                        if result then exit;
                      end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_021()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tqinifile.readsections(strings: tstrings);
                  const
                    initialbufsize = 16*16384;
                    maxiterations = 10;
                  var
                    gppsres: integer;
                    bufsize: integer;
                    buffer, p: pchar;
                    i: integer;
                  begin
                    bufsize := initialbufsize;
                    getmem(buffer, bufsize*sizeof(char));
                    try
                      for i:=0 to maxiterations-1 do
                      begin
                        gppsres :=  getprivateprofilestring(nil, nil, nil, buffer, bufsize, pchar(filename));
                        if gppsres = 0 then
                          break
                        else if gppsres \<\> bufsize-2 then
                        begin
                          p := buffer;
                          while p^ \<\> #0 do
                          begin
                            strings.add(p);
                            inc(p, strlen(p) + 1);
                          end;
                          break;
                        end
                        else
                        begin
                          bufsize := 2* bufsize;
                          freemem(buffer);
                          getmem(buffer, bufsize*sizeof(char));
                        end;
                      end;
                    finally
                      freemem(buffer);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_022()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tqinifile.sectionexists(const sectionsubstring: string): boolean;
                  const
                    initialbufsize = 16*16384;
                    maxiterations = 10;
                  var
                    gppsres: integer;
                    bufsize: integer;
                    buffer, p: pchar;
                    i: integer;
                  begin
                    bufsize := initialbufsize;
                    getmem(buffer, bufsize*sizeof(char));
                    result := false;
                    try
                      for i:=0 to maxiterations-1 do
                      begin
                        gppsres :=  getprivateprofilestring(nil, nil, nil, buffer, bufsize, pchar(filename));
                        if gppsres = 0 then
                          break
                        else if gppsres \<\> bufsize-2 then
                        begin
                          p := buffer;
                          while p^ \<\> #0 do
                          begin
                            if matchesmask(p, sectionsubstring) then
                            begin
                              result := true;
                              break;
                            end;
                            inc(p, strlen(p) + 1);
                          end;
                          break;
                        end
                        else
                        begin
                          bufsize := 2* bufsize;
                          freemem(buffer);
                          getmem(buffer, bufsize*sizeof(char));
                        end;
                      end;
                    finally
                      freemem(buffer);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_023()
{
    return parse(#DelphiGrammar::MethodImplementation, "constructor tscan.create(owner: tform);
                  var
                    i : integer;
                  begin
                    inherited create;
                    fowner      := owner;
                    data        := tavsfield.create(self, \'data\');
                    lut         := tavsfield.create(self, \'lut\');
                    externallut := tavsfield.create(self, \'externallut\');
                    properties  := tavsfield.create(self, \'properties\');
                    tosiddon    := ttransform.create(self, \'tosiddon\'); tosiddon.clear;
                    topatient   := ttransform.create(self, \'topatient\'); topatient.clear;
                    tomachine   := ttransform.create(self, \'tomachine\'); tomachine.clear;
                    for i := 1 to nclipbox do
                      clipbox[i]  := tavsfield.create(self, \'clipbox_\'+inttostr(i));
                    compressionlevel := 2;
                    headerstring     := \'\';
                    filename         := \'\';
                    level      := tupdatabledouble.create(self, \'level\');
                    window     := tupdatabledouble.create(self, \'window\');
                    processing := tupdatableinteger.create(self, \'processing\');
                    tomachine.adddependency((fowner as tform1).machine_to_siddon);
                    tomachine.adddependency(tosiddon);
                    tomachine.onupdate := updatetomachine;
                    lut.adddependency(externallut);
                    lut.adddependency(processing);
                    lut.onupdate := updatelut;
                    for i := 1 to nclipbox do
                    begin
                      clipbox[i].adddependency((fowner as tform1).clipbox[i]);
                      clipbox[i].adddependency((fowner as tform1).machine_to_machineadjust);
                      clipbox[i].adddependency(tomachine);
                      clipbox[i].adddependency((fowner as tform1).reversemotion);
                      clipbox[i].onupdate  := updateclipbox;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_024()
{
    return parse(#DelphiGrammar::MethodImplementation, "destructor tscan.destroy;
                  var
                    i   : integer;
                  begin
                    inherited;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_025()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tscan.connectviewer(viewer: tlightquirtviewerupd; channel: integer);
                  var i:integer;
                  begin
                    if channel=1 then
                      viewer.grid.removedependency(viewer.transform[1]);
                    viewer.field     [channel] := data;
                    viewer.lut       [channel] := lut;
                    viewer.transform [channel] := tomachine;
                    viewer.level     [channel] := level;
                    viewer.window    [channel] := window;
                    viewer.processing[channel] := processing;
                    viewer.fieldname [channel].value := fieldname;
                    if channel=1 then
                    begin
                      for i:=1 to high((fowner as tform1).online   ) do viewer.viewtransform.removedependency((fowner as tform1).online   [i].tomachine);
                      for i:=1 to high((fowner as tform1).reference) do viewer.viewtransform.removedependency((fowner as tform1).reference[i].tomachine);
                      for i:=1 to high((fowner as tform1).dose     ) do viewer.viewtransform.removedependency((fowner as tform1).dose     [i].tomachine);
                      viewer.viewtransform.adddependency(tomachine);
                      for i:=1 to high((fowner as tform1).online   ) do viewer.grid.removedependency((fowner as tform1).online   [i].data);
                      for i:=1 to high((fowner as tform1).reference) do viewer.grid.removedependency((fowner as tform1).reference[i].data);
                      for i:=1 to high((fowner as tform1).dose     ) do viewer.grid.removedependency((fowner as tform1).dose     [i].data);
                      viewer.grid.adddependency(data);
                      viewer.grid.adddependency(viewer.transform[1]);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_026()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tscan.clear;
                  var
                    i : integer;
                  begin
                    data.clear;
                    tomachine.clear;
                    topatient.clear;
                    tosiddon.clear;
                    externallut.clear;
                    for i := 1 to nclipbox do clipbox[i].clear;
                    level.value := 0;
                    window.value := 0;
                    processing.value := 0;
                    filename := \'\';
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_027()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tscan.updatetomachine(sender: tobject; var unchanged: boolean);
                  begin
                    if not tosiddon.empty then
                      transform_math(tosiddon, (fowner as tform1).machine_to_siddon, tomachine, false, true);
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_028()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tscan.updatelut(sender: tobject; var unchanged: boolean);
                  begin
                    if processing.value=411 then
                    begin
                      field_overlay_lut(lut, \'monochrome\', 0, 256);
                      level.locked := true;
                      window.locked := true;
                    end
                    else
                    begin
                      lut.assign(externallut);
                      level.locked := false;
                      window.locked := false;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_029()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tscan.updateclipbox(sender: tobject; var unchanged: boolean);
                  var t1: ttransform;
                      i, j : integer;
                      bclpadj  : boolean;
                  begin
                    if data.empty then exit;
                    t1 := ttransform.create;
                    t1.assign(tomachine);
                    t1.invert;
                    bclpadj := false;
                    for i:=1 to high((fowner as tform1).online   ) do
                      for j:=1 to nclipbox do
                        if (tavsfield(sender)=(fowner as tform1).online[i].clipbox[j]) then
                          bclpadj := true;
                    for i := 1 to nclipbox do
                    begin
                      clipbox[i].enabled := false;
                      if (fowner as tform1).clipbox[i].empty then clipbox[i].clear
                      else
                      begin
                        if bclpadj then
                        begin
                          t1.assign(tomachine);
                          t1.premultiply((fowner as tform1).machine_to_machineadjust);
                          t1.invert;
                        end;
                        cropbox_transform((fowner as tform1).clipbox[i],t1,clipbox[i]);
                      end;
                      clipbox[i].owner   := (fowner as tform1).clipbox[i].owner;
                      clipbox[i].locked  := (fowner as tform1).clipbox[i].locked  or (data.ndim=2);
                      clipbox[i].blanking:= (fowner as tform1).clipbox[i].blanking;
                      clipbox[i].enabled := true;
                    end;
                    t1.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_030()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tscan.loadinternal(fld: tavsfield; base, name: string);
                  var i: integer;
                  begin
                    if fileexists(base+name) then
                    begin
                        read_xdr(fld, base+name);
                      lastfile := base+name;
                    end
                    else
                    begin
                      for i:=low(aliases) to high(aliases) do
                        if aliases[i].name=name then
                          if fileexists(base+aliases[i].alias) then
                          begin
                            read_xdr(fld, base+aliases[i].alias);
                            lastfile := base+aliases[i].alias;
                            exit;
                          end;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_031()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tscan.existsinternal(base, name: string): boolean;
                  var i: integer;
                  begin
                    result := false;
                    if fileexists(base+name) then result := true
                    else
                    begin
                      for i:=low(aliases) to high(aliases) do
                        if aliases[i].name=name then
                          if fileexists(base+aliases[i].alias) then
                          begin
                            result := true;
                            exit;
                          end;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_032()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tscan.deleteinternal(base, name: string): boolean;
                  var i: integer;
                  begin
                    result := false;
                    if fileexists(base+name) then
                    begin
                      deletefile(base+name);
                      result := true;
                    end
                    else
                    begin
                      for i:=low(aliases) to high(aliases) do
                        if aliases[i].name=name then
                          if fileexists(base+aliases[i].alias) then
                          begin
                            deletefile(base+aliases[i].alias);
                            result := true;
                            exit;
                          end;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_033()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tscan.load(dir, uid, name: string): boolean;
                  var base: string;
                  begin
                    result := false;
                    if uid\<\>\'\' then base := dir + uid + \'.\'
                    else            base := dir;
                    data.clear;
                    tomachine.clear;
                    topatient.clear;
                    tosiddon.clear;
                    externallut.clear;
                    if not existsinternal(base, name) then exit;
                    result := true;
                    try
                      loadinternal(data, base, name);
                      filename := lastfile;
                      loadinternal(tosiddon,    base, name + \'.orientation\');
                      loadinternal(topatient,   base, name + \'.patientorientation\');
                      loadinternal(tomachine,   base, name + \'.machineorientation\');
                      loadinternal(externallut, base, name + \'.lut\');
                      loadinternal(properties,  base, name + \'.properties\');
                    except
                      result := false;
                    end;
                    tomachine.make;
                    lut.make;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_034()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tscan.exists(dir, uid, name: string): boolean;
                  begin
                    result := existsinternal(dir + uid + \'.\', name);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_035()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tscan.save(dir, uid, name: string): boolean;
                  var f: string;
                  begin
                    result := true;
                    f := dir + uid + \'.\' + name;
                    try
                      if      not data.empty      then
                      begin
                        write_xdr(data,      f + \'\', headerstring, \'\', compressionlevel);
                        filename := f;
                      end;
                      if      not topatient.empty   then write_xdr(topatient,   f + \'.patientorientation\');
                      if      not externallut.empty then write_xdr(externallut, f + \'.lut\');
                      if      not properties.empty  then write_xdr(properties,  f + \'.properties\');
                      if      not tosiddon.empty    then write_xdr(tosiddon,    f + \'.orientation\')
                      else if not tomachine.empty   then write_xdr(tomachine,   f + \'.machineorientation\');
                    except
                      result := false;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_036()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tscan.delete(dir, uid, name: string): boolean;
                  var base: string;
                  begin
                    result := true;
                    base := dir + uid + \'.\';
                    try
                      deleteinternal(base, name);
                      deleteinternal(base, name + \'.patientorientation\');
                      deleteinternal(base, name + \'.lut\');
                      deleteinternal(base, name + \'.properties\');
                      deleteinternal(base, name + \'.orientation\');
                      deleteinternal(base, name + \'.machineorientation\');
                    except
                      result := false;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_037()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tscan.readheader(entry: string): string;
                  begin
                    result := \'\';
                    if fileexists(filename) then read_xdr_header(result, filename, entry)
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_038()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure avsmessagehandler(const smessage: pansichar; const stitle: pansichar) cdecl;
                  var
                    tf: textfile;
                  begin
                    inc(form1timer1enabled);
                    if form1.avlstate=6 then
                    begin
                      sysutils.forcedirectories(extractfilepath(application.exename) + \'logs\');
                      assignfile(tf, extractfilepath(application.exename) + \'logs\\ntpars_error.log\');
                      if fileexists(extractfilepath(application.exename) + \'logs\\ntpars_error.log\') then append(tf) else rewrite(tf);
                      write(tf, formatdatetime(\'yyyymmdd hh:nn:ss \', now));
                      write(tf, smessage);
                      write(tf, \' \');
                      writeln(tf, stitle);
                      closefile(tf);
                      form1.reconterminate(false, avs_error_msg);
                      exit;
                    end;
                    if smessage = \'match stopped close to search limits - possibly incorrect answer\' then
                    begin
                      if not disableshowmessage then showmessage(avs_matc_warning)
                    end
                    else if smessage = \'invalid histogram; check input image or histogram max value\' then
                    begin
                      if not disableshowmessage then showmessage(avs_mrtr_warning)
                    end
                    else if pos(ansistring(\'avs_rpinnacle: could not find\'), smessage)=1 then
                    begin
                      if not disableshowmessage then showmessage(pinnacle_warning + #10 + string(smessage));
                      sysutils.forcedirectories(extractfilepath(application.exename) + \'logs\');
                      assignfile(tf, extractfilepath(application.exename) + \'logs\\ntpars_error.log\');
                      if fileexists(extractfilepath(application.exename) + \'logs\\ntpars_error.log\') then append(tf) else rewrite(tf);
                      write(tf, formatdatetime(\'yyyymmdd hh:nn:ss \', now));
                      write(tf, smessage);
                      write(tf, \' \');
                      writeln(tf, stitle);
                      closefile(tf);
                    end
                    else
                    begin
                      if not disableshowmessage then showmessage(avs_error_msg);
                      sysutils.forcedirectories(extractfilepath(application.exename) + \'logs\');
                      assignfile(tf, extractfilepath(application.exename) + \'logs\\ntpars_error.log\');
                      if fileexists(extractfilepath(application.exename) + \'logs\\ntpars_error.log\') then append(tf) else rewrite(tf);
                      write(tf, formatdatetime(\'yyyymmdd hh:nn:ss \', now));
                      write(tf, smessage);
                      write(tf, \' \');
                      writeln(tf, stitle);
                      closefile(tf);
                      application.terminate;
                      exit;
                    end;
                    dec(form1timer1enabled);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_039()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.fixdirectory(var f: string);
                  var
                    i1, j1, i2, j2: integer;
                  begin
                    i1 := 0;
                    repeat
                      j1 := i1;
                      i1 := posex(\'\\patient_\', lowercase(paramstr2), i1+1);
                    until i1=0;
                    i2 := 0;
                    repeat
                      j2 := i2;
                      i2 := posex(\'\\patient_\', lowercase(f), i2+1);
                    until i2=0;
                    if (j1=0) or (j2=0) then exit;
                    f := copy(paramstr2, 1, j1-1) + copy(f, j2, 1000);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_040()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.activesettingsdblclick(sender: tobject);
                  var r: integer;
                      s: string;
                  begin
                    s := \'\';
                    for r:=0 to (sender as tlistview).items.count-1 do
                    begin
                      s := s + (sender as tlistview).items[r].caption + #9;
                      s := s + (sender as tlistview).items[r].subitems.strings[0] + #9;
                      s := s + (sender as tlistview).items[r].subitems.strings[1] + #9;
                      s := s + (sender as tlistview).items[r].subitems.strings[2] + #9;
                      s := s + (sender as tlistview).items[r].subitems.strings[3];
                      s := s + #13#10;
                    end;
                    clipboard.astext := s;
                    showmessage(message_copiedtexttoclpbrd);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_041()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.handlelvcolor(sender: tcustomlistview; item: tlistitem;
                      state: tcustomdrawstate; var defaultdraw: boolean);
                  var
                    lv: tlistview;
                    c: tcolor;
                  begin
                    c := clblack;
                    if pos(\' (default)\', item.subitems[1])\>0 then c := clblue;
                    if pos(\'.xvi\', item.subitems[2])\>0 then c := clred;
                    lv := tlistview(item.listview);
                    if lv.canvas.font.color \<\> c then
                      lv.canvas.font.color := c;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_042()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.populatelistview(lv: tlistview);
                  var
                    i: integer;
                    li: tlistitem;
                    id: tinidetails;
                  begin
                    lv.items.clear;
                    for i := 0 to gquerylist.count - 1 do
                    begin
                      li := lv.items.add;
                      li.caption := gquerylist[i];
                      id := tinidetails(gquerylist.objects[i]);
                      li.subitems.add(id.datatype);
                      li.subitems.add(id.value);
                      li.subitems.add(id.source);
                      li.subitems.add(id.candidates);
                      li.subitems.add(id.files);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_043()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.popupmenumarkerspopup(sender: tobject);
                  begin
                    popupmenumarkers.items[1].enabled := not readonly;
                    popupmenumarkers.items[3].enabled := not readonly;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_044()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updatequerylist(inifile: tinifiles);
                  var
                    sc: tinidetails;
                    j: integer;
                    i: integer;
                  begin
                    for i := 0 to inifile.querylist.count - 1 do
                    begin
                      j := gquerylist.indexof(inifile.querylist[i]);
                      if j \< 0 then
                        sc := tinidetails.create
                      else
                        sc := tinidetails(gquerylist.objects[j]);
                      sc.value := tinidetails(inifile.querylist.objects[i]).value;
                      sc.source := tinidetails(inifile.querylist.objects[i]).source;
                      sc.datatype := tinidetails(inifile.querylist.objects[i]).datatype;
                      sc.candidates := tinidetails(inifile.querylist.objects[i]).candidates;
                      sc.files := tinidetails(inifile.querylist.objects[i]).files;
                      if j \< 0 then
                      begin
                        if (pos(\',\', sc.candidates) = 0) and (pos(\',\', inifile.querylist[i]) = 0) then
                          gquerylist.addobject(sc.candidates + \',\' + inifile.querylist[i], sc)
                        else
                          gquerylist.addobject(inifile.querylist[i], sc);
                      end;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_045()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.preparesettingsform(var lv: tlistview);
                  begin
                    if not assigned(gactivesettingsform) then
                    begin
                      gquerylist := tstringlist.create;
                      gquerylist.sorted := true;
                      gquerylist.duplicates := dupignore;
                      gactivesettingsform := tform.create(application);
                      gactivesettingsform.caption := \'settings\';
                      gactivesettingsform.position := poscreencenter;
                      gactivesettingsform.width := screen.width - 200;
                      gactivesettingsform.height := screen.height - 200;
                      lv := tlistview.create(gactivesettingsform);
                      lv.align := alclient;
                      lv.parent := gactivesettingsform;
                      lv.viewstyle := vsreport;
                      lv.rowselect := true;
                      lv.columns.add;
                      lv.columns.add;
                      lv.columns.add;
                      lv.columns.add;
                      lv.columns.add;
                      lv.columns.add;
                      lv.columns[0].caption := \'name\';
                      lv.columns[1].caption := \'type\';
                      lv.columns[2].caption := \'value\';
                      lv.columns[3].caption := \'source\';
                      lv.columns[4].caption := \'candidates\';
                      lv.columns[5].caption := \'files\';
                      lv.ondblclick := activesettingsdblclick;
                    end
                    else
                      lv := gactivesettingsform.controls[0] as tlistview;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_046()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.activesettingstolistview(inifile: tinifiles; bupdatelistview: boolean);
                  var
                    lv: tlistview;
                  begin
                    preparesettingsform(lv);
                    updatequerylist(inifile);
                    if bupdatelistview then
                    begin
                      lv.columns[0].width :=  50;
                      lv.columns[1].width :=  50;
                      lv.columns[2].width := 250;
                      lv.columns[3].width :=  50;
                      lv.columns[4].width :=  50;
                      lv.columns[5].width :=  50;
                      populatelistview(lv);
                      lv.columns[0].width :=  -1;
                      lv.columns[1].width :=  -1;
                      lv.columns[2].width := 250;
                      lv.columns[3].width :=  -1;
                      lv.columns[4].width :=  -1;
                      lv.columns[5].width :=  -1;
                      lv.oncustomdrawitem := handlelvcolor;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_047()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.showactivesettings(sender: tobject);
                  begin
                    activesettingstolistview(inifile, true);
                    gactivesettingsform.showmodal;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_048()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure removealltempdbfiles(const path: string);
                  var
                    searchrec: tsearchrec;
                    spath: string;
                    ires: integer;
                  begin
                    spath := includetrailingpathdelimiter(path);
                    ires := findfirst(spath + \'_qsql*.dbf\', not fadirectory, searchrec);
                    while ires = 0 do
                    begin
                      deletefile(spath + searchrec.name);
                      ires := findnext(searchrec);
                    end;
                    findclose(searchrec);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_049()
{
    return parse(#DelphiGrammar::MethodImplementation, "function sqlformatted(const wherelist: tstringlist): string;
                  var
                    i: integer;
                  begin
                    result := \'\';
                    for i:=0 to wherelist.count-1 do
                    begin
                      if length(trim(wherelist[i]))\>0 then
                        result := result + trim(wherelist[i]) + \' and \'
                    end;
                    if length(result)\>0 then
                    begin
                      delete(result, length(result)-4, 5);
                      if length(result)\>0 then
                        result := \'where \' + result;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_050()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.createtablesandqueries(sqldatasource: string);
                  begin
                    freeandnil(tabledbid);
                    freeandnil(tablepatients);
                    freeandnil(tableports);
                    freeandnil(tableprocedure);
                    freeandnil(tabletreatments);
                    freeandnil(queryscans);
                    freeandnil(queryframes);
                    freeandnil(queryoffsets);
                    freeandnil(queryscandetails);
                    freeandnil(queryframedetails);
                    freeandnil(queryoffsetframes);
                    freeandnil(queryimages);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_051()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.formcreate(sender: tobject);
                  var
                    i, j           : integer;
                    reg            : tregistry;
                    tmpstr         : array [0..255] of char;
                    s, stationname : string;
                    h              : tqinifile;
                    guirefreshinterval: integer;
                    query: tabstractquery;
                    rtdatasourceinifile: trtdatasourceinifile;
                  begin
                    timer1.enabled := false;
                    form1 := self;
                    screenlayoutmode  := 0;
                    screenlayoutratio1:= 0.48;
                    screenlayoutratio2:= 0.52;
                    activated         := false;
                    levels[0] := 0;
                    levels[1] := 0;
                    levels[2] := 0;
                    levels[3] := 0;
                    restore1.enabled := false;
                    if not xviischildwindow then
                    begin
                      paramstr1 := paramstr(1);
                      paramstr2 := paramstr(2);
                      paramcnt  := paramcount;
                    end;
                    setavsmessagehandler(avsmessagehandler);
                    decimalseparator := \'.\';
                    try
                      if loadnewresourcemodule(english) \<\> 0 then
                        reinitializeforms;
                    finally
                    end;
                    if not xviischildwindow then
                    begin
                      top       := 0;
                      left      := 0;
                      if abs(font.height)\<\>11 then
                      begin
                        width     := round(1007*abs(form1.font.height)/11);
                        height    := round(815*abs(form1.font.height)/11);
                      end
                      else
                      begin
                        width     := round(1047*abs(form1.font.height)/11);
                        height    := round(856*abs(form1.font.height)/11);
                        windowstate := wsnormal;
                      end;
                      if width\<screen.width then
                        constraints.minwidth  := width;
                      if height\<screen.height then
                        constraints.minheight := height;
                    end
                    else
                    begin
                      constraints.minwidth  := 100;
                      constraints.minheight := 100;
                    end;
                    gettemppath(255, @tmpstr);
                    tempdir := tmpstr;
                    reg := tregistry.create;
                    reg.rootkey := hkey_local_machine;
                    if reg.openkey(\'hardware\\description\\system\\centralprocessor\\1\', false) then
                    begin
                      checkboxmultithread.checked := true;
                      reg.closekey;
                    end
                    else
                    begin
                      checkboxmultithread.checked := false;
                      checkboxmultithread.enabled := false;
                    end;
                    reg.free;
                    h := tqinifile.create(getfullinifilename(\'datasources.ini\'));
                    datasource := h.readstring(\'xvi\', \'device\', \'\');
                    h.free;
                    i := pos(\':\', datasource);
                    if i\>0 then
                    begin
                      datatype := uppercase(copy(datasource, 1, i-1));
                      datapath := copy(datasource, i+1, 250);
                      if datapath[length(datapath)]\<\>\'\\\' then datapath := datapath + \'\\\';
                    end;
                    avlstate := 0;
                    if (paramcnt = 2) then
                    begin
                      if (strtointdef(paramstr1, -1) in [1..6]) and
                         (uppercase(extractfileext(paramstr2))=\'.ini\') then
                        avlstate := strtointdef(paramstr1, -1);
                    end
                    else if (uppercase(extractfileext(paramstr1))=\'.ini\') then
                      avlstate := 0;
                    if avlstate\<0 then
                    begin
                      h := tqinifile.create(getfullinifilename(\'xvi.ini\'));
                      s := h.readstring(\'xvi\', \'localinifilename\', \'\');
                      h.free;
                      inifile := tinifiles.create([getfullinifilename(\'xvi.ini\'), s]);
                    end
                    else
                      inifile := tinifiles.create([paramstr2 + \'.xvi\', paramstr2]);
                    if paramstr2=paramstr1 then avlstate := inifile.readinteger(\'xvi\', \'avlstate\', 0);
                    if avlstate\<\>inifile.readinteger(\'xvi\', \'avlstate\', -1) then
                    begin
                      if avlstate=6 then reconterminate(false, error_inifile)
                      else
                      begin
                        showmessage(error_inifile);
                        application.terminate;
                      end;
                    end;
                    admincount := inifile.readinteger(\'xvi\', \'admincount\', 0);
                    if inifile.readbool(\'xvi\', \'profile\', false) then
                    begin
                      appstarttime := now;
                      quirtavstrace(\'\');
                    end;
                    reconstructlatestscan:=inifile.readbool(\'xvi\', \'reconstructlatestscan\', false);
                    loadlatestalignment  :=inifile.readbool(\'xvi\', \'loadlatestalignment\', false);
                    readonly := inifile.readbool(\'xvi\', \'readonly\', false);
                    buttonelektaaccept.enabled := not readonly;
                    exitaccept1.enabled := buttonelektaaccept.enabled;
                    complabprec := 2;
                    if avlstate\<0 then
                    begin
                      lastdb              := inifile.readstring(\'xvi\', \'lastdb\', \'\');
                      lastdb              := inifile.readstring(\'xvi\', \'maindb\', lastdb);
                      if (paramcnt \> 1) then cmddb := paramstr2 else cmddb := \'\\\';
                      for i:=1 to 10 do
                        backupdb[i] := inifile.readstring(\'xvi\', \'backupdb\'+inttostr(i), \'\');
                      setlength(jukeboxbase,10);
                      for i:=0 to 9 do
                      begin
                        jukeboxbase[i] := inifile.readstring(\'xvi\', \'jukeboxdirectory\'+inttostr(i+1), \'\');
                        if jukeboxbase[i] = \'\' then
                        begin
                          jukeboxbase := copy(jukeboxbase,0,max(1,i));
                          break;
                        end
                      end;
                      if (jukeboxbase[0] = \'\') then
                        jukeboxbase[0]        := inifile.readstring(\'xvi\', \'jukeboxdirectory\', \'\');
                      jukeboxreadproj    := inifile.readbool(\'xvi\', \'jukeboxreadproj\', false);
                      if (cmddb[length(cmddb)] = \'\\\') then delete(cmddb, length(cmddb), 1);
                      lastdb := excludetrailingpathdelimiter(lastdb);
                      if fileexists(cmddb+\'\\dbid.dbf\') then
                        edit1.text := cmddb
                      else
                        edit1.text := lastdb;
                      nframedb := inifile.readinteger(\'xvi\', \'nframedb\', 1);
                      sqldatasource  := inifile.readstring(\'xvi\', \'sqldatasource\', \'\');
                      sqllogin       := inifile.readstring(\'xvi\', \'sqllogin\',      \'\');
                      sqlpassword    := inifile.readstring(\'xvi\', \'sqlpassword\',   \'\');
                      queryscanswhere := tstringlist.create;
                      fakeimporturl := inifile.readstring(\'xvi\', \'fakeimporturl\', \'[xvi]:\');
                      if fakeimporturl \<\> \'[xvi]:\' then
                      begin
                        s:=fakeimporturl;
                        i:= pos(\'[\', s);
                        s:= copy(s, i+1, 250);
                        i:= pos(\']\', s);
                        s:= copy(s, 1, i-1);
                        rtdatasourceinifile := trtdatasourceinifile.create();
                        importdatatype := rtdatasourceinifile.device(s);
                        importdatapath := rtdatasourceinifile.datapath(s);
                        rtdatasourceinifile.free;
                        if length(importdatapath)\>0 then
                        begin
                          if importdatapath[length(importdatapath)]\<\>\'\\\' then importdatapath := importdatapath + \'\\\';
                        end
                        else
                        begin
                          importdatatype := datatype;
                          importdatapath := datapath;
                        end;
                      end;
                    end;
                    runtableshift       := inifile.readstring(\'xvi\', \'runtableshift\', \'\');
                    bad                       := tavsfield.create;
                    offset                    := tavsfield.create(bad);
                    gain                      := tavsfield.create(bad);
                    bowtie                    := tavsfield.create(bad);
                    offset2                   := tavsfield.create(bad);
                    gain2                     := tavsfield.create(bad);
                    bowtie2                   := tavsfield.create(bad);
                    gfmultianglegain          := tavsfield.create(bad);
                   caldirlist   := tstringlist.create;
                    avlflexmapmode := false;
                    bonematchdoubtthreshold := inifile.readfloat(\'xvi\', \'bonematchdoubtthreshold\', 2.0);
                    seedmatchdoubtthreshold := inifile.readfloat(\'xvi\', \'seedmatchdoubtthreshold\', 2.0);
                    projectionsinverted := inifile.readbool(\'xvi\', \'projectionsinverted\', true);
                    begin
                      projectionscalibrated := inifile.readinteger(\'reconstruction\', \'projectionscalibrated\', 0);
                      offsetfilename     := inifile.readstring(\'reconstruction\', \'offsetfile\',    \'\');
                      gainfilename       := inifile.readstring(\'reconstruction\', \'gainfile\',      \'\');
                      gainfilename       := inifile.readstring(\'reconstruction\', \'gainfileopen\', gainfilename);
                      gainbowtiefilename := inifile.readstring(\'reconstruction\', \'gainfilebowtie\',\'\');
                      badmapfilename     := inifile.readstring(\'reconstruction\', \'badmapfile\',    \'\');
                      readcorrectionimages(gain, offset, bad, bowtie);
                    end;
                    checkboxmultithread.checked := inifile.readbool(\'xvi\', \'multithreaded\', true) and checkboxmultithread.enabled;
                    checkboxmedian.checked      := inifile.readbool(\'xvi\', \'medianfilter\', false);
                    skipcolumnsleft             := inifile.readinteger(\'xvi\', \'skipcolumnsleft\',  0);
                    skipcolumnsright            := inifile.readinteger(\'xvi\', \'skipcolumnsright\', 0);
                    skiprowstop                 := inifile.readinteger(\'xvi\', \'skiprowstop\',  0);
                    skiprowsbottom              := inifile.readinteger(\'xvi\', \'skiprowsbottum\', 0);
                    skiprowsbottom              := inifile.readinteger(\'xvi\', \'skiprowsbottom\', skiprowsbottom);
                    fastcorrectimage            := inifile.readbool   (\'xvi\', \'fastcorrectimage\', false);
                    fastcorrectimagescale       := inifile.readinteger(\'xvi\', \'fastcorrectimagescale\', 4);
                    correctfor0xffffpixelbug    := inifile.readbool   (\'xvi\', \'correctfor0xffffpixelbug\', false);
                    editprojectionimageresolution.text    := \'256\';
                    editreconstructedimageresolution.text := \'256\';
                    editreconstructionsize.text           := format(\'%.1f\', [25.6]);
                    editgainimage.text                    := gainfilename;
                    editoffsetimage.text                  := offsetfilename;
                    edituseints.text                      := inttostr(2);
                    editinterpolate.text                  := inttostr(2);
                    editscale.text                        := floattostr(420);
                    useonlinereconstruction := false;
                    editfp0.text      := format(\'%.2f\', [inifile.readfloat(\'xvi\', \'fp0\', 0.7)]);
                    editfp1.text      := format(\'%.2f\', [inifile.readfloat(\'xvi\', \'fp1\', 90)]);
                    editspr.text      := \'0.33\';
                    editghost.text    := \'0.989\'; editghost.visible := false; label19.visible := false;
                    editghostampl.text:= \'0\'; ;   editghostampl.visible := false;
                    editgainimage.readonly   := true;
                    editoffsetimage.readonly := true;
                    inplanerotationcorrectionangle :=
                      inifile.readfloat(\'xvi\', \'inplanerotationcorrectionangle\', 0);
                    iec_angle_convention := inifile.readbool(\'xvi\', \'iecangleconvention\', false);
                    iec_linear_convention := inifile.readinteger(\'xvi\', \'ieclinearconvention\', 1);
                    nameof6dofsystem     := inifile.readstring(\'xvi\', \'nameof6dofsystem\', \'\');
                    nameof3dofsystem     := inifile.readstring(\'xvi\', \'nameof3dofsystem\', \'precision couch\');
                    b6dofsystemhascrp    := inifile.readbool(\'xvi\', \'6dofsystemhascrp\', false);
                    matchrotmark := false;
                    matchprerotate := false;
                    match4dsingleframe := false;
                    appliedcorrectionprotocol := \'\';
                    appliedcorrectionfrom     := \'\';
                    appliedcorrectionby       := \'\';
                    appliedclipboxmatchmethod := \'\';
                    appliedmaskmatchmethod    := \'\';
                    correctionapprovalby := \'\';
                    correctionapproved := -1;
                    f                         := tavsfield.create(bad);
                    phase                     := tavsfield.create(bad);
                    phasehist                 := tavsfield.create(bad);
                    carm                      := tavsfield.create(bad);
                    doseaccu                  := tavsfield.create(bad);
                    doseacculut               := tavsfield.create(bad);
                    clipboxlist := tavsfield.create(bad);
                    clipboxlist.debugname := \'clipboxlist\';
                    cbnames := tstringlist.create ;
                    for i := 1 to nclipbox do
                    begin
                      clipbox[i]             := tavsfield.create;
                      clipbox[i].debugname := \'clipbox[\' + inttostr(i) + \']\';
                      cbnames.add(clipbox[i].debugname);
                      cbweights[i] := 1.0 ;
                      quirtviewerupdcoronal.clipboxtext[i] := tupdatablestring.create;
                      quirtviewerupdsagittal.clipboxtext[i]    := quirtviewerupdcoronal.clipboxtext[i];
                      quirtviewerupdtransversal.clipboxtext[i] := quirtviewerupdcoronal.clipboxtext[i];
                      quirtviewerupdcoronal.clipboxtext[i].owner := self;
                      quirtviewerupdcoronal.clipboxtext[i].locked := true ;
                      clipboxlist.adddependency(clipbox[i]);
                      clipboxlist.adddependency(quirtviewerupdcoronal.clipboxtext[i]);
                    end;
                    clipboxlist.onupdate := updateclipboxlist;
                    transform4d               := tavsfield.create(bad);
                    backuptransform4d         := tavsfield.create(bad);
                    vistransform4d            := tavsfield.create(bad);
                    vistransform4d2           := ttransform.create;
                    vistransform4d2.clear;
                    delineationdots           := tavsfield.create(bad);
                    delineationindex          := tavsfield.create(bad);
                    delineationdotslut        := tavsfield.create(bad);
                    delineationtransform      := tavsfield.create(bad);
                    warpvectors               := tavsfield.create(bad);
                    beamdots                  := tavsfield.create(bad);
                    beamindex                 := tavsfield.create(bad);
                    beamlut                   := tavsfield.create(bad);
                    beamtransform             := tavsfield.create(bad);
                    maskedreference           := tavsfield.create(bad);
                    referencemask             := tavsfield.create(bad);
                    maskedreferencelut        := tavsfield.create(bad);
                    maskedreferencetransform  := tavsfield.create(bad);
                    for i := 1 to nclipbox do
                    begin
                      mask_cog[i]             := tavsfield.create(bad);
                      field_create(mask_cog[i], \'field 1d 3-space 0-vector irregular float\', 3);
                      mask_cog[i].coordinate[0,0] := -9999;
                      mask_cog[i].coordinate[1,0] := -9999;
                      mask_cog[i].coordinate[2,0] := -9999;
                      if i=1 then
                      begin
                        mask_cog[i].adddependency(maskedreference);
                        mask_cog[i].onupdate := update_mask_cog;
                      end;
                    end;
                    machine_to_machineadjust    := ttransform.create;
                    machine_to_machineadjust.debugname := \'machine_to_machineadjust\';
                    prevmachine_to_machineadjust:= ttransform.create;
                    oldmachine_to_machineadjust := tavsfield.create(bad);
                    machine_to_machineadjustwarpi:= tavsfield.create(bad);
                    externalwarp :=                 tavsfield.create(bad);
                    viewwarp:= tavsfield.create(bad);
                    machine_to_siddon           := ttransform.create;
                    f_cbctmarkers             := tavsfield.create(bad);
                    chamferdots               := tavsfield.create(bad);
                    chamferdotslut            := tavsfield.create(bad);
                    field_create(chamferdotslut, \'field 1d 4-vector byte\', 1);
                    chamferdotsonline               := tavsfield.create(bad);
                    chamferdotslutonline            := tavsfield.create(bad);
                    field_create(chamferdotslutonline, \'field 1d 5-vector byte\', 1);
                    chamferdotslutreference            := tavsfield.create(bad);
                    field_create(chamferdotslutreference, \'field 1d 5-vector byte\', 1);
                    chamferdotsreference               := tavsfield.create(bad);
                    chamferdotsreference.adddependency(referencemask);
                    chamferdotsreference.onupdate      := updatechamferdotsreference;
                    visboneseg(false);
                    reversemotion := tupdatableinteger.create(bad);
                    transformdisplaymode := tupdatableinteger.create(bad);
                    alignmentmode := tupdatableinteger.create(bad);
                    activeregion := tupdatableinteger.create(bad);
                    maskactiveregion := tupdatableinteger.create(bad);
                    comboboxregistrationprotocol.itemindex := 0;
                    btncorrectionby.visible := false;
                    btncorrectionby.enabled := false;
                    comboboxcorrectionby.itemindex := 0;
                    comboboxcorrectionby.visible := (nameof6dofsystem\<\>\'\');
                    label21.visible := (nameof6dofsystem\<\>\'\');
                    comboboxcorrectionby.clear;
                    comboboxcorrectionby.add(nameof3dofsystem, [nameof3dsystemmappedtext]);
                    if nameof6dofsystem\<\>\'\' then
                      comboboxcorrectionby.add(nameof6dofsystem, [nameof6dsystemmappedtext]);
                    compressionmode := inifile.readinteger(\'xvi\', \'compressionmode\',  2);
                    avicodec := inifile.readstring(\'xvi\', \'avicodec\',  \'vidc\');
                    cbctonline := tscan.create(self);
                    dtsonline := tscan.create(self);
                    cbctreference := tscan.create(self);
                    dtsreference := tscan.create(self);
                    for i:=1 to high(online)    do online[i]    := tscan.create(self);
                    for i:=1 to high(reference) do reference[i] := tscan.create(self);
                    for i:=1 to high(dose)      do dose[i]      := tscan.create(self);
                    online[1].link := cbctonline;
                    reference[1].link := cbctreference;
                    for i:=1 to high(online)    do online[i].compressionlevel := compressionmode;
                    for i:=1 to high(reference) do reference[i].compressionlevel := compressionmode;
                    for i:=1 to high(dose)      do dose[i].compressionlevel := compressionmode;
                    online[1].fieldname    := viewer_cbct;
                    reference[1].fieldname := viewer_ref;
                    dose[1].fieldname      := viewer_dose;
                    for i:=2 to high(online)    do online[i].fieldname    := viewer_cbct + inttostr(i);
                    for i:=2 to high(reference) do reference[i].fieldname := viewer_ref  + inttostr(i);
                    for i:=2 to high(dose)      do dose[i].fieldname      := viewer_dose + inttostr(i);
                    onlinecube           := online[1].data;
                    online_to_machine    := online[1].tomachine;
                    referencecube        := reference[1].data;
                    reference_to_machine := reference[1].tomachine;
                    reference_to_patient := reference[1].topatient;
                    reference_to_siddon  := reference[1].tosiddon;
                    dosecube             := dose[1].data;
                    dose_to_machine      := dose[1].tomachine;
                    dose_to_siddon       := dose[1].tosiddon;
                    doselut              := dose[1].lut;
                    readcorrectionimages(gain, offset, bad, bowtie);
                    online_to_machine.makerotation(270, 0, 270);
                    savetoquirt     := false;
                    needloadmatch := false ;
                    panelplanselectprepare.visible := false;
                    comboboxfiltertype.items.clear;
                    comboboxfiltertype.items.add(\'none\');
                    comboboxfiltertype.items.add(\'enhance\');
                    comboboxfiltertype.items.add(\'extract\');
                    comboboxfiltertype.items.add(\'unsharp mask\');
                    comboboxfiltertype.items.add(\'umask + hismod\');
                    comboboxfiltertype.itemindex:=0;
                    if avlstate\<0 then
                    begin
                      createtablesandqueries(sqldatasource);
                      if assigned(queryscans) then
                      begin
                        if queryscans is tabstractquery then
                          (queryscans as tabstractquery).datasource := datasourceports
                        else
                          (queryscans as tabstracttable).mastersource := datasourceports;
                        queryscansselect := \'select img_date,img_time,kv,ma,kvlength,fov,patimg.dbid,patimg.dicom_uid from patimg,patimg_k\';
                        queryscanswhere.clear;
                        queryscanswhere.add(\'patimg.dbid=patimg_k.pimg_dbid\');
                        queryscanswhere.add(\'patimg_k.type!=68\');
                        queryscanswhere.add(\'patimg.port_dbid = :dbid\');
                        queryscansorder := \'order by img_date, img_time\';
                    if queryscans is tabstractquery then
                        begin
                          query := queryscans as tabstractquery;
                          query.sql.clear;
                          query.sql.add(queryscansselect);
                          query.sql.add(sqlformatted(queryscanswhere));
                          query.sql.add(queryscansorder);
                        end;
                      end;
                      if queryoffsets is tabstractquery then
                        (queryoffsets as tabstractquery).datasource := datasourceports
                      else
                        (queryoffsets as tabstracttable).mastersource := datasourceports;
                      if queryoffsets is tabstractquery then
                      begin
                        query := queryoffsets as tabstractquery;
                        query.sql.clear;
                        query.sql.add(\'select img_date,img_time,patimg.dbid,patimg.dicom_uid from patimg,patimg_k where\');
                        query.sql.add(\'patimg.dbid=patimg_k.pimg_dbid and patimg_k.type=68 and patimg.port_dbid = :dbid\');
                        query.sql.add(\'order by img_time\');
                      end;
                      if queryscandetails is tabstractquery then
                        (queryscandetails as tabstractquery).datasource := datasourcescansquery
                      else
                        (queryscandetails as tabstracttable).mastersource := datasourcescansquery;
                      if queryscandetails is tabstractquery then
                      begin
                        query := queryscandetails as tabstractquery;
                        query.sql.clear;
                        query.sql.add(\'select * from patimg_k where\');
                        query.sql.add(\'patimg_k.pimg_dbid=:dbid\');
                      end;
                      if assigned(queryframes) then
                      begin
                        if queryframes is tabstractquery then
                          (queryframes as tabstractquery).datasource := datasourcescansquery
                        else
                          (queryframes as tabstracttable).mastersource := datasourcescansquery;
                        if queryframes is tabstractquery then
                        begin
                          query := queryframes as tabstractquery;
                          query.sql.clear;
                          query.sql.add(\'select * from frame where\');
                          query.sql.add(\'frame.pimg_dbid=:dbid\');
                          query.sql.add(\'order by seq_num\');
                        end;
                      end;
                      if queryframedetails is tabstractquery then
                        (queryframedetails as tabstractquery).datasource := datasourceframes
                      else
                        (queryframedetails as tabstracttable).mastersource := datasourceframes;
                      if queryframedetails is tabstractquery then
                      begin
                        query := queryframedetails as tabstractquery;
                        query.sql.clear;
                        query.sql.add(\'select * from frame_k where\');
                        query.sql.add(\'frame_k.frm_dbid=:dbid\');
                      end;
                      if queryoffsetframes is tabstractquery then
                        (queryoffsetframes as tabstractquery).datasource := datasourceoffsetsquery
                      else
                        (queryoffsetframes as tabstracttable).mastersource := datasourceoffsetsquery;
                      if queryoffsetframes is tabstractquery then
                      begin
                        query := queryoffsetframes as tabstractquery;
                        query.sql.clear;
                        query.sql.add(\'select * from frame where\');
                        query.sql.add(\'frame.pimg_dbid=:dbid\');
                      end;
                      if queryimages is tabstractquery then
                      begin
                        query := queryimages as tabstractquery;
                        query.sql.clear;
                        query.sql.add(\'select * from patimg\');
                        query.sql.add(\'order by dicom_uid\');
                      end;
                    end;
                    application.hinthidepause := inifile.readinteger(\'xvi\', \'hinthidepauselength\', 2500);
                    if inifile.readbool(\'xvi\', \'runmaximized\', false) then
                      windowstate := wsmaximized;
                   if (inifile.readinteger(\'xvi\', \'starttab\', 1) \>= 0) and
                       (inifile.readinteger(\'xvi\', \'starttab\', 1) \< pagecontrol1.pagecount)
                    then pagecontrol1.activepageindex := inifile.readinteger(\'xvi\', \'starttab\', 1)
                    else pagecontrol1.activepageindex := 1;
                    tabsheet1.tabvisible := inifile.readbool(\'xvi\', \'elektadatabasesheetvisible\', true);
                    tabsheet2.tabvisible := inifile.readbool(\'xvi\', \'imageselectionsheetvisible\', true);
                    tabsheet1.tabvisible := false;
                    tabsheet2.tabvisible := false;
                    groupbox1.visible := inifile.readbool(\'xvi\', \'reconstructiongroupvisible\', true);
                    groupbox5.visible := inifile.readbool(\'xvi\', \'displaygroupvisible\', true);
                    groupbox6.visible := inifile.readbool(\'xvi\', \'calibrationgroupvisible\', true);
                    statusbar1.panels[0].text := inifile.readstring(\'xvi\', \'statuslinetext\', \'\');
                    statusbar1.visible := statusbar1.panels[0].text\<\>\'\';
                    showmatchresultsdetailsgreyvalue := inifile.readbool(\'xvi\', \'showmatchresultsdetailsgreyvalue\', true);
                    showmatchresultsdetailsbone := inifile.readbool(\'xvi\', \'showmatchresultsdetailsbone\', true);
                    showmatchresultsdetails     := inifile.readbool(\'xvi\', \'showmatchresultsdetails\', false);
                    if (avlstate\<=0) and not pagecontrol1.pages[1].tabvisible then
                    begin
                      pagecontrol1.tabheight := 1;
                      pagecontrol1.tabwidth  := 1;
                    end;
                    if true then
                    begin
                      popupmenueditmask.items[0].clear;
                      trackbartranslationlr.visible:= false;
                      trackbartranslationap.visible:= false;
                      trackbartranslationcc.visible:= false;
                      trackbarrotationlr.visible:= false;
                      trackbarrotationap.visible:= false;
                      trackbarrotationcc.visible:= false;
                      edittranslationlr.left := edittranslationlr.left - trackbartranslationlr.width + 20 - 5;
                      edittranslationcc.left := edittranslationcc.left - trackbartranslationlr.width + 20 - 5;
                      edittranslationap.left := edittranslationap.left - trackbartranslationlr.width + 20 - 5;
                      edittranslationlr.width := edittranslationlr.width + 10;
                      edittranslationcc.width := edittranslationcc.width + 10;
                      edittranslationap.width := edittranslationap.width + 10;
                      updowntranslationlr.left := updowntranslationlr.left - trackbartranslationlr.width + 30 - 5;
                      updowntranslationcc.left := updowntranslationcc.left - trackbartranslationlr.width + 30 - 5;
                      updowntranslationap.left := updowntranslationap.left - trackbartranslationlr.width + 30 - 5;
                      editrotationlr.left := editrotationlr.left - trackbarrotationlr.width + 20 - 5;
                      editrotationap.left := editrotationap.left - trackbarrotationlr.width + 20 - 5;
                      editrotationcc.left := editrotationcc.left - trackbarrotationlr.width + 20 - 5;
                      updownrotationlr.left := updownrotationlr.left - trackbarrotationlr.width + 20 - 5;
                      updownrotationap.left := updownrotationap.left - trackbarrotationlr.width + 20 - 5;
                      updownrotationcc.left := updownrotationcc.left - trackbarrotationlr.width + 20 - 5;
                      updownrotationlr.visible := true;
                      updownrotationap.visible := true;
                      updownrotationcc.visible := true;
                      panelelektacouchshift.visible := true;
                      panelnkicouchshift.visible := false;
                      comboboxmaskmatch.left := comboboxclipboxmatch.left;
                      comboboxmaskmatch.top := comboboxclipboxmatch.top;
                      comboboxsummarytype.top := comboboxclipboxmatch.top;
                      comboboxsummarytype.itemindex := 0;
                      panelelektamode.visible := true;
                    end;
                    if avlstate\>0 then
                    begin
                      buttonreconstruct.visible := false;
                      comboboxprotocol.visible := false;
                      buttonclinicalpatient.visible := false;
                      checkboxenablerotation.visible := false;
                      buttontoreference.visible := false;
                      buttonexport.visible := false;
                      buttonloadscan.visible := false;
                      buttonsavescan.visible := false;
                      updown1.visible := false;
                      menushowunlockpresentclipbox.visible := false;
                    end;
                    memo1.scrollbars := ssvertical;
                      about1.caption := menu_about1_caption;
                      bitbtnaverage4d.caption := button_bitbtnaverage4d_caption;
                      bitbtnaverage4d.hint := button_bitbtnaverage4d_hint;
                      bitbtnaverage4dtransform.caption := button_bitbtnaverage4dtransform_caption;
                      bitbtnaverage4dtransform.hint := button_bitbtnaverage4dtransform_hint;
                      bitbtnback4d.caption := button_bitbtnback4d_caption;
                      bitbtnback4d.hint := button_bitbtnback4d_hint;
                      bitbtndismisscorrection.caption := button_bitbtndismisscorrection_caption;
                      bitbtndismisscorrection.hint := button_bitbtndismisscorrection_hint;
                      bitbtnfwd4d.caption := button_bitbtnfwd4d_caption;
                      bitbtnfwd4d.hint := button_bitbtnfwd4d_hint;
                      bitbtngreenpurplecut.caption := button_bitbtngreenpurplecut_caption;
                      bitbtngreenpurplecut.hint := button_bitbtngreenpurplecut_hint;
                      bitbtnlock.caption := button_bitbtnlock_caption;
                      bitbtnlock.hint := button_bitbtnlock_hint;
                      bitbtnplaygreen.caption := button_bitbtnplaygreen_caption;
                      bitbtnplaygreen.hint := button_bitbtnplaygreen_hint;
                      bitbtnplaypurple.caption := button_bitbtnplaypurple_caption;
                      bitbtnplaypurple.hint := button_bitbtnplaypurple_hint;
                      bitbtnpresetlevelwindows.caption := button_bitbtnpresetlevelwindows_caption;
                      bitbtnpresetlevelwindows.hint := button_bitbtnpresetlevelwindows_hint;
                      bitbtnrefloc.caption := button_bitbtnrefloc_caption;
                      bitbtnrefloc.hint := button_bitbtnrefloc_hint;
                      bitbtnstop4d.caption := button_bitbtnstop4d_caption;
                      bitbtnstop4d.hint := button_bitbtnstop4d_hint;
                      bitbtnunlock.caption := button_bitbtnunlock_caption;
                      bitbtnunlock.hint := button_bitbtnunlock_hint;
                      bitbtnunlockprotocol.caption := button_bitbtnunlockprotocol_caption;
                      bitbtnunlockprotocol.hint := button_bitbtnunlockprotocol_hint;
                      bitbtnwarp.caption := button_bitbtnwarp_caption;
                      bitbtnwarp.hint := button_bitbtnwarp_hint;
                      button1.caption := button_button1_caption;
                      button26.caption := button_button26_caption;
                      button3d2d.caption := button_button3d2d_caption;
                      buttonacceptmatch.caption := button_buttonacceptmatch_caption;
                      buttonacceptmatch.hint := button_buttonacceptmatch_hint;
                      buttonbatchmatch.caption := button_buttonbatchmatch_caption;
                      buttonchangecalibration.caption := button_buttonchangecalibration_caption;
                      buttonclearonline.caption := button_buttonclearonline_caption;
                      buttonclearreference.caption := button_buttonclearreference_caption;
                      buttonclearreference.hint := button_buttonclearreference_hint;
                      buttonclinicalpatient.caption := button_buttonclinicalpatient_caption;
                      buttonclinicalpatient.hint := button_buttonclinicalpatient_hint;
                      buttonclipbox.caption := button_buttonclipbox_caption;
                      buttonclipbox.hint := button_buttonclipbox_hint;
                      buttonclipstats.caption := button_buttonclipstats_caption;
                      buttonconverttocorrection.caption := button_buttonconverttocorrection_caption;
                      buttonconverttocorrection.hint := button_buttonconverttocorrection_hint;
                      buttoncopytohexapod1.caption := format(button_buttoncopytohexapod1_caption, [nameof6dofsystem]);
                      buttondoseaccumulate.caption := button_buttondoseaccumulate_caption;
                      buttondoseaccumulate.hint := button_buttondoseaccumulate_hint;
                      buttonelektaaccept.caption := button_buttonelektaaccept_caption;
                      buttonelektadismiss.caption := button_buttonelektadismiss_caption;
                      buttonexport.caption := button_buttonexport_caption;
                      buttonexport.hint := button_buttonexport_hint;
                      buttonfirst.caption := button_buttonfirst_caption;
                      buttonfirst.hint := button_buttonfirst_hint;
                      buttonflexmapbb.caption := button_buttonflexmapbb_caption;
                      buttongenerateanglefiles.caption := button_buttongenerateanglefiles_caption;
                      buttongotoisoc.caption := button_buttongotoisoc_caption;
                      buttongotoisoc.hint := button_buttongotoisoc_hint;
                      buttongraphicalhelp.caption := button_buttongraphicalhelp_caption;
                      buttongraphicalhelp.hint := button_buttongraphicalhelp_hint;
                      buttonidealcatphanasref.caption := button_buttonidealcatphanasref_caption;
                      buttonidealcatphanasref.hint := button_buttonidealcatphanasref_hint;
                      buttonlast.caption := button_buttonlast_caption;
                      buttonlast.hint := button_buttonlast_hint;
                      buttonlimitinformation.caption := button_buttonlimitinformation_caption;
                      buttonlimitinformation.hint := button_buttonlimitinformation_hint;
                      buttonloadmatch.caption := button_buttonloadmatch_caption;
                      buttonloadmatch.hint := button_buttonloadmatch_hint;
                      buttonloadreference.caption := button_buttonloadreference_caption;
                      buttonloadreference.hint := button_buttonloadreference_hint;
                      buttonloadscan.caption := button_buttonloadscan_caption;
                      buttonloadscan.hint := button_buttonloadscan_hint;
                      buttonmarkers.caption := button_buttonmarkers_caption;
                      buttonmarkers.hint := button_buttonmarkers_hint;
                      buttonmask.caption := button_buttonmask_caption;
                      buttonmask.hint := button_buttonmask_hint;
                      buttonmatch.caption := button_buttonmatch_caption;
                      buttonmatch.hint := button_buttonmatch_hint;
                      buttonmatch2.caption := button_buttonmatch2_caption;
                      buttonmatch2.hint := button_buttonmatch2_hint;
                      buttonmeasureinserts.caption := button_buttonmeasureinserts_caption;
                      buttonmeasureinserts.hint := button_buttonmeasureinserts_hint;
                      buttonmovecouch.hint := button_buttonmovecouch_hint;
                      buttonnext.hint := button_buttonnext_hint;
                      buttonnextstep.caption := button_buttonnextstep_caption;
                      buttonnextstep.hint := button_buttonnextstep_hint;
                      buttonpause.caption := button_buttonpause_caption;
                      buttonpause.hint := button_buttonpause_hint;
                      buttonplay4d.caption := button_buttonplay4d_caption;
                      buttonplay4d.hint := button_buttonplay4d_hint;
                      buttonprevious.caption := button_buttonprevious_caption;
                      buttonprevious.hint := button_buttonprevious_hint;
                      buttonread4dtransform.caption := button_buttonread4dtransform_caption;
                      buttonreadmatch.caption := button_buttonreadmatch_caption;
                      buttonreconstruct.caption := button_buttonreconstruct_caption;
                      buttonreconstruct.hint := button_buttonreconstruct_hint;
                      buttonreconstructorview.caption := button_buttonreconstructorview_caption;
                      buttonreconstructorview.hint := button_buttonreconstructorview_hint;
                      buttonresetmatch.hint := button_buttonresetmatch_hint;
                      buttonroistats.caption := button_buttonroistats_caption;
                      buttonrun.caption := button_buttonrun_caption;
                      buttonrun.hint := button_buttonrun_hint;
                      buttonsavegainoffset.caption := button_buttonsavegainoffset_caption;
                      buttonsavereference.caption := button_buttonsavereference_caption;
                      buttonsavereference.hint := button_buttonsavereference_hint;
                      buttonsavescan.caption := button_buttonsavescan_caption;
                      buttonsavescan.hint := button_buttonsavescan_hint;
                      buttonscan.caption := button_buttonscan_caption;
                      buttonscan.hint := button_buttonscan_hint;
                      buttonselectlatest.caption := button_buttonselectlatest_caption;
                      buttonselectlatest.hint := button_buttonselectlatest_hint;
                      buttonsetcorrectionreferencepoint.caption := button_buttonsetcorrectionreferencepoint_caption;
                      buttonsetcorrectionreferencepoint.hint := button_buttonsetcorrectionreferencepoint_hint;
                      buttonsetdelineation.caption := button_buttonsetdelineation_caption;
                      buttonsetdelineation.hint := button_buttonsetdelineation_hint;
                      buttonsetdose.caption := button_buttonsetdose_caption;
                      buttonsetdose.hint := button_buttonsetdose_hint;
                      buttonsetplan.caption := button_buttonsetplan_caption;
                      buttonsetplan.hint := button_buttonsetplan_hint;
                      buttonsetreferencemask.caption := button_buttonsetreferencemask_caption;
                      buttonsetreferencemask.hint := button_buttonsetreferencemask_hint;
                      buttonsetroi.caption := button_buttonsetroi_caption;
                      buttonsetroi.hint := button_buttonsetroi_hint;
                      buttonsetscan.caption := button_buttonsetscan_caption;
                      buttonsetscan.hint := button_buttonsetscan_hint;
                      buttonstat.caption := button_buttonstat_caption;
                      buttonstopstep4d.caption := button_buttonstopstep4d_caption;
                      buttonstopstep4d.hint := button_buttonstopstep4d_hint;
                      buttonstructures.caption := button_buttonstructures_caption;
                      buttonstructures.hint := button_buttonstructures_hint;
                      buttonsummarizeclip.caption := button_buttonsummarizeclip_caption;
                      buttontoreference.caption := button_buttontoreference_caption;
                      buttontoreference.hint := button_buttontoreference_hint;
                      buttonwritematch.caption := button_buttonwritematch_caption;
                      buttonwritematch.hint := button_buttonwritematch_hint;
                      buttonzoom.caption := button_buttonzoom_caption;
                      buttonzoom.hint := button_buttonzoom_hint;
                      buttonzoomout.caption := button_buttonzoomout_caption;
                      buttonzoomout.hint := button_buttonzoomout_hint;
                      calibration1.caption := menu_calibration1_caption;
                      centerofclipbox1.caption := menu_centerofclipbox1_caption;
                      centerofmask1.caption := menu_centerofmask1_caption;
                      checkbox4dcorrected.caption := checkbox_checkbox4dcorrected_caption;
                      checkboxadvancedoptions.caption := checkbox_checkboxadvancedoptions_caption;
                      checkboxadvancedoptions.hint := checkbox_checkboxadvancedoptions_hint;
                      checkboxallframes.caption := checkbox_checkboxallframes_caption;
                      checkboxallrois.caption := checkbox_checkboxallrois_caption;
                      radiobuttoncurrentframe.caption := radiobuttoncurrentframes_caption;
                      radiobuttonallframes.caption := radiobuttonallframes_caption;
                      checkboxcorrectionreference.caption := checkbox_checkboxcorrectionreference_caption;
                      checkboxcorrectionreference.hint := checkbox_checkboxcorrectionreference_hint;
                      checkboxdelineation.caption := checkbox_checkboxdelineation_caption;
                      checkboxdelineation.hint := checkbox_checkboxdelineation_hint;
                      checkboxdose.caption := checkbox_checkboxdose_caption;
                      checkboxdose.hint := checkbox_checkboxdose_hint;
                      checkboxdoseaccu.caption := checkbox_checkboxdoseaccu_caption;
                      checkboxdoseaccu.hint := checkbox_checkboxdoseaccu_hint;
                      checkboxenablerotation.caption := checkbox_checkboxenablerotation_caption;
                      checkboxenablerotation.hint := checkbox_checkboxenablerotation_hint;
                      checkboxghostcorrection.caption := checkbox_checkboxghostcorrection_caption;
                      checkboxghostcorrection.enabled := false;
                      checkboxghostcorrection.checked := false;
                      checkboxlockrap.caption := checkbox_checkboxlockrap_caption;
                      checkboxlockrap.hint := checkbox_checkboxlockrap_hint;
                      checkboxlockrcc.caption := checkbox_checkboxlockrcc_caption;
                      checkboxlockrcc.hint := checkbox_checkboxlockrcc_hint;
                      checkboxlockrlr.caption := checkbox_checkboxlockrlr_caption;
                      checkboxlockrlr.hint := checkbox_checkboxlockrlr_hint;
                      checkboxmarkers.caption := checkbox_checkboxmarkers_caption;
                      checkboxmarkers.hint := checkbox_checkboxmarkers_hint;
                      checkboxmean.caption := checkbox_checkboxmean_caption;
                      checkboxmedian.caption := checkbox_checkboxmedian_caption;
                      checkboxmedian.hint := checkbox_checkboxmedian_hint;
                      checkboxmultithread.caption := checkbox_checkboxmultithread_caption;
                      checkboxmultithread.hint := checkbox_checkboxmultithread_hint;
                      checkboxplan.caption := checkbox_checkboxplan_caption;
                      checkboxplan.hint := checkbox_checkboxplan_hint;
                      checkboxrecordform.caption := checkbox_checkboxrecordform_caption;
                      checkboxreferencemask.caption := checkbox_checkboxreferencemask_caption;
                      checkboxreferencemask.hint := checkbox_checkboxreferencemask_hint;
                      checkboxreversemotion.caption := checkbox_checkboxreversemotion_caption;
                      checkboxroi.caption := checkbox_checkboxroi_caption;
                      checkboxroi.hint := checkbox_checkboxroi_hint;
                      checkboxscan.caption := checkbox_checkboxscan_caption;
                      checkboxscan.hint := checkbox_checkboxscan_hint;
                      checkboxusecalibrationimages.caption := checkbox_checkboxusecalibrationimages_caption;
                      checkboxusecalibrationimages.hint := checkbox_checkboxusecalibrationimages_hint;
                      checkboxwarp.caption := checkbox_checkboxwarp_caption;
                      clearmask.caption := menu_clearmask_caption;
                      clinicalmode.caption := menu_clinicalmode_caption;
                      clipbox1.caption := menu_clipbox1_caption;
                      colorstringgrid1.hint := stringgrid_colorstringgrid1_hint;
                      colorstringgrid2.hint := stringgrid_colorstringgrid2_hint;
                      colorstringgrid3.hint := stringgrid_colorstringgrid3_hint;
                      colorstringgridsummary.hint := stringgrid_colorstringgridsummary_hint;
                      comboboxclipboxmatch.hint := combobox_comboboxclipboxmatch_hint;
                      comboboxcorrectionby.hint := combobox_comboboxcorrectionby_hint;
                      comboboxcorrectionprotocol.hint := combobox_comboboxcorrectionprotocol_hint;
                      comboboxdisplaymode.hint := combobox_comboboxdisplaymode_hint;
                      comboboxfiltertype.hint := combobox_comboboxfiltertype_hint;
                      comboboxmaskmatch.hint := combobox_comboboxmaskmatch_hint;
                      comboboxmatch.hint := combobox_comboboxmatch_hint;
                      comboboxprotocol.hint := combobox_comboboxprotocol_hint;
                      comboboxregistrationprotocol.hint := combobox_comboboxregistrationprotocol_hint;
                      comboboxsliceaveraging.hint := combobox_comboboxsliceaveraging_hint;
                      comboboxtransformmode.hint := combobox_comboboxtransformmode_hint;
                      convertmatch.caption := button_convertmatch_caption;
                      copy1.caption := menu_copy1_caption;
                      copyallrecons.caption := menu_copyallrecons_caption;
                      copyallscans.caption := menu_copyallscans_caption;
                      copyalltolocal.caption := menu_copyalltolocal_caption;
                      copyeconstructions.caption := menu_copyeconstructions_caption;
                      copyprojections.caption := menu_copyprojections_caption;
                      copyreferencedata.caption := menu_copyreferencedata_caption;
                      copyreferencesettings.caption := menu_copyreferencesettings_caption;
                      copythisreconstruction.caption := menu_copythisreconstruction_caption;
                      copythisscan.caption := menu_copythisscan_caption;
                      copytoclipboard1.caption := menu_copytoclipboard1_caption;
                      copyxvifile.caption := button_copyxvifile_caption;
                      correction1.caption := menu_correction1_caption;
                      createcatphanreference1.caption := menu_createcatphanreference1_caption;
                      creategeometry.caption := menu_creategeometry_caption;
                      createmask1.caption := menu_createmask1_caption;
                      detectmarkers2.caption := menu_detectmarkers2_caption;
                      editbeamhardening.hint := edit_editbeamhardening_hint;
                      editfp0.hint := edit_editfp0_hint;
                      editfp1.hint := edit_editfp1_hint;
                      editinterpolate.hint := edit_editinterpolate_hint;
                      editmask.caption := menu_editmask_caption;
                      masklocked.caption := menu_masklocked_caption;
                      editprojectionimageresolution.hint := edit_editprojectionimageresolution_hint;
                      editreconstructedimageresolution.hint := edit_editreconstructedimageresolution_hint;
                      editreconstructionsize.hint := edit_editreconstructionsize_hint;
                      editrotationap.hint := edit_editrotationap_hint;
                      editrotationcc.hint := edit_editrotationcc_hint;
                      editrotationlr.hint := edit_editrotationlr_hint;
                      editscale.hint := edit_editscale_hint;
                      editskip.hint := edit_editskip_hint;
                      editspr.hint := edit_editspr_hint;
                      edittranslationap.hint := edit_edittranslationap_hint;
                      edittranslationcc.hint := edit_edittranslationcc_hint;
                      edittranslationlr.hint := edit_edittranslationlr_hint;
                      edituseints.hint := edit_edituseints_hint;
                      exit1.caption := menu_exit1_caption;
                      exitaccept1.caption := menu_exitaccept1_caption;
                      exportmatched3d1.caption := menu_exportmatched3d1_caption;
                      exportmatched4d1.caption := menu_exportmatched4d1_caption;
                      exportraw3d1.caption := menu_exportraw3d1_caption;
                      exportraw4d1.caption := menu_exportraw4d1_caption;
                      file1.caption := menu_file1_caption;
                      gotocorrectionreferencepoint.caption := menu_gotocorrectionreferencepoint_caption;
                      gotoisocenter.caption := menu_gotoisocenter_caption;
                      gotomarker.caption := menu_gotomarker_caption;
                      hard1.caption := menu_hard1_caption;
                      help1.caption := menu_help1_caption;
                      importdose1.caption := menu_importdose1_caption;
                      label1.caption := label_label1_caption;
                      label10.caption := label_label10_caption;
                      label11.caption := label_label11_caption;
                      label12.caption := label_label12_caption;
                      label13.caption := label_label13_caption;
                      label14.caption := label_label14_caption;
                      label15.caption := label_label15_caption;
                      label16.caption := label_label16_caption;
                      label17.caption := label_label17_caption;
                      label18.caption := label_label18_caption;
                      label19.caption := label_label19_caption;
                      label2.caption := label_label2_caption;
                      label20.caption := label_label20_caption;
                      label21.caption := label_label21_caption;
                      label22.caption := label_label22_caption;
                      label23.caption := label_label23_caption;
                      label24.caption := label_label24_caption;
                      label25.caption := label_label25_caption;
                      label26.caption := label_label26_caption;
                      label27.caption := label_label27_caption;
                      label28.caption := label_label28_caption;
                      label29.caption := label_label29_caption;
                      label3.caption := label_label3_caption;
                      label31.caption := label_label31_caption;
                      label32.caption := label_label32_caption;
                      label33.caption := label_label33_caption;
                      label34.caption := label_label34_caption;
                      label36.caption := label_label36_caption;
                      label37.caption := label_label37_caption;
                      label38.caption := label_label38_caption;
                      label39.caption := label_label39_caption;
                      label4.caption := label_label4_caption;
                      label40.caption := label_label40_caption;
                      label41.caption := label_label41_caption;
                      label42.caption := label_label42_caption;
                      label43.caption := label_label43_caption;
                      label44.caption := label_label44_caption;
                      label45.caption := label_label45_caption;
                      label46.caption := label_label46_caption;
                      label47.caption := label_label47_caption;
                      label48.caption := label_label48_caption;
                      label49.caption := label_label49_caption;
                      label4d.caption := label_label4d_caption;
                      label4d.hint := label_label4d_hint;
                      label5.caption := label_label5_caption;
                      label50.caption := label_label50_caption;
                      label54.caption := label_label54_caption;
                      label55.caption := label_label55_caption;
                      label56.caption := label_label56_caption;
                      label57.caption := label_label57_caption;
                      label6.caption := label_label6_caption;
                      label61.caption := label_label61_caption;
                      label62.caption := label_label62_caption;
                      label65.caption := label_label65_caption;
                      label66.caption := label_label66_caption;
                      label67.caption := label_label67_caption;
                      label68.caption := label_label68_caption;
                      label69.caption := label_label69_caption;
                      label7.caption := label_label7_caption;
                      label70.caption := label_label70_caption;
                      label71.caption := label_label71_caption;
                      label72.caption := label_label72_caption;
                      label73.caption := label_label73_caption;
                      label74.caption := label_label74_caption;
                      label75.caption := label_label75_caption;
                      label79.caption := label_label79_caption;
                      label8.caption := label_label8_caption;
                      label80.caption := label_label80_caption;
                      label81.caption := label_label81_caption;
                      label9.caption := label_label9_caption;
                      labelactualheight.caption := label_labelactualheight_caption;
                      labelactuallat.caption := label_labelactuallat_caption;
                      labelactuallong.caption := label_labelactuallong_caption;
                      labelcomputedheight.caption := label_labelcomputedheight_caption;
                      labelcomputedheight2.caption := label_labelcomputedheight2_caption;
                      labelcomputedlat.caption := label_labelcomputedlat_caption;
                      labelcomputedlat2.caption := label_labelcomputedlat2_caption;
                      labelcomputedlong.caption := label_labelcomputedlong_caption;
                      labelcomputedlong2.caption := label_labelcomputedlong2_caption;
                      labelcomputedpitch2.caption := label_labelcomputedpitch2_caption;
                      labelcomputedroll2.caption := label_labelcomputedroll2_caption;
                      labelcomputedyaw2.caption := label_labelcomputedyaw2_caption;
                      labelelektamode.caption := label_labelelektamode_caption;
                      labelheight.caption := label_labelheight_caption;
                      labelheight2.caption := label_labelheight2_caption;
                      labellat.caption := label_labellat_caption;
                      labellat2.caption := label_labellat2_caption;
                      labellimitshelp.caption := label_labellimitshelp_caption;
                      labellong.caption := label_labellong_caption;
                      labellong2.caption := label_labellong2_caption;
                      labelpitch2.caption := label_labelpitch2_caption;
                      labelrois.caption := label_labelrois_caption;
                      labelroll2.caption := label_labelroll2_caption;
                      labeltabpage.caption := label_labeltabpage_caption;
                      labelyaw2.caption := label_labelyaw2_caption;
                      loadacceptedmatch.caption := menu_loadacceptedmatch_caption;
                      loadbonematch.caption := menu_loadbonematch_caption;
                      loadonlinemarkers.caption := menu_loadonlinemarkers_caption;
                      loadreferencemarkers.caption := menu_loadreferencemarkers_caption;
                      loadtumormatch.caption := menu_loadtumormatch_caption;
                      lung1.caption := menu_lung1_caption;
                      makematchinactive.caption := menu_makematchinactive_caption;
                      mask1.caption := menu_mask1_caption;
                      matchclassbutton.caption := button_matchclassbutton_caption;
                      measurecatphaninserts1.caption := menu_measurecatphaninserts1_caption;
                      createmultianglegainfile1.caption := menu_createmultianglegainfile1_caption;
                      medium1.caption := menu_medium1_caption;
                      memoclipboxcorrectiondifference.hint := memo_memoclipboxcorrectiondifference_hint;
                      memomaskclipboxdifference.hint := memo_memomaskclipboxdifference_hint;
                      menuclipboxlocked.caption := menu_menuclipboxlocked_caption;
                      menushowunlockpresentclipbox.caption := menu_menushowunlockpresentclipbox_caption;
                      n1.caption := menu_n1_caption;
                      n10mm1.caption := menu_n10mm1_caption;
                      n15mm1.caption := menu_n15mm1_caption;
                      n2.caption := menu_n2_caption;
                      n20mm1.caption := menu_n20mm1_caption;
                      n2mm1.caption := menu_n2mm1_caption;
                      n3.caption := menu_n3_caption;
                      n4.caption := menu_n4_caption;
                      n4mm1.caption := menu_n4mm1_caption;
                      n5.caption := menu_n5_caption;
                      n6.caption := menu_n6_caption;
                      overview1.caption := menu_overview1_caption;
                      page1.caption := menu_page1_caption;
                      paintbrushsize.caption := menu_paintbrushsize_caption;
                      pasteasreference1.caption := menu_pasteasreference1_caption;
                      pastetostitch1.caption := menu_pastetostitch1_caption;
                      plannedisoc1.caption := menu_plannedisoc1_caption;
                      print1.caption := menu_print1_caption;
                      readmask.caption := menu_readmask_caption;
                      recordvideo1.caption := menu_recordvideo1_caption;
                      refpointatcenterofclipbox1.caption := menu_refpointatcenterofclipbox1_caption;
                      refpointatcenterofdelineation.caption := menu_refpointatcenterofdelineation_caption;
                      refpointatisocenter1.caption := menu_refpointatisocenter1_caption;
                      refpointatmarker.caption := menu_refpointatmarker_caption;
                      research.caption := menu_research_caption;
                      restore1.caption := menu_restore1_caption;
                      saveas1.caption := menu_saveas1_caption;
                      saveonlinemarkers.caption := menu_saveonlinemarkers_caption;
                      savereferencemarkerlist.caption := menu_savereferencemarkerlist_caption;
                      shiftscan1.caption := menu_shiftscan1_caption;
                      showall1.caption := menu_showall1_caption;
                      showmarkertool.caption := menu_showmarkertool_caption;
                      soft1.caption := menu_soft1_caption;
                      tools.caption := menu_tools_caption;
                      trackbarfilterkernel.hint := trackbar_trackbarfilterkernel_hint;
                      trackbarrotationap.hint := trackbar_trackbarrotationap_hint;
                      trackbarrotationcc.hint := trackbar_trackbarrotationcc_hint;
                      trackbarrotationlr.hint := trackbar_trackbarrotationlr_hint;
                      trackbartranslationap.hint := trackbar_trackbartranslationap_hint;
                      trackbartranslationcc.hint := trackbar_trackbartranslationcc_hint;
                      trackbartranslationlr.hint := trackbar_trackbartranslationlr_hint;
                      trackbarweight.hint := trackbar_trackbarweight_hint;
                      updown1.hint := updown_updown1_hint;
                      updownrois.hint := updown_updownrois_hint;
                      verysoft1.caption := menu_verysoft1_caption;
                      viewerhelp1.caption := menu_viewerhelp1_caption;
                      viewpoint1.caption := menu_viewpoint1_caption;
                      visualizebonesegmentation1.caption := menu_visualizebonesegmentation1_caption;
                      warpform1.caption := menu_warpform1_caption;
                      writemask.caption := menu_writemask_caption;
                    if avlstate\>0 then
                    begin
                      buttonsetscan.visible := false;
                      buttonsetplan.visible := false;
                      checkboxplan.visible := false;
                      buttonsetdelineation.visible := false;
                      buttonmarkers.visible := false;
                      checkboxmarkers.visible := false;
                      buttonclearreference.visible := false;
                      buttonsetreferencemask.visible := false;
                      buttonsetroi.visible := false;
                      buttonloadreference.visible := false;
                      buttonsavereference.visible := false;
                      pagecontrol1.pages[0].tabvisible := false;
                      if not pagecontrol1.pages[1].tabvisible then
                      begin
                        pagecontrol1.tabheight := 1;
                        pagecontrol1.tabwidth  := 1;
                      end;
                      panelelektamode.visible := true;
                      case avlstate of
                        1: labelelektamode.caption := mode1_caption;
                        2: labelelektamode.caption := mode2_caption;
                        3: labelelektamode.caption := mode3_caption;
                        4: labelelektamode.caption := mode4_caption;
                        5: labelelektamode.caption := mode5_caption;
                        6: labelelektamode.caption := mode2_caption;
                        else labelelektamode.caption := mode_unknown;
                      end;
                      if readonly then labelelektamode.caption := labelelektamode.caption + mode_readonly;
                      buttonloadreference.caption := caption_reload;
                      buttonloadmatch.caption := caption_reload;
                      buttonacceptmatch.visible := false;
                      buttonloadmatch.visible     := false;
                    end;
                    if xviischildwindow then
                    begin
                      panelnkicouchshift.visible := false;
                      panelimage.visible := false;
                      panelrotation.visible := false;
                      paneltranslation.visible := false;
                      panelelektacouchshift.visible := false;
                      panelreferencepreset.visible := false;
                      panelalignment.visible := false;
                      panelelektamode.visible := false;
                      tabcontrol1.visible := false;
                      progressbar3.left := 907;
                      progressbar3.height := 762;
                      statusbar1.visible := false;
                      borderstyle := bsnone;
                      quirtviewerupdcoronal.parent := self;
                      quirtviewerupdsagittal.parent := self;
                      quirtviewerupdtransversal.parent := self;
                      progressbar3.parent := self;
                      pagecontrol1.visible := false;
                    end;
                    colorstringgrid1.cells[1,0] := grid_clipbox;
                    colorstringgrid1.cells[2,0] := grid_mask;
                    colorstringgrid1.cellprops[1,0].alignment := tacenter;
                    colorstringgrid1.cellprops[2,0].alignment := tacenter;
                    colorstringgrid1.cellprops[3,0].alignment := tacenter;
                    colorstringgrid1.cellprops[1,0].bgcolor := clbtnface;
                    colorstringgrid1.cellprops[2,0].bgcolor := clbtnface;
                    colorstringgrid1.cellprops[3,0].bgcolor := clbtnface;
                    colorstringgrid1.cells[0,1] := grid_tx;
                    colorstringgrid1.cells[0,2] := grid_ty;
                    colorstringgrid1.cells[0,3] := grid_tz;
                    colorstringgrid1.cells[0,4] := grid_rx;
                    colorstringgrid1.cells[0,5] := grid_ry;
                    colorstringgrid1.cells[0,6] := grid_rz;
                    for i:=1 to 6 do
                    begin
                      colorstringgrid1.cellprops[0,i].alignment := tacenter;
                      colorstringgrid1.cellprops[0,i].bgcolor := clbtnface;
                    end;
                    for i:=1 to 6 do
                    begin
                      colorstringgrid1.cellprops[1,i].alignment := tacenter;
                      colorstringgrid1.cellprops[2,i].alignment := tacenter;
                    end;
                    colorstringgrid1.cells[3,0] := grid_adjust;
                    for i:=1 to 6 do
                    begin
                      colorstringgrid1.cells[3,i] := \'\';
                      colorstringgrid1.cellprops[3,i].box.checked := false;
                    end;
                    if screen.pixelsperinch = 120 then
                    begin
                      colorstringgrid1.defaultcolwidth := (colorstringgrid1.defaultcolwidth * 120) div 96;
                      colorstringgrid2.defaultcolwidth := (colorstringgrid2.defaultcolwidth * 120) div 96;
                      colorstringgrid3.defaultcolwidth := (colorstringgrid3.defaultcolwidth * 120) div 96;
                      colorstringgrid1.defaultrowheight := (colorstringgrid1.defaultrowheight * 120) div 96;
                      colorstringgrid2.defaultrowheight := (colorstringgrid2.defaultrowheight * 120) div 96;
                      colorstringgrid3.defaultrowheight := (colorstringgrid3.defaultrowheight * 120) div 96;
                    end;
                    colorstringgrid1.scrollbars := ssnone;
                    colorstringgrid2.scrollbars := ssnone;
                    colorstringgrid3.scrollbars := ssnone;
                    colorstringgrid3.options := colorstringgrid3.options - [goediting];
                    colorstringgrid2.options := colorstringgrid2.options - [goediting];
                    colorstringgrid2.cells[1,0] := grid_allthesame;
                    colorstringgrid2.cellprops[1,0].box.checked := true;
                    colorstringgrid2.cellprops[1,0].box.enabled := true;
                    colorstringgrid2.cellprops[1,0].span := 2;
                    colorstringgrid2.cellprops[1,0].alignment := tacenter;
                    colorstringgrid2.cells[0,0] := grid_limits;
                    colorstringgrid2.cells[0,1] := grid_tx;
                    colorstringgrid2.cells[0,2] := grid_ty;
                    colorstringgrid2.cells[0,3] := grid_tz;
                    colorstringgrid2.cells[1,4] := grid_allthesame;
                    colorstringgrid2.cellprops[1,4].box.checked := true;
                    colorstringgrid2.cellprops[1,4].box.enabled := true;
                    colorstringgrid2.cellprops[1,4].span := 2;
                    colorstringgrid2.cellprops[1,4].alignment := tacenter;
                    colorstringgrid2.cells[0,4] := grid_limits2;
                    colorstringgrid2.cells[0,5] := grid_rx;
                    colorstringgrid2.cells[0,6] := grid_ry;
                    colorstringgrid2.cells[0,7] := grid_rz;
                    for i:=0 to 7 do
                    begin
                      colorstringgrid2.cellprops[0,i].alignment := tacenter;
                      colorstringgrid2.cellprops[0,i].bgcolor := clbtnface;
                    end;
                    colorstringgrid2.cellprops[1,0].box.onclick := boxclick;
                    colorstringgrid2.cellprops[1,4].box.onclick := boxclick;
                    boxclick(colorstringgrid2.cellprops[1,0].box);
                    colorstringgrid3.cells[1,0] := grid_allthesame;
                    colorstringgrid3.cellprops[1,0].box.checked := true;
                    colorstringgrid3.cellprops[1,0].box.enabled := true;
                    colorstringgrid3.cellprops[1,0].span := 2;
                    colorstringgrid3.cellprops[1,0].alignment := tacenter;
                    colorstringgrid3.cells[0,0] := grid_limits;
                    colorstringgrid3.cells[0,1] := grid_tx;
                    colorstringgrid3.cells[0,2] := grid_ty;
                    colorstringgrid3.cells[0,3] := grid_tz;
                    colorstringgrid3.cells[1,4] := grid_allthesame;
                    colorstringgrid3.cellprops[1,4].box.checked := true;
                    colorstringgrid3.cellprops[1,4].box.enabled := true;
                    colorstringgrid3.cellprops[1,4].span := 2;
                    colorstringgrid3.cellprops[1,4].alignment := tacenter;
                    colorstringgrid3.cells[0,4] := grid_limits2;
                    colorstringgrid3.cells[0,5] := grid_rx;
                    colorstringgrid3.cells[0,6] := grid_ry;
                    colorstringgrid3.cells[0,7] := grid_rz;
                    for i:=0 to 7 do
                    begin
                      colorstringgrid3.cellprops[0,i].alignment := tacenter;
                      colorstringgrid3.cellprops[0,i].bgcolor := clbtnface;
                    end;
                    colorstringgrid3.cellprops[1,0].box.onclick := boxclick;
                    colorstringgrid3.cellprops[1,4].box.onclick := boxclick;
                    boxclick(colorstringgrid3.cellprops[1,0].box);
                    quirtviewer1.transpose.value := 0;
                    quirtviewer1.interpolatedzoom.value := 0;
                    quirtviewer1.slicedir.value := 3;
                    quirtviewer1.onprocessing := quirtviewerprocessing;
                    if avlstate\>0 then
                    begin
                      patientid          := inifile.readstring(\'identification\', \'patientid\', \'\');
                      patientname        := inifile.readstring(\'identification\', \'lastname\', \'\') + \', \' +
                                            inifile.readstring(\'identification\', \'firstname\', \'\');
                      treatmentid        := inifile.readstring(\'identification\', \'treatmentid\', \'\');
                      plansopuid         := inifile.readstring(\'identification\', \'referenceuid\', \'\');
                      treatmentuid       := inifile.readstring(\'identification\', \'referenceuid\', \'\');
                      elektatreatmentuid := inifile.readstring(\'identification\', \'treatmentuid\', \'\');
                      scanuid            := inifile.readstring(\'identification\', \'scanuid\', \'\');
                      titlebarstring         := inifile.readstring(\'identification\', \'titlebarstring\', \'\');
                      referenceoverlaystring := inifile.readstring(\'identification\', \'referenceoverlaystring\', \'\');
                      onlineoverlaystring    := inifile.readstring(\'identification\', \'onlineoverlaystring\', \'\');
                      dob                    := inifile.readstring(\'identification\', \'dob\', \'\');
                      reconfilebase      := inifile.readstring(\'xvi\', \'reconstructedscansdirectory\', \'\');
                      fixdirectory(reconfilebase);
                      adminfilebase      := inifile.readstring(\'xvi\', \'administrativefilesdirectory\', \'\');
                      fixdirectory(adminfilebase);
                      substituteparms(adminfilebase);
                        sysutils.forcedirectories(extractfilepath(adminfilebase));
                      cachefilebase      := inifile.readstring(\'xvi\', \'referencecachedirectory\', \'\');
                      fixdirectory(cachefilebase);
                      if avlstate in [2, 6] then
                        cachefilebase := cachefilebase + plansopuid + \'\\\';
                      projectionfilebase := inifile.readstring(\'xvi\', \'projectiondirectory\', \'\');
                      fixdirectory(projectionfilebase);
                      h := tqinifile.create(paramstr2);
                      anglefilebase      := h.readstring(\'xvi\', \'administrativefilesdirectory\', \'\') +
                                            h.readstring(\'reconstruction\', \'projectionanglefile\', \'\');
                      h.free;
                      fixdirectory(anglefilebase);
                      matchresultlogfile := inifile.readstring(\'xvi\', \'matchresultlogfile\', \'\');
                      flexmapfilename := inifile.readstring(\'reconstruction\', \'flexmap\', \'\');
                      useonlinereconstruction := inifile.readbool(\'reconstruction\', \'useonlinereconstruction\', false);
                      projectiontimeout := inifile.readinteger(\'reconstruction\', \'projectiontimeout\', 10);
                      fakeimporturl := inifile.readstring(\'xvi\', \'fakeimporturl\', \'[xvi]:\');
                      patienturl := fakeimporturl + patientid;
                      if assigned(uexportscan.okbottomdlg) then
                      begin
                        uexportscan.okbottomdlg.edit1.text := patientid;
                        uexportscan.okbottomdlg.edit2.text := patientname;
                        uexportscan.okbottomdlg.edit3.text := \'\';
                      end;
                      if titlebarstring\<\>\'\' then
                        caption:=titlebarstring
                      else
                        caption:=format(nki_caption, [patientid, patientname]);
                      if avlstate in [2, 4, 6] then
                      begin
                        if useonlinereconstruction then
                          numframes:=9000
                        else
                        begin
                          for i:=0 to 9000 do
                          begin
                            s := format(anglefilebase, [i]);
                            for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                            if fileexists(s) then numframes := i+1 else break;
                          end;
                        end;
                        frameid   := 0;
                        if useonlinereconstruction then
                          projdim := inifile.readinteger(\'reconstruction\', \'camerawidth\', 512)
                        else
                        begin
                          s := format(anglefilebase, [frameid]);
                          for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                          h :=tqinifile.create(s);
                          s := format(\'%.4d\', [frameid]);
                          s := projectionfilebase + h.readstring(s, \'projectiondatafile\', \'\');
                          read_heimann_his(f, s);
                          projdim := f.dimensions[0];
                          h.free;
                        end;
                        prepad  := 0;
                        case projdim of
                          960, 480, 240, 120, 60:
                            begin
                              detectorsize := 43.0;
                              fdd          := 153.2;
                            end;
                          780, 390, 195:
                            begin
                              detectorsize := 28.7;
                              fdd          := 153.6;
                            end;
                          1024, 512, 256, 128, 64:
                            begin
                              detectorsize := 40.96;
                              fdd          := 153.6;
                            end;
                          else
                            begin
                              showmessage(\'unsupported detector\');
                              detectorsize := 10.0;
                              fdd          := 153.6;
                            end;
                        end;
                        detectorsize := inifile.readfloat(\'xvi\', \'detectorsize\', detectorsize);
                        fdd := inifile.readfloat(\'xvi\', \'focusdetectordistance\', fdd);
                        fid := inifile.readfloat(\'xvi\', \'focusisocdistance\', 100.00);
                      end;
                    end;
                    filteredrecords := tstringlist.create;
                    filteredrecords.sorted := true;
                    filteredrecords.duplicates := dupignore;
                    scanlist := tstringlist.create;
                    zoomfix := inifile.readfloat(\'xvi\', \'zoomfix\', 1);
                    gridvoxelsize := inifile.readfloat(\'xvi\', \'gridvoxelsize\', 0.1);
                    enabletestmode := inifile.readbool(\'xvi\', \'testmode\', false);
                    progressoffset := 0;
                    progressscale := 1;
                    if avlstate\>0 then
                    begin
                      comboboxprotocol.items.clear;
                      comboboxprotocol.items.add(reconprotocolprog);
                    end
                    else
                    begin
                      comboboxprotocol.items.clear;
                      inifile.readsections(comboboxprotocol.items);
                      i := comboboxprotocol.items.indexof(\'planselection\');
                      if i\>=0 then
                        comboboxprotocol.items.delete(i);
                      comboboxprotocol.items[0] := reconprotocolgui;
                    end;
                    comboboxprotocol.dropdowncount := min(comboboxprotocol.items.count, 50);
                    quirtviewerupdcoronal.fieldname[5].value := \'\';
                    quirtviewerupdsagittal.fieldname[5].value := \'\';
                    quirtviewerupdtransversal.fieldname[5].value := \'\';
                    quirtviewerupdcoronal.fieldname[7].value := viewer_accu;
                    quirtviewerupdsagittal.fieldname[7].value := viewer_accu;
                    quirtviewerupdtransversal.fieldname[7].value := viewer_accu;
                    quirtviewerupdcoronal.interpolatedzoom := quirtviewerupdtransversal.interpolatedzoom;
                    quirtviewerupdsagittal.interpolatedzoom := quirtviewerupdtransversal.interpolatedzoom;
                    quirtviewerupdtransversal.interpolatedzoom.value := ord(inifile.readbool(\'xvi\', \'interpolatedzoom\', true));
                    quirtviewerupdcoronal.frame := quirtviewerupdtransversal.frame;
                    quirtviewerupdsagittal.frame := quirtviewerupdtransversal.frame;
                    quirtviewerupdcoronal.activeclipbox :=  quirtviewerupdsagittal.activeclipbox;
                    quirtviewerupdtransversal.activeclipbox :=  quirtviewerupdsagittal.activeclipbox;
                    quirtviewerupdcoronal.activeclipbox.value := 1;
                    quirtviewerupdcoronal.activeclipbox.locked := true;
                    quirtviewerupdcoronal.sliceblur := quirtviewerupdtransversal.sliceblur;
                    quirtviewerupdsagittal.sliceblur := quirtviewerupdtransversal.sliceblur;
                    quirtviewerupdtransversal.showhelp := quirtviewerupdsagittal.showhelp;
                    quirtviewerupdcoronal.showhelp     := quirtviewerupdsagittal.showhelp;
                    quirtviewer1.showhelp              := quirtviewerupdsagittal.showhelp;
                    quirtviewerupdcoronal.zoom  := quirtviewerupdtransversal.zoom;
                    quirtviewerupdsagittal.zoom := quirtviewerupdtransversal.zoom;
                    quirtviewerupdcoronal.cutmode := quirtviewerupdsagittal.cutmode;
                    quirtviewerupdtransversal.cutmode := quirtviewerupdsagittal.cutmode;
                    quirtviewerupdcoronal.markerdots[1] := quirtviewerupdsagittal.markerdots[1];
                    quirtviewerupdtransversal.markerdots[1] := quirtviewerupdsagittal.markerdots[1];
                    quirtviewerupdcoronal.markerdots[nmarkers+1] := quirtviewerupdsagittal.markerdots[nmarkers+1];
                    quirtviewerupdtransversal.markerdots[nmarkers+1] := quirtviewerupdsagittal.markerdots[nmarkers+1];
                    correctionreferencepoint  := tavsfield.create(bad);
                    field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                    correctionreferencepoint.debugname := \'0\';
                    quirtviewerupdcoronal.markerdots[2] := correctionreferencepoint;
                    quirtviewerupdsagittal.markerdots[2] := correctionreferencepoint;
                    quirtviewerupdtransversal.markerdots[2] := correctionreferencepoint;
                    quirtviewerupdcoronal.markerdots[3] := quirtviewerupdsagittal.markerdots[3];
                    quirtviewerupdtransversal.markerdots[3] := quirtviewerupdsagittal.markerdots[3];
                    quirtviewerupdsagittal.markerdots[4] := tavsfield.create(bad);
                    field_create(quirtviewerupdsagittal.markerdots[4], \'field 1d 3-space irregular 10-vector byte\', 1);
                    quirtviewerupdsagittal.markerdots[4].empty := false;
                    quirtviewerupdsagittal.markerdots[4].ischangedby := nil;
                    quirtviewerupdcoronal.markerdots[4] := quirtviewerupdsagittal.markerdots[4];
                    quirtviewerupdtransversal.markerdots[4] := quirtviewerupdsagittal.markerdots[4];
                    quirtviewerupdtransversal.transpose.value := 1;
                    quirtviewerupdcoronal.transpose.value := 1;
                    quirtviewerupdsagittal.transpose.value := 1;
                    quirtviewerupdcoronal.slice.value := 128;
                    quirtviewerupdtransversal.slice.value := 128;
                    quirtviewerupdsagittal.slice.value := 128;
                    quirtviewerupdcoronal.sliceborder[1] := quirtviewerupdsagittal.slice;
                    quirtviewerupdcoronal.sliceborder[2] := quirtviewerupdtransversal.slice;
                    quirtviewerupdsagittal.sliceborder[1] := quirtviewerupdcoronal.slice;
                    quirtviewerupdsagittal.sliceborder[2] := quirtviewerupdtransversal.slice;
                    quirtviewerupdtransversal.sliceborder[1] := quirtviewerupdsagittal.slice;
                    quirtviewerupdtransversal.sliceborder[2] := quirtviewerupdcoronal.slice;
                    eulerxfm(machine_to_machineadjust);
                    transformdisplaymode.value := 0;
                    alignmentmode.value := 0;
                    activeregion.value := 0;
                    maskactiveregion.value := 0;
                    machine_to_machineadjustwarpi.clear;
                    viewwarp.clear;
                    externalwarp.clear;
                    online[1].connectviewer(quirtviewerupdcoronal, 1);
                    online[1].connectviewer(quirtviewerupdsagittal, 1);
                    online[1].connectviewer(quirtviewerupdtransversal, 1);
                    quirtviewerupdcoronal.onprocessing := quirtviewerprocessing;
                    quirtviewerupdtransversal.onprocessing := quirtviewerprocessing;
                    quirtviewerupdsagittal.onprocessing := quirtviewerprocessing;
                    quirtviewerupdcoronal.adjust[1] := machine_to_machineadjust;
                    quirtviewerupdsagittal.adjust[1] := machine_to_machineadjust;
                    quirtviewerupdtransversal.adjust[1] := machine_to_machineadjust;
                    quirtviewerupdcoronal.inversewarp[1] := machine_to_machineadjustwarpi;
                    quirtviewerupdsagittal.inversewarp[1] := machine_to_machineadjustwarpi;
                    quirtviewerupdtransversal.inversewarp[1] := machine_to_machineadjustwarpi;
                    quirtviewerupdcoronal.viewwarp := viewwarp;
                    quirtviewerupdsagittal.viewwarp := viewwarp;
                    quirtviewerupdtransversal.viewwarp := viewwarp;
                    quirtviewerupdcoronal.extoutsidewarpfflag.value := true;
                    quirtviewerupdsagittal.extoutsidewarpfflag := quirtviewerupdcoronal.extoutsidewarpfflag;
                    quirtviewerupdtransversal.extoutsidewarpfflag := quirtviewerupdcoronal.extoutsidewarpfflag;
                    quirtviewerupdcoronal.grid := tavsfield.create(bad);
                    quirtviewerupdcoronal.grid.debugname := \'quirtviewerupdcoronal.grid\';
                    quirtviewerupdcoronal.grid.adddependency(onlinecube);
                    quirtviewerupdcoronal.grid.onupdate := updategrid;
                    quirtviewerupdsagittal.grid := tavsfield.create(bad);
                    quirtviewerupdsagittal.grid.debugname := \'quirtviewerupdsagittal.grid\';
                    quirtviewerupdsagittal.grid.adddependency(onlinecube);
                    quirtviewerupdsagittal.grid.onupdate := updategrid;
                    quirtviewerupdtransversal.grid := tavsfield.create(bad);
                    quirtviewerupdtransversal.grid.debugname := \'quirtviewerupdtransversal.grid\';
                    quirtviewerupdtransversal.grid.adddependency(onlinecube);
                    quirtviewerupdtransversal.grid.onupdate := updategrid;
                    quirtviewerupdcoronal.viewtransform := tavsfield.create(bad);
                    quirtviewerupdcoronal.viewtransform.debugname := \'quirtviewerupdcoronal.viewtransform\';
                    quirtviewerupdcoronal.viewtransform.adddependency(online_to_machine);
                    quirtviewerupdcoronal.viewtransform.adddependency(machine_to_machineadjust);
                    quirtviewerupdcoronal.viewtransform.adddependency(reversemotion);
                    quirtviewerupdcoronal.viewtransform.onupdate := updateviewtransform;
                    quirtviewerupdsagittal.viewtransform := tavsfield.create(bad);
                    quirtviewerupdsagittal.viewtransform.debugname := \'quirtviewerupdsagittal.viewtransform\';
                    quirtviewerupdsagittal.viewtransform.adddependency(online_to_machine);
                    quirtviewerupdsagittal.viewtransform.adddependency(machine_to_machineadjust);
                    quirtviewerupdsagittal.viewtransform.adddependency(reversemotion);
                    quirtviewerupdsagittal.viewtransform.onupdate := updateviewtransform;
                    quirtviewerupdtransversal.viewtransform := tavsfield.create(bad);
                    quirtviewerupdtransversal.viewtransform.debugname := \'quirtviewerupdtransversal.viewtransform\';
                    quirtviewerupdtransversal.viewtransform.adddependency(online_to_machine);
                    quirtviewerupdtransversal.viewtransform.adddependency(machine_to_machineadjust);
                    quirtviewerupdtransversal.viewtransform.adddependency(reversemotion);
                    quirtviewerupdtransversal.viewtransform.onupdate := updateviewtransform;
                    reversemotion.value := inifile.readinteger(\'xvi\', \'planningstationary\', 0);
                    checkboxreversemotion.checked := reversemotion.value\<\>0;
                    reference[1].connectviewer(quirtviewerupdcoronal,     2);
                    reference[1].connectviewer(quirtviewerupdsagittal,    2);
                    reference[1].connectviewer(quirtviewerupdtransversal, 2);
                    reference[2].connectviewer(quirtviewerupdcoronal,     4);
                    reference[2].connectviewer(quirtviewerupdsagittal,    4);
                    reference[2].connectviewer(quirtviewerupdtransversal, 4);
                    quirtviewerupdcoronal.trackertransform := machine_to_machineadjust;
                    quirtviewerupdsagittal.trackertransform := machine_to_machineadjust;
                    quirtviewerupdtransversal.trackertransform := machine_to_machineadjust;
                    quirtviewerupdcoronal.trackerviewtransform := quirtviewerupdcoronal.viewtransform;
                    quirtviewerupdsagittal.trackerviewtransform := quirtviewerupdsagittal.viewtransform;
                    quirtviewerupdtransversal.trackerviewtransform := quirtviewerupdtransversal.viewtransform;
                    quirtviewerupdcoronal.trackershapetransform := tavsfield.create(bad);
                    quirtviewerupdsagittal.trackershapetransform := quirtviewerupdcoronal.trackershapetransform;
                    quirtviewerupdtransversal.trackershapetransform := quirtviewerupdcoronal.trackershapetransform;
                    quirtviewerupdcoronal.trackershapetransform.adddependency(reference_to_patient);
                    quirtviewerupdcoronal.trackershapetransform.adddependency(reference_to_siddon);
                    quirtviewerupdcoronal.trackershapetransform.onupdate := updatetrackershapetransform;
                    quirtviewerupdcoronal.trackershape := quirtviewerupdtransversal.trackershape;
                    quirtviewerupdsagittal.trackershape := quirtviewerupdtransversal.trackershape;
                    quirtviewerupdcoronal.trackerdots := quirtviewerupdtransversal.trackerdots;
                    quirtviewerupdsagittal.trackerdots := quirtviewerupdtransversal.trackerdots;
                    quirtviewerupdcoronal.trackerindex := quirtviewerupdtransversal.trackerindex;
                    quirtviewerupdsagittal.trackerindex := quirtviewerupdtransversal.trackerindex;
                    quirtviewerupdcoronal.trackerlut := quirtviewerupdtransversal.trackerlut;
                    quirtviewerupdsagittal.trackerlut := quirtviewerupdtransversal.trackerlut;
                    if getfullinifilename(\'_potatorl_vr.wrl\') \<\> \'\' then
                      vrml_read(quirtviewerupdcoronal.trackerdots, quirtviewerupdcoronal.trackerindex, quirtviewerupdcoronal.trackerlut, getfullinifilename(\'_potatorl_vr.wrl\'));
                    machine_to_machineadjust.onchanged := changemachine_to_machineadjust;
                    transform4d.debugname := \'transform4d\';
                    quirtviewerupdcoronal.frame.debugname := \'quirtviewerupdcoronal.frame\';
                    activeregion.debugname := \'activeregion\';
                    maskactiveregion.debugname := \'maskactiveregion\';
                    alignmentmode.debugname := \'alignmentmode\';
                    transformdisplaymode.debugname := \'transformdisplaymode\';
                    machine_to_machineadjust.adddependency(transform4d);
                    machine_to_machineadjust.adddependency(quirtviewerupdcoronal.frame);
                    machine_to_machineadjust.adddependency(activeregion);
                    machine_to_machineadjust.adddependency(maskactiveregion);
                    machine_to_machineadjust.adddependency(alignmentmode);
                    machine_to_machineadjust.adddependency(transformdisplaymode);
                    machine_to_machineadjust.onupdate := updatemachine_to_machineadjust;
                    quirtviewerupdsagittal.text[2].adddependency(transform4d);
                    quirtviewerupdsagittal.text[2].adddependency(quirtviewerupdcoronal.frame);
                    quirtviewerupdsagittal.text[2].adddependency(activeregion);
                    quirtviewerupdsagittal.text[2].adddependency(maskactiveregion);
                    quirtviewerupdsagittal.text[2].adddependency(alignmentmode);
                    quirtviewerupdsagittal.text[2].adddependency(transformdisplaymode);
                    quirtviewerupdsagittal.text[2].onupdate := updatesagitaltext2;
                    machine_to_machineadjustwarpi.adddependency(transform4d);
                    machine_to_machineadjustwarpi.adddependency(quirtviewerupdcoronal.frame);
                    machine_to_machineadjustwarpi.adddependency(transformdisplaymode);
                    machine_to_machineadjustwarpi.adddependency(externalwarp);
                    machine_to_machineadjustwarpi.onupdate := updatemachine_to_machineadjustwarpi;
                    viewwarp.adddependency(machine_to_machineadjustwarpi);
                    viewwarp.adddependency(transformdisplaymode);
                    viewwarp.adddependency(reversemotion);
                    viewwarp.onupdate := updateviewwarp;
                    quirtviewerupdcoronal.polydots[1] := delineationdots;
                    quirtviewerupdsagittal.polydots[1] := delineationdots;
                    quirtviewerupdtransversal.polydots[1] := delineationdots;
                    quirtviewerupdcoronal.polyindex[1] := delineationindex;
                    quirtviewerupdsagittal.polyindex[1] := delineationindex;
                    quirtviewerupdtransversal.polyindex[1] := delineationindex;
                    quirtviewerupdcoronal.polytransform[1] := delineationtransform;
                    quirtviewerupdsagittal.polytransform[1] := delineationtransform;
                    quirtviewerupdtransversal.polytransform[1] := delineationtransform;
                    quirtviewerupdcoronal.polylut[1] := delineationdotslut;
                    quirtviewerupdsagittal.polylut[1] := delineationdotslut;
                    quirtviewerupdtransversal.polylut[1] := delineationdotslut;
                    quirtviewerupdcoronal.polydots[8] := warpvectors;
                    quirtviewerupdsagittal.polydots[8] := warpvectors;
                    quirtviewerupdtransversal.polydots[8] := warpvectors;
                    quirtviewerupdcoronal.polydots[3] := beamdots;
                    quirtviewerupdsagittal.polydots[3] := beamdots;
                    quirtviewerupdtransversal.polydots[3] := beamdots;
                    quirtviewerupdcoronal.polyindex[3] := beamindex;
                    quirtviewerupdsagittal.polyindex[3] := beamindex;
                    quirtviewerupdtransversal.polyindex[3] := beamindex;
                    quirtviewerupdcoronal.polytransform[3] := beamtransform;
                    quirtviewerupdsagittal.polytransform[3] := beamtransform;
                    quirtviewerupdtransversal.polytransform[3] := beamtransform;
                    quirtviewerupdcoronal.polylut[3] := beamlut;
                    quirtviewerupdsagittal.polylut[3] := beamlut;
                    quirtviewerupdtransversal.polylut[3] := beamlut;
                    field_create(beamlut, \'field 1d 256-vector byte\', 256);
                    for i:=0 to 255 do
                    begin
                      beamlut.setvalue([i,0], 255);
                      beamlut.setvalue([i,1],   0);
                      beamlut.setvalue([i,2],   0);
                      beamlut.setvalue([i,3], 255);
                    end;
                    isocdots := tavsfield.create(bad);
                    field_create(isocdots, \'field 1d 0-vector byte 3-space irregular\', 600);
                    for i:=0   to 199 do isocdots.coordinate[0, i]:= (i - 100)/10;
                    for i:=200 to 399 do isocdots.coordinate[1, i]:= (i - 300)/10;
                    for i:=400 to 599 do isocdots.coordinate[2, i]:= (i - 500)/10;
                    isoclut  := tavsfield.create(bad);
                    field_create(isoclut, \'field 1d 4-vector byte\', 1);
                    isoclut.setvalue([0, 0], 255);
                    isoclut.setvalue([0, 1], 255);
                    isoclut.setvalue([0, 2], 255);
                    isoclut.setvalue([0, 3],   0);
                    quirtviewerupdcoronal.polydots[4]        := isocdots;
                    quirtviewerupdsagittal.polydots[4]       := isocdots;
                    quirtviewerupdtransversal.polydots[4]    := isocdots;
                    quirtviewerupdcoronal.polylut[4]         := isoclut;
                    quirtviewerupdsagittal.polylut[4]        := isoclut;
                    quirtviewerupdtransversal.polylut[4]     := isoclut;
                    clipbox[1].owner := self;
                    for i:=1 to nclipbox do
                    begin
                      quirtviewerupdcoronal.clipbox[i]     := clipbox[i];
                      quirtviewerupdsagittal.clipbox[i]    := quirtviewerupdcoronal.clipbox[i];
                      quirtviewerupdtransversal.clipbox[i] := quirtviewerupdcoronal.clipbox[i];
                      quirtviewerupdcoronal.clipbox[i].onchanged := changeclipbox;
                      quirtviewerupdcoronal.activeclipbox.onchanged := quirtviewerupdcoronalactiveclipboxchanged;
                      quirtviewerupdcoronal.clipboxtext[i].onchanged := changeclipboxtext;
                      if i\>1 then clipbox[i].owner := self;
                    end;
                    quirtviewerupdcoronal.field[5]         := maskedreference;
                    quirtviewerupdsagittal.field[5]        := maskedreference;
                    quirtviewerupdtransversal.field[5]     := maskedreference;
                    quirtviewerupdcoronal.transform[5]     := maskedreferencetransform;
                    quirtviewerupdsagittal.transform[5]    := maskedreferencetransform;
                    quirtviewerupdtransversal.transform[5] := maskedreferencetransform;
                    quirtviewerupdcoronal.lut[5]           := maskedreferencelut;
                    quirtviewerupdsagittal.lut[5]          := maskedreferencelut;
                    quirtviewerupdtransversal.lut[5]       := maskedreferencelut;
                    dose[1].connectviewer(quirtviewerupdcoronal, 6);
                    dose[1].connectviewer(quirtviewerupdsagittal, 6);
                    dose[1].connectviewer(quirtviewerupdtransversal, 6);
                    quirtviewerupdcoronal.field[7] := doseaccu;
                    quirtviewerupdsagittal.field[7] := doseaccu;
                    quirtviewerupdtransversal.field[7] := doseaccu;
                    quirtviewerupdcoronal.lut[7] := doseacculut;
                    quirtviewerupdsagittal.lut[7] := doseacculut;
                    quirtviewerupdtransversal.lut[7] := doseacculut;
                    buttonzerocouch.enabled := false;
                    comboboxmatch.items.clear;
                    comboboxmatch.items.add(match_bone);
                    comboboxmatch.items.add(match_greyvalue);
                    comboboxmatch.items.add(match_manual);
                    comboboxmatch.items.add(match_mask);
                    comboboxmatch.itemindex          := 0;
                    comboboxregistrationprotocol.clear;
                    comboboxregistrationprotocol.add(protocol_clipbox, [\'clipbox\']);
                    if (admincount and admincount_roi3d)\<\>0 then
                      comboboxregistrationprotocol.add(protocol_mask, [\'mask\']);
                    if (admincount and admincount_dualregistration)\<\>0 then
                      comboboxregistrationprotocol.add(protocol_clipbox_mask, [\'clipbox --\> mask\']);
                    comboboxsummarytype.items.clear;
                    comboboxsummarytype.items.add(summary_current);
                    comboboxsummarytype.items.add(summary_details);
                    comboboxsummarytype.items.add(summary_residuals);
                    comboboxsummarytype.items.add(summary_limits);
                    comboboxsummarytype.itemindex := 0;
                    comboboxcorrectionprotocol.clear;
                    comboboxcorrectionprotocol.add(correction_from_clipbox, [\'clipbox\', \'clipbox registration\']);
                    comboboxcorrectionprotocol.add(correction_from_mask_mean, [\'mask (mean if 4d)\']);
                    comboboxcorrectionprotocol.add(correction_from_mask_exh, [\'mask (exhale if 4d)\']);
                    comboboxclipboxmatch.clear;
                    comboboxclipboxmatch.add(match_manual, [\'manual\']);
                    comboboxclipboxmatch.add(match_bone_tr, [\'bone (t + r)\']);
                    if (admincount and admincount_seedmatch)\<\>0 then
                      comboboxclipboxmatch.add(match_seed_tr, [\'seed (t + r)\']);
                    comboboxclipboxmatch.add(match_greyvalue_tr, [\'grey value (t + r)\']);
                    comboboxclipboxmatch.add(match_greyvalue_t, [\'grey value (t)\']);
                    comboboxclipboxmatch.itemindex := 1;
                    comboboxclipboxmatch.dropdowncount := comboboxclipboxmatch.items.count;
                    comboboxmaskmatch.clear;
                    comboboxmaskmatch.add(match_manual, [\'manual\']);
                    comboboxmaskmatch.add(match_bone_tr, [\'bone (t + r)\']);
                    if (admincount and admincount_seedmatch)\<\>0 then
                      comboboxmaskmatch.add(match_seed_tr, [\'seed (t + r)\']);
                    comboboxmaskmatch.add(match_greyvalue_tr, [\'grey value (t + r)\']);
                    comboboxmaskmatch.add(match_greyvalue_t, [\'grey value (t)\']);
                    if (admincount and admincount_reconstructionandviewing4d)\<\>0 then
                      comboboxmaskmatch.add(match_greyvalue_4dt, [\'grey value 4d (t)\']);
                    comboboxmaskmatch.itemindex := 3;
                    comboboxmaskmatch.dropdowncount := comboboxmaskmatch.items.count;
                    bonetumormatchlist := tstringlist.create;
                    convertcorexcllist := tstringlist.create;
                    bonetumormatchlist.add(match_bone_manualcc);
                    bonetumormatchlist.add(match_greyvalue_manualcc);
                    bonetumormatchlist.add(match_bone_4dmask);
                    bonetumormatchlist.add(match_greyvalue_4dmask);
                    bonetumormatchlist.sort;
                    convertcorexcllist.add(match_mask_art);
                    convertcorexcllist.sort;
                    buttonsetreferencemask.visible := false;
                    checkboxreferencemask.visible := false;
                    buttonmask.visible := false;
                    if (admincount and admincount_roi3d)=0 then
                    begin
                      buttonmask.visible := false;
                      checkboxreferencemask.visible := false;
                      checkboxreferencemask.checked := false;
                    end;
                    checkboxusecalibrationimages.enabled := false;
                    buttonchangecalibration.visible := false;
                    buttonsavegainoffset.visible := false;
                    buttonflexmapbb.visible := false;
                    detectmarkers2.visible := false;
                    calibration1.visible := false;
                    clinicalmode.visible := false;
                    hidetracker1.visible := false;
                    warpform1.visible    := false;
                    research.visible := false;
                    tools.visible := false;
                    page1.visible := screen.monitors[0].height\<=800;
                    loaddvf1.visible := false;
                    buttonexport.visible := false;
                    checkbox4dcorrected.visible := false;
                    checkboxenablerotation.visible := false;
                    buttonmovecouch.visible := false;
                    buttonstopcouch.visible := false;
                    buttonzerocouch.visible := false;
                    comboboxsliceaveraging.items.clear;
                    comboboxsliceaveraging.items.add(sliceavg_none);
                    comboboxsliceaveraging.items.add(\'3\'+sliceavg_slices);
                    comboboxsliceaveraging.items.add(\'5\'+sliceavg_slices);
                    comboboxsliceaveraging.items.add(\'7\'+sliceavg_slices);
                    comboboxsliceaveraging.items.add(\'9\'+sliceavg_slices);
                    comboboxsliceaveraging.itemindex := 0;
                    comboboxdisplaymode.items.clear;
                    comboboxdisplaymode.items.add(displaymode_grpu);
                    comboboxdisplaymode.items.add(displaymode_cut);
                    comboboxdisplaymode.items.add(displaymode_online);
                    comboboxdisplaymode.items.add(displaymode_ref);
                    comboboxdisplaymode.itemindex    := 0;
                    comboboxtransformmode.items.clear;
                    comboboxtransformmode.items.add(transformmode_asis);
                    comboboxtransformmode.items.add(transformmode_selected);
                    comboboxtransformmode.items.add(transformmode_warp);
                    comboboxtransformmode.items.add(transformmode_correction);
                    comboboxtransformmode.items.add(transformmode_average);
                    comboboxtransformmode.itemindex    := 0;
                    comboboxprotocol.itemindex       := 0;
                    guirefreshinterval := inifile.readinteger(\'xvi\', \'guirefreshinterval\', 20);
                    if guirefreshinterval=0 then
                      timer1.enabled := false
                    else
                      timer1.interval:= guirefreshinterval;
                    if avlstate = 5 then
                    begin
                      buttonelektaaccept.enabled:=false;
                      exitaccept1.enabled := buttonelektaaccept.enabled;
                    end;
                    sf := tform.create(self);
                    sf.position := podesigned;
                    sf.top := 500;
                    sf.left := 500;
                    sf.width := 300;
                    sf.height := 70;
                    sf.caption := wait_viewerloading;
                    sf.formstyle := fsstayontop;
                    sf.bordericons := [];
                    sl := tlabel.create(sf);
                    sl.parent := sf;
                    sl.align := alclient;
                    sl.font.style := [fsbold];
                    sl.alignment := tacenter;
                    sl.layout := tlcenter;
                    sl.caption := wait_preparation;
                    sl.update;
                    if not useonlinereconstruction then sf.show;
                    sf.update;
                    if avlstate in [1..6] then
                    begin
                      buttonelektaaccept.enabled := false;
                      exitaccept1.enabled := buttonelektaaccept.enabled;
                    end;
                    if enabletestmode then
                    begin
                      help1.insert(help1.count, tmenuitem.create(help1));
                      help1.items[help1.count-1].caption := \'show active settings\';
                      help1.items[help1.count-1].onclick := showactivesettings;
                    end;
                    hintwindowclass := thackhintwindow;
                    timer1.enabled := guirefreshinterval\<\>0;
                    gbmultianglecorrection := inifile.readbool(\'xvi\', \'multianglecorrection\', false);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_052()
{
    return parse(#DelphiGrammar::MethodImplementation, "function controlisvisible(control: tcontrol): boolean;
                  begin
                    result := true;
                    while assigned(control.parent) do
                    begin
                      if not control.visible then
                      begin
                        result := false;
                        exit;
                      end;
                      control := control.parent;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_053()
{
    return parse(#DelphiGrammar::MethodImplementation, "function compareitems(item1, item2: pointer): integer;
                  var
                    r1, r2: trect;
                    icent1, icent2: integer;
                  begin
                    r1 := thintandrect(item1).rect;
                    r2 := thintandrect(item2).rect;
                    icent1 := (r1.left + r1.right) div 2;
                    icent2 := (r2.left + r2.right) div 2;
                    if r1.top\<r2.top then
                      result := -1
                    else if r1.top=r2.top then
                    begin
                      if icent1\<icent2 then
                        result := -1
                      else if icent1=icent2 then
                          result := 0
                      else
                        result := 1
                    end
                    else
                      result := 1
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_054()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buildhintlist;
                  var
                    tw: thackhintwindow;
                    i : integer;
                    ha: thintandrect;
                    r1: trect;
                    ioffshor, ioffsvert: integer;
                  begin
                    destroyhintlist;
                    twl := tlist.create;
                    for i := 0 to self.componentcount - 1 do
                    begin
                      if self.components[i] is twincontrol then
                      begin
                        if (twincontrol(self.components[i]).showhint) and
                           (twincontrol(self.components[i]).hint \<\> \'\') and
                           (twincontrol(self.components[i]).hint[1] \<\> avlonly) and
                           controlisvisible(twincontrol(self.components[i])) then
                        begin
                          tw := thackhintwindow.create(self.components[i]);
                          tw.hint := twincontrol(self.components[i]).hint;
                          tw.parent := twincontrol(self.components[i]);
                          tw.color := application.hintcolor;
                          ha := thintandrect.create;
                          ha.hintwindow := tw;
                          twl.add(ha);
                        end;
                      end;
                    end;
                    twl.sort(compareitems);
                    for i := 0 to twl.count - 1 do
                    begin
                      r1 := thintandrect(twl[i]).hintwindow.calchintrect(1000, thintandrect(twl[i]).hintwindow.hint,nil);
                      r1.topleft := thintandrect(twl[i]).hintwindow.parent.clientorigin;
                      r1.bottom := r1.bottom + r1.top;
                      r1.right := r1.right + r1.left;
                      ioffshor := thintandrect(twl[i]).hintwindow.parent.width div 2;
                      ioffsvert := thintandrect(twl[i]).hintwindow.parent.height div 2;
                      r1.top    := r1.top    + ioffsvert;
                      r1.left   := r1.left   + ioffshor;
                      r1.bottom := r1.bottom + ioffsvert;
                      r1.right  := r1.right  + ioffshor;
                      thintandrect(twl[i]).rect := r1;
                    end
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_055()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.destroyhintlist;
                  var
                    i : integer;
                    ha: thintandrect;
                  begin
                    if assigned(twl) then
                    begin
                      for i := 0 to twl.count - 1 do
                      begin
                        thintandrect(twl[i]).hintwindow.releasehandle;
                        ha := thintandrect(twl[i]);
                        if assigned(ha) then
                        begin
                          freeandnil(ha.hintwindow);
                          freeandnil(ha);
                        end
                      end;
                      twl.free;
                      twl := nil;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_056()
{
    return parse(#DelphiGrammar::MethodImplementation, "function conflictinghint(i: integer): boolean;
                  var
                    j: integer;
                    r1, r2: trect;
                  begin
                    result := false;
                    r1 := thintandrect(twl[i]).rect;
                    for j:=0 to twl.count-1 do
                    begin
                      if i=j then
                        continue;
                      r2 := thintandrect(twl[j]).rect;
                      if ((abs(r1.top-r2.top)\<15) or
                          (abs(r1.bottom-r2.bottom)\<15))
                        and
                        (inrange(r1.left, r2.left, r2.right) or inrange(r1.right, r2.left, r2.right) or
                         inrange(r2.left, r1.left, r1.right) or inrange(r2.right, r1.left, r1.right)) then
                      begin
                        result := true;
                        exit;
                      end;
                    end
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_057()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.showallhints;
                  var
                    i : integer;
                    irnd: integer;
                  begin
                    for i := 0 to twl.count - 1 do
                    begin
                      while conflictinghint(i) do
                      begin
                        irnd := random(30)-15;
                        inc(thintandrect(twl[i]).rect.top, irnd);
                        inc(thintandrect(twl[i]).rect.bottom, irnd);
                      end;
                      thintandrect(twl[i]).hintwindow.activatehint(thintandrect(twl[i]).rect, thintandrect(twl[i]).hintwindow.hint);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_058()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.hideallhints;
                  var i : integer;
                  begin
                    if assigned(twl) then
                    for i := 0 to twl.count - 1 do
                      thintandrect(twl[i]).hintwindow.releasehandle;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_059()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.hideisoccorrefpoint1click(sender: tobject);
                  begin
                     hideisoccorrefpoint1.checked := not hideisoccorrefpoint1.checked;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_060()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.hidetracker1click(sender: tobject);
                  begin
                     hidetracker1.checked := not hidetracker1.checked;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_061()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.findpopupcontrol(control: twincontrol; const apopup: tpopupmenu): twincontrol;
                  var
                    i: integer;
                    c: tcontrol;
                  begin
                    result := nil;
                    for i:=0 to control.controlcount-1 do
                    begin
                      c := control.controls[i];
                      if assigned(c) then
                      begin
                        if thackcontrol(c).popupmenu=apopup then
                        begin
                          result := c as twincontrol;
                          break;
                        end
                        else if c is twincontrol then
                        begin
                          result := findpopupcontrol((c as twincontrol), apopup);
                          if assigned(result) then
                            break
                        end;
                      end
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_062()
{
    return parse(#DelphiGrammar::MethodImplementation, "function clienttoparent(const c: tcontrol; const point: tpoint; aparent: twincontrol): tpoint;
                  var
                    lparent: twincontrol;
                  begin
                    if aparent = nil then
                      aparent := c.parent;
                    if aparent = nil then
                      raise einvalidoperation.createfmt(sparentrequired, [c.name]);
                    result := point;
                    inc(result.x, c.left);
                    inc(result.y, c.top);
                    lparent := c.parent;
                    while lparent \<\> nil do
                    begin
                      if lparent.parent \<\> nil then
                      begin
                        inc(result.x, lparent.left);
                        inc(result.y, lparent.top);
                      end;
                      if lparent = aparent then
                        break
                      else
                        lparent := lparent.parent;
                    end;
                    if lparent = nil then
                      raise einvalidoperation.createfmt(sinvalidname, [c.name]);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_063()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.showallpopupmenus;
                  var
                    i: integer;
                    p: tpoint;
                    c: twincontrol;
                  begin
                    timerpopup1.enabled := true;
                    for i:=0 to popuplist.count-1 do
                    begin
                      if tpopupmenu(popuplist[i]).items.count=0 then continue;
                      if tpopupmenu(popuplist[i]).items[0].caption=\'\' then continue;
                      if tpopupmenu(popuplist[i]).items[0].caption[1]=\'*\' then continue;
                      gipopup := i;
                      c := findpopupcontrol(form1, tpopupmenu(popuplist[i]));
                      if not assigned(c) then
                      begin
                        p := point(longrec(tpopupmenu(popuplist[i]).designinfo).lo, longrec(tpopupmenu(popuplist[i]).designinfo).hi);
                        p := clienttoscreen(p);
                      end
                      else if controlisvisible(c) then
                      begin
                        p := point(c.width div 2, c.height div 2);
                        if assigned(c) then
                          p :=  main3.clienttoparent(c, p, c.parent);
                        p := clienttoscreen(p);
                      end
                      else
                      begin
                        p := point(0,0);
                        p := clienttoscreen(p);
                      end;
                      gipopuppointx := p.x;
                      gipopuppointy := p.y;
                      tpopupmenu(popuplist[i]).popup(p.x, p.y);
                    end;
                    form1.sendtoback;
                    timerpopup1.enabled := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_064()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.showallpopupmenusasforms;
                  var
                    i: integer;
                  begin
                    timerpopup1.enabled := false;
                    if not timerpopup1.enabled then
                    begin
                      for i:=0 to high(gformarray) do
                        if assigned(gformarray[i]) then
                          gformarray[i].show;
                    end
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_065()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.popupmenuscanpopup(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_066()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.showdvf1click(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_067()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.applydvfclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_068()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.btncorrectionbyclick(sender: tobject);
                  begin
                    popupmenucorrectionby.popup(btncorrectionby.clientorigin.x + btncorrectionby.width div 2, btncorrectionby.clientorigin.y + btncorrectionby.height div 2);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_069()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.showuniformity;
                  const
                    box_size=7;
                  var
                    meas00, meas04: double;
                    i0, i1, i2: integer;
                    fmax: double;
                    measregion: tavsfield;
                  begin
                    if assigned(onlinecube) and (not onlinecube.empty) then
                    begin
                      i0 := onlinecube.nearestpixel[0,0];
                      i1 := onlinecube.nearestpixel[1,0];
                      i2 := onlinecube.nearestpixel[2,0];
                      measregion := tavsfield.create;
                      field_crop(onlinecube, measregion, i0, i0, i1-box_size, i1+box_size, i2-box_size, i2+box_size);
                      meas00 := measregion.mean;
                      i0 := onlinecube.nearestpixel[0,0];
                      i1 := onlinecube.nearestpixel[1,4];
                      i2 := onlinecube.nearestpixel[2,0];
                      field_crop(onlinecube, measregion, i0, i0, i1-box_size, i1+box_size, i2-box_size, i2+box_size);
                      meas04 := measregion.mean;
                      fmax := meas04;
                      i0 := onlinecube.nearestpixel[0,0];
                      i1 := onlinecube.nearestpixel[1,0];
                      i2 := onlinecube.nearestpixel[2,4];
                      field_crop(onlinecube, measregion, i0, i0, i1-box_size, i1+box_size, i2-box_size, i2+box_size);
                      meas04 := measregion.mean;
                      fmax := max(meas04, fmax);
                      i0 := onlinecube.nearestpixel[0,0];
                      i1 := onlinecube.nearestpixel[1,-4];
                      i2 := onlinecube.nearestpixel[2,0];
                      field_crop(onlinecube, measregion, i0, i0, i1-box_size, i1+box_size, i2-box_size, i2+box_size);
                      meas04 := measregion.mean;
                      fmax := max(meas04, fmax);
                      i0 := onlinecube.nearestpixel[0,0];
                      i1 := onlinecube.nearestpixel[1,0];
                      i2 := onlinecube.nearestpixel[2,-4];
                      field_crop(onlinecube, measregion, i0, i0, i1-box_size, i1+box_size, i2-box_size, i2+box_size);
                      meas04 := measregion.mean;
                      fmax := max(meas04, fmax);
                      if fmax\>0 then
                        showmessage(
                          format(\'uniformity (measured at origin and 4 cm apart, %dx%d voxels sampled):\'+
                            #13#10+#13#10+
                            \'min: %.5g, max: %.5g, uniformity (in %%): %.5g\',
                            [2*box_size+1, 2*box_size+1,
                            meas00, fmax, abs(100*(fmax-meas00)/fmax)]))
                        else
                          showmessage(\'unable to compute uniformity, maximum value should not be 0\');
                      measregion.free;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_070()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure screenshotactivewindow(bild: tbitmap);
                  var
                    c: tcanvas;
                    r: trect;
                  begin
                    c := tcanvas.create;
                    c.handle := getwindowdc(getdesktopwindow);
                    try
                      r := rect(0, 0, gpopupwindowrect.right - gpopupwindowrect.left, gpopupwindowrect.bottom - gpopupwindowrect.top);
                      bild.width := gpopupwindowrect.right - gpopupwindowrect.left;
                      bild.height := gpopupwindowrect.bottom - gpopupwindowrect.top;
                      bild.canvas.copyrect(r, c, gpopupwindowrect);
                    finally
                      releasedc(0, c.handle);
                      c.free;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_071()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.timerpopup1timer(sender: tobject);
                  const
                    icnt: integer = 0;
                  var
                    posmenu, sm: tpoint;
                    locitem: hmenu;
                    wnd: hwnd;
                    classname: array [0..80] of char;
                    r: trect;
                    j: integer;
                    rp: trect;
                    frm: tform;
                    im: timage;
                    isleep: integer;
                  begin
                    if gigrabbingstate=1 then
                    begin
                      exit;
                    end;
                    inc(icnt);
                    posmenu := point(gipopuppointx, gipopuppointy);
                    wnd := windowfrompoint(posmenu);
                    if wnd \<\> 0 then
                    begin
                      getclassname(wnd, classname, 80 );
                      if (classname = \'#32768\') then
                      begin
                        windows.getwindowrect(wnd, gpopupwindowrect);
                        if gigrabbingstate\<\>2 then
                          r := gpopupwindowrect;
                        frm := tform.create(form1);
                        frm.position := podesigned;
                        frm.borderstyle := bsnone;
                        im := timage.create(frm);
                        im.onmousemove := image1mousemove;
                        im.width := gpopupwindowrect.right-gpopupwindowrect.left-2;
                        im.height  := gpopupwindowrect.bottom - gpopupwindowrect.top-2;
                        frm.color  := clblack;
                        frm.left   := gipopuppointx;
                        frm.top    := gipopuppointy;
                        frm.width  := im.width+2;
                        frm.height := im.height+2;
                        im.parent := frm;
                        im.left := 1;
                        im.top := 1;
                        screenshotactivewindow(im.picture.bitmap);
                        gformarray[icnt-1] := frm;
                        if gigrabbingstate=2 then
                        else
                        begin
                          for j:=0 to tpopupmenu(popuplist[gipopup]).items.count-1 do
                          begin
                            if tpopupmenu(popuplist[gipopup]).items[j].count\>0 then
                            begin
                              locitem := getsubmenu(tpopupmenu(popuplist[gipopup]).handle, j);
                              if locitem=0 then
                                continue;
                              if locitem\<\>gsubitem then
                              begin
                                gsubitem := 0;
                                timerpopup2.enabled := false;
                                getmenuitemrect(popuplist.window, tpopupmenu(popuplist[gipopup]).handle, j, rp);
                                sm := point(0, rp.top);
                                sm := clienttoscreen(sm);
                                gipopuppointx := r.right;
                                gipopuppointy := rp.top + gipopuppointy;
                                gigrabbingstate := 1;
                                isleep := 0;
                                gsubitem := locitem;
                                timerpopup2.enabled := true;
                                while (timerpopup2.enabled) or (gigrabbingstate \<\> 0) do
                                begin
                                  application.processmessages;
                                  sleep(10);
                                  inc(isleep);
                                  if isleep\>500 then
                                    break;
                                end;
                                windows.getwindowrect(wnd, gpopupwindowrect);
                                gipopuppointx := gpopupwindowrect.left;
                                gipopuppointy := gpopupwindowrect.top
                                end;
                            end
                          end;
                        end;
                        begin
                          begin
                            form1.update;
                            endmenu;
                          end;
                          gigrabbingstate := 0;
                        end
                      end
                      else
                      begin
                        end
                    end
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_072()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.timerpopup2timer(sender: tobject);
                  const
                    icnt: integer = 0;
                  begin
                    inc(icnt);
                    if gsubitem\<\>0 then
                    begin
                      timerpopup2.enabled := false;
                      gigrabbingstate := 2;
                      if not trackpopupmenu(gsubitem, tpm_leftalign or tpm_leftbutton or tpm_recurse,
                        gipopuppointx, gipopuppointy,
                        0 , popuplist.window, nil) then
                  ;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_073()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.image1mousemove(sender: tobject; shift: tshiftstate; x,
                    y: integer);
                  begin
                   if ssleft in shift then
                    begin
                      releasecapture();
                      sendmessage((sender as timage).parent.handle, $a1, 2, 0);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_074()
{
    return parse(#DelphiGrammar::MethodImplementation, "function findmonitor(handle: hmonitor): tmonitor;
                  var
                    i: integer;
                  begin
                    result := nil;
                    for i := 0 to screen.monitorcount - 1 do
                      if screen.monitors[i].handle = handle then
                      begin
                        result := screen.monitors[i];
                        break;
                      end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_075()
{
    return parse(#DelphiGrammar::MethodImplementation, "function monitorfrompoint(const point: tpoint;
                    monitordefault: tmonitordefaultto): tmonitor;
                  begin
                    result := findmonitor(multimon.monitorfrompoint(point,
                      monitordefaultflags[monitordefault]));
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_076()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure thackhintwindow.activatehint(rect: trect; const ahint: string);
                  type
                    tanimationstyle = (atslideneg, atslidepos, atblend);
                  const
                    animationstyle: array[tanimationstyle] of integer = (aw_ver_negative,
                      aw_ver_positive, aw_blend);
                    ilastactive: cardinal = 0;
                  var
                    userhandle: hmodule;
                    animate: bool;
                    style: tanimationstyle;
                    monitor: tmonitor;
                  begin
                    try
                      caption := ahint;
                      inc(rect.bottom, 4);
                      updateboundsrect(rect);
                      monitor := monitorfrompoint(point(rect.left, rect.top),mdnearest);
                      if width \> monitor.width then
                        width := monitor.width;
                      if height \> monitor.height then
                        height := monitor.height;
                      if rect.top + height \> monitor.top + monitor.height then
                        rect.top := (monitor.top + monitor.height) - height;
                      if rect.left + width \> monitor.left + monitor.width then
                        rect.left := (monitor.left + monitor.width) - width;
                      if rect.left \< monitor.left then rect.left := monitor.left;
                      if rect.bottom \< monitor.top then rect.bottom := monitor.top;
                      setwindowpos(handle, hwnd_topmost, rect.left, rect.top, width, height,
                        swp_noactivate);
                      if not assigned(animatewindowproc) then
                      begin
                        userhandle := getmodulehandle(\'user32\');
                        if userhandle \<\> 0 then
                          @animatewindowproc := getprocaddress(userhandle, \'animatewindow\');
                      end;
                      if (gettickcount - ilastactive \> 250) and (length(ahint) \< 100) and
                         assigned(animatewindowproc) then
                      begin
                        systemparametersinfo(spi_gettooltipanimation, 0, @animate, 0);
                        if animate then
                        begin
                          systemparametersinfo(spi_gettooltipfade, 0, @animate, 0);
                          if animate then
                            style := atblend
                          else
                            if mouse.cursorpos.y \> rect.top then
                              style := atslideneg
                            else
                              style := atslidepos;
                          animatewindowproc(handle, 100, animationstyle[style] or aw_slide);
                        end;
                      end;
                      parentwindow := application.handle;
                      showwindow(handle, sw_shownoactivate);
                      invalidate;
                    finally
                      ilastactive := gettickcount;
                      end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_077()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure thackhintwindow.wmnchittest(var msg: twmnchittest);
                  begin
                    inherited;
                    if (getasynckeystate(vk_lbutton) and ($8000 or vk_lbutton))=($8000 or vk_lbutton) then
                      msg.result := htcaption
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_078()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.wasimageexposed: boolean;
                  var
                    g: tavsfield;
                  begin
                    if not f.empty then
                    begin
                      g := tavsfield.create;
                      field_crop(f, g, 0, 41, 0, 41);
                      result := g.mean\>1000;
                      g.free;
                    end
                    else
                     result := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_079()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.showframenumberandgantryangle();
                  var
                    s: string;
                  begin
                    if queryframes.active then
                    begin
                      s := frame_number + \' = \' + queryframes.fieldbyname(\'seq_num\').asstring + \' \' + gantry_angle + \' = \' + floattostrf(gantryangle, fffixed, 5, 1);
                      if not wasimageexposed then
                        s := #27#255#0#0 + s + \', not exposed\';
                      quirtviewer1.text[3].value := s;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_080()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.settrackbarpos(const ipos: integer);
                  begin
                    trackbar1.selend   := trackbar1.max;
                    trackbar1.onchange := nil;
                    trackbar1.position := trackbar1.max+1-ipos;
                    trackbar1.selstart := trackbar1.position;
                    trackbar1.onchange := trackbar1change;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_081()
{
    return parse(#DelphiGrammar::MethodImplementation, "function digits(const inum: integer): string;
                  var
                    i: integer;
                  begin
                    setlength(result, inum);
                    for i:=1 to inum-1 do
                      result[i] := chr(ord(\'0\')+((i-1) mod 10));
                    result[inum] := \' \';
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_082()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.enumeratecontrols(control: twincontrol);
                  var
                    i,j: integer;
                    c: tcontrol;
                    w: thackwincontrol;
                    g: thackgraphiccontrol;
                    f: tfontname;
                  begin
                    for i:=0 to control.controlcount-1 do
                    begin
                      c := control.controls[i];
                      if assigned(c) then
                      begin
                        if c is tcustomedit then
                        begin
                          end
                        else if c is ttabcontrol then
                        begin
                          for j:=0 to (c as ttabcontrol).tabs.count-1 do
                          begin
                            if gpct30active then
                              (c as ttabcontrol).tabs[j] := digits(ceil(length((c as ttabcontrol).tabs[j])*0.3)) + (c as ttabcontrol).tabs[j]
                            else
                              (c as ttabcontrol).tabs[j] := copy((c as ttabcontrol).tabs[j], pos(\' \', (c as ttabcontrol).tabs[j])+1, maxint);
                          end;
                          enumeratecontrols(c as ttabcontrol);
                        end
                        else if c is twincontrol then
                        begin
                          w := thackwincontrol(c as twincontrol);
                          if length(w.caption)\>0 then
                          begin
                            f := w.font.name;
                            if (pos(\'dings\', uppercase(f))\<=0) then
                              if gpct30active then
                                w.caption := digits(ceil(length(w.caption)*0.3)) + w.caption
                              else
                                w.caption := copy(w.caption, pos(\' \', w.caption)+1, maxint);
                          end;
                          enumeratecontrols(w);
                        end
                        else if c is tgraphiccontrol then
                        begin
                          g := thackgraphiccontrol(c as tgraphiccontrol);
                          if length(g.caption)\>0 then
                          begin
                            f := g.font.name;
                            if (pos(\'dings\', uppercase(f))\<=0) then
                              if gpct30active then
                                g.caption := digits(ceil(length(g.caption)*0.3)) + g.caption
                              else
                                g.caption := copy(g.caption, pos(\' \', g.caption)+1, maxint);
                          end
                        end
                      end
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_083()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.groworshrinklabels30pct;
                  var
                    iorg, i: integer;
                  begin
                    gpct30active := not gpct30active;
                    iorg := pagecontrol1.activepageindex;
                    for i:=0 to pagecontrol1.pagecount-1 do
                    begin
                      pagecontrol1.activepageindex := i;
                      timer1timer(timer1);
                    end;
                    timer1.enabled := not gpct30active;
                    if gpct30active then
                      pagecontrol1.onchange := nil
                    else
                      pagecontrol1.onchange := pagecontrol1change;
                    enumeratecontrols(form1);
                    pagecontrol1.activepageindex := iorg;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_084()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.formactivate(sender: tobject);
                  begin
                    if activated then exit;
                    activated := true;
                    if not xviischildwindow then
                    begin
                      if pagecontrol1.activepageindex = 2 then
                        if buttonelektadismiss.enabled and buttonelektadismiss.visible and (avlstate\>0) then
                          focuscontrol(buttonelektadismiss);
                    end;
                    if inifile.readbool(\'xvi\', \'stayontop\', false) then
                      setwindowpos(handle, hwnd_top, 0, 0, 0, 0, swp_nomove or swp_nosize);
                    if not inifile.readbool(\'xvi\', \'visible\', true) then
                      showwindow(handle, sw_hide );
                    if inifile.readbool(\'xvi\', \'runminimized\', false) then
                      showwindow(handle, sw_minimize );
                    sectiontoload := \'\';
                    if avlstate=3 then
                    begin
                      timer1.enabled := false;
                      if inifile.readstring (\'alignment\', \'alignmentapprovalby\', \'xxnonexx\')\<\>\'xxnonexx\' then
                      begin
                        if messagedlg(message_reviewingprevious  + inifile.readstring (\'alignment\', \'alignmentapprovalby\', \'\'),
                                      mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                          sectiontoload := \'none\';
                        quirtviewerupdcoronal.make;
                        quirtviewerupdsagittal.make;
                        quirtviewerupdtransversal.make;
                      end;
                      timer1.enabled := true;
                    end;
                    case avlstate of
                      1: begin                               buttonloadreferenceclick(self);                                                        end;
                      2: begin buttonreconstructclick(self); if onlinecube.ndim=4 then timer4d.enabled := true;                                     end;
                      3: begin                               buttonloadscanclick(self); buttonloadreferenceclick(self); buttonloadmatchclick(self);
                      end;
                      4: begin buttonreconstructclick(self); buttonloadscanclick(self); buttonloadreferenceclick(self); buttonloadmatchclick(self); end;
                      5: begin                               buttonloadscanclick(self);                                                             end;
                      6: begin buttonreconstructclick(self); buttonelektadismissclick(buttonelektaaccept); 					  end;
                      1003: if enabletestmode then begin     buttonloadscanclick(self); buttonloadreferenceclick(self); buttonloadmatchclick(self); end;
                    end;
                    if avlstate in [1..6] then exit;
                    if (avlstate = 1003) and enabletestmode then
                    begin
                      application.processmessages;
                      buttonmatch2click(buttonmatch2);
                      if comboboxregistrationprotocol.itemindex=2 then
                      begin
                        mask1click(self);
                        application.processmessages;
                        buttonmatch2click(buttonmatch2);
                      end;
                      application.terminate;
                      exit;
                    end;
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_085()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.formclose(sender: tobject; var action: tcloseaction);
                  begin
                    if checkboxrecordform.checked then
                      avi_close(avihandle);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_086()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.formclosequery(sender: tobject; var canclose: boolean);
                  begin
                    if avlstate\>0 then canclose := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_087()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.button1click(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_088()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.edit1keydown(sender: tobject; var key: word;
                    shift: tshiftstate);
                  begin
                    if key=vk_return then button1click(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_089()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.datasourcepatientsdatachange(sender: tobject; field: tfield);
                  var
                    s : string;
                    i: integer;
                  begin
                    if (tablepatients.recordcount=0) or (tablepatients.fieldcount=0) then
                      exit;
                    if comparestr(trimright(tablepatients.fields[1].asstring), patientid) = 0 then
                      exit;
                    patientid := trimright(tablepatients.fields[1].asstring);
                    if (tablepatients.fields[2].fieldname = \'fold_name\') then
                      patientname := trimright(tablepatients.fields[3].asstring) + \', \' + trimright(tablepatients.fields[4].asstring)
                    else
                      patientname := trimright(tablepatients.fields[2].asstring) + \', \' + trimright(tablepatients.fields[3].asstring);
                    patienturl := fakeimporturl + patientid;
                    if (tablepatients.fields[2].fieldname = \'fold_name\') then
                    begin
                      if sqlmode then
                      begin
                        patientid := trimright(tablepatients.fields[2].asstring);
                        if length(patientid)=7 then
                          s := \'19\' + copy(patientid,0,2)
                        else if length(patientid)=8 then
                          s := patientid[1] + \'0\' + copy(patientid,2,2)
                        else
                          s := \'misc\';
                        if not trystrtoint(s, i) then
                          s := \'misc\';
                        patientdir := \'\\year_\' + s + \'\\patient_\'+trimright(tablepatients.fields[2].asstring)
                      end
                      else if synergymode then
                        patientdir := \'\\patient_\'+trimright(tablepatients.fields[2].asstring)
                      else
                        patientdir := \'\\img\\patient_\'+trimright(tablepatients.fields[2].asstring);
                    end
                    else
                      patientdir := \'\\img\';
                    if assigned(uexportscan.okbottomdlg) then begin
                      uexportscan.okbottomdlg.edit1.text := patientid;
                      uexportscan.okbottomdlg.edit2.text := patientname;
                      uexportscan.okbottomdlg.edit3.text := \'\';
                    end;
                    if titlebarstring\<\>\'\' then
                      caption:=titlebarstring
                    else
                      caption:=format(nki_caption, [patientid, patientname]);
                    if iview3dmode or synergymode then
                    begin
                      if tablepatients.recordcount\>0  then
                      begin
                        try
                          applyfilter(tabletreatments, tabletreatments.name, \'pat_dbid\', tablepatients.fields[0].asstring);
                          assignwidememoeventhandlers(tabletreatments);
                        except
                        end;
                      end;
                    end;
                    dicomtreevalid := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_090()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.assignwidememoeventhandlers(dataset: tabstractdataset);
                  var
                    i: integer;
                    f: tfield;
                  begin
                  exit;
                    for i := 0 to dataset.fieldcount-1 do
                    begin
                      f := dataset.fields[i];
                      if f.datatype=ftwidememo then
                        f.ongettext := getdescriptiontext;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_091()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.substituteparms(var t: string);
                  var i: integer;
                      p: string;
                      inp: boolean;
                  begin
                    p := \'\';
                    inp := false;
                    for i:=1 to length(t) do
                    begin
                      if not inp then
                      begin
                        if t[i] = \'%\' then
                          inp := true
                        else
                          p := p + t[i];
                      end
                      else
                      begin
                        if t[i] = \'p\' then
                        begin
                          if avlstate \> 0 then
                            p := p + patientid
                          else
                            p := p + trimright(tablepatients.fields[1].asstring);
                        end;
                        if t[i] = \'i\' then p := p + format(\'%.8x\', [queryscans.fields[0].asinteger]);
                        if t[i] = \'%\' then p := p + \'%\';
                        inp := false;
                      end;
                    end;
                    if (avlstate\>0) and (p \<\> \'\') then
                    begin
                      p := includetrailingpathdelimiter(p);
                    end;
                    t := p;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_092()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.datasourcetreatmentsdatachange(sender: tobject; field: tfield);
                  var filename: string;
                      ii : integer;
                      t1 : ttransform;
                  begin
                    if (tablepatients.recordcount=0) or (tablepatients.fieldcount=0) then
                      exit;
                    if comparestr(tabletreatments.fieldbyname(\'dbid\').asstring,treatmentdbid) = 0 then
                      exit;
                    if comparestr(trimright(tablepatients.fields[1].asstring), patientid) \<\> 0 then
                      datasourcepatientsdatachange(self,nil);
                    treatmentid   := trimright(tabletreatments.fieldbyname(\'id\').asstring);
                    treatmentuid  := trimright(tabletreatments.fieldbyname(\'dicom_uid\').asstring);
                    treatmentdbid := tabletreatments.fieldbyname(\'dbid\').asstring;
                    if treatmentuid=\'\' then
                      treatmentuid := tabletreatments.fieldbyname(\'dbid\').asstring;
                    if assigned(uexportscan.okbottomdlg) then
                      uexportscan.okbottomdlg.edit4.text := treatmentid;
                    buttonclearreferenceclick(self);
                    filename := inifile.readstring(\'xvi\', \'administrativefilesdirectory\', \'\');
                    if filename=\'\' then
                      adminfilebase := extractfilepath(application.exename)
                    else
                      adminfilebase := filename + \'\\\';
                    substituteparms(adminfilebase);
                      sysutils.forcedirectories(extractfilepath(adminfilebase));
                    filename := inifile.readstring(\'xvi\', \'referencecachedirectory\', \'\');
                    if filename=\'\' then cachefilebase := extractfilepath(application.exename)
                    else                cachefilebase := filename + \'\\\';
                    substituteparms(cachefilebase);
                    quirtviewerupdtransversal.text[3].value := \'\';
                    quirtviewerupdtransversal.text[4].value := \'\';
                    if synergymode then
                    begin
                      ctv_dbid := \'\';
                      str_dbid := \'\';
                      iso_dbid := \'\';
                      clp_dbid := \'\';
                      rtp_dbid := \'\';
                      ref_path := \'\';
                      rtp_path := \'\';
                      str_path := \'\';
                      studyurl := \'\';
                      scanurl  := \'\';
                      planurl  := \'\';
                      beamurl  := \'\';
                      delineationurl := \'\';
                      for ii := 1 to nclipbox do clipbox[ii].clear;
                      syn_crpm := \'isocenter\';
                      syn_crpx := 0;
                      syn_crpy := 0;
                      syn_crpz := 0;
                      syn_isox := \'-9999\';
                      syn_isoy := \'-9999\';
                      syn_isoz := \'-9999\';
                      if queryscandetails is tabstractquery then
                        (queryscandetails as tabstractquery).datasource := nil
                      else
                        (queryscandetails as tabstracttable).mastersource := nil;
                      applyfilter(queryscandetails, \'rtplan\', \'trt_dbid\', treatmentdbid);
                      if not queryscandetails.eof then
                      begin
                        rtp_dbid := queryscandetails.fieldbyname(\'dbid\').asstring;
                        rtp_path := trimright(queryscandetails.fieldbyname(\'file_path\').asstring);
                        plansopuid := trimright(queryscandetails.fieldbyname(\'rtplan_uid\').asstring);
                        ctv_dbid := queryscandetails.fieldbyname(\'ctv_dbid\').asstring;
                        str_dbid := queryscandetails.fieldbyname(\'str_dbid\').asstring;
                        queryscandetails.next;
                        if not queryscandetails.eof then showmessage(error_nkimultiplertplan);
                        queryscandetails.active := false;
                      end
                      else
                      begin
                      end;
                      if ctv_dbid\<\>\'\' then
                      begin
                        applyfilter(queryscandetails, \'ctvolume\', \'dbid\', ctv_dbid);
                    ref_path := trimright(queryscandetails.fieldbyname(\'file_path\').asstring);
                        syn_crpx := queryscandetails.fieldbyname(\'crp_x\').asfloat;
                        syn_crpy := queryscandetails.fieldbyname(\'crp_y\').asfloat;
                        syn_crpz := queryscandetails.fieldbyname(\'crp_z\').asfloat;
                        syn_crpm := trimright(queryscandetails.fieldbyname(\'crp_mode\').asstring);
                        scanseriesuid := trimright(queryscandetails.fieldbyname(\'dicom_uid\').asstring);
                    queryscandetails.active := false;
                      end;
                      if (plansopuid = \'\') then plansopuid := scanseriesuid;
                      if ctv_dbid\<\>\'\' then
                      begin
                        applyfilter(queryscandetails, \'iso_cntr\', \'trt_dbid\', treatmentdbid);
                        iso_dbid := queryscandetails.fieldbyname(\'dbid\').asstring;
                        syn_isox := floattostr(queryscandetails.fieldbyname(\'w_x\').asfloat/10);
                        syn_isoy := floattostr(queryscandetails.fieldbyname(\'w_y\').asfloat/10);
                        syn_isoz := floattostr(queryscandetails.fieldbyname(\'w_z\').asfloat/10);
                        queryscandetails.next;
                        if not queryscandetails.eof then
                          showmessage(error_nkimultipleisoc);
                        queryscandetails.active := false;
                        applyfilter(queryscandetails, \'str_set\', \'ctv_dbid\', ctv_dbid);
                        str_dbid := queryscandetails.fieldbyname(\'dbid\').asstring;
                        str_path := trimright(queryscandetails.fieldbyname(\'file_path\').asstring);
                        queryscandetails.next;
                        if not queryscandetails.eof then showmessage(error_nkimultiplestrucset);
                        queryscandetails.active := false;
                        applyfilter(queryscandetails, \'clipbox\', \'ctv_dbid\', ctv_dbid);
                        clp_dbid := queryscandetails.fieldbyname(\'dbid\').asstring;
                        if clp_dbid\<\>\'\' then
                        begin
                          field_create(clipbox[1], \'field 1d float\', 6);
                          clipbox[1].setvalue([0], queryscandetails.fieldbyname(\'x1\').asfloat / 10);
                          clipbox[1].setvalue([1], queryscandetails.fieldbyname(\'x2\').asfloat / 10);
                          clipbox[1].setvalue([2], queryscandetails.fieldbyname(\'y1\').asfloat / 10);
                          clipbox[1].setvalue([3], queryscandetails.fieldbyname(\'y2\').asfloat / 10);
                          clipbox[1].setvalue([4], queryscandetails.fieldbyname(\'z1\').asfloat / 10);
                          clipbox[1].setvalue([5], queryscandetails.fieldbyname(\'z2\').asfloat / 10);
                          t1 := ttransform.create;
                          t1.makerotation(270, 0, 270);
                          cropbox_transform(clipbox[1], t1, clipbox[1]);
                          t1.free;
                        end;
                        queryscandetails.next;
                        if not queryscandetails.eof then showmessage(error_nkimultipleclipbox);
                        queryscandetails.active := false;
                      end;
                      cachefilebase := edit1.text + patientdir + \'\\ct_set\\\' + ref_path + \'\\\';
                    end;
                    if pagecontrol1.activepage = tabsheet4 then
                      togglebuttonloadreference
                    else
                      gneedtogglebuttonloadreference := true;
                    if iview3dmode or synergymode then
                    begin
                      if synergymode then
                        applyfilter(tableports, tableports.name, \'trt_dbid;id\', tabletreatments.fields[0].asstring + chr(256) + \'\'\'***kv-images***\'\'\')
                      else
                        applyfilter(tableports, tableports.name, \'trt_dbid\', tabletreatments.fields[0].asstring);
                      assignwidememoeventhandlers(tableports);
                    end;
                    tumbonediscrleft  := -9999;
                    tumbonediscrright := -9999;
                    tumbonediscrsup   := -9999;
                    tumbonediscrinf   := -9999;
                    tumbonediscrant   := -9999;
                    tumbonediscrpos   := -9999;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_093()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.datasourceportsdatachange(sender: tobject; field: tfield);
                  begin
                    if not iview3dmode then
                    begin
                      if comparestr(trimright(tableports.fieldbyname(\'dicom_uid\').asstring), portuid) = 0 then
                        exit;
                    end;
                    if (tablepatients.recordcount=0) or (tablepatients.fieldcount=0) then
                      exit;
                    if comparestr(trimright(tablepatients.fields[1].asstring), patientid) \<\> 0 then
                      datasourcepatientsdatachange(self,nil);
                    if comparestr(trimright(tabletreatments.fieldbyname(\'dicom_uid\').asstring), treatmentuid) \<\> 0 then
                    begin
                      if not iview3dmode then
                        datasourcetreatmentsdatachange(self,nil);
                    end;
                    if not iview3dmode then
                    begin
                      portid := trimright(tableports.fieldbyname(\'id\').asstring);
                      portuid := trimright(tableports.fieldbyname(\'dicom_uid\').asstring);
                    end;
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_094()
{
    return parse(#DelphiGrammar::MethodImplementation, "function findpatientdvd(rootdir: string; patientdir: string): string;
                  var
                    srouter, srinner: tsearchrec;
                  begin
                    screen.cursor := crhourglass;
                    try
                      result := \'\';
                      if findfirst(includetrailingpathdelimiter(rootdir) + \'..\\*.*\', fadirectory, srouter)=0 then
                      repeat
                        if ((srouter.attr and file_attribute_directory)=file_attribute_directory)
                          and (srouter.name\<\>\'.\') and (srouter.name\<\>\'..\') then
                        begin
                          if findfirst(includetrailingpathdelimiter(rootdir) + \'..\\\' + srouter.name + \'\\img\\*.*\', fadirectory, srinner)=0 then
                            repeat
                              if ((srinner.attr and file_attribute_directory)=file_attribute_directory) then
                                if sametext(srinner.name, patientdir) then
                                  result := result + \';\\..\\\' + srouter.name + \'\\img\\\' + patientdir;
                            until (findnext(srinner)\<\>0);
                            findclose(srinner);
                        end;
                      until (findnext(srouter)\<\>0);
                      findclose(srouter);
                      if length(result)\>0 then
                        delete(result, 1, 1)
                      else
                        result := \'\<not found:\\img\\\' + patientdir + \'\>\';
                    finally
                      screen.cursor := crdefault;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_095()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.datasourcescansquerydatachange(sender: tobject; field: tfield);
                  var
                    filename, t, s : string;
                    j, fileattrs: integer;
                    sr             : tsearchrec;
                    query          : tabstractquery;
                    dvds           : tstringlist;
                  begin
                    if (tablepatients.recordcount=0) or (tablepatients.fieldcount=0) then
                      exit;
                    gfmultianglegain.clear;
                    if comparestr(trimright(tablepatients.fields[1].asstring), patientid) \<\> 0 then
                      datasourcepatientsdatachange(self,nil);
                    if not iview3dmode then
                    begin
                      try
                        t := trimright(tabletreatments.fieldbyname(\'dicom_uid\').asstring);
                      except
                        exit;
                      end;
                      if comparestr(t,treatmentuid) \<\> 0 then
                        datasourcetreatmentsdatachange(self,nil);
                    end;
                    if not iview3dmode then
                    begin
                      if comparestr(trimright(tableports.fieldbyname(\'dicom_uid\').asstring), portuid) \<\> 0 then
                        datasourceportsdatachange(self,nil);
                    end;
                    if queryframes is tabstractquery then
                      query := queryframes as tabstractquery
                    else
                      query := nil;
                    if synergymode and
                      assigned(query) and
                      (pos(\'frame \', query.sql.strings[0]) = 0) then
                    begin
                      query.active := false;
                      query.sql.clear;
                      query.sql.add(\'select * from frame where\');
                      query.sql.add(\'frame.ima_dbid=:dbid\');
                      query.sql.add(\'order by seq_num\');
                      assignwidememoeventhandlers(query);
                      queryframes.active := true;
                    end;
                    if not iview3dmode then
                    begin
                      currentscan := queryscans.fieldbyname(\'dbid\').asstring;
                      scanuid     := trimright(queryscans.fieldbyname(\'dicom_uid\').asstring);
                      scandate    := trimright(queryscans.fieldbyname(\'img_date\').asstring);
                      t := queryscans.fieldbyname(\'img_time\').text;
                      if length(t)=8 then t := \'0\' + t;
                      scantime    := t;
                      if synergymode then
                        t := trimright(queryscans.fieldbyname(\'org_dtl\').asstring);
                      if (t\<\>machinename) and (t\<\>\'\') and (avlflexmapmode) and synergymode then
                      begin
                        machinename := t;
                        caldirroot   := inifile.readstring(\'xvi\', \'caldir\',\'\');
                        caldirroot := includetrailingpathdelimiter(caldirroot);
                        caldirroot := caldirroot + machinename + \'\\\';
                        fileattrs    := fadirectory;
                        caldirlist.clear;
                        if caldirroot\<\>\'\' then
                        begin
                          if findfirst(caldirroot+\'*.*\', fileattrs, sr) = 0 then
                          begin
                            if ((sr.attr and fadirectory) = fadirectory) and ((sr.name \<\> \'.\') and (sr.name \<\> \'..\')) then
                              caldirlist.add(sr.name);
                            while findnext(sr) = 0 do
                            begin
                              if ((sr.attr and fadirectory) = fadirectory) and ((sr.name \<\> \'.\') and (sr.name \<\> \'..\')) then
                                caldirlist.add(sr.name);
                            end;
                            findclose(sr);
                            caldirlist.sort;
                          end;
                        end;
                      end;
                    end
                    else
                    begin
                      currentscan := queryscans.fieldbyname(\'dbid\').asstring;
                      scanuid     := trimright(queryscans.fieldbyname(\'identifier\').asstring);
                      f.clear;
                    end;
                    updown1.max := scanlist.count-1;
                    updown1.position := scanlist.indexof(currentscan);
                    updown1.hint := format(updown_hint, [updown1.position+1, updown1.max+1]);
                    needloadimage := true;
                    acqpars := \'\';
                    reconstructioncompletedstatus := false;
                    if (tablepatients.fields[2].fieldname = \'fold_name\') then
                    begin
                      if sqlmode then
                      begin
                        patientid := trimright(tablepatients.fields[2].asstring);
                        if length(patientid)=7 then
                          s := \'19\' + copy(patientid,0,2)
                        else if length(patientid)=8 then
                          s := patientid[1] + \'0\' + copy(patientid,2,2)
                        else
                          s := \'misc\';
                        if not trystrtoint(s, j) then
                          s:= \'misc\';
                        patientdir := \'\\year_\' + s + \'\\patient_\'+trimright(tablepatients.fields[2].asstring)
                      end
                      else if synergymode then
                        patientdir := \'\\patient_\'+trimright(tablepatients.fields[2].asstring)
                      else
                      begin
                        patientdir := \'\\img\\patient_\'+trimright(tablepatients.fields[2].asstring);
                        if not sysutils.directoryexists(edit1.text + patientdir) then
                        begin
                          if pos(uppercase(\'\\img\\patient_\' + tablepatients.fields[2].asstring), uppercase(fdvddirs))\<=0 then
                            fdvddirs := findpatientdvd(edit1.text, \'patient_\' + tablepatients.fields[2].asstring);
                          if pos(\'\<not found:\', fdvddirs)\<=0 then
                          begin
                            dvds := tstringlist.create;
                            dvds.delimiter := \';\';
                            dvds.strictdelimiter := true;
                            dvds.delimitedtext := fdvddirs;
                            j := 0;
                            while (j\<dvds.count) and (not sysutils.directoryexists(edit1.text + dvds[j] + \'\\\' + scanuid)) do
                              inc(j);
                            if j\<dvds.count then
                              patientdir := dvds[j];
                            dvds.free;
                          end;
                        end;
                      end;
                    end
                    else
                      patientdir := \'\\img\';
                    filename := inifile.readstring(\'xvi\', \'reconstructedscansdirectory\', \'\');
                    if filename=\'\' then reconfilebase := extractfilepath(application.exename)
                    else                reconfilebase := filename + \'\\\';
                    substituteparms(reconfilebase);
                    if synergymode then
                    begin
                      rec_dbid := \'\';
                      reg_dbid := \'\';
                      if queryscans.fieldbyname(\'dbid\').asstring\<\>\'\' then
                      begin
                        if queryscandetails is tabstractquery then
                          (queryscandetails as tabstractquery).datasource := nil
                        else
                          (queryscandetails as tabstracttable).mastersource := nil;
                        applyfilter(queryscandetails, \'reconst\', \'ima_dbid\', queryscans.fieldbyname(\'dbid\').asstring);
                        rec_dbid := queryscandetails.fieldbyname(\'dbid\').asstring;
                        t        := trimright(queryscandetails.fieldbyname(\'file_path\').asstring);
                        if t \<\> \'\' then
                          scanuid := t;
                        if length(scanuid)\>5 then scanuid := copy(scanuid, 1, length(scanuid)-5);
                        queryscandetails.next;
                        if not queryscandetails.eof then showmessage(error_nkimultiplerecon);
                        queryscandetails.active := false;
                      end;
                    end;
                    if queryscans.fields[1].fieldname = \'prnt_dbid\' then
                    begin
                      sequencedir := \'\\..\\img3d\\\'+format(\'%.8x\\\', [strtointdef(currentscan, 0)])+scanuid;
                      end
                    else if synergymode then
                    begin
                      if sequencedir \<\> patientdir + \'\\images\\img_\' + trimright(queryscans.fieldbyname(\'dicom_uid\').asstring) + \'\\\' then
                      begin
                        sequencedir := patientdir + \'\\images\\img_\' + trimright(queryscans.fieldbyname(\'dicom_uid\').asstring) + \'\\\';
                        needloadimage := true;
                      end;
                      scantype := queryscans.fieldbyname(\'type\').asinteger;
                      scanfov  := queryscans.fieldbyname(\'fov\').asinteger;
                      scanma   := queryscans.fieldbyname(\'ma\').asinteger;
                      scankv   := queryscans.fieldbyname(\'kv\').asinteger;
                      scanms   := queryscans.fieldbyname(\'kvlength\').asinteger;
                      t := trimright(queryscans.fieldbyname(\'kvfilter\').asstring);
                      scankvfilter := strtointdef(t, -1)
                    end
                    else if (patientdir \<\> \'\\img\') then
                      sequencedir := patientdir + \'\\\' +  scanuid +\'\\\'
                    else
                      sequencedir := patientdir+\'\\\';
                    numberoffirstimageinsequencedir := -1;
                    if synergymode then
                      reconfilebase := edit1.text+sequencedir + \'reconstruction\\\';
                    matchresultlogfile := inifile.readstring(\'xvi\', \'matchresultlogfile\', \'\');
                    substituteparms(matchresultlogfile);
                    readmatchfromini;
                    j := 1;
                    reconbackupfilebase := \'\';
                    filename := reconfilebase + scanuid;
                    while not(fileexists(filename + \'.scan\')) and not(fileexists(filename + \'.image1\')) do
                    begin
                      reconbackupfilebase := inifile.readstring(\'xvi\', \'reconstructedscansdirectorybackup\'+inttostr(j), \'\');
                      if reconbackupfilebase=\'\' then
                        break
                      else
                        reconbackupfilebase := reconbackupfilebase + \'\\\';
                      substituteparms(reconbackupfilebase);
                      filename := reconbackupfilebase + scanuid;
                      inc(j);
                    end;
                    if reconbackupfilebase \<\> \'\' then
                      reconfilebase := reconbackupfilebase
                    else if (not (fileexists(filename + \'.scan\')) ) and (jukeboxbase[0] \<\> \'\') then
                    begin
                      if queryscans.findfield(\'offline\') \<\> nil then
                        if (queryscans.fieldbyname(\'offline\').asvariant \<\> null) then
                        begin
                          t := trimright(queryscans.fieldbyname(\'offline\').asstring);
                          t := copy(t,6,length(t));
                          j := min(length(jukeboxbase),strtoint(t[3]));
                          reconfilebase := jukeboxbase[j-1] + t + sequencedir + \'reconstruction\\\';
                        end
                    end
                    else
                      sysutils.forcedirectories(extractfilepath(reconfilebase));
                    buttonloadscan.enabled := online[1].exists(reconfilebase, scanuid, \'scan\') or
                                              online[1].exists(reconfilebase, scanuid, \'image1\');
                    if buttonloadscan.enabled then
                    begin
                      buttonreconstructorview.caption := view_caption;
                      if onlineoverlaystring\<\>\'\' then
                        quirtviewerupdtransversal.text[3].value := onlineoverlaystring
                      else
                      begin
                          quirtviewerupdtransversal.text[3].value := online_overlay + scandate;
                      end;
                    end
                    else
                    begin
                      buttonreconstructorview.caption := recon_caption;
                      if onlineoverlaystring\<\>\'\' then
                        quirtviewerupdtransversal.text[3].value := onlineoverlaystring
                      else
                        quirtviewerupdtransversal.text[3].value := online_overlay + scandate + norecon_overlay;
                    end;
                    onlinecube.clear;
                    if (not referencecube.empty) or (not maskedreference.empty) or (not dosecube.empty) or (not doseaccu.empty) then
                    begin
                      field_create(onlinecube, \'field 3d 0-vector byte\', 256, 256, 256);
                      case defaultfov of
                        76:  modify_extents(onlinecube, onlinecube, 0.2,   0.2,   0.2);
                        77:  modify_extents(onlinecube, onlinecube, 0.156, 0.156, 0.156);
                        83:  modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                        else modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                      end;
                    end;
                    phase.clear;
                    phasehist.clear;
                    transform4d.clear;
                    makeregistrationbackup(0, 9999, 0, 9999);
                    vistransform4d.clear;
                    vistransform4d2.clear;
                    quirtviewerupdcoronal.warp[1].clear;
                    quirtviewerupdcoronal.warp[6].clear;
                    quirtviewerupdcoronal.viewwarp.clear;
                    if assigned(chamferdotsonline) then
                      chamferdotsonline.clear;
                    if assigned(chamferdotsreference) then
                      chamferdotsreference.clear;
                    alignmentmode.value := 0;
                    activeregion.value := 0;
                    maskactiveregion.value := 0;
                    buttonresetmatchclick(self);
                    matchprerotate := false;
                    matchrotmark   := false;
                    match4dsingleframe := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_096()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.datasourcescandetailsdatachange(sender: tobject;
                    field: tfield);
                  begin
                    if synergymode then exit;
                    scantype := queryscandetails.fieldbyname(\'type\').asinteger;
                    scanfov  := queryscandetails.fieldbyname(\'fov\').asinteger;
                    if not(tablepatients.fields[2].fieldname = \'fold_name\') then
                      if scanfov=76 then scanfov:=77;
                    scanma   := queryscandetails.fieldbyname(\'ma\').asinteger;
                    scankv   := queryscandetails.fieldbyname(\'kv\').asinteger;
                    scanms   := queryscandetails.fieldbyname(\'kvlength\').asinteger;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_097()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.datasourceframesdatachange(sender: tobject;
                    field: tfield);
                  begin
                    if (queryframes.recordcount\>0) and (queryframes.fieldcount\>0) then
                    begin
                      if synergymode then
                        frameid := queryframes.fields[0].asinteger
                      else
                        frameid := queryframes.recno-1;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_098()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.datasourceframedetailsdatachange(sender: tobject;
                    field: tfield);
                  begin
                    gantryangle := queryframedetails.fieldbyname(\'proj_ang\').asfloat;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_099()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.tablepatientsfilterrecord(dataset: tdataset;
                    var accept: boolean);
                  begin
                    if (csdestroying in dataset.componentstate) or (dataset.fieldcount=0) then
                      exit;
                    accept := (length(editfilterpatient.text)=0) or
                              (pos(uppercase(editfilterpatient.text), uppercase(trimright(dataset.fieldbyname(\'last_name\').asstring)))\>0) or
                              (pos(uppercase(editfilterpatient.text), uppercase(trimright(dataset.fieldbyname(\'id\').asstring)))\>0);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_100()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.tablepatientstrtdescrfilterrecord(dataset: tdataset;
                    var accept: boolean);
                  begin
                    if csdestroying in dataset.componentstate then exit;
                    begin
                      if dataset.fieldcount\>0 then
                        accept := filteredrecords.indexof(dataset.fieldbyname(\'dbid\').asstring)\>=0
                      else
                        accept := false;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_101()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.editfilterpatientexit(sender: tobject);
                  const
                    sprevfilter: string = \'\';
                  var
                    prevactive: boolean;
                    table: tabstracttable;
                  begin
                    if editfilterpatient.text=sprevfilter then
                      exit;
                    editfilterpatient.text :=  trimright(editfilterpatient.text);
                    datasourcepatients.enabled := false;
                    datasourcescansquery.enabled := false;
                    prevactive := tablepatients.active;
                    tablepatients.active := false;
                    begin
                      table := tablepatients as tabstracttable;
                      table.filter := \'\';
                      table.filtered := editfilterpatient.text \<\> \'\';
                      sprevfilter := editfilterpatient.text;
                      table.onfilterrecord := nil;
                      table.onfilterrecord := tablepatientsfilterrecord;
                    end;
                    tablepatients.active := prevactive;
                    label7.caption := label_label7_caption + \' (\' + inttostr(tablepatients.recordcount) + \' patients)\';
                    datasourcepatients.enabled := true;
                    datasourcescansquery.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_102()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.editfilterpatientkeydown(sender: tobject; var key: word;
                    shift: tshiftstate);
                  begin
                    if key=vk_return then
                      editfilterpatientexit(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_103()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.editfiltertrtdescriptionexit(sender: tobject);
                  var
                    strsql : string;
                    table: tabstracttable;
                    query: tabstractquery;
                  begin
                    table := nil;
                    query := nil;
                    if tablepatients is tabstracttable then
                      table := tablepatients as tabstracttable
                    else
                      query := tablepatients as tabstractquery;
                    if editfiltertrtdescription.text = \'\' then
                    begin
                      if assigned(table) then
                      begin
                        table.filtered := false;
                        table.filter := \'\';
                        table.onfilterrecord := nil;
                      end
                      else if assigned(query) then
                      begin
                        query.sql.text := \'select * from patient\';
                        query.active := true;
                      end;
                      label7.caption := label_label7_caption + \' (\' + inttostr(tablepatients.recordcount) + \' patients)\';
                      exit;
                    end;
                    datasourcetreatments.enabled := false;
                    begin
                      if assigned(query) then
                        query.active := false;
                      strsql := \'select distinct pat_dbid \' +
                                \'from   trtmnt trt \';
                      try
                        if assigned(query) then
                          query.active := true;
                      except
                        on e: exception do
                            raise;
                      end;
                    end;
                    datasourcepatients.enabled := false;
                    datasourcescansquery.enabled := false;
                    if assigned(table) then
                    begin
                      table.filter := \'\';
                      table.onfilterrecord := tablepatientstrtdescrfilterrecord;
                      table.filtered := editfiltertrtdescription.text \<\> \'\';
                      table.first;
                      label7.caption := label_label7_caption + \' (\' + inttostr(filteredrecords.count) + \' patients)\';
                    end
                    else
                      label7.caption := label_label7_caption + \' (\' + inttostr(query.recordcount) + \' patients)\';
                    datasourcepatients.enabled := true;
                    datasourcetreatments.enabled := true;
                    datasourcescansquery.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_104()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.editfiltertrtdescriptionkeydown(sender: tobject;
                    var key: word; shift: tshiftstate);
                  begin
                    if key=vk_return then
                      editfiltertrtdescriptionexit(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_105()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.selectlatestscan (dicom_uid: string);
                  var str2, str3, str4 : string;
                  begin
                    if not queryimages.active then exit;
                    if (dicom_uid \<\> \'\') then
                      queryimages.locate(\'dicom_uid\', dicom_uid, [])
                    else
                      queryimages.last;
                    str4 := trimright(queryimages.fields[1].asstring);
                    if tableports is tabstractquery then
                      (tableports as tabstractquery).datasource := nil
                    else
                      (tableports as tabstracttable).mastersource := nil;
                    if tableports is tabstracttable then
                      (tableports as tabstracttable).indexname := \'\';
                    tableports.locate(\'dbid\', str4, []);
                    str3 := trimright(tableports.fields[1].asstring);
                    if tableports is tabstracttable then
                      (tableports as tabstracttable).indexname := \'trt_dbid\';
                    if tableports is tabstractquery then
                      (tableports as tabstractquery).datasource := datasourcetreatments
                    else
                      (tableports as tabstracttable).mastersource := datasourcetreatments;
                    if tabletreatments is tabstractquery then
                      (tabletreatments as tabstractquery).datasource := nil
                    else
                      (tabletreatments as tabstracttable).mastersource := nil;
                    if tabletreatments is tabstracttable then
                      (tabletreatments as tabstracttable).indexname := \'\';
                    tabletreatments.locate(\'dbid\', str3, []);
                    str2 := trimright(tabletreatments.fields[1].asstring);
                    if tabletreatments is tabstracttable then
                      (tabletreatments as tabstracttable).indexname := \'pat_dbid\';
                    if tabletreatments is tabstractquery then
                      (tabletreatments as tabstractquery).datasource := datasourcepatients
                    else
                      (tabletreatments as tabstracttable).mastersource := datasourcepatients;
                    tablepatients.locate(\'dbid\', str2, []);
                    tablepatients.enablecontrols;
                    tabletreatments.locate(\'dbid\', str3, []);
                    tabletreatments.enablecontrols;
                    tableports.locate(\'dbid\', str4, []);
                    tableports.enablecontrols;
                    datasourcetreatmentsdatachange(nil, nil);
                    if (dicom_uid \<\> \'\') then
                      queryscans.locate(\'dicom_uid\', dicom_uid, []);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_106()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonselectlatestclick(sender: tobject);
                  begin
                    selectlatestscan(\'\');
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_107()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.existanglefile(filename: string): boolean;
                  var h : thandle;
                      starttime, waittime: double;
                  begin
                      starttime := time;
                      repeat
                        h := fileopen(filename,fmshareexclusive);
                        if h = invalid_handle_value then
                        begin
                          sleep(200);
                        end;
                        waittime := (time-starttime)*24*3600;
                      until ((h \<\> invalid_handle_value) or (waittime\>projectiontimeout));
                      if waittime\>projectiontimeout then
                       begin
                          showmessage(\'finished reading files. last file=\'+filename);
                          result:=false;
                          stopreconstructing:=true;
                          numframes:=frameid;
                          showmessage(\'number of frames=\'+inttostr(numframes));
                  	end
                      else
                      begin
                          result:=true;
                          fileclose(h);
                      end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_108()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.setclipboxweightsclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_109()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.setgantry;
                  var h: tqinifile;
                      j: integer;
                      s: string;
                  begin
                    if synergymode and (not (avlstate\>0))then
                    begin
                      gantryangle := queryframes.fieldbyname(\'proj_ang\').asfloat;
                      exit;
                    end;
                    if assigned(queryframes) and queryframes.active then
                      exit;
                    if avlstate\>0 then
                    begin
                      s := format(anglefilebase, [frameid]);
                      for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                      h := tqinifile.create(s);
                      s := format(\'%.4d\', [frameid]);
                      gantryangle := h.readfloat(s, \'angle\', 0);
                      h.free;
                      exit;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_110()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.togglebuttonloadreference;
                  var
                    i: tqinifile;
                    uid: string;
                  begin
                    gneedtogglebuttonloadreference := false;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    if fileexists(adminfilebase + uid + \'.xvi\') then
                    begin
                      i := tqinifile.create(adminfilebase + uid + \'.xvi\');
                      buttonloadreference.enabled := i.sectionexists(\'xvi\') and (reference[1].exists(cachefilebase, scanseriesuid, \'ref\') or reference[1].exists(cachefilebase, uid, \'ref\'));
                      if buttonloadreference.enabled then
                        buttonloadreference.hint := \'load reference data prepared by \' + i.readstring(\'xvi\',\'signature\',\'unknown\') + \' on \' + i.readstring(\'xvi\',\'datetime\',\'unknown\');
                      i.free;
                    end
                    else
                      buttonloadreference.enabled := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_111()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.readmatchfromini;
                  var
                    j: integer;
                    i: tqinifile;
                    ininame: string;
                  begin
                    if synergymode then
                      ininame := adminfilebase + plansopuid + \'.xvi\'
                    else if iview3dmode then
                      ininame := adminfilebase + treatmentuid + \'.xvi\'
                    else
                      ininame := adminfilebase + tabletreatments.fieldbyname(\'dicom_uid\').asstring + \'.xvi\';
                    i := tqinifile.create(ininame);
                    buttonloadmatch.enabled := (i.sectionexists(scanuid + \'.align\') or i.sectionexists(scanuid + \'.bonealign\'));
                    if buttonloadmatch.enabled then
                    begin
                      if (i.sectionexists(scanuid + \'.bonealign\')) and (i.sectionexists(scanuid + \'.align\')) then
                      begin
                        buttonloadmatch.hint := i.readstring(scanuid + \'.bonealign\', \'matchmethod\', \'\') + \' \' + i.readstring(scanuid + \'.bonealign\', \'match\', \'\') + \'\'#13\'\' + i.readstring(scanuid + \'.align\', \'matchmethod\', \'\') + \' \' + i.readstring(scanuid + \'.align\', \'match\', \'\');
                      end
                      else if (i.sectionexists(scanuid + \'.align\')) and (i.sectionexists(scanuid + \'.arttumoralign\')) then
                      begin
                        buttonloadmatch.hint := i.readstring(scanuid + \'.align\', \'matchmethod\', \'\') + \' \' + i.readstring(scanuid + \'.align\', \'match\', \'\') + \'\'#13\'\' + i.readstring(scanuid + \'.arttumoralign\', \'matchmethod\', \'\') + \' \' + i.readstring(scanuid + \'.arttumoralign\', \'match\', \'\');
                      end
                      else
                        buttonloadmatch.hint := i.readstring(scanuid + \'.align\', \'matchmethod\', \'\') + \' \' + i.readstring(scanuid + \'.align\', \'match\', \'\');
                      quirtviewerupdcoronal.text[2].value := hr(255) + \'\' + \'\' + \'matched by: \' + i.readstring(scanuid + \'.align\', \'signature\', \'\');
                    end
                    else
                    begin
                      buttonloadmatch.hint := loadmatch_hint;
                      quirtviewerupdcoronal.text[2].value := hr(255) + \'\' + text_noprevious;
                    end;
                    exportedscan := i.readstring(scanuid + \'.export\', \'exportedscanid\', \'\');
                    if exportedscan \<\> \'\' then
                    begin
                      j := pos(\']\', exportedscan);
                      exportedscan := \'[xvi\' + copy(exportedscan, j, 250);
                    end;
                    i.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_112()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.visitcenterofmask;
                  var
                    x,y,z: single;
                    k: integer;
                  begin
                    k := 1;
                    mask_cog[k].make;
                    x := mask_cog[k].coordinate[0,0];
                    y := mask_cog[k].coordinate[1,0];
                    z := mask_cog[k].coordinate[2,0];
                    if x\<-9998 then exit;
                    field_create(quirtviewerupdcoronal.markerdots[nmarkers + 1], \'field 1d 3-space irregular\');
                    quirtviewerupdcoronal.markerdots[nmarkers + 1].coordinate[0, 0] := x;
                    quirtviewerupdcoronal.markerdots[nmarkers + 1].coordinate[1, 0] := y;
                    quirtviewerupdcoronal.markerdots[nmarkers + 1].coordinate[2, 0] := z;
                    quirtviewerupdcoronal.markerdots[nmarkers + 1].ischangedby := self;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_113()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.fatlines1click(sender: tobject);
                  var
                    i: integer;
                    linewidth: integer;
                  begin
                    fatlines1.checked := not fatlines1.checked;
                    if fatlines1.checked then
                      linewidth := 20
                    else
                      linewidth := 0;
                    for i := 0 to delineationdotslut.dimensions[0]-1 do
                      dil_set_width(delineationdotslut, delineationdotslut, i, linewidth);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_114()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.fillmaskedreferencelut;
                  var
                    i: integer;
                  begin
                    field_overlay_lut(maskedreferencelut, \'monochrome\', masklevel - maskwindow, masklevel + maskwindow,
                      4096, 255, -1, false);
                    maskedreferencelut.setvalue([0, 0], 0);
                    for i:=0 to maskedreferencelut.dimensions[0]-1 do
                    begin
                      maskedreferencelut.setvalue([i, 3],
                        maskedreferencelut.getvalue([i, 3])*0.8);
                      maskedreferencelut.setvalue([i, 2],
                        maskedreferencelut.getvalue([i, 2])*0.8);
                      maskedreferencelut.setvalue([i, 1], max(100, maskedreferencelut.getvalue([i, 1])*0.8+50));
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_115()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.getflex(imagenumber: integer; var u: single; var v: single);
                  begin
                    if synergymode  then
                    begin
                      u := queryframes.fieldbyname(\'u_centre\').asfloat/10;
                      v := queryframes.fieldbyname(\'v_centre\').asfloat/10;
                      exit;
                    end;
                    if queryframes.active then exit;
                    if avlstate\>0 then exit;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_116()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.queryframes_last;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      queryframes.last
                    else
                      frameid := numframes-1;
                    setgantry;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_117()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.queryframes_first;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      queryframes.first
                    else
                      frameid := 0;
                    setgantry;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_118()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.queryframes_eof: boolean;
                  var h : tqinifile;
                      s : string;
                      j : integer;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      result := queryframes.eof
                    else
                    begin
                      if useonlinereconstruction and (frameid \< numframes)then
                      begin
                        s := format(anglefilebase, [frameid]);
                        for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                        if not existanglefile(s) then
                        begin
                          result := true;
                          exit;
                        end;
                        h :=tqinifile.create(s);
                        s := format(\'%.4d\', [frameid]);
                        j := h.readinteger(s, \'status\', 0);
                        if j = 3 then
                        begin
                          h.free;
                          reconterminate(false, recon_notcomplete);
                          result := false;
                          application.terminate;
                          exit;
                        end
                        else if j in [1..2] then
                        begin
                          if j = 2 then
                          begin
                            bringtofront();
                            setwindowpos(handle, hwnd_top, 0, 0, 0, 0, swp_nomove or swp_nosize);
                            showwindow(handle, sw_showmaximized);
                          end;
                          numframes := frameid+1;
                        end;
                        h.free;
                      end;
                      result := (frameid \> numframes-1);
                    end
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_119()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.reconterminate(stat: bool; mes: string);
                  var h: tqinifile;
                  begin
                    h := tqinifile.create(paramstr2+\'.xvi\');
                    h.writebool(\'status\', \'completionstatus\', stat);
                    h.writestring(\'status\', \'reconstructionerrormessage\', mes);
                    setwindowpos(handle, hwnd_top, 0, 0, 0, 0, swp_nomove or swp_nosize);
                    showwindow(handle, sw_showmaximized);
                    h.free;
                    application.terminate;
                    stopreconstructing := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_120()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.queryframes_next;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      queryframes.next
                    else
                      inc(frameid);
                    if not queryframes_eof then
                      setgantry
                    else
                      frameid:=numframes-1;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_121()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.queryframes_goto(noproj: string);
                  begin
                    if strtoint(noproj)\<numframes then
                    begin
                      queryframes.locate(\'seq_num\',noproj,[locaseinsensitive]);
                      setgantry;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_122()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.queryframes_prior;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      queryframes.prior
                    else
                      dec(frameid);
                    setgantry;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_123()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.queryframes_bof: boolean;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      result := queryframes.bof
                    else
                      result := (frameid \<= 0);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_124()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.makemultianglegainfile(input: tavsfield; nframes: integer);
                  var
                    output1, neighbourhood, average, temp1                                        : tavsfield;
                    angles                                                                        : array of single;
                    angle1, angle2, midangle, alpha                                               : single;
                    i, p1, p2, j                                                                  : integer;
                    filename                                                                      : string;
                    fov, filt, kv                                                                 : string;
                    fovid, filtid, kvid                                                           : integer;
                  begin
                    neighbourhood := tavsfield.create;
                    average  := tavsfield.create;
                    temp1    := tavsfield.create;
                    output1  := tavsfield.create;
                    filename := caldir + \'magain_\' + inttostr(projdim) + \'_\';
                    fovid := form1.queryscans.fieldbyname(\'fov\').asinteger;
                    case fovid of
                      83: fov:=\'sfov\';
                      77: fov:=\'mfov\';
                    else
                      fov:=\'mfov\';
                    end;
                    filtid := form1.queryscans.fieldbyname(\'kvfilter\').asinteger;
                    case filtid of
                      2: filt:=\'f1\';
                      3: filt:=\'f2\';
                      4: filt:=\'f0\';
                    else
                      filt:=\'f1\';
                    end;
                    kvid:=form1.queryscans.fieldbyname(\'kv\').asinteger;
                    kv:=\'k\'+inttostr(kvid);
                    filename:=filename+fov+\'_\'+kv+\'_\'+filt+\'.xdr\';
                    if fileexists(filename) then
                    begin
                      if messagedlg(multi_angle_gainfile_replace1+filename+multi_angle_gainfile_replace2,
                           mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                        exit;
                    end;
                    setlength(angles, nframes);
                   field_create(output1, \'field 3d short rectilinear\', input.dimensions[0], input.dimensions[1], nframes);
                    field_getcoor(input, angle1, 2, 0);
                    field_getcoor(input, angle2, 2, input.dimensions[2]-1);
                    angles[0]:=angle1;
                    angles[nframes-1]:=angle2;
                    midangle:=(abs(angle1)+abs(angle2))/(nframes-1);
                    for i := 1 to nframes-2 do
                      angles[i]:=angles[i-1]+midangle;
                    progressbar1.max := nframes;
                    progressbar1.min := 0;
                    progressbar1.position := progressbar1.min;
                   for i := 0 to nframes-1 do
                    begin
                      alpha := angles[i];
                      angle1 := alpha-midangle/2-2;
                      angle2 := alpha+midangle/2+2;
                      field_getnearestpixel(input, p1, 2, angle1);
                      field_getnearestpixel(input, p2, 2, angle2);
                      if p1\>p2 then
                      begin
                        j  := p2;
                        p2 := p1;
                        p1 := j;
                      end;
                      field_crop(input, neighbourhood, 0, input.dimensions[0]-1,
                        0, input.dimensions[1]-1, p1, p2);
                      nstats(neighbourhood, average, nstats_mean, 0, 0, 0, 1);
                      field_inc_ndim(average, temp1);
                      field_to_short(temp1, temp1);
                      field_insert(output1, temp1, output1, 0, 0, i);
                      field_setcoor(output1, alpha, 2, i);
                      progressbar1.position := i;
                    end;
                    field_to_signed(output1, output1);
                    write_xdr(output1, filename);
                    progressbar1.position := progressbar1.max;
                    showmessage(\'file saved at \'+filename);
                    progressbar1.min := 0;
                    progressbar1.position := progressbar1.min;
                     angles := nil;
                    temp1.free;
                    neighbourhood.free;
                    average.free;
                    output1.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_125()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.multianglegaincorrection(image, multianglegain: tavsfield; size: integer);
                  var
                    downsize1, scaleout, i, proj                                : integer;
                    proj_i                                                      : string;
                    pixsize, max                                                : single;
                    imtype1                                                     : field_convert_typetype;
                    maskeduncorrected, maskedcorrected                          : tavsfield;
                    masksaturated, maskpatient                                  : tavsfield;
                    multianglegainimage: tavsfield;
                  begin
                    maskeduncorrected := tavsfield.create;
                    maskedcorrected   := tavsfield.create;
                    masksaturated     := tavsfield.create;
                    maskpatient       := tavsfield.create;
                    multianglegainimage := tavsfield.create;
                    imtype1:=field_convert_typetype(image.datatype+1);
                    if form1.fastcorrectimage then scaleout:= 65536 div form1.fastcorrectimagescale
                    else                           scaleout:= 65535;
                    proj_i:=form1.editprojectionimageresolution.text;
                    proj:=strtoint(proj_i);
                     max := image.maximum;
                    if max=65535 then
                    begin
                      field_threshold(image, masksaturated, 0, 65534);
                    end;
                    field_threshold(image, maskpatient, 0, 10000);
                    field_mask(image, maskpatient, maskeduncorrected);
                    field_to_float(maskeduncorrected, maskeduncorrected);
                    if imtype1\<\>field_convert_short then
                      field_to_short(image,image);
                    field_getnearestpixel(multianglegain, i, 2, form1.gantryangle);
                    field_slice(multianglegain, multianglegainimage, -1,-1,i);
                    downsize1:=round(proj/size);
                    if downsize1=0 then downsize1:=1;
                    pixsize:=form1.detectorsize/(image.dimensions[0]/downsize1);
                    correct_asi_2(image, nil, multianglegainimage, nil, image, downsize1, scaleout, pixsize, scaleout);
                    field_mask(image, maskpatient, maskedcorrected);
                    field_to_float(image, image);
                    field_to_float(maskedcorrected, maskedcorrected);
                    field_divc(image, image, maskedcorrected.mean/maskeduncorrected.mean);
                    if max=65535 then
                      field_mask(image, masksaturated, image, 65535);
                    field_minc(image, image, 65535);
                     if imtype1\<\>field_convert_short then
                      field_convert(image, image, imtype1);
                    multianglegainimage.free;
                    maskeduncorrected.free;
                    maskedcorrected.free;
                    masksaturated.free;
                    maskpatient.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_126()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.readmultianglegainimage(multianglegainimage: tavsfield; imsize: integer): boolean;
                  var
                    downsize                : integer;
                    localcachedirectory     : string;
                    multianglegainfilename  : string;
                    fov, filter             : string;
                    resolution              : integer;
                  begin
                    result := false;
                    case form1.scankvfilter of
                      2: filter := \'f1\';
                      3: filter := \'f2\';
                      4: filter := \'f0\';
                      5: filter := \'f2\';
                    else
                      filter := \'f1\';
                    end;
                    if scanfovcodetofourcc(form1.scanfov)\<\>\'\' then
                      fov := scanfovcodetofourcc(form1.scanfov)
                    else
                    begin
                      fov := form1.inifile.readstring(recons, \'fov\', \'\');
                      if fov = \'small\' then
                        fov := \'sfov\'
                      else if fov = \'large\' then
                        fov := \'lfov\'
                      else if fov = \'medium\' then
                        fov := \'mfov\'
                      else
                        fov := \'sfov\';
                    end;
                    resolution := imsize;
                    if (resolution\<\>256) and (resolution\<\>512) and (resolution\<\>1024) then
                    begin
                      exit;
                    end;
                    localcachedirectory := inifile.readstring(\'xvi\', \'multianglefilelocalcache\', \'c:\\xvi\\calimg\\\');
                    localcachedirectory := localcachedirectory + rightstr(caldir, 9);
                    repeat
                      multianglegainfilename := \'magain_\' + inttostr(resolution);
                      multianglegainfilename := multianglegainfilename + \'_\' + fov;
                      multianglegainfilename := multianglegainfilename + \'_k\' + inttostr(form1.scankv);
                      multianglegainfilename := multianglegainfilename + \'_\' + filter + \'.xdr\';
                      resolution := resolution*2;
                    until fileexists(caldir + multianglegainfilename) or (resolution\>1024);
                    if resolution\>1024 then
                    begin
                      showmessage(multianglegainfilename+ #13#10 +error_multi_angle_gain_file_not_found);
                      result := false;
                      exit;
                    end;
                    if fileexists(localcachedirectory + multianglegainfilename) then
                      read_xdr(multianglegainimage, localcachedirectory + multianglegainfilename)
                    else
                    begin
                      read_xdr(multianglegainimage, caldir + multianglegainfilename);
                        forcedirectories(localcachedirectory);
                      write_xdr(multianglegainimage, localcachedirectory+multianglegainfilename);
                    end;
                    downsize := multianglegainimage.dimensions[0] div imsize;
                    if downsize = 0 then downsize := 1;
                    if downsize\>1 then
                      field_resize(multianglegainimage, multianglegainimage, downsize, downsize, 0, field_resize_average);
                    result := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_127()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure detectsaturatedpixels(f, saturated: tavsfield);
                  begin
                    if assigned(saturated) then
                      field_threshold(f, saturated, 0, 0, 1, 0, false);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_128()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure detectandaddsaturatedpixels(f, saturated: tavsfield);
                  var
                    x: tavsfield;
                    satref: tavsfield;
                  begin
                    if assigned(saturated) then
                    begin
                      x := nil;
                      satref := saturated;
                    end
                    else
                    begin
                      x := tavsfield.create;
                      satref := x;
                    end;
                    field_threshold(f, satref, -1, 0, 1, 0, false);
                    field_add(f, satref, f);
                    x.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_129()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure rotateprojectionimageinplane(f: tavsfield; inplanerotationcorrectionangle: single);
                  var
                    x: tavsfield;
                    y: tavsfield;
                  begin
                    x := tavsfield.create;
                    y := tavsfield.create;
                    eulerxfm(x, 0, 0, inplanerotationcorrectionangle);
                    fieldxfm(f, x, f, y);
                    field_eqsc(y, x, 0);
                    field_divc(x, x, -255);
                    field_and(f, x, x);
                    field_or(x, y, f);
                    x.free;
                    y.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_130()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure filterprojectionimage(f: tavsfield; prefilter: string);
                  begin
                    if (prefilter \<\> \'\') then
                    begin
                      if prefilter = \'despeckle\' then
                        field_filter(f, f, field_filter_despeckle8)
                      else if prefilter = \'median5\' then
                        field_filter(f, f, field_filter_median5)
                      else if prefilter = \'median9\' then
                        field_filter(f, f, field_filter_median9)
                      else if prefilter = \'blur2x2\' then
                        field_filter(f, f, field_filter_blur2x2)
                      else if prefilter = \'blur5\' then
                        field_filter(f, f, field_filter_blur5)
                      else if prefilter = \'blur9\' then
                        field_filter(f, f, field_filter_blur9)
                      else if prefilter = \'blur5x5\' then
                        field_ops(f, f, 5, field_ops_smooth);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_131()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure enforcesquaredimensions(f: tavsfield; size: integer);
                  var
                    psize: single;
                    x: tavsfield;
                  begin
                    if (size\>f.dimensions[1]) then
                    begin
                      form1.prepad := (size - f.dimensions[1]) div 2;
                      x := tavsfield.create;
                      if f.datatype = avs_type_integer then
                        field_create(x, \'field 2d integer\', size, size)
                      else
                        field_create(x, \'field 2d short\', size, size);
                      psize := f.coordinate[0, 1] - f.coordinate[0, 0];
                      x.coordinate[0, 0] := f.coordinate[0, 0];
                      x.coordinate[0, 1] := f.coordinate[0, f.dimensions[0] - 1];
                      x.coordinate[1, 0] := f.coordinate[1, 0] - form1.prepad * psize;
                      x.coordinate[1, 1] := f.coordinate[1, f.dimensions[1] - 1] + form1.prepad * psize;
                      field_insert(x, f, f, 0, form1.prepad);
                      x.free;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_132()
{
    return parse(#DelphiGrammar::MethodImplementation, "function mapimagenumbertofilenameinanglefile(imagenumber: integer): string;
                  var
                    j: integer;
                    s: string;
                    h: tinifile;
                  begin
                    s := format(form1.anglefilebase, [imagenumber]);
                    for j := pos(\'%\', form1.anglefilebase) to length(s) do
                      if s[j] = \' \' then
                        s[j] := \'0\';
                    h := tinifile.create(s);
                    s := format(\'%.4d\', [imagenumber]);
                    result := form1.projectionfilebase + h.readstring(s, \'projectiondatafile\', \'\');
                    h.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_133()
{
    return parse(#DelphiGrammar::MethodImplementation, "function firsthisfileinfolder(dbname: string): integer;
                  var
                    sr: tsearchrec;
                    current: integer;
                    lowest: integer;
                  begin
                    lowest := maxint;
                    if findfirst(includetrailingpathdelimiter(dbname) + \'*.his\', not fadirectory, sr)=0 then
                    repeat
                      current := strtointdef(\'$\' + changefileext(sr.name, \'\'), -1);
                      if current\<lowest then
                        lowest := current;
                    until findnext(sr)\<\>0;
                    findclose(sr);
                    if lowest\<maxint then
                      result := lowest
                    else
                      result := -1;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_134()
{
    return parse(#DelphiGrammar::MethodImplementation, "function mapimagenumbertofilenameinsequencedir(basedir: string; imagenumber: integer; synergymode: boolean): string;
                  var
                    lowest: integer;
                  begin
                    if not synergymode then
                    begin
                      if form1.numberoffirstimageinsequencedir\<0 then
                      begin
                        lowest := firsthisfileinfolder(basedir + form1.sequencedir);
                        form1.numberoffirstimageinsequencedir := lowest;
                      end;
                      result := format(\'%.8x.his\', [math.max(0, form1.numberoffirstimageinsequencedir)+2*imagenumber]);
                    end
                    else
                      result := format(\'%.8x.his\', [imagenumber]);
                    if form1.sqlmode then
                      result[1] := \'0\';
                    result := basedir + form1.sequencedir + result;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_135()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure swap(var a, b: integer);
                  var
                    t: integer;
                  begin
                    t := a;
                    a := b;
                    b := t;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_136()
{
    return parse(#DelphiGrammar::MethodImplementation, "function mapimagenumbertofilename(basedir: string; avlstate: integer; imagenumber: integer; synergymode: boolean): string;
                  begin
                    if avlstate\<0 then
                      result := mapimagenumbertofilenameinsequencedir(basedir, imagenumber, synergymode)
                    else
                      result := mapimagenumbertofilenameinanglefile(imagenumber)
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_137()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.readhisimage(imagenumber: integer; basedir: string;
                    gain, offset, projectionimage, saturated: tavsfield;
                    size: integer; prefilter: string): boolean;
                  const
                    scale = 65535;
                  var
                    downsize1, downsize2, downsize: integer;
                    pixelsize: single;
                    gainref: tavsfield;
                    offsetref: tavsfield;
                    filename: string;
                  begin
                    result := false;
                    gainref := nil;
                    offsetref := nil;
                    if lowercase(prefilter)=\'none\' then
                      prefilter := \'\';
                    size := ensurerange(size, 8, 1024);
                    downsize := ensurerange(round(projdim / size), 1, maxint);
                    downsize1 := downsize;
                    downsize2 := 1;
                    if (prefilter\<\>\'\') then
                      swap(downsize1, downsize2);
                    filename := mapimagenumbertofilename(basedir, avlstate, imagenumber, synergymode);
                    if (not fileexists(filename)) then
                    begin
                      projectionimage.clear;
                      if avlstate\>0 then
                        reconterminate(false, error_missingprojimage);
                    end
                    else
                    begin
                      read_heimann_his(projectionimage, filename);
                      if projectionimage.dimensions[0]\<\>projdim then
                      begin
                        if avlstate\>0 then
                          reconterminate(false, error_wrongprojimage);
                        exit;
                      end;
                      result := true;
                      pixelsize := detectorsize / (projectionimage.dimensions[0] / downsize1);
                      if correctfor0xffffpixelbug then
                        detectandaddsaturatedpixels(projectionimage, saturated)
                      else
                        detectsaturatedpixels(projectionimage, saturated);
                      if projectionsinverted then
                        field_not(projectionimage,projectionimage);
                      if projectionscalibrated\<=2 then
                      begin
                        gainref := gain;
                        offsetref := offset;
                      end;
                      correct_asi_2(projectionimage, offsetref, gainref, nil, projectionimage, downsize1, scale, pixelsize, scale);
                      if (inplanerotationcorrectionangle\<\>0) then
                        rotateprojectionimageinplane(projectionimage, inplanerotationcorrectionangle);
                      gbmultianglecorrection := inifile.readbool(\'xvi\', \'multianglecorrection\', false);
                      if gbmultianglecorrection then
                      begin
                        if gfmultianglegain.empty or (gfmultianglegain.dimensions[0]\<\>projectionimage.dimensions[0]) then
                        begin
                          gfmultianglegain.clear;
                          readmultianglegainimage(gfmultianglegain, projectionimage.dimensions[0]);
                        end;
                        if not gfmultianglegain.empty then
                          multianglegaincorrection(projectionimage, gfmultianglegain, size);
                      end;
                      filterprojectionimage(projectionimage, prefilter);
                      if downsize2 \<\> 1 then
                        field_resize(projectionimage, projectionimage, downsize2, downsize2, 1, field_resize_average);
                      if assigned(saturated) then
                      begin
                        field_resize(saturated, saturated, downsize, downsize);
                        field_convert(saturated, saturated, field_convert_typetype(projectionimage.datatype+1));
                        field_data_coords(saturated, projectionimage, saturated);
                      end;
                      enforcesquaredimensions(projectionimage, size);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_138()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.existshisimage(imagenumber: integer; basedir : string) : boolean;
                  var
                    filename,s: string;
                    j: integer;
                    h : tqinifile;
                  begin
                    result := false;
                    if avlstate\>0 then
                    begin
                      s := format(anglefilebase, [imagenumber]);
                      for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                      h :=tqinifile.create(s);
                      s := format(\'%.4d\', [imagenumber]);
                      filename := projectionfilebase + h.readstring(s, \'projectiondatafile\', \'\');
                      h.free;
                      if fileexists(filename) then
                        result := true;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_139()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.readcorrectionimages(gain, offset, bad, bowtie : tavsfield) : boolean;
                  var
                    tmpfield : tavsfield;
                  begin
                    result := true;
                    gain.clear;
                    offset.clear;
                    bowtie.clear;
                    gfmultianglegain.clear;
                    tmpfield := tavsfield.create;
                    if fileexists(offsetfilename) then
                    begin
                       if extractfileext(offsetfilename)=\'.his\' then
                         read_heimann_his(offset, offsetfilename)
                       else
                         if extractfileext(offsetfilename)=\'.xdr\' then
                           read_xdr(offset, offsetfilename);
                       if patientdir = \'\\img\' then
                       begin
                         field_to_float(offset,offset);
                         field_mulc(offset,offset,26/25);
                         field_addc(offset,offset,0.5);
                         field_to_short(offset,offset);
                       end;
                       editoffsetimage.text:=offsetfilename;
                    end
                    else
                    begin
                      result := false;
                      editoffsetimage.text := offset_error;
                    end;
                    if fileexists(gainfilename) then
                    begin
                      if extractfileext(gainfilename)=\'.his\' then
                        read_heimann_his(gain, gainfilename)
                      else if extractfileext(gainfilename)=\'.xdr\' then
                        read_xdr(gain, gainfilename);
                      if gain.datasize=4 then
                      begin
                        field_to_float(gain, gain);
                        field_setc(gain, tmpfield, 65536);
                        field_div(tmpfield, gain, gain);
                        field_minc(gain, gain,   1);
                        field_maxc(gain, gain, 0.1);
                        field_to_short(gain, gain, 65536, 1, true);
                      end;
                      field_eqsc(gain,tmpfield,0);
                      field_add(gain,tmpfield,gain);
                      editgainimage.text:=gainfilename;
                    end
                    else
                    begin
                      result := false;
                      editgainimage.text := gain_error;
                    end;
                    if fileexists(badmapfilename) then
                    begin
                      if extractfileext(badmapfilename)=\'.xdr\' then
                        read_xdr(bad, badmapfilename);
                    end;
                    if fileexists(gainbowtiefilename) then
                    begin
                      if extractfileext(gainbowtiefilename)=\'.his\' then
                        read_heimann_his(bowtie, gainbowtiefilename)
                      else if extractfileext(gainbowtiefilename)=\'.xdr\' then
                        read_xdr(bowtie, gainbowtiefilename);
                      if bowtie.datasize=4 then
                      begin
                        field_to_float(bowtie, bowtie);
                        field_setc(bowtie, tmpfield, 65536);
                        field_div(tmpfield, bowtie, bowtie);
                        field_minc(bowtie, bowtie,   1);
                        field_maxc(bowtie, bowtie, 0.1);
                        field_to_short(bowtie, bowtie, 65536, 1, true);
                      end;
                      field_eqsc(bowtie,tmpfield,0);
                      field_add(bowtie,tmpfield,bowtie);
                      if not gain.empty then
                      begin
                        field_copy(gain, tmpfield);
                        field_copy(bowtie, gain);
                        field_copy(tmpfield, bowtie);
                        field_to_signed(gain,   tmpfield);
                        field_to_signed(bowtie, bowtie);
                        field_mulc(tmpfield, tmpfield, 8192);
                        field_div(tmpfield, bowtie, bowtie);
                      end;
                    end;
                    tmpfield.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_140()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.loadimage;
                  var
                    s1               : variant;
                    filename, filter, s : string;
                    i, imagenumber,k   : integer;
                    date:              integer;
                    a: single;
                    query: tabstractquery;
                  begin
                    needloadimage := false;
                    memo1.lines.clear;
                    begin
                      if not queryframes.active then
                      begin
                      if length(exportedscan)\>0 then
                        memo1.lines.add(memo_exported + exportedscan);
                        exit;
                      end;
                      queryframes.first;
                        numframes := queryframes.recordcount;
                      if synergymode and (numframes = 0) and (nframedb\>1) then
                      begin
                        if queryframes is tabstractquery then
                          query := queryframes as tabstractquery
                        else
                          query := nil;
                        if assigned(query.sql) then
                        begin
                          if (pos(\'frame\' + inttostr(nframedb-2), query.sql.strings[0]) = 0) then
                          begin
                            if (pos(\'frame \' , query.sql.strings[0]) \<\> 0) then
                              s := \'0\'
                            else
                            begin
                              s := query.sql.strings[0];
                              k := pos(\'frame\' , s);
                              s := inttostr(strtoint(s[k+5]) + 1);
                            end;
                            query.active := false;
                            query.sql.clear;
                            query.sql.add(\'select * from frame\' + s +\' where\');
                            query.sql.add(\'frame\' + s + \'.ima_dbid=:dbid\');
                            query.sql.add(\'order by seq_num\');
                          end;
                        end;
                        queryframes.active := true;
                        assignwidememoeventhandlers(queryframes);
                        queryframes.first;
                          numframes := queryframes.recordcount;
                      end;
                      if synergymode then
                        projdim   := strtointdef(queryscans.fieldbyname(\'width\').asstring,0)
                      else
                        projdim   := strtointdef(queryimages.fieldbyname(\'width\').asstring,0);
                      prepad      := 0;
                      case projdim of
                        960, 480, 240, 120, 60:
                          begin
                            detectorsize := 43.0;
                            fdd          := 153.2;
                          end;
                        780, 390, 195:
                          begin
                            detectorsize := 28.7;
                            fdd          := 153.6;
                          end;
                        1024, 512, 256, 128, 64:
                          begin
                            detectorsize := 40.96;
                            fdd          := 153.6;
                          end;
                        else
                          begin
                            showmessage(\'unsupported detector\');
                            detectorsize := 10.0;
                            fdd          := 153.6;
                          end;
                      end;
                      detectorsize := inifile.readfloat(\'xvi\', \'detectorsize\', detectorsize);
                      fdd := inifile.readfloat(\'xvi\', \'focusdetectordistance\', fdd);
                      fid := inifile.readfloat(\'xvi\', \'focusisocdistance\', 100.00);
                    end;
                    memo1.lines.add(memo_frames + inttostr(numframes));
                    quirtviewer1.text[1].value := \'\';
                    quirtviewer1.text[2].value := \'\';
                    quirtviewer1.text[3].value := \'\';
                    quirtviewer1.text[4].value := \'\';
                    if numframes=0 then
                    begin
                      if length(exportedscan)\>0 then
                        memo1.lines.add(memo_exported + exportedscan);
                      exit;
                    end;
                    if (checkboxusecalibrationimages.checked) or avlflexmapmode then
                    begin
                      date:= strtointdef(scandate, 0);
                      caldir := \'\';
                      for k:=0 to caldirlist.count-1 do
                      begin
                        if (strtointdef(caldirlist[k],0)-date)\<0 then
                          caldir:=caldirroot+caldirlist[k]+\'\\\';
                      end;
                      if (caldir = \'\') then
                        showmessage(calib_error_nki)
                      else
                        inifile.addinifile(caldir + \'fpi.ini\', ilend);
                      end;
                    case scantype of
                      70 : s1 := memo_type70;
                      67 : s1 := memo_type67;
                      66 : s1 := memo_type66;
                      68 : s1 := memo_type68;
                      77 : s1 := memo_type77;
                      78 : s1 := memo_type78;
                      82 : s1 := memo_type82;
                    else
                      s1 := memo_typeunknown;
                    end;
                    s1 := memo_type + s1;
                    s1 := s1 + \'  \' + inttostr(scankv) + \' kv\';
                    s1 := s1 + \'  \' + inttostr(scanma) + \' ma\';
                    s1 := s1 + \'  \' + inttostr(scanms) + \' ms\';
                    case scanfov of
                    76: begin
                          s1 := s1 + \'  full offset field of view\';
                          editreconstructedimageresolution.text:=\'512\';
                          editreconstructionsize.text:=\'51.2\';
                          showmessage(oldbd_warning);
                        end;
                    77: begin
                          s1 := s1 + \'  half offset field of view\';
                          editreconstructedimageresolution.text:=\'400\';
                          editreconstructionsize.text:=\'40\';
                        end;
                    83: begin
                          s1 := s1 + \'  centered field of view\';
                          editreconstructedimageresolution.text:=\'256\';
                          editreconstructionsize.text:=\'25.6\';
                        end
                    else
                      s1 := s1 + panel_warning;
                    end;
                    case scankvfilter of
                    2: s1 := s1 + \'  f1\';
                    3: s1 := s1 + \'  f2\';
                    4: s1 := s1 + \'  f0\';
                    else
                      s1 := s1 + \' unknown kv filter\';
                    end;
                    memo1.lines.add(s1);
                    if synergymode then
                      if length(trimright(queryscans.fieldbyname(\'comment\').asstring))\>0 then
                        memo1.lines.add(adjustlinebreaks(trimright(queryscans.fieldbyname(\'comment\').asstring)));
                    if length(exportedscan)\>0 then
                      memo1.lines.add(memo_exported + exportedscan);
                    if (checkboxusecalibrationimages.checked) and
                      (not iview3dmode) and (not fastmode) and (not synergymode) then
                    begin
                      if scantype\<\>68 then
                      begin
                        gainfilename:=\'gain_\';
                        case scanfov of
                          76: gainfilename := gainfilename + \'fulloffset\';
                          77: gainfilename := gainfilename + \'halfoffset\';
                          83: gainfilename := gainfilename + \'centered\';
                        end;
                        gainfilename := gainfilename + \'_\'+inttostr(scanma);
                        gainfilename := gainfilename + \'_\'+inttostr(scanms);
                        gainfilename := gainfilename + \'_\'+inttostr(scankv);
                        gainfilename := gainfilename + \'.xdr\';
                        gainfilename := caldir+gainfilename;
                        if not(fileexists(gainfilename)) then
                        begin
                          quirtviewer1.text[1].value := calib_warning;
                          memo1.lines.add(missing_gain + gainfilename);
                        end;
                        flexmapfilename:=\'flexmap_\';
                        case scanfov of
                          76: flexmapfilename := flexmapfilename + \'fulloffset\';
                          77: flexmapfilename := flexmapfilename + \'halfoffset\';
                          83: flexmapfilename := flexmapfilename + \'centered\';
                        end;
                        flexmapfilename := flexmapfilename + \'.xdr\';
                        flexmapfilename := caldir+flexmapfilename;
                        if not(fileexists(flexmapfilename)) then
                        begin
                          quirtviewer1.text[1].value := calib_warning;
                          memo1.lines.add(missing_flexmap + flexmapfilename);
                        end;
                        imagenumber := 0;
                        queryoffsets.disablecontrols;
                        if queryoffsets.recordcount\<\>0 then
                        begin
                          queryoffsets.first;
                          i := queryoffsets.fieldbyname(\'dbid\').asinteger;
                          repeat
                            k := queryoffsets.fieldbyname(\'dbid\').asinteger;
                            if strtointdef(queryoffsets.fieldbyname(\'img_time\').asstring,0) \<
                               strtointdef(queryscans  .fieldbyname(\'img_time\').asstring,0) then i:=k;
                            queryoffsets.next;
                          until queryoffsets.eof;
                          queryoffsets.locate(\'dbid\', i, []);
                          offsetdir := patientdir + \'\\\' + trimright(queryoffsets.fieldbyname(\'dicom_uid\').asstring) + \'\\\';
                          queryoffsets.enablecontrols;
                          imagenumber:=queryoffsetframes.fieldbyname(\'dbid\').asinteger;
                        end;
                        queryoffsets.enablecontrols;
                        filename := format(\'%.8x.his\', [imagenumber]);
                        offsetfilename := edit1.text+sequencedir+filename;
                        i := 1;
                        while not(fileexists(offsetfilename)) and (i\<10) and (backupdb[i]\<\>\'\') do
                        begin
                          offsetfilename := backupdb[i]+sequencedir+filename;
                          inc(i);
                        end;
                        if not(fileexists(offsetfilename)) then
                        begin
                          if synergymode then
                            offsetfilename := edit1.text+offsetdir+filename
                          else
                            offsetfilename := edit1.text+offsetdir + inttohex(firsthisfileinfolder(edit1.text+offsetdir), 8) + \'.his\';
                          i := 1;
                          while not(fileexists(offsetfilename)) and (i\<10) and (backupdb[i]\<\>\'\') do
                          begin
                            offsetfilename := backupdb[i]+offsetdir+filename;
                            inc(i);
                          end;
                          if not fileexists(offsetfilename) then
                          begin
                            if queryoffsetframes.findfield(\'framelink\') \<\> nil then
                            begin
                              if (queryoffsetframes.fieldbyname(\'framelink\').asvariant \<\> null) then
                              begin
                                s := trimright(queryframes.fieldbyname(\'framelink\').asstring);
                                i := min(length(jukeboxbase),strtoint(s[3]));
                                offsetfilename := jukeboxbase[i-1] + s;
                              end
                            end;
                          end;
                          if not(fileexists(offsetfilename)) then
                          begin
                            quirtviewer1.text[1].value := calib_warning;
                            memo1.lines.add(missing_offset + offsetfilename);
                          end;
                        end;
                        readcorrectionimages(gain, offset, bad, bowtie);
                      end;
                    end
                    else if synergymode and avlflexmapmode then
                    begin
                      if ((queryscans.fieldbyname(\'stopacqang\').asfloat - queryscans.fieldbyname(\'startacqag\').asfloat) \< 0) then
                        flexmapfilename := \'cc_\'
                      else
                        flexmapfilename := \'cw_\';
                      case scanfov of
                        76: flexmapfilename := flexmapfilename + \'lfov\';
                        77: flexmapfilename := flexmapfilename + \'mfov\';
                        83: flexmapfilename := flexmapfilename + \'sfov\';
                      end;
                      flexmapfilename := flexmapfilename + \'.xdr\';
                      flexmapfilename := caldir+flexmapfilename;
                      if not(fileexists(flexmapfilename)) then
                        flexmapfilename := copy(flexmapfilename,1,length(flexmapfilename)-3) + \'flexmap\';
                      if not(fileexists(flexmapfilename)) then
                      begin
                        quirtviewer1.text[1].value := calib_warning;
                        memo1.lines.add(missing_flexmap + flexmapfilename);
                      end;
                      gain.clear;
                      offset.clear;
                    end
                    else
                    begin
                      gain.clear;
                      offset.clear;
                    end;
                    filter := \'\'; if checkboxmedian.checked then filter := \'despeckle\';
                    if readhisimage(frameid, edit1.text, gain, offset, f, nil, strtointdef(editprojectionimageresolution.text, 256), filter) then
                    begin
                      quirtviewer1.field[1] := f;
                      quirtviewer1.field[2] := nil;
                      quirtviewer1.zoom.value := 0;
                    end
                    else
                      memo1.lines.add(missing_images);
                    memo1.lines.add(\'patient id \'+patientid);
                    queryframes_first;
                    a := gantryangle;
                    queryframes_last;
                    a := a - gantryangle;
                    queryframes_first;
                    if (abs(a)\<(180 + 2*7.59 + 2)) or ((abs(a)\>270) and (abs(a)\<358)) then
                    begin
                      memo1.lines.add(format(acq_notcomover, [abs(a)]));
                      quirtviewer1.text[3].value := acq_notcomplete;
                    end
                    else
                    begin
                      memo1.lines.add(format(acq_over, [abs(a)]));
                      showframenumberandgantryangle();
                    end;
                    if iview3dmode then
                      memo1.lines.add(\'scan location: \' + sequencedir);
                    pause := true;
                    progressbar1.position := 0;
                    trackbar1.max := numframes;
                    settrackbarpos(1);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_141()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.movieloop(sender: tobject);
                  var
                    raw,projvol       : tavsfield;
                    k                 : integer;
                    s, fileheader, filter: string;
                  begin
                    if (sender=buttonfirst) then
                    begin
                      queryframes_first;
                      pause:=true;
                      movieloop(self);
                      progressbar1.position := 0;
                      settrackbarpos(1);
                    end;
                    if (sender=buttonpause) then
                    begin
                      if (getkeystate(vk_lshift) and $8000)\<\>0 then
                      begin
                        s := queryframes.fieldbyname(\'seq_num\').asstring;
                        if inputquery(\'navigate to frame\',\'which frame?\', s) then
                        begin
                          queryframes_goto(s);
                          movieloop(self);
                        end
                        else
                          exit;
                      end;
                      pause:=true;
                    end;
                    if (sender=buttonrun) then
                    begin
                      if (getkeystate(vk_control) and $8000)\<\>0 then
                      begin
                        raw := tavsfield.create;
                        filter := \'\'; if checkboxmedian.checked then filter := \'despeckle\';
                        readhisimage(frameid, edit1.text, gain, offset, raw, nil, strtointdef(editprojectionimageresolution.text, 256), filter);
                        projvol:=tavsfield.createas(\'field 3d integer\',[raw.dimensions[0], numframes, raw.dimensions[1]]);
                        projvol.coordinate[0, 0] := -(detectorsize/2.0) * (projvol.dimensions[0]-1) / projvol.dimensions[0];
                        projvol.coordinate[0, 1] :=  (detectorsize/2.0) * (projvol.dimensions[0]-1) / projvol.dimensions[0];
                        projvol.coordinate[1, 0] := 0;
                        projvol.coordinate[1, 1] := (projvol.dimensions[1]-1)*0.371;
                        projvol.coordinate[2, 0] := -(detectorsize/2.0) * (projvol.dimensions[2]-1) / projvol.dimensions[2];
                        projvol.coordinate[2, 1] :=  (detectorsize/2.0) * (projvol.dimensions[2]-1) / projvol.dimensions[2];
                        k:=0;
                        queryframes_first;
                        repeat
                          if readhisimage(frameid, edit1.text, gain, offset, raw, nil, strtointdef(editprojectionimageresolution.text, 256), filter) then
                          begin
                            field_inc_ndim(raw,raw);
                            field_transpose(raw,raw,1);
                            field_transpose(raw,raw,0);
                            field_insert(projvol,raw,projvol,0,k,0);
                          end;
                          queryframes_next;
                          k:=k+1;
                        until queryframes_eof;
                        savedialog2.title:=saveprojdialog;
                        fileheader := \'date=\'  + copy(scandate, 3, 6)+
                                      \';time=\' + copy(scantime, 0, 6)+
                                      \';dicom=\'+ scanuid;
                        if savedialog2.execute then write_xdr(projvol, savedialog2.filename, fileheader);
                        projvol.free;
                        raw.free;
                      end
                      else
                      begin
                        if (queryframes_eof) then
                        begin
                          queryframes_first;
                          progressbar1.position := 0;
                          settrackbarpos(1);
                        end;
                        if pause then
                        begin
                          pause:=false;
                          movieloop(self);
                        end;
                      end
                    end;
                    if (sender=buttonprevious) then
                    begin
                      pause:=true;
                      if not queryframes_bof then
                      begin
                        queryframes_prior;
                        progressbar1.position := queryframes.fieldbyname(\'seq_num\').asinteger;
                        settrackbarpos(queryframes.fieldbyname(\'seq_num\').asinteger);
                        movieloop(self);
                        progressbar1.step := 1;
                      end
                      else
                      begin
                        progressbar1.position := 0;
                        settrackbarpos(1);
                      end;
                    end;
                    if (sender=buttonnext) then
                    begin
                      pause:=true;
                      if not queryframes_eof then
                      begin
                        queryframes_next;
                        movieloop(self);
                      end;
                    end;
                    if (sender=buttonlast) then
                    begin
                      pause:=true;
                      queryframes_last;
                      progressbar1.position := progressbar1.max;
                      settrackbarpos(trackbar1.max);
                      movieloop(self);
                    end;
                    if (sender=self) then
                    begin
                      progressbar1.max := numframes;
                      trackbar1.max := numframes;
                      repeat
                        if readhisimage(frameid, edit1.text, gain, offset, f, nil, strtointdef(editprojectionimageresolution.text, 256), filter) then
                        begin
                          showframenumberandgantryangle();
                          progressbar1.position := queryframes.fieldbyname(\'seq_num\').asinteger;
                          settrackbarpos(queryframes.fieldbyname(\'seq_num\').asinteger);
                          buttonstatclick(nil);
                          application.processmessages;
                        end;
                        if not pause then queryframes_next;
                        if ((not pause) and (queryframes_eof)) then
                        begin
                          queryframes_first;
                          progressbar1.position := 0;
                          settrackbarpos(1);
                        end;
                      until queryframes_eof or pause;
                    end;
                    if queryframes_eof then
                    begin
                      queryframes_last;
                      progressbar1.position := progressbar1.max;
                      settrackbarpos(trackbar1.max);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_142()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.checkboxmedianclick(sender: tobject);
                  begin
                    needloadimage := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_143()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonreconstructorviewclick(sender: tobject);
                  var i    : tqinifile;
                      uid  : string;
                  begin
                    if (getkeystate(vk_lshift) and $8000)=0 then
                    begin
                      pagecontrol1.activepageindex := 2;
                      pagecontrol1change(nil);
                      if buttonloadscan.enabled then
                      begin
                        pagecontrol1.activepageindex := 2;
                        needloadscan := true;
                        if referencecube.empty then
                        begin
                          if synergymode then uid := plansopuid else uid := treatmentuid;
                          if fileexists(adminfilebase + uid + \'.xvi\') then
                          begin
                            i := tqinifile.create(adminfilebase + uid + \'.xvi\');
                            needloadreference := i.sectionexists(\'xvi\') or (synergymode and reference[1].exists(cachefilebase, scanseriesuid, \'ref\'));
                            i.free;
                          end
                          else
                             needloadreference := (synergymode and reference[1].exists(cachefilebase, scanseriesuid, \'ref\'));
                        end;
                        if loadlatestalignment and buttonloadmatch.enabled then
                        begin
                          timer1timer(self);
                          buttonloadmatchclick(buttonreconstructorview);
                        end;
                        exit;
                      end
                    end
                    else
                    begin
                      pagecontrol1.activepageindex := 1;
                      pagecontrol1change(nil);
                    end;
                    if buttonreconstruct.enabled then
                      buttonreconstructclick(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_144()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.about1click(sender: tobject);
                  begin
                    aboutdlg2.showmodal;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_145()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.createcorrectionimages;
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_146()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.createflexmapsinglebb;
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_147()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonchangecalibrationclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_148()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.checkboxusecalibrationimagesclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_149()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonflexmapbbclick(sender: tobject);
                  begin
                     createflexmapsinglebb;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_150()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsavegainoffsetclick(sender: tobject);
                  begin
                     createcorrectionimages;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_151()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.editprojectionimageresolutionchange(sender: tobject);
                  begin
                    if (sender\<\>nil) and queryscans.active then
                      needloadimage := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_152()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonreconstructclick(sender: tobject);
                  begin
                      volumereconstructclick(sender);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_153()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.quirtviewerprocessing(sender: tobject; field: tavsfield; mode: integer);
                  var pmode, level, i: integer;
                      t1: tavsfield;
                  begin
                    pmode := mode div 100;
                    level := mode mod 100;
                    if pmode=0 then exit;
                    t1 := tavsfield.create;
                    if pmode=1 then
                    begin
                      if      level=1 then field_filter(field, field, field_filter_laplaceenhance)
                      else if level=2 then field_filter(field, field, field_filter_laplace9enhance)
                      else
                      begin
                        field_filter(field, t1, field_filter_laplace);
                        for i:=2 to level div 2 do field_mulc(t1, t1, 2);
                        if odd(level) then field_fmul(t1, t1, 1.414);
                        field_filter(t1, t1, field_filter_blur5);
                        field_filter(t1, t1, field_filter_blur9);
                        field_add(field, t1, field);
                      end;
                    end
                    else if pmode=2 then
                    begin
                      if      level=1 then field_filter(field, field, field_filter_laplace)
                      else if level=2 then field_filter(field, field, field_filter_laplace9)
                      else
                      begin
                        field_filter(field, t1, field_filter_laplace);
                        for i:=2 to level div 2 do field_mulc(t1, t1, 2);
                        if odd(level) then field_fmul(t1, t1, 1.414);
                        field_filter(t1, t1, field_filter_blur5);
                        field_filter(t1, field, field_filter_blur9);
                      end;
                    end
                    else if pmode=3 then
                    begin
                      field_ops(field, t1, (level-1)*2 + 1);
                      field_sub(field, t1, field);
                    end
                    else if pmode=4 then
                    begin
                      field_ops(field, t1, (level-1)*2 + 1);
                      field_sub(field, t1, field);
                      field_to_short(field, field);
                      field_hismod(field, field, 255, true);
                    end
                    else if pmode=5 then
                    begin
                       field_filter(field,field,field_filter_operationtype(strtoint(\'10\')));
                    end;
                    t1.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_154()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.comboboxfiltertypechange(sender: tobject);
                  begin
                    if comboboxfiltertype.itemindex=0 then
                      quirtviewer1.processing[1].value := 0
                    else
                    begin
                      if (comboboxfiltertype.itemindex\>=3) and (trackbarfilterkernel.position\<=1) then
                        trackbarfilterkernel.position := 11;
                      quirtviewer1.processing[1].value := comboboxfiltertype.itemindex*100+trackbarfilterkernel.position;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_155()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonroistatsclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_156()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonclipstatsclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_157()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updategrid(sender: tobject; var unchanged: boolean);
                  var f, x, y, s: tavsfield;
                      eq, g : integer;
                  begin
                    x := tavsfield.create;
                    y := tavsfield.create;
                    s := tavsfield.create;
                    eulerxfm(x);
                    eulerxfm(y, 270, 0, 270, 0, 0, 0);
                    if showall1.checked then g := 2 else g := 1;
                    f := onlinecube;
                    if tavsfield(sender)=quirtviewerupdcoronal.grid then
                    begin
                      f := quirtviewerupdcoronal.field[g];
                      transform_math(x, quirtviewerupdcoronal.transform[g], x);
                    end;
                    if tavsfield(sender)=quirtviewerupdsagittal.grid then
                    begin
                      f := quirtviewerupdsagittal.field[g];
                      transform_math(x, quirtviewerupdsagittal.transform[g], x);
                    end;
                    if tavsfield(sender)=quirtviewerupdtransversal.grid then
                    begin
                      f := quirtviewerupdtransversal.field[g];
                      transform_math(x, quirtviewerupdtransversal.transform[g], x);
                    end;
                    transform_math(x, y, x, false, true);
                    if f.empty then
                    begin
                      tavsfield(sender).clear;
                      x.free;
                      y.free;
                      s.free;
                      exit;
                    end;
                    field_to_grid(f, s);
                    eulerxfm(y);
                    field_compare_data(x, y, eq);
                    if (s.ndim=3) and (eq=0) then
                      extents_grid2(s, nil, x, nil, s, gridvoxelsize);
                    if s.ndim=4 then
                      if s.dimensions[2]=1 then
                        field_slice(s, s, -1, -1, 0, 0, 0);
                    field_compare_coords(tavsfield(sender), s, eq);
                    unchanged := (eq=1)
                                 and (s.ndim=2);
                    if not unchanged then field_copy(s, tavsfield(sender));
                    x.free;
                    y.free;
                    s.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_158()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updateclipboxlist(sender: tobject; var unchanged: boolean);
                  var i: integer;
                      f: tavsfield;
                  begin
                    f := tavsfield.create;
                    field_create(clipboxlist, \'field 2d float\', 7, nclipbox);
                    for i:=1 to nclipbox do
                    begin
                      if not clipbox[i].empty then
                      begin
                        field_inc_ndim(clipbox[i], f);
                        field_insert(clipboxlist, f, clipboxlist, 0, i-1);
                        clipboxlist.setvalue([i-1, 6], 1);
                        cbweights[i] :=1;
                        end;
                    end;
                    updateviewernamelabels() ;
                    f.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_159()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updateactiveclipbox(sender: tobject; var unchanged: boolean);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_160()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.update_mask_cog(sender: tobject; var unchanged: boolean);
                  var
                    s: string;
                    x, y, z: single;
                    k : integer;
                    mskdref,msk : tavsfield;
                  begin
                    k := 1;
                    mskdref := maskedreference;
                    if mskdref.empty or ((mskdref.mean=0) and (mskdref.standarddeviation=0)) then
                    begin
                      mask_cog[k].coordinate[0,0] := -9999;
                      mask_cog[k].coordinate[1,0] := -9999;
                      mask_cog[k].coordinate[2,0] := -9999;
                      exit;
                    end;
                    msk := tavsfield.create;
                    field_gtec(mskdref, msk, 1);
                    field_center(msk,x,y,z,s);
                    mask_cog[k].coordinate[0,0] := x;
                    mask_cog[k].coordinate[1,0] := y;
                    mask_cog[k].coordinate[2,0] := z;
                    dotxfm(mask_cog[k], maskedreferencetransform, mask_cog[k]);
                    msk.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_161()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updateviewtransform(sender: tobject; var unchanged: boolean);
                  var f: tavsfield;
                  begin
                    f := online_to_machine;
                    if tavsfield(sender)=quirtviewerupdcoronal.viewtransform then
                      f := quirtviewerupdcoronal.transform[1];
                    if tavsfield(sender)=quirtviewerupdsagittal.viewtransform then
                      f := quirtviewerupdsagittal.transform[1];
                    if tavsfield(sender)=quirtviewerupdtransversal.viewtransform then
                      f := quirtviewerupdtransversal.transform[1];
                    eulerxfm(sender as tavsfield, 270, 0, 270, 0, 0, 0);
                    if online[1].data.ndim\<\>2 then
                      f := (sender as tavsfield);
                    if f.empty then
                    begin
                      eulerxfm(sender as tavsfield, 270, 0, 270, 0, 0, 0);
                      transform_math((sender as tavsfield), nil, (sender as tavsfield), false, false, true);
                      exit;
                    end;
                    if reversemotion.value\<\>0 then transform_math(f, nil, (sender as tavsfield), false, false, true)
                    else                           transform_math(f, machine_to_machineadjust, (sender as tavsfield), false, false, true);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_162()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updatetrackershapetransform(sender: tobject;
                    var unchanged: boolean);
                  begin
                    if reference_to_patient.empty then
                    begin
                      quirtviewerupdcoronal.trackershapetransform.clear;
                      exit;
                    end;
                    transform_math(reference_to_patient, reference_to_siddon, quirtviewerupdcoronal.trackershapetransform, true);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_163()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updatemachine_to_machineadjust(sender: tobject; var unchanged: boolean);
                  var t, s: tavsfield;
                      r, f, i: integer;
                      count: single;
                  begin
                    f := quirtviewerupdcoronal.frame.value;
                    if      alignmentmode.value = 0 then r := activeregion.value
                    else if alignmentmode.value = 1 then r := nclipbox+maskactiveregion.value
                    else if alignmentmode.value in [2,3,4] then begin r := 2*nclipbox; f:=0; end
                    else r := -1;
                    if r\<0 then
                    begin
                     if quirtviewerupdcoronal.activeclipbox.newerthan(machine_to_machineadjust) then
                     begin
                       unchanged := true;
                       exit;
                     end
                     else
                       r := 0;
                    end;
                    if r\>=transform4d.dimensions[2] then r := 0;
                    if f\<0 then f := 0;
                    if f\>=transform4d.dimensions[3] then f := 0;
                    case transformdisplaymode.value of
                      0: unchanged := true;
                      1: begin
                           if transform4d.empty then exit;
                           t := tavsfield.create;
                           field_slice(transform4d, t, -1, -1, r, f);
                           if t.getvalue([3,3])\>0.99 then
                             field_copy(t, machine_to_machineadjust)
                           else
                             machine_to_machineadjust.makeidentity;
                           t.free;
                         end;
                      2: eulerxfm(machine_to_machineadjust);
                      3: begin
                           if transform4d.empty then exit;
                           t := tavsfield.create;
                           field_slice(transform4d, t, -1, -1, r, f);
                           if t.getvalue([3,3])\>0.99 then
                             field_copy(t, machine_to_machineadjust)
                           else
                             machine_to_machineadjust.makeidentity;
                           t.free;
                         end;
                      4: begin
                           if transform4d.empty then exit;
                           t := tavsfield.create;
                           s := tavsfield.createas(\'field 2d float\', [4, 4]);
                           count := 0;
                           for i:=0 to max(transform4d.dimensions[3]-1, 0) do
                           begin
                             field_slice(transform4d, t, -1, -1, r, i);
                             if t.getvalue([3,3])\>0.99 then
                             begin
                               if not phasehist.empty then field_mulc(t, t, phasehist.getvalue([i]));
                               field_add(t, s, s);
                               if not phasehist.empty then count := count + phasehist.getvalue([i])
                               else                        count := count + 1;
                             end;
                           end;
                           if count\>0 then
                             field_divc(s, machine_to_machineadjust, count)
                           else
                             machine_to_machineadjust.makeidentity;
                           t.free;
                           s.free;
                         end;
                      5: eulerxfm(machine_to_machineadjust);
                      6: eulerxfm(machine_to_machineadjust);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_164()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updatesagitaltext2(sender: tobject; var unchanged: boolean);
                  var r, f: integer;
                      s: string;
                  begin
                    f := quirtviewerupdcoronal.frame.value;
                    if      alignmentmode.value = 0 then r := activeregion.value
                    else if alignmentmode.value = 1 then r := nclipbox+maskactiveregion.value
                    else if alignmentmode.value in [2,3,4] then begin r := 2*nclipbox; f:=0; end
                    else r := -1;
                    if r\<0 then r := 0;
                    if not transform4d.empty then
                      if r\>=transform4d.dimensions[2] then r := 0;
                    if f\<0 then f := 0;
                    if f\>=transform4d.dimensions[3] then f := 0;
                    if referencecube.empty then
                    begin
                      quirtviewerupdsagittal.text[2].value := \'\';
                      exit;
                    end;
                    case transformdisplaymode.value of
                      0: quirtviewerupdsagittal.text[2].value := \'\';
                      1: begin
                           quirtviewerupdsagittal.text[2].value := \'\';
                           if transform4d.empty and (avlstate\<\>1) then exit;
                           if (transform4d.getvalue([f,r,3,3])\>0.99) or (avlstate=1) then
                           begin
                             if r\<nclipbox then        s:=displaytransform_clipbox
                             else if r\<2*nclipbox then s:=displaytransform_mask
                             else                      s:=displaytransform_correction;
                             if (onlinecube.ndim\>3) and (s\<\>displaytransform_correction) then
                               quirtviewerupdsagittal.text[2].value := format(displaytransform_reg2, [s, f])
                             else
                               quirtviewerupdsagittal.text[2].value := format(displaytransform_reg1, [s]);
                           end;
                         end;
                      2: quirtviewerupdsagittal.text[2].value :=  displaytransform_deform;
                      3: quirtviewerupdsagittal.text[2].value :=  displaytransform_correction2;
                      4: begin
                           if r\<nclipbox then        s:=displaytransform_clipbox
                           else if r\<2*nclipbox then s:=displaytransform_mask
                           else                      s:=displaytransform_correction;
                           quirtviewerupdsagittal.text[2].value :=  format(displaytransform_avg4dfor, [s]);
                         end;
                      5: quirtviewerupdsagittal.text[2].value :=  text_warpandaverage;
                      6: quirtviewerupdsagittal.text[2].value :=  displaytransform_extwarp;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_165()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updatemachine_to_machineadjustwarpi(sender: tobject; var unchanged: boolean);
                  var p1, p2, t, c, s: tavsfield;
                      i, j, f, nclip, eq: integer;
                      count: extended;
                      begin
                    case transformdisplaymode.value of
                      0: machine_to_machineadjustwarpi.clear;
                      1: machine_to_machineadjustwarpi.clear;
                      2: if not transform4d.empty then
                         begin
                           clipboxlist.make;
                           f := max(quirtviewerupdcoronal.frame.value, 0);
                           nclip := 0;
                           p1 := tavsfield.createas(\'field 1d 3-space irregular\', [nclipbox * 10]);
                           p2 := tavsfield.createas(\'field 1d 3-space irregular\', [nclipbox * 10]);
                           t  := tavsfield.create;
                           c  := tavsfield.createas(\'field 1d 3-space irregular\', [6]);
                           for i:=1 to nclipbox do
                           begin
                             if i-1 \>= transform4d.dimensions[2] then continue;
                             if f   \>= transform4d.dimensions[3] then continue;
                             field_slice(transform4d, t, -1, -1, i-1, f);
                             if t.getvalue([3,3])\<0.99 then continue;
                             c.coordinate[0, 0] :=  clipboxlist.getvalue([i-1, 0]);
                             c.coordinate[1, 0] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 0] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 1] :=  clipboxlist.getvalue([i-1, 1]);
                             c.coordinate[1, 1] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 1] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 2] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 2] :=  clipboxlist.getvalue([i-1, 2]);
                             c.coordinate[2, 2] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 3] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 3] :=  clipboxlist.getvalue([i-1, 3]);
                             c.coordinate[2, 3] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 4] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 4] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 4] :=  clipboxlist.getvalue([i-1, 4]);
                             c.coordinate[0, 5] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 5] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 5] :=  clipboxlist.getvalue([i-1, 5]);
                             field_insert(p1, c, p1, nclip*6, 0, 0, field_insert_coord);
                             dotxfm(c, t, c);
                             field_insert(p2, c, p2, nclip*6, 0, 0, field_insert_coord);
                             inc(nclip);
                           end;
                           if (nclip=0) then exit;
                           field_crop(p1, p1, 0, nclip*6-1);
                           field_crop(p2, p2, 0, nclip*6-1);
                           field_create(machine_to_machineadjustwarpi, \'field 3d 3-vector uniform float\', 100, 100, 100);
                           field_croptogrid(machine_to_machineadjustwarpi, p1, machine_to_machineadjustwarpi, 3);
                           thin_plate(p2, p1, machine_to_machineadjustwarpi, machine_to_machineadjustwarpi);
                           p1.free;
                           p2.free;
                           t.free;
                           c.free;
                           end;
                      3: machine_to_machineadjustwarpi.clear;
                      4: machine_to_machineadjustwarpi.clear;
                      5: if not transform4d.empty then
                         begin
                           clipboxlist.make;
                           nclip := 0;
                           p1 := tavsfield.createas(\'field 1d 3-space irregular\', [nclipbox * 10]);
                           p2 := tavsfield.createas(\'field 1d 3-space irregular\', [nclipbox * 10]);
                           t  := tavsfield.create;
                           c  := tavsfield.createas(\'field 1d 3-space irregular\', [6]);
                           s  := tavsfield.create;
                           for i:=1 to nclipbox do
                           begin
                             if i-1 \>= transform4d.dimensions[2] then continue;
                             field_create(s, \'field 2d float\', 4, 4);
                             count := 0;
                             for j:=0 to max(transform4d.dimensions[3]-1, 0) do
                             begin
                               field_slice(transform4d, t, -1, -1, i-1, j);
                               if t.getvalue([3,3])\>0.99 then
                               begin
                                 if not phasehist.empty then field_mulc(t, t, phasehist.getvalue([i]));
                                 field_add(t, s, s);
                                 if not phasehist.empty then count := count + phasehist.getvalue([i])
                                 else                        count := count + 1;
                               end;
                             end;
                             if count\>0 then field_divc(s, t, count);
                             if count=0 then continue;
                             c.coordinate[0, 0] :=  clipboxlist.getvalue([i-1, 0]);
                             c.coordinate[1, 0] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 0] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 1] :=  clipboxlist.getvalue([i-1, 1]);
                             c.coordinate[1, 1] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 1] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 2] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 2] :=  clipboxlist.getvalue([i-1, 2]);
                             c.coordinate[2, 2] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 3] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 3] :=  clipboxlist.getvalue([i-1, 3]);
                             c.coordinate[2, 3] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 4] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 4] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 4] :=  clipboxlist.getvalue([i-1, 4]);
                             c.coordinate[0, 5] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 5] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 5] :=  clipboxlist.getvalue([i-1, 5]);
                             field_insert(p1, c, p1, nclip*6, 0, 0, field_insert_coord);
                             dotxfm(c, t, c);
                             field_insert(p2, c, p2, nclip*6, 0, 0, field_insert_coord);
                             inc(nclip);
                           end;
                           if nclip=0 then exit;
                           field_crop(p1, p1, 0, nclip*6-1);
                           field_crop(p2, p2, 0, nclip*6-1);
                           field_create(machine_to_machineadjustwarpi, \'field 3d 3-vector uniform float\', 100, 100, 100);
                           field_croptogrid(machine_to_machineadjustwarpi, p1, machine_to_machineadjustwarpi, 3);
                           thin_plate(p2, p1, machine_to_machineadjustwarpi, machine_to_machineadjustwarpi);
                           p1.free;
                           p2.free;
                           t.free;
                           c.free;
                           s.free;
                           end;
                      6: begin
                           field_compare_data(externalwarp, machine_to_machineadjustwarpi, eq);
                           if eq\<\>0 then unchanged := true;
                           if not unchanged then
                             machine_to_machineadjustwarpi.assign(externalwarp);
                         end;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_166()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updateviewwarp(sender: tobject; var unchanged: boolean);
                  var s: string;
                  begin
                    viewwarp.locked := false;
                    viewwarp.clear;
                    if (transformdisplaymode.value in [2, 5, 6]) and (reversemotion.value=0) then
                    begin
                      warp_math(machine_to_machineadjustwarpi, nil, viewwarp, false, false, false, s);
                      viewwarp.locked := true;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_167()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.unpackregistration(region, frame: integer; var stx, sty, stz, srx, sry, srz, r: string; rel: boolean=false; relc: boolean=false; isocentric: boolean=true): integer;
                  const
                    epsilon: single = 1e-3;
                  var
                    s, t, u, v, mn, mx, ur, vr, wr, mnr, mxr: tavsfield;
                    tx, ty, tz, rx, ry, rz: single;
                    clipboxes, i, f1, f2, j, k, r1, r2: integer;
                    strdummy: string;
                    count, countr: double;
                    g: tcolorstringgrid;
                    nexhale: integer;
                    crp : tavsfield;
                    ttr : ttransform;
                    x,y,z : single;
                    multiclip : boolean;
                    procedure unpackregistrationfreefields;
                    begin
                      s.free;
                      t.free;
                      u.free;
                      v.free;
                      mn.free;
                      mx.free;
                      ur.free;
                      vr.free;
                      wr.free;
                      mnr.free;
                      mxr.free;
                      crp.free;
                      ttr.free;
                    end;
                  begin
                    stx := \'\';
                    sty := \'\';
                    stz := \'\';
                    srx := \'\';
                    sry := \'\';
                    srz := \'\';
                    r   := \'\';
                    result := 0;
                    clipboxes := 0;
                    if transform4d.empty then exit;
                    s := tavsfield.create;
                    t := tavsfield.create;
                    u := tavsfield.create;
                    v := tavsfield.create;
                    mn:= tavsfield.create;
                    mx:= tavsfield.create;
                    ur := tavsfield.create;
                    vr := tavsfield.create;
                    wr := tavsfield.create;
                    mnr:= tavsfield.create;
                    mxr:= tavsfield.create;
                    crp := tavsfield.create;
                    ttr := ttransform.create;
                    if rel then
                    begin
                      field_copy(machine_to_machineadjust, s);
                      if s.getvalue([3, 3])\<0.99 then
                      begin
                        unpackregistrationfreefields;
                        exit;
                      end;
                      transform_math(s, nil, s, true);
                      euler_componen2(s, s, strdummy, 0.001, 6);
                      field_mulc(s, s, -1);
                      s.setvalue([0],  -s.getvalue([0]));
                      s.setvalue([1],  -s.getvalue([1]));
                      s.setvalue([2],  -s.getvalue([2]));
                    end;
                    if relc then
                    begin
                      field_slice(transform4d, s, -1, -1, nclipbox*2, 0);
                      if s.getvalue([3, 3])\<0.99 then
                      begin
                        unpackregistrationfreefields;
                        exit;
                      end;
                      transform_math(s, nil, s, true);
                      euler_componen2(s, s, strdummy, 0.001, 6);
                      field_mulc(s, s, -1);
                      s.setvalue([0],  -s.getvalue([0]));
                      s.setvalue([1],  -s.getvalue([1]));
                      s.setvalue([2],  -s.getvalue([2]));
                    end;
                    r1 := region;
                    r2 := r1;
                    if r1\<0 then
                    begin
                      if r1\>-10 then
                      begin
                        clipboxes := 0;
                        for i:=1 to nclipbox do
                          if not clipbox[i].empty then inc(clipboxes) else break;
                        r1 := 0;
                        r2:=clipboxes-1;
                      end
                      else
                      begin
                        r1 := nclipbox;
                        r2 := r1;
                      end;
                    end;
                    k :=0;
                    for i:=1 to nclipbox do
                      if (clipboxlist.getvalue([i-1, 6])\<\>0) then k := k + 1;
                    multiclip := k\>1;
                    f1 := frame;
                    f2 := f1;
                    if f1\<0 then
                    begin f1 := 0; f2:=max(transform4d.dimensions[3]-1, 0); end;
                    countr := 0;
                    for j:=r1 to r2 do
                    begin
                      count := 0;
                      for i:=f1 to f2 do
                      begin
                        field_slice(transform4d, t, -1, -1, j, i);
                        if t.getvalue([3, 3])\<0.99 then continue;
                        if frame=-5 then
                        begin
                          nexhale := onlinecube.dimensions[3] div 8;
                          if (comboboxcorrectionprotocol.text = correction_from_mask_exh) then
                            if (i\>nexhale) and (i\<onlinecube.dimensions[3]-nexhale) then continue;
                        end;
                        ttr.assign(t);
                        field_copy(correctionreferencepoint, crp);
                        if (not isocentric) and ( (multiclip) or (comboboxcorrectionprotocol.text \<\> correction_from_clipbox) ) then
                        begin
                          if (j\<nclipbox) and (not clipbox[j+1].empty) then
                          begin
                            crp.coordinate[0,0] := (clipbox[j+1].getvalue([0]) + clipbox[j+1].getvalue([1]))/2;
                            crp.coordinate[1,0] := (clipbox[j+1].getvalue([2]) + clipbox[j+1].getvalue([3]))/2;
                            crp.coordinate[2,0] := (clipbox[j+1].getvalue([4]) + clipbox[j+1].getvalue([5]))/2;
                          end;
                        end
                        else if (not isocentric) and ( comboboxcorrectionprotocol.text = correction_from_clipbox) then
                        begin
                          if (j=nclipbox) then
                          begin
                            mask_cog[1].make;
                            if mask_cog[1].coordinate[0,0] \> -9998 then
                            begin
                              crp.coordinate[0,0] := mask_cog[1].coordinate[0,0];
                              crp.coordinate[1,0] := mask_cog[1].coordinate[1,0];
                              crp.coordinate[2,0] := mask_cog[1].coordinate[2,0];
                            end;
                          end
                        end;
                        tr2t(ttr,crp);
                        ttr.gettranslation(x,y,z);
                        transform_math(t, nil, t, true);
                        euler_componen2(t, t, strdummy, 0.001, 6);
                        field_mulc(t, t, -1);
                        if isocentric then
                        begin
                          t.setvalue([0],  -t.getvalue([0]));
                          t.setvalue([1],  -t.getvalue([1]));
                          t.setvalue([2],  -t.getvalue([2]));
                        end
                        else
                        begin
                          t.setvalue([0],  x);
                          t.setvalue([1],  y);
                          t.setvalue([2],  z);
                        end;
                        if not s.empty then
                        begin
                          field_sub(s, t, t);
                          if relc then field_mulc(t, t, -1);
                        end;
                        if frame\<0 then
                        begin
                          if mn.empty then field_copy(t, mn) else field_min(t,mn,mn);
                          if mx.empty then field_copy(t, mx) else field_max(t,mx,mx);
                          if not phasehist.empty then
                          begin
                            field_mulc(t, t, phasehist.getvalue([i]));
                            count := count + phasehist.getvalue([i]);
                          end
                          else
                            count := count + 1;
                          if u.empty  then field_copy(t,  u) else field_add(t, u, u);
                          field_sqr(t, t);
                          if not phasehist.empty then field_divc(t, t, phasehist.getvalue([i]));
                          if v.empty then  field_copy(t,  v) else field_add(t, v, v);
                        end
                        else
                          count := 1;
                      end;
                      if count\<0.0001 then continue;
                      if (frame=-1) or (frame=-5) then
                        field_divc(u, t, count)
                      else if frame=-2 then
                      begin
                        field_sqr(u, u);
                        field_divc(u, u, count);
                        field_sub(v, u, t);
                        field_divc(t, t, count*(f2-f1)/(f2-f1+1));
                        field_sqrt(t, t);
                      end
                      else if frame=-3 then
                        field_sub(mx, mn, t)
                      else if frame=-4 then
                      begin
                        for k:=0 to t.dimensions[0]-1 do
                        begin
                          if (abs(mn.getvalue1d(k))\>abs(mx.getvalue1d(k))) then
                            t.setvalue([k],mn.getvalue1d(k))
                          else
                            t.setvalue([k],mx.getvalue1d(k));
                        end;
                      end;
                      if region\<0 then
                      begin
                        if mnr.empty then field_copy(t, mnr) else field_min(t,mnr,mnr);
                        if mxr.empty then field_copy(t, mxr) else field_max(t,mxr,mxr);
                        if (j\<nclipbox) and (clipboxes\>1) then countr := countr + clipboxlist.getvalue([j, 6])
                        else               countr := countr + 1;
                        if ur.empty  then field_copy(t,  ur) else field_add(t, ur, ur);
                        field_sqr(t, t);
                        if j\<nclipbox then field_divc(t, t, clipboxlist.getvalue([j, 6]));
                        if vr.empty then  field_copy(t,  vr) else field_add(t, vr, vr);
                      end
                      else
                        countr := 1;
                      u.clear;
                      v.clear;
                    end;
                    if countr\<0.0001 then
                    begin
                      unpackregistrationfreefields;
                      exit;
                    end;
                    if region=-1 then
                      field_divc(ur, t, countr)
                    else if region=-2 then
                    begin
                      field_sqr(ur, ur);
                      field_divc(ur, ur, countr);
                      field_sub(vr, ur, t);
                      field_divc(t, t, countr);
                      field_sqrt(t, t);
                    end
                    else if region=-3 then
                      field_sub(mxr, mnr, t)
                    else if region=-4 then
                    begin
                      for k:=0 to t.dimensions[0]-1 do
                      begin
                        if (abs(mnr.getvalue1d(k))\>abs(mxr.getvalue1d(k))) then
                          t.setvalue([k],mnr.getvalue1d(k))
                        else
                          t.setvalue([k],mxr.getvalue1d(k));
                      end;
                    end;
                    tx := t.getvalue([0]);
                    ty := t.getvalue([1]);
                    tz := t.getvalue([2]);
                    rx := t.getvalue([9]);
                    ry := t.getvalue([10]);
                    rz := t.getvalue([11]);
                    stx := floattostrf(tx, fffixed, 5, 2);
                    sty := floattostrf(ty, fffixed, 5, 2);
                    stz := floattostrf(tz, fffixed, 5, 2);
                    if not iec_angle_convention then
                    begin
                      srx := floattostrf(rx, fffixed, 5, 1);
                      sry := floattostrf(ry, fffixed, 5, 1);
                      srz := floattostrf(rz, fffixed, 5, 1);
                    end
                    else
                    begin
                      if rx\>-0.005 then srx := floattostrf( rx, fffixed, 5, 1)
                      else              srx := floattostrf( rx + 360, fffixed, 5, 1);
                      if ry\>-0.005 then sry := floattostrf( ry, fffixed, 5, 1)
                      else              sry := floattostrf( ry + 360, fffixed, 5, 1);
                      if rz\>-0.005 then srz := floattostrf( rz, fffixed, 5, 1)
                      else              srz := floattostrf( rz + 360, fffixed, 5, 1);
                    end;
                    if region\<nclipbox then
                      g := colorstringgrid2
                    else
                      g := colorstringgrid3;
                    result :=
                      $001*ord((tx+epsilon)\<safestrtofloat(g.cells[1,1]))+
                      $002*ord((tx-epsilon)\>safestrtofloat(g.cells[2,1]))+
                      $004*ord((ty+epsilon)\<safestrtofloat(g.cells[1,2]))+
                      $008*ord((ty-epsilon)\>safestrtofloat(g.cells[2,2]))+
                      $010*ord((tz+epsilon)\<safestrtofloat(g.cells[1,3]))+
                      $020*ord((tz-epsilon)\>safestrtofloat(g.cells[2,3]))+
                      $040*ord((rx+epsilon)\<safestrtofloat(g.cells[1,5]))+
                      $080*ord((rx-epsilon)\>safestrtofloat(g.cells[2,5]))+
                      $100*ord((ry+epsilon)\<safestrtofloat(g.cells[1,6]))+
                      $200*ord((ry-epsilon)\>safestrtofloat(g.cells[2,6]))+
                      $400*ord((rz+epsilon)\<safestrtofloat(g.cells[1,7]))+
                      $800*ord((rz-epsilon)\>safestrtofloat(g.cells[2,7]));
                    if comboboxregistrationprotocol.itemindex\<2 then
                      result := 0;
                    r := format(\'%s, %s, %s, %s, %s, %s\', [stx, sty, stz, srx, sry, srz]);
                    unpackregistrationfreefields;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_168()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.comboboxsummarytypechange(sender: tobject);
                  begin
                    colorstringgridsummaryupd.forceupdate;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_169()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.overviewchartgetpointerstyle(sender: tchartseries; valueindex: integer): tseriespointerstyle;
                  begin
                    if (valueindex = (sender as tlineseries).count-2) then
                    begin
                      (sender as tlineseries).pointer.pen.visible := false;
                      (sender as tlineseries).pointer.brush.style := bsclear;
                    end;
                    result := (sender as tlineseries).pointer.style;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_170()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.overviewchartgetlegendpos(sender: tcustomchart; index: integer; var x, y, xcolor: integer);
                  var
                    i: integer;
                  begin
                    for i:=0 to 5 do
                    begin
                      (sender.series[i] as tlineseries).pointer.brush.style := bssolid;
                      (sender.series[i] as tlineseries).pointer.brush.color := (sender.series[i] as tlineseries).seriescolor;
                      (sender.series[i] as tlineseries).pointer.pen.visible := true;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_171()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updatesummary;
                  var k, j, p: integer;
                      dx, dy, dz, drx, dry, drz, s: string;
                      relc, i4d, i4dclp, i4dmsk: boolean;
                      phase: double;
                      isoc : boolean;
                      locsubstr : string;
                      i, col: integer;
                      val, ll, hl: double;
                  begin
                    relc       := (comboboxsummarytype.text=summary_residuals) or (comboboxsummarytype.text=summary_limits);
                    col := 255;
                    if not assigned(colorstringgridsummaryupd) then
                      colorstringgridsummaryupd := tupdatable.create(bad);
                    if colorstringgridsummary.visible and transform4d.newerthan(colorstringgridsummaryupd) then
                    begin
                      i4dclp :=false;
                      for k:=1 to nclipbox do
                      begin
                        if i4dclp then break;
                        unpackregistration(k-1, -3, dx, dy, dz, drx, dry, drz, s, false, relc);
                        if s\<\>\'\' then
                          i4dclp := strtofloat(dx) + strtofloat(dy) + strtofloat(dz) + strtofloat(drx) + strtofloat(dry) + strtofloat(drz) \<\> 0;
                      end;
                      i4dmsk :=false;
                      for k:=nclipbox+1 to 2*nclipbox do
                      begin
                        if i4dmsk then break;
                        unpackregistration(k-1, -3, dx, dy, dz, drx, dry, drz, s, false, relc);
                        if s\<\>\'\' then
                          i4dmsk := strtofloat(dx) + strtofloat(dy) + strtofloat(dz) + strtofloat(drx) + strtofloat(dry) + strtofloat(drz) \<\> 0;
                      end;
                      i4d := i4dclp or i4dmsk;
                      if i4d then
                      begin
                        quirtviewerupdtransversal.visible := false;
                        if not assigned(chart) then
                        begin
                          chart := tchart.create(self);
                          for j:=0 to 5 do
                            chart.addseries(tlineseries.create(self));
                          for j:=0 to 2 do
                            chart.addseries(tpointseries.create(self));
                        end;
                        chart.parent := quirtviewerupdtransversal.parent;
                        chart.left := quirtviewerupdtransversal.left;
                        chart.top := quirtviewerupdtransversal.top;
                        chart.width := quirtviewerupdtransversal.width;
                        chart.height := quirtviewerupdtransversal.height;
                        chart.visible := true;
                        chart.view3d := false;
                        chart.allowzoom := false;
                        chart.allowpanning := pmvertical;
                        chart.undozoom;
                        chart.bottomaxis.automatic := false;
                        chart.bottomaxis.minimum :=  0;
                        chart.bottomaxis.maximum :=  onlinecube.dimensions[3];
                        chart.clippoints := false;
                        chart.ongetlegendpos := overviewchartgetlegendpos;
                        for j:=0 to 8 do
                        begin
                          chart.serieslist[j].clear;
                          chart.serieslist[j].active := false;
                        end;
                        for j:=0 to 5 do
                        begin
                          (chart.serieslist[j] as tlineseries).pointer.visible := true;
                          (chart.serieslist[j] as tlineseries).pointer.pen.color := clblack;
                          (chart.serieslist[j] as tlineseries).pointer.pen.visible := true;
                          (chart.serieslist[j] as tlineseries).ongetpointerstyle := overviewchartgetpointerstyle;
                          (chart.serieslist[j] as tlineseries).xvalues.order := lonone;
                          (chart.serieslist[j] as tlineseries).treatnulls:=tndontpaint;
                          if j\<3 then
                          begin
                            (chart.serieslist[j] as tlineseries).pointer.vertsize := 4;
                            (chart.serieslist[j] as tlineseries).pointer.horizsize := 4;
                            (chart.serieslist[j] as tlineseries).linepen.width := 3;
                            (chart.serieslist[j] as tlineseries).pointer.style := pscircle;
                          end
                          else
                          begin
                            (chart.serieslist[j] as tlineseries).pointer.vertsize := 5;
                            (chart.serieslist[j] as tlineseries).pointer.horizsize := 5;
                            (chart.serieslist[j] as tlineseries).linepen.width := 2;
                            (chart.serieslist[j] as tlineseries).pointer.style := psdiamond;
                            (chart.serieslist[j] as tlineseries).linepen.style := psdot;
                          end;
                        end;
                        chart.serieslist[0].title := chart_legendtxmask;
                        chart.serieslist[1].title := chart_legendtymask;
                        chart.serieslist[2].title := chart_legendtzmask;
                        chart.serieslist[3].title := chart_legendtxclipbox;
                        chart.serieslist[4].title := chart_legendtyclipbox;
                        chart.serieslist[5].title := chart_legendtzclipbox;
                        chart.serieslist[6].title := chart_legendtxcorr;
                        chart.serieslist[7].title := chart_legendtycorr;
                        chart.serieslist[8].title := chart_legendtzcorr;
                        chart.serieslist[3].seriescolor := chart.serieslist[0].seriescolor;
                        chart.serieslist[4].seriescolor := chart.serieslist[1].seriescolor;
                        chart.serieslist[5].seriescolor := chart.serieslist[2].seriescolor;
                        chart.serieslist[6].seriescolor := chart.serieslist[0].seriescolor;
                        chart.serieslist[7].seriescolor := chart.serieslist[1].seriescolor;
                        chart.serieslist[8].seriescolor := chart.serieslist[2].seriescolor;
                        if phasehist.empty then
                          chart.bottomaxis.title.caption := chart_captionframes
                        else
                          chart.bottomaxis.title.caption := chart_captionphase;
                        if relc then
                          chart.leftaxis.title.caption := chart_captionresidual
                        else
                          chart.leftaxis.title.caption := chart_captiondisplacement;
                        chart.leftaxis.automatic := false;
                        chart.leftaxis.minimum := -2.5;
                        chart.leftaxis.maximum := 2.5;
                      end
                      else
                      begin
                        quirtviewerupdtransversal.visible := true;
                        if assigned(chart) then chart.visible := false;
                      end;
                      colorstringgridsummaryupd.hasnewvalue;
                      for k := 0 to colorstringgridsummary.colcount-1 do
                        for j := 0 to colorstringgridsummary.rowcount-1 do
                        begin
                          colorstringgridsummary.cells[k,j] := \'\';
                          if k\>0 then colorstringgridsummary.cellprops[k,j].color := 0;
                        end;
                      colorstringgridsummary.defaultcolwidth := round(55*abs(form1.font.height)/11);
                      colorstringgridsummary.colwidths[0] := round(100*abs(form1.font.height)/11);
                      colorstringgridsummary.colcount := 7;
                      colorstringgridsummary.rowcount := 1;
                      colorstringgridsummary.cells[1, 0] := grid_tx;
                      colorstringgridsummary.cells[2, 0] := grid_ty;
                      colorstringgridsummary.cells[3, 0] := grid_tz;
                      colorstringgridsummary.cells[4, 0] := grid_rx;
                      colorstringgridsummary.cells[5, 0] := grid_ry;
                      colorstringgridsummary.cells[6, 0] := grid_rz;
                      for isoc:=false to true do
                      begin
                        if not isoc then
                         locsubstr := grid_local
                        else
                         locsubstr := \'\';
                        for k:=1 to nclipbox do
                        begin
                          unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc);
                          if s\<\>\'\' then
                          begin
                            if not i4dclp then
                            begin
                              unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if s\<\>\'\' then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + locsubstr;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                    unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, true, false);
                                for i := 1 to 6 do
                                begin
                                  hl  := safestrtofloat(colorstringgrid2.cells[2,i+ord(i\>3)]);
                                  ll  := safestrtofloat(colorstringgrid2.cells[1,i+ord(i\>3)]);
                                  case i of
                                    1 : val := safestrtofloat(dx);
                                    2 : val := safestrtofloat(dy);
                                    3 : val := safestrtofloat(dz);
                                    4 : val := safestrtofloat(drx);
                                    5 : val := safestrtofloat(dry);
                                    6 : val := safestrtofloat(drz);
                                    else
                                      val := min(hl,ll);
                                  end;
                                  if (val \> hl) or (val \< ll) then
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := col
                                  else
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := 0;
                                end;
                    if comboboxsummarytype.text=summary_limits then
                                begin
                                  colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                      colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_limit1;
                      colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,1];
                                  colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,2];
                                  colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,3];
                                  colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,5];
                                  colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,6];
                                  colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,7];
                                  colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                      colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_limit2;
                      colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,1];
                                  colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,2];
                                  colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,3];
                                  colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,5];
                                  colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,6];
                                  colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,7];
                                end;
                                if isoc and assigned(chart) and chart.visible then
                                begin
                                  unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                                  chart.serieslist[3].addxy(0, strtofloat(dx));
                                  chart.serieslist[4].addxy(0, strtofloat(dy));
                                  chart.serieslist[5].addxy(0, strtofloat(dz));
                                  chart.serieslist[3].addxy(0.5, strtofloat(dx));
                                  chart.serieslist[4].addxy(0.5, strtofloat(dy));
                                  chart.serieslist[5].addxy(0.5, strtofloat(dz));
                                  chart.serieslist[3].active := true;
                                  chart.serieslist[4].active := true;
                                  chart.serieslist[5].active := true;
                               end;
                              end;
                            end
                            else
                            begin
                              unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if s\<\>\'\' then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_mean + locsubstr;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                    unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, true, false);
                                for i := 1 to 6 do
                                begin
                                  hl  := safestrtofloat(colorstringgrid2.cells[2,i+ord(i\>3)]);
                                  ll  := safestrtofloat(colorstringgrid2.cells[1,i+ord(i\>3)]);
                                  case i of
                                    1 : val := safestrtofloat(dx);
                                    2 : val := safestrtofloat(dy);
                                    3 : val := safestrtofloat(dz);
                                    4 : val := safestrtofloat(drx);
                                    5 : val := safestrtofloat(dry);
                                    6 : val := safestrtofloat(drz);
                                    else
                                      val := min(hl,ll);
                                  end;
                                  if (val \> hl) or (val \< ll) then
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := col
                                  else
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := 0;
                                end;
                              end;
                    unpackregistration(k-1, -5, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if (s\<\>\'\')  and
                                 (comboboxcorrectionprotocol.text = correction_from_mask_exh)
                                 then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_exhale + locsubstr;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              unpackregistration(k-1, -2, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                              if isoc and (s\<\>\'\') and (comboboxsummarytype.text\<\>summary_limits) then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_sd;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              unpackregistration(k-1, -3, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                              if isoc and (s\<\>\'\') and (comboboxsummarytype.text\<\>summary_limits) then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_a;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              if comboboxsummarytype.text=summary_limits then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_limit1;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,5];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,6];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,7];
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_limit2;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,4];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,5];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,6];
                              end;
                              for j:=0 to max(transform4d.dimensions[3]-1, 0) do
                              begin
                                unpackregistration(k-1, j, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                                if s\<\>\'\' then
                                begin
                                  if comboboxsummarytype.text=summary_details then
                                  begin
                                    colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + \';\' + grid_frame + inttostr(j) + locsubstr;
                    colorstringgridsummary.colcount := 8;
                                    colorstringgridsummary.cells[7, 0] := grid_weight;
                                    colorstringgridsummary.cells[7, colorstringgridsummary.rowcount-1] := format(\'%.1f\', [phasehist.getvalue([j])*100.0]);
                                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                    colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                    colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                    colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                    colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                    colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                                  end;
                                  if isoc and assigned(chart) and chart.visible then
                                  begin
                                    if phasehist.empty then
                                    begin
                                      chart.serieslist[3].add(strtofloat(dx));
                                      chart.serieslist[4].add(strtofloat(dy));
                                      chart.serieslist[5].add(strtofloat(dz));
                                    end
                                    else
                                    begin
                                      if (k\>1) and (j=0) then
                                      begin
                                        chart.serieslist[3].addnullxy(0,0);
                                        chart.serieslist[4].addnullxy(0,0);
                                        chart.serieslist[5].addnullxy(0,0);
                                      end;
                                      phase := 0;
                                      for p:=0 to j-1 do phase := phase + phasehist.getvalue([p]);
                                      chart.serieslist[3].addxy(phase * transform4d.dimensions[3], strtofloat(dx));
                                      chart.serieslist[4].addxy(phase * transform4d.dimensions[3], strtofloat(dy));
                                      chart.serieslist[5].addxy(phase * transform4d.dimensions[3], strtofloat(dz));
                                    end;
                                    chart.serieslist[3].active := true;
                                    chart.serieslist[4].active := true;
                                    chart.serieslist[5].active := true;
                                  end;
                                end;
                              end;
                              if isoc and assigned(chart) and chart.visible and i4dclp then
                              begin
                                unpackregistration(k-1, 0, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                                chart.serieslist[3].addxy(transform4d.dimensions[3], strtofloat(dx));
                                chart.serieslist[4].addxy(transform4d.dimensions[3], strtofloat(dy));
                                chart.serieslist[5].addxy(transform4d.dimensions[3], strtofloat(dz));
                              end;
                            end
                          end
                        end;
                        for k:=nclipbox+1 to 2*nclipbox do
                        begin
                          unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                          if s\<\>\'\' then
                          begin
                            if not i4dmsk then
                            begin
                              unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if s\<\>\'\' then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + locsubstr;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                    unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, true, false);
                                for i := 1 to 6 do
                                begin
                                  hl  := safestrtofloat(colorstringgrid3.cells[2,i+ord(i\>3)]);
                                  ll  := safestrtofloat(colorstringgrid3.cells[1,i+ord(i\>3)]);
                                  case i of
                                    1 : val := safestrtofloat(dx);
                                    2 : val := safestrtofloat(dy);
                                    3 : val := safestrtofloat(dz);
                                    4 : val := safestrtofloat(drx);
                                    5 : val := safestrtofloat(dry);
                                    6 : val := safestrtofloat(drz);
                                    else
                                      val := min(hl,ll);
                                  end;
                                  if (val \> hl) or (val \< ll) then
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := col
                                  else
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := 0;
                                end;
                    end;
                              if comboboxsummarytype.text=summary_limits then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                                colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_limit1;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,5];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,6];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,7];
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                                colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_limit2;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,5];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,6];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,7];
                              end;
                              if isoc and assigned(chart) and chart.visible then
                              begin
                                unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                                chart.serieslist[0].addxy(0, strtofloat(dx));
                                chart.serieslist[1].addxy(0, strtofloat(dy));
                                chart.serieslist[2].addxy(0, strtofloat(dz));
                                chart.serieslist[0].addxy(0.5, strtofloat(dx));
                                chart.serieslist[1].addxy(0.5, strtofloat(dy));
                                chart.serieslist[2].addxy(0.5, strtofloat(dz));
                                chart.serieslist[0].active := true;
                                chart.serieslist[1].active := true;
                                chart.serieslist[2].active := true;
                              end;
                            end
                            else
                            begin
                              unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if s\<\>\'\' then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_mean + locsubstr;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                    unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, true, false);
                                for i := 1 to 6 do
                                begin
                                  hl  := safestrtofloat(colorstringgrid3.cells[2,i+ord(i\>3)]);
                                  ll  := safestrtofloat(colorstringgrid3.cells[1,i+ord(i\>3)]);
                                  case i of
                                    1 : val := safestrtofloat(dx);
                                    2 : val := safestrtofloat(dy);
                                    3 : val := safestrtofloat(dz);
                                    4 : val := safestrtofloat(drx);
                                    5 : val := safestrtofloat(dry);
                                    6 : val := safestrtofloat(drz);
                                    else
                                      val := min(hl,ll);
                                  end;
                                  if (val \> hl) or (val \< ll) then
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := col
                                  else
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := 0;
                                end;
                    end;
                    unpackregistration(k-1, -5, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if (s\<\>\'\')  and
                                 (comboboxcorrectionprotocol.text = correction_from_mask_exh)
                                 then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_exhale + locsubstr;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              unpackregistration(k-1, -2, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                              if isoc and (s\<\>\'\') and (comboboxsummarytype.text\<\>summary_limits) then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_sd;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              unpackregistration(k-1, -3, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                              if isoc and (s\<\>\'\') and (comboboxsummarytype.text\<\>summary_limits) then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_a;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              if comboboxsummarytype.text=summary_limits then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                                colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_limit1;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,5];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,6];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,7];
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                                colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_limit2;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,5];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,6];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,7];
                              end;
                              for j:=0 to max(transform4d.dimensions[3]-1, 0) do
                              begin
                                unpackregistration(k-1, j, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                                if s\<\>\'\' then
                                begin
                                  if comboboxsummarytype.text=summary_details then
                                  begin
                                    colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + \';\' + grid_frame + inttostr(j) + locsubstr;
                    colorstringgridsummary.colcount := 8;
                                    colorstringgridsummary.cells[7, 0] := grid_weight;
                                    colorstringgridsummary.cells[7, colorstringgridsummary.rowcount-1] := format(\'%.0f\', [phasehist.getvalue([j])*100.0]);
                                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                    colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                    colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                    colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                    colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                    colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                                  end;
                                  if isoc and assigned(chart) and chart.visible then
                                  begin
                                    if phasehist.empty then
                                    begin
                                      chart.serieslist[0].add(strtofloat(dx));
                                      chart.serieslist[1].add(strtofloat(dy));
                                      chart.serieslist[2].add(strtofloat(dz));
                                    end
                                    else
                                    begin
                                      if (k\>(nclipbox+1)) and (j=0) then
                                      begin
                                        chart.serieslist[3].addnullxy(0,0);
                                        chart.serieslist[4].addnullxy(0,0);
                                        chart.serieslist[5].addnullxy(0,0);
                                      end;
                                      phase := 0;
                                      for p:=0 to j-1 do phase := phase + phasehist.getvalue([p]);
                                      chart.serieslist[0].addxy(phase * transform4d.dimensions[3], strtofloat(dx));
                                      chart.serieslist[1].addxy(phase * transform4d.dimensions[3], strtofloat(dy));
                                      chart.serieslist[2].addxy(phase * transform4d.dimensions[3], strtofloat(dz));
                                    end;
                                    chart.serieslist[0].active := true;
                                    chart.serieslist[1].active := true;
                                    chart.serieslist[2].active := true;
                                  end;
                                end;
                              end;
                              if isoc and assigned(chart) and chart.visible and i4dmsk then
                              begin
                                unpackregistration(k-1, 0, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                                chart.serieslist[0].addxy(transform4d.dimensions[3], strtofloat(dx));
                                chart.serieslist[1].addxy(transform4d.dimensions[3], strtofloat(dy));
                                chart.serieslist[2].addxy(transform4d.dimensions[3], strtofloat(dz));
                              end;
                            end
                          end
                        end;
                      end;
                      unpackregistration(2*nclipbox, -1, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                      if s\<\>\'\' then
                      begin
                        colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                        colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_corr;
                        colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                        colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                        colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                        colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                        colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                        colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                        if assigned(chart) and chart.visible then
                        begin
                          chart.serieslist[6].addxy(onlinecube.dimensions[3], strtofloat(dx));
                          chart.serieslist[7].addxy(onlinecube.dimensions[3], strtofloat(dy));
                          chart.serieslist[8].addxy(onlinecube.dimensions[3], strtofloat(dz));
                          chart.serieslist[6].active := true;
                          chart.serieslist[7].active := true;
                          chart.serieslist[8].active := true;
                        end;
                      end;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_172()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.colorstringgridsummarydblclick(sender: tobject);
                  var r,c: integer;
                      s: string;
                  begin
                    s := caption + #9 +
                         clipboard_ref  + referenceoverlaystring + #9 +
                         clipboard_loc  + onlineoverlaystring + #9 +
                         clipboard_sign + copy(quirtviewerupdcoronal.text[2].value, 5, 250) + #9 +
                         clipboard_disp + comboboxsummarytype.text;
                    for r:=0 to colorstringgridsummary.rowcount-1 do
                    begin
                      s := s + #13#10;
                      for c:=0 to colorstringgridsummary.colcount-1 do
                        s := s + colorstringgridsummary.cells[c, r] + #9;
                    end;
                    clipboard.astext := s;
                    showmessage(message_copiedtexttoclpbrd);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_173()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.timer1timer(sender: tobject);
                  var t: ttransform;
                      tx, ty, tz, rx, ry, rz, w: single;
                      i, i2, clipboxes, rois, nexhale, equalclip, equalroi, icb:  integer;
                      tm : longint;
                      tc: tcontrol;
                      onlinepresent, referencepresent, planar: boolean;
                      s, dx, dy, dz, drx, dry, drz, name: string;
                      formimage: tbitmap;
                      pixmap: tavsfield;
                      v: tlightquirtviewerupd;
                      activeflag   : boolean;
                      limits1, limits2: integer;
                      cursorposition: tpoint;
                  begin
                    if not visible then exit;
                    if form1timer1enabled\>0 then exit;
                    if not windows.getcursorpos(cursorposition) then
                    begin
                      cursorposition.x := -1;
                      cursorposition.y := -1;
                    end;
                    inc(form1timer1enabled);
                    clipboxes := 0;
                    for i:=1 to nclipbox do
                      if not clipbox[i].empty then inc(clipboxes) else break;
                    rois := ord(checkboxreferencemask.enabled);
                    equalclip := compareregistrationbackuppartial(0, clipboxes-1);
                    equalroi := compareregistrationbackuppartial(nclipbox, nclipbox+rois-1);
                    if testmode then
                    begin
                      quirtviewerupdcoronal.textcolor[6].value := rgb(255, 255, 200);
                      quirtviewerupdcoronal.text[6].value :=
                      format(\'clipboxes: %d\'+#10+
                             \'masks: %d\'+#10+
                             \'invalid clipbox match: %d\'+#10+
                             \'invalid mask match: %d\'+#10+
                             \'valid correction: %d\'+#10+
                             \'correction label: %s\'+#10+
                             \'correctionapprovalby: %s\'+#10+
                             \'hit clipbox limit:  %d\'+#10+
                             \'hit mask limit: %d\'+#10+
                             \'version: %s\'+#10+
                             \'mask id: %s\' + #10 +
                             \'threshold 1: %d\' + #10 +
                             \'threshold 2: %d\',
                      [clipboxes, rois, equalclip, equalroi,
                       compareregistrationbackuppartial(2*nclipbox, 2*nclipbox+rois-1),
                       labelcomputedlat2.caption,
                       correctionapprovalby,
                       (unpackregistration(-4, -1, s, s, s, s, s, s, s, false, true, false)),
                       (unpackregistration(nclipbox, -5, s, s, s, s, s, s, s, false, true, false)),
                       xvi_version + \' (\' + xvi_builddate + \')\', maskid,
                       githreshold1, githreshold2
                      ])
                    end
                    else
                      quirtviewerupdcoronal.text[6].value := \'\';
                    paneltest.visible := testmode;
                    if avlstate in [1..6] then
                      buttonelektaaccept.enabled := not readonly and not reconstructing
                                                    and (((alignmentmode.value = 3) and (labelcomputedlat2.caption \<\> \'-\'))
                                                    and labelcomputedlat2.enabled or (avlstate\<\>3));
                    exitaccept1.enabled := buttonelektaaccept.enabled;
                    viewerhelp1.checked := bool(quirtviewerupdsagittal.showhelp.value);
                    if (not viewerhelp1.checked) or
                      (quirtviewerupdtransversal.showhelp.value\<\>0) or
                      (quirtviewerupdcoronal.showhelp.value\<\>0) then
                    begin
                      if  quirtviewerupdtransversal.showhelp \<\> quirtviewerupdsagittal.showhelp then
                        quirtviewerupdtransversal.showhelp := quirtviewerupdsagittal.showhelp;
                      if  quirtviewerupdcoronal.showhelp \<\> quirtviewerupdsagittal.showhelp then
                        quirtviewerupdcoronal.showhelp := quirtviewerupdsagittal.showhelp;
                    end;
                    if needloadimage then
                      loadimage;
                    if needloadscan  then
                      buttonloadscanclick(self);
                    if needloadmatch  then
                    begin
                      buttonloadmatchclick(self);
                      needloadmatch := false ;
                    end;
                    if needloadreference then
                      buttonloadreferenceclick(self);
                    if assigned(sf) then
                    begin
                      visible := true;
                      sf.free;
                      sf := nil;
                    end;
                    if pagecontrol1.activepageindex=1 then
                    begin
                      if (formstyle \<\> fsstayontop) and active then
                      begin
                        tc := findvclwindow(cursorposition);
                        if tc=quirtviewer1 then quirtviewer1.setfocus;
                      end;
                      quirtviewer1.make;
                    end;
                    if pagecontrol1.activepageindex=2 then
                    begin
                      onlinepresent    := not (onlinecube.empty or (onlinecube.veclen=0));
                      referencepresent := not referencecube.empty;
                      if onlinepresent then planar := onlinecube.ndim=2 else planar := false;
                      scanis4d         := onlinecube.ndim\>3;
                      if referencepresent then
                        clipboxlist.make;
                      clipboxes := 0;
                      for i:=1 to nclipbox do
                        if not clipbox[i].empty then inc(clipboxes) else break;
                      rois := ord(checkboxreferencemask.enabled);
                      if          onlinepresent and not (referencepresent and checkboxscan.checked) then
                        begin
                          quirtviewerupdsagittal.cutmode.value := 11;
                        end
                      else if not onlinepresent and     (referencepresent and checkboxscan.checked) then
                        begin
                          quirtviewerupdsagittal.cutmode.value := 12;
                        end
                      else if not onlinepresent and not (referencepresent and checkboxscan.checked) then
                        begin
                          quirtviewerupdsagittal.cutmode.value := 11;
                        end
                      else
                        case comboboxdisplaymode.itemindex of
                          0: quirtviewerupdsagittal.cutmode.value := 212;
                          1:begin
                               if quirtviewerupdsagittal.cutmode.value\<14 then quirtviewerupdsagittal.cutmode.value := 14;
                               if quirtviewerupdsagittal.cutmode.value\>19 then quirtviewerupdsagittal.cutmode.value := 14;
                             end;
                          2: quirtviewerupdsagittal.cutmode.value := 11;
                          3: quirtviewerupdsagittal.cutmode.value := 12;
                        end;
                      if visualizebonesegmentation1.checked or
                       ((pos(match_substring_seed, comboboxmaskmatch.text)\>0) and editmask.checked)
                      then
                      begin
                        if chamferdotsreference.empty then chamferdotsreference.forceupdate;
                        case comboboxdisplaymode.itemindex of
                          0: begin
                               quirtviewerupdcoronal.polydots[5].blanking := false;
                               quirtviewerupdcoronal.polydots[9].blanking := false;
                             end;
                          1: begin
                               quirtviewerupdcoronal.polydots[5].blanking := false;
                               quirtviewerupdcoronal.polydots[9].blanking := false;
                             end;
                          2: begin
                               quirtviewerupdcoronal.polydots[5].blanking := false;
                               quirtviewerupdcoronal.polydots[9].blanking := not ((pos(match_substring_seed, comboboxmaskmatch.text)\>0) and editmask.checked);
                             end;
                          3: begin
                               quirtviewerupdcoronal.polydots[5].blanking := true;
                               quirtviewerupdcoronal.polydots[9].blanking := false;
                             end;
                        end;
                      end
                      else
                      begin
                        if assigned(chamferdotsonline) and not chamferdotsonline.empty then
                          chamferdotsonline.clear;
                        if assigned(chamferdotsreference) and not chamferdotsreference.empty then
                          chamferdotsreference.clear;
                      end;
                      if (comboboxsliceaveraging.itemindex\>=0) and not planar then
                        quirtviewerupdsagittal.sliceblur.value := comboboxsliceaveraging.itemindex;
                      if  striphotkey(menushowunlockpresentclipbox.caption) \<\> menu_menushowall_caption then
                      begin
                        for i:=1 to nclipbox do
                        begin
                          if clipbox[i].blanking \<\> not checkboxroi.checked then
                             clipbox[i].blanking := not checkboxroi.checked;
                        end;
                      end
                      else
                      begin
                        activeflag := false;
                        for i:= 1 to nclipbox do
                        begin
                          if i = quirtviewerupdsagittal.activeclipbox.value then
                          begin
                            if clipbox[i].blanking \<\> not checkboxroi.checked then
                              clipbox[i].blanking := not checkboxroi.checked;
                            activeflag := true;
                          end
                          else clipbox[i].blanking := true;
                        end;
                        if not activeflag then
                        begin
                          activeregion.value := updownrois.position;
                          if alignmentmode.value=0 then
                          begin
                            quirtviewerupdsagittal.activeclipbox.value :=  activeregion.value+1;
                            clipbox[activeregion.value+1].blanking := false;
                            clipbox[activeregion.value+1].ischangedby := self;
                          end;
                        end;
                      end;
                      if delineationdots.blanking \<\> not checkboxdelineation.checked then
                        delineationdots.blanking := not checkboxdelineation.checked;
                      maskedreference.blanking := true;
                      referencemask.blanking := true;
                      dosecube.blanking := true;
                      doseaccu.blanking := true;
                      if (beamdots.blanking \<\> not (checkboxplan.checked and not planar)) and not xviischildwindow then
                        beamdots.blanking := not (checkboxplan.checked and not planar);
                      if (bonetumormatchlist.find(comboboxmatch.text,i)) then
                        bonetumormatchstatus := 10 + bonetumormatchstatus mod 10
                      else
                        bonetumormatchstatus := bonetumormatchstatus mod 10;
                      if (
                          ((comboboxclipboxmatch.itemindex=0) and (alignmentmode.value=0) and onlinepresent) or
                          ((comboboxmaskmatch.itemindex=0) and (alignmentmode.value=1) and onlinepresent) or
                          radiobuttoncurrentframe.checked or radiobuttoncurrentroi.checked
                         )
                         and referencepresent and onlinepresent then
                        tm:=1
                      else
                        tm:=0;
                      if (tm\<\>0) and (editmask.checked) then
                        editmaskclick(self);
                      if reversemotion.value=0 then
                      begin
                        quirtviewerupdcoronal.trackermode.value := -tm;
                        quirtviewerupdsagittal.trackermode.value := -tm;
                        quirtviewerupdtransversal.trackermode.value := -tm;
                      end
                      else
                      begin
                        quirtviewerupdcoronal.trackermode.value := tm;
                        quirtviewerupdsagittal.trackermode.value := tm;
                        quirtviewerupdtransversal.trackermode.value := tm;
                      end;
                      if striphotkey(menushowunlockpresentclipbox.caption) \<\> menu_menulockall_caption then
                      begin
                        for i:=1 to nclipbox do
                           clipbox[i].locked := menuclipboxlocked.checked or (tm\<\>0) or (editmask.checked) or matchinprogress;
                      end
                      else
                      begin
                        activeflag := false;
                        for i:= 1 to nclipbox do
                        begin
                          if i = quirtviewerupdsagittal.activeclipbox.value then
                          begin
                            clipbox[i].locked := false;
                            activeflag := true;
                          end
                          else clipbox[i].locked := true;
                        end;
                        if not activeflag then
                        begin
                          activeregion.value := updownrois.position;
                          if alignmentmode.value=0 then
                          begin
                            quirtviewerupdsagittal.activeclipbox.value :=  activeregion.value+1;
                            clipbox[activeregion.value+1].blanking := false;
                            clipbox[activeregion.value+1].ischangedby := self;
                          end;
                        end;
                      end;
                      if referencepresent then
                      begin
                          quirtviewerupdcoronal.trackershape.value := 28;
                        quirtviewerupdcoronal.trackerdots.blanking := false;
                      end
                      else
                      begin
                        quirtviewerupdcoronal.trackershape.value := -1;
                        quirtviewerupdcoronal.trackerdots.blanking := true;
                      end;
                      if (quirtviewerupdcoronal.markerdots[1].newerthan(correctionreferencepoint)) and (strtoint(correctionreferencepoint.debugname)=2) then
                      begin
                        if quirtviewerupdcoronal.markerdots[1].empty then
                          quirtviewerupdcoronal.text[3].value := #27+#1+chr(255)+chr(255)+corr_ref_marker_ns
                        else
                          quirtviewerupdcoronal.text[3].value := #27+#1+chr(255)+chr(255)+corr_ref_marker_ch;
                      end;
                      if referencepresent then
                        if hideisoccorrefpoint1.checked\<\>correctionreferencepoint.blanking then
                          correctionreferencepoint.blanking := hideisoccorrefpoint1.checked;
                      if hideisoccorrefpoint1.checked\<\>isocdots.blanking then
                          isocdots.blanking := hideisoccorrefpoint1.checked;
                      if (tm\<\>0) and radiobuttoncurrentframe.checked then
                        transformdisplaymode.value := 1
                      else if (tm\<\>0) then
                        transformdisplaymode.value := 1
                                                                                  else if alignmentmode.value in [2,3,4] then
                        transformdisplaymode.value := 3
                      else
                      begin
                        if not (externalwarp.empty) and radiobuttonwarpallrois.checked then
                          transformdisplaymode.value := 6
                        else if scanis4d and (radiobuttonaverageframes.checked or (quirtviewerupdcoronal.frame.value=-1)) then
                        begin
                          if radiobuttonwarpallrois.checked then
                            transformdisplaymode.value := 5
                          else
                            transformdisplaymode.value := 4;
                        end
                        else if radiobuttonwarpallrois.checked and radiobuttoneachframe.checked then
                          transformdisplaymode.value := 2
                        else if radiobuttoneachroi.checked     and radiobuttoneachframe.checked then
                          transformdisplaymode.value := 1
                      end;
                      s := \'\';
                      if not onlinecube.empty then
                      begin
                        if onlinecube.ndim=4 then
                        begin
                          if reversemotion.value=1 then s := s + #27 + #1 + chr(255) + #1
                          else                          s := s + #27 + chr(255) + #1 + chr(255);
                          if quirtviewerupdcoronal.frame.value = -1 then
                            s := s + avg_overlay_avg
                          else
                            s := s + format(overlay_4d, [quirtviewerupdcoronal.frame.value, onlinecube.dimensions[3]]);
                        end;
                      end;
                      if not referencecube.empty then
                        if referencecube.ndim=4 then
                        begin
                          s := s + #10 + #27 + chr(255) + #1 + chr(255);
                          if quirtviewerupdcoronal.frame.value = -1 then
                            s := s + avg_overlay_avg
                          else
                            s := s + format(overlay_4d, [quirtviewerupdcoronal.frame.value, referencecube.dimensions[3]]);
                        end;
                      quirtviewerupdsagittal.text[4].value := s;
                      if not xviischildwindow then
                      begin
                        paneltranslation.visible      := onlinepresent and referencepresent and (alignmentmode.value in [0,1,2,3]);
                        panelrotation.visible         := onlinepresent and referencepresent and (alignmentmode.value in [0,1,2,3]);
                        panelelektacouchshift.visible := onlinepresent and referencepresent and (alignmentmode.value = 3) and true;
                        labelcomputedlat2.visible := ((comboboxcorrectionby.text\<\>nameof6dofsystem) or (nameof6dofsystem=\'\'));
                        labelcomputedlong2.visible := labelcomputedlat2.visible;
                        labelcomputedheight2.visible := labelcomputedlat2.visible;
                        bitbtndismisscorrection.visible := onlinepresent and referencepresent and (alignmentmode.value = 3);
                        label18.visible := paneltranslation.visible;
                        panelimage.visible            := onlinepresent or referencepresent;
                          panelreferencepreset.visible  := referencepresent;
                        panelalignment.visible        := referencepresent;
                        tabcontrol1.visible           := referencepresent;
                        panelregistration.visible     := alignmentmode.value in [0,1,2];
                        colorstringgridsummary.visible     := alignmentmode.value=4;
                        comboboxsummarytype.visible   := alignmentmode.value=4;
                        comboboxclipboxmatch.visible  := alignmentmode.value=0;
                        comboboxmaskmatch.visible     := alignmentmode.value=1;
                        label79.visible               := alignmentmode.value in [0, 1];
                        buttonresetmatch.visible      := onlinepresent and referencepresent and (alignmentmode.value in [0,1]);
                        buttoncopytohexapod1.visible  := onlinepresent and referencepresent and (alignmentmode.value in [3]) and (correctionbyhexapod) and (runtableshift\<\>\'\');
                        buttonnextstep.visible        := onlinepresent and referencepresent;
                        buttonmatch2.visible          := onlinepresent and referencepresent and (alignmentmode.value\<\>2);
                        if alignmentmode.value=0 then s := comboboxclipboxmatch.text else s := comboboxmaskmatch.text;
                        bitbtnplaygreen.enabled := referencepresent and not radiobuttoncurrentframe.checked
                                                   and (pos(match_substring_4d,s)\>0) and (alignmentmode.value in [0,1]);
                        bitbtnplaypurple.enabled := not radiobuttoncurrentframe.checked;
                        bitbtnstop4d.enabled := not radiobuttoncurrentframe.checked;
                        bitbtnaverage4d.enabled := not radiobuttoncurrentframe.checked;
                        if not bitbtnplaygreen.enabled then reversemotion.value := 0;
                        labelrois.visible             := ((alignmentmode.value = 0) and (clipboxes\>1)) or ((alignmentmode.value = 1) and (rois\>1));
                        updownrois.visible            := labelrois.visible;
                        bitbtnlockregistrationmethod.visible := labelrois.visible;
                        updownrois.enabled            := (not match2inprogress) ;
                        panelallrois.visible          := labelrois.visible and onlinepresent and (s\<\>match_manual);
                        bitbtnwarp.visible            := (labelrois.visible or not externalwarp.empty) and onlinepresent and (s\<\>match_manual);
                        panelallframes.visible        := (onlinecube.ndim=4) and (alignmentmode.value in [0,1]) and (pos(match_substring_4d,s)\>0);
                        bitbtnaverage4dtransform.visible    := false;
                        label4d.visible        := (onlinecube.ndim=4) or (referencecube.ndim=4);
                        panelcontrol4d.visible := (onlinecube.ndim=4) or (referencecube.ndim=4);
                        showdvf1.visible       := false;
                        applydvf.visible       := false;
                        loaddvf1.visible       := false;
                        labelpitch2.visible := false;
                        labelroll2.visible := false;
                        labelyaw2.visible := false;
                        labelcomputedpitch2.visible := false;
                        labelcomputedroll2.visible := false;
                        labelcomputedyaw2.visible := false;
                        label24.visible := false;
                        if not labelcomputedlat2.visible then
                        begin
                          label16.caption := \'\';
                          label17.caption := \'\';
                          label18.caption := format(label_label18_caption2, [nameof6dofsystem]);
                          labellat2.caption := \'\';
                          labelheight2.caption := \'\';
                          labellong2.caption := \'\';
                        end
                        else
                        begin
                          label16.caption := label_label16_caption;
                          label17.caption := label_label17_caption;
                          label18.caption := label_label18_caption;
                          labellat2.caption := label_labellat2_caption;
                          labelheight2.caption := label_labelheight2_caption;
                          labellong2.caption := label_labellong2_caption;
                        end;
                        memomaskclipboxdifference.visible := onlinepresent and referencepresent and
                                                             (((alignmentmode.value = 2) and (comboboxregistrationprotocol.itemindex\<\>1)) or ((alignmentmode.value = 1) and (comboboxregistrationprotocol.itemindex=2)));
                        memoclipboxcorrectiondifference.visible := onlinepresent and referencepresent and
                                                             (((alignmentmode.value = 2) and (comboboxregistrationprotocol.itemindex\<\>0)));
                        memoclipboxcorrectiondifference.height := 0;
                        memomaskclipboxdifference.height := 0;
                        memoclipboxcorrectiondifference.enabled := false;
                        memomaskclipboxdifference.enabled := false;
                        trackbarweight.visible := memomaskclipboxdifference.visible and memoclipboxcorrectiondifference.visible;
                        label44.visible := trackbarweight.visible;
                        label45.visible := trackbarweight.visible;
                        label44.visible          := memomaskclipboxdifference.visible and memoclipboxcorrectiondifference.visible;
                        label45.visible          := memomaskclipboxdifference.visible and memoclipboxcorrectiondifference.visible;
                        trackbarweight.visible   := memomaskclipboxdifference.visible and memoclipboxcorrectiondifference.visible;
                        colorstringgrid1.cells[3,0] := grid_adjust;
                        for i:= 1 to 3 do
                          colorstringgrid1.cellprops[3,i].box.visible := trackbarweight.visible;
                        for i:= 4 to 6 do
                          colorstringgrid1.cellprops[3,i].box.visible := trackbarweight.visible and (correctionbyhexapod);
                        colorstringgrid1.visible := (memomaskclipboxdifference.visible or memoclipboxcorrectiondifference.visible) and
                                                    (comboboxregistrationprotocol.itemindex=2) and
                                                    (alignmentmode.value = 2);
                        colorstringgrid2.visible       := (not onlinepresent) and referencepresent and
                                                          (comboboxregistrationprotocol.itemindex=2) and
                                                          (alignmentmode.value=0);
                        colorstringgrid3.visible       := (not onlinepresent) and referencepresent and
                                                          (comboboxregistrationprotocol.itemindex=2) and
                                                          (alignmentmode.value=1);
                        buttonlimitinformation.visible := false;
                        panellimitsinformation.visible := colorstringgrid2.visible or colorstringgrid3.visible;
                        if not quirtviewerupdcoronal.toolbar[1].empty then
                          case ord(colorstringgrid2.visible) + 2*ord(colorstringgrid3.visible) + 10 * ord(comboboxregistrationprotocol.text=protocol_clipbox_mask)
                          of
                            1:  labellimitshelp.caption := labellimitshelp_caption1;
                            2:  labellimitshelp.caption := labellimitshelp_caption2;
                            11: labellimitshelp.caption := labellimitshelp_caption11;
                            12: labellimitshelp.caption := labellimitshelp_caption12;
                          end
                        else
                          labellimitshelp.caption := \'\';
                        editmask.visible              := false;
                        masklocked.visible            := not referencemask.empty;
                        clearmask.visible             := not referencemask.empty;
                        paintbrushsize.visible        := (editmask.checked) and not referencemask.empty;
                        if alignmentmode.value=0 then s := comboboxclipboxmatch.text else s := comboboxmaskmatch.text;
                        paneltranslation.enabled := (radiobuttoneachroi.checked and radiobuttoneachframe.checked and
                                                    (alignmentmode.value in [0, 1, 2]) and
                                                    onlinepresent and referencepresent and
                                                    (not matchinprogress) and
                                                    ((pos(match_substring_4d,s)=0) or not scanis4d or radiobuttoncurrentframe.checked))
                                                    or (alignmentmode.value = 2);
                        panelrotation.enabled := (paneltranslation.enabled and
                          (((pos(\'(t)\',comboboxclipboxmatch.mappedtext)=0) and comboboxclipboxmatch.visible) or
                           ((pos(\'(t)\',comboboxmaskmatch.mappedtext)=0) and comboboxmaskmatch.visible) or
                           ((correctionbyhexapod) and (alignmentmode.value\>1))))
                           or ((alignmentmode.value = 2) and (correctionbyhexapod));
                        for i:=0 to paneltranslation.controlcount-1 do
                          if paneltranslation.controls[i].enabled \<\> paneltranslation.enabled then
                            paneltranslation.controls[i].enabled := paneltranslation.enabled;
                        for i:=0 to panelrotation.controlcount-1 do
                          if panelrotation.controls[i].enabled \<\> panelrotation.enabled then
                            panelrotation.controls[i].enabled := panelrotation.enabled;
                        if paneltranslation.enabled then
                        begin
                          if edittranslationlr.color \<\> clwindow then
                          begin
                            edittranslationlr.color := clwindow;
                            edittranslationap.color := clwindow;
                            edittranslationcc.color := clwindow;
                          end;
                        end
                        else
                        begin
                          if edittranslationlr.color \<\> clmenu then
                          begin
                            edittranslationlr.color := clmenu;
                            edittranslationap.color := clmenu;
                            edittranslationcc.color := clmenu;
                          end;
                        end;
                        if panelrotation.enabled then
                        begin
                          if editrotationlr.color \<\> clwindow then
                          begin
                            editrotationlr.color := clwindow;
                            editrotationap.color := clwindow;
                            editrotationcc.color := clwindow;
                          end;
                        end
                        else
                        begin
                          if editrotationlr.color \<\> clmenu then
                          begin
                            editrotationlr.color := clmenu;
                            editrotationap.color := clmenu;
                            editrotationcc.color := clmenu;
                          end;
                        end;
                        buttonclipbox.enabled := (tm = 0) and referencepresent
                        and (((avlstate=-1) or (avlstate in [0, 1, 3, 4])) and (comboboxregistrationprotocol.itemindex in [0,2,3,5])) and (not matchinprogress);
                        checkboxscan.enabled          := false;
                        comboboxdisplaymode.enabled   := referencepresent;
                        bitbtngreenpurplecut.enabled  := referencepresent;
                        bitbtnrefloc.enabled          := referencepresent;
                        label54.enabled               := referencepresent;
                        checkboxplan.enabled          := not beamdots.empty and not planar;
                        checkboxdelineation.enabled   := not delineationdots.empty;
                        buttonstructures.enabled      := not delineationdots.empty;
                        checkboxreferencemask.enabled := not referencemask.empty;
                        checkboxdose.enabled          := not dosecube.empty;
                        checkboxdoseaccu.enabled      := not doseaccu.empty;
                        buttondoseaccumulate.enabled  := not dosecube.empty;
                        checkboxroi.enabled           := onlinepresent or referencepresent;
                        buttonconverttocorrection.enabled := onlinepresent and referencepresent and (not convertedtocorrections) and
                                                             (bonetumormatchstatus\<\>10) and
                                                             (not convertcorexcllist.find(comboboxmatch.text,i)) and
                                                             (not matchinprogress);
                        buttonsetcorrectionreferencepoint.enabled := ((avlstate=-1) or (avlstate in [0, 1])) and referencepresent;
                        buttonmask.enabled                        := ((avlstate=-1) or (avlstate in [0, 1, 3, 4])) and referencepresent and (comboboxregistrationprotocol.itemindex in [1,2,3,5]) and (not matchinprogress);
                        buttonmarkers.enabled                     := ((avlstate=-1) or (avlstate in [0, 1, 3, 4])) and referencepresent;
                        labelrois.enabled := quirtviewerupdcoronal.activeclipbox.value = activeregion.value + 1;
                       if alignmentmode.value=0 then
                         buttonnextstep.enabled := not match2inprogress and
                           (equalclip=0) and
                           ( (equalroi\<\>0)  or
                           (comboboxregistrationprotocol.itemindex=0));
                       if alignmentmode.value=1 then
                         buttonnextstep.enabled := not match2inprogress and
                         ((equalclip=0) or (comboboxregistrationprotocol.itemindex=1)) and
                         (equalroi=0)
                         and (correctionapprovalby=\'\');
                       if alignmentmode.value\>1 then buttonnextstep.enabled := true;
                        buttonmatch2.enabled := onlinepresent and referencepresent and
                        (((alignmentmode.value=0) and (comboboxclipboxmatch.itemindex\>0)) or ((alignmentmode.value=1) and (comboboxmaskmatch.itemindex\>0)));
                        buttoncopytohexapod1.enabled := labelcomputedlat2.caption \<\> \'-\';
                        bitbtnunlockprotocol.visible := onlinepresent;
                        label80.enabled := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        label81.enabled := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        label21.enabled := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        comboboxregistrationprotocol.enabled := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        comboboxcorrectionprotocol.enabled   := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        comboboxcorrectionby.enabled         := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        nexhale := 1000;
                        if (not onlinecube.empty) and (onlinecube.ndim=4) then
                          if comboboxcorrectionprotocol.text = correction_from_mask_exh then nexhale := onlinecube.dimensions[3] div 8;
                        if (((alignmentmode.value in [1,2,3,4]) and (comboboxcorrectionprotocol.text = correction_from_mask_mean)) or
                            ((alignmentmode.value in [1,2,3,4]) and (comboboxcorrectionprotocol.text = correction_from_mask_exh)) or
                            ((alignmentmode.value in [0,2,3,4]) and (comboboxcorrectionprotocol.text = correction_from_clipbox)))
                          and (quirtviewerupdcoronal.frame.value\>=0)
                          and not ((quirtviewerupdcoronal.frame.value\>nexhale) and (quirtviewerupdcoronal.frame.value\<onlinecube.dimensions[3]-nexhale)) then
                           label4d.font.color := clgreen
                         else
                           label4d.font.color := clblack;
                        buttonsavescan.enabled        := onlinepresent and (not viewonly);
                        buttonexport.enabled          := onlinepresent and (not readonly) and (not viewonly);
                    buttontoreference.enabled     := onlinepresent;
                    buttonzoom.enabled            := onlinepresent or referencepresent;
                        buttonzoomout.enabled         := onlinepresent or referencepresent;
                        buttongotoisoc.enabled        := (onlinepresent or referencepresent) and not planar;
                        bitbtnpresetlevelwindows.enabled  := onlinepresent or referencepresent;
                    comboboxsliceaveraging.enabled:= (onlinepresent or referencepresent) and not planar;
                        label55.enabled               := (onlinepresent or referencepresent) and not planar;
                        buttonmatch.enabled           := onlinepresent and referencepresent and (not (tm=1)) and not planar;
                        buttonresetmatch.enabled      := onlinepresent and referencepresent and (not matchinprogress);
                        buttonsavereference.enabled   := (referencepresent or (not delineationdots.empty and not beamdots.empty)) and
                        (not readonly)
                  ;
                        buttonclearreference.enabled  := referencepresent or (not delineationdots.empty and not beamdots.empty);
                        buttonacceptmatch.enabled     := onlinepresent and referencepresent and
                                                         (not beamdots.empty or synergymode) and buttonloadreference.enabled
                                                         and (not referencedatachanged) and (not readonly) and
                                                         (convertedtocorrections or (bonetumormatchstatus=10) or
                                                          convertcorexcllist.find(comboboxmatch.text,i));
                        buttonsetreferencemask.enabled := referencepresent and (not delineationdots.empty);
                        gotoisocenter.enabled                := onlinepresent;
                        gotocorrectionreferencepoint.enabled := referencepresent;
                        gotomarker.enabled                   := not quirtviewerupdcoronal.markerdots[1].empty;
                        viewpoint1.enabled                   := not quirtviewerupdcoronal.markerdots[3].empty;
                        plannedisoc1.enabled                 := referencepresent;
                        centerofclipbox1.enabled             := (not clipbox[1].empty) and (comboboxregistrationprotocol.itemindex \<\> 1);
                        centerofmask1.enabled                := (not referencemask.empty) and (comboboxregistrationprotocol.itemindex \<\> 0);
                        centerofmask1.visible                := (admincount and admincount_roi3d)\<\>0;
                        refpointatcenterofclipbox1.enabled := not clipbox[1].empty and (comboboxregistrationprotocol.itemindex \<\> 1);
                        refpointatmarker.enabled := not quirtviewerupdcoronal.markerdots[1].empty;
                        refpointatcenterofdelineation.enabled := not delineationdots.empty;
                        for i:=0 to refpointatcenterofdelineation.count-1 do
                          refpointatcenterofdelineation.items[i].checked :=
                            striphotkey(refpointatcenterofdelineation.items[i].caption)=correctionreferencepointstructure;
                        if quirtviewerupdcoronal.markerdots[1].empty then
                        begin
                          matchrotmark := false;
                          if (popupmenucomboboxmatch.items.count \<\> 0) then
                          begin
                            popupmenucomboboxmatch.items.items[1].enabled := false;
                            popupmenucomboboxmatch.items.items[1].checked := false;
                          end
                        end
                        else if (popupmenucomboboxmatch.items.count \<\> 0) then
                            popupmenucomboboxmatch.items.items[1].enabled := true;
                        panelaverageframes.enabled := (quirtviewerupdcoronal.frame.value\<\>-1) and not radiobuttoncurrentframe.checked;
                        radiobuttonaverageframes.enabled := panelaverageframes.enabled;
                        radiobuttoneachframe.enabled := panelaverageframes.enabled;
                        panelwarpallrois.enabled := (not radiobuttoncurrentroi.checked) or (not externalwarp.empty);
                        radiobuttonwarpallrois.enabled := panelwarpallrois.enabled;
                        radiobuttoneachroi.enabled := panelwarpallrois.enabled;
                        if clipbox[1].empty then checkboxroi.checked := false;
                        if radiobuttoncurrentframe.checked then
                        begin
                          timer4d.enabled := false;
                          reversemotion.value := 0;
                          if quirtviewerupdcoronal.frame.value\<-0 then quirtviewerupdcoronal.frame.value := 0;
                        end;
                        comboboxclipboxmatch.enabled := (not radiobuttoncurrentframe.checked) and (not radiobuttoncurrentroi.checked) and (not matchinprogress);
                        comboboxmaskmatch.enabled    := (not radiobuttoncurrentframe.checked) and (not radiobuttoncurrentroi.checked) and (not matchinprogress);
                        if radiobuttoncurrentframe.checked then
                          buttonresetmatch.caption := buttonresetmatch_caption2
                        else
                          buttonresetmatch.caption := buttonresetmatch_caption;
                        if radiobuttoncurrentframe.checked then radiobuttoneachframe.checked := true;
                        if not panelallframes.visible      then radiobuttonallframes.checked := true;
                        if radiobuttoncurrentroi.checked then radiobuttoneachroi.checked := true;
                        if not panelallrois.visible        then radiobuttonallrois.checked := true;
                        if not ((onlinecube.ndim=4) and (alignmentmode.value in [0,1]) and (pos(match_substring_4d,s)\>0)) then
                          radiobuttoneachframe.checked := true;
                        if not bitbtnwarp.visible    then radiobuttoneachroi.checked := true;
                        case alignmentmode.value of
                          0: if onlinepresent or not colorstringgrid2.visible then labeltabpage.caption := tab_registrationclipbox else labeltabpage.caption := tab_registrationclipbox2;
                          1: if onlinepresent or not colorstringgrid3.visible then labeltabpage.caption := tab_registrationmask else labeltabpage.caption := tab_registrationmask2;
                          2: labeltabpage.caption := tab_reviewcorrection;
                          3: labeltabpage.caption := tab_correction;
                          4: labeltabpage.caption := tab_overview;
                        end;
                        if (transform4d.dimensions[3]\>1) and
                           ((pos(match_4d, comboboxmatch.text)\>0) or (pos(match_manualcc, comboboxmatch.text)\>0)) and
                           not converted4dtomean then
                          buttonconverttocorrection.caption := convert_to_corr_button_caption2
                        else
                          buttonconverttocorrection.caption := convert_to_corr_button_caption;
                        if alignmentmode.value=4 then
                          updatesummary
                        else if assigned(chart) and chart.visible then
                        begin
                          chart.visible := false;
                          quirtviewerupdtransversal.visible := true;
                        end;
                        updownrois.min := 0;
                        if alignmentmode.value=0 then
                        begin
                          updownrois.max := clipboxes-1;
                          labelrois.caption := format(label_clipbox, [activeregion.value+1, clipboxes]);
                          end
                        else if alignmentmode.value=1 then
                        begin
                          updownrois.max := rois-1;
                          labelrois.caption := format(label_mask, [maskactiveregion.value+1, rois]);
                        end;
                        case alignmentmode.value of
                          0:  if (comboboxregistrationprotocol.itemindex in [0,3,4]) then
                              begin
                                  buttonnextstep.caption := convert_to_corr_button_caption;
                              end
                              else
                                buttonnextstep.caption := next_registermask;
                          1:
                               buttonnextstep.caption := convert_to_corr_button_caption;
                             2: buttonnextstep.caption := next_acceptcorrection
                          else
                            buttonnextstep.caption := next_invalid;
                        end;
                        if onlinepresent and referencepresent and (not (tm=1) or radiobuttoncurrentframe.checked or radiobuttoncurrentroi.checked)
                           and not planar  then
                        begin
                          if buttonmatch2.caption = match_manual2 then
                            buttonmatch2.caption := match_automatic;
                        end
                        else
                          buttonmatch2.caption := match_manual2;
                        if quirtviewerupdcoronal.frame.value=-1 then
                          label4d.caption := label_4davg
                        else
                          label4d.caption := format(label_4d, [quirtviewerupdcoronal.frame.value, onlinecube.dimensions[3]]);
                        if loadedalignmentdatachanged = false then
                          buttonacceptmatch.caption := confirm_caption
                        else
                          buttonacceptmatch.caption := accept_caption;
                          buttonelektaaccept.caption := button_buttonelektaaccept_caption;
                        if manualmatchactive then
                        begin
                          if      (alignmentmode.value=0) and (pos(match_substring_4d, comboboxclipboxmatch.text)=0) then
                            externalmanualmatchto4d(-1, activeregion.value)
                          else if (alignmentmode.value=0) and (pos(match_substring_4d, comboboxclipboxmatch.text)\>0) and radiobuttonallframes.checked then
                            externalmanualmatchto4d(-1, activeregion.value)
                          else if (alignmentmode.value=0) and (pos(match_substring_4d, comboboxclipboxmatch.text)\>0) and radiobuttoncurrentframe.checked then
                            externalmanualmatchto4d(quirtviewerupdcoronal.frame.value, activeregion.value)
                          else if (alignmentmode.value=1) and (pos(match_substring_4d, comboboxmaskmatch.text)=0) then
                            externalmanualmatchto4d(-1, nclipbox+maskactiveregion.value)
                          else if (alignmentmode.value=1) and (pos(match_substring_4d, comboboxmaskmatch.text)\>0) and radiobuttonallframes.checked then
                            externalmanualmatchto4d(-1, nclipbox+maskactiveregion.value)
                          else if (alignmentmode.value=1) and (pos(match_substring_4d, comboboxmaskmatch.text)\>0) and radiobuttoncurrentframe.checked then
                            externalmanualmatchto4d(quirtviewerupdcoronal.frame.value, nclipbox+maskactiveregion.value)
                          else if (alignmentmode.value in [2, 3]) then
                          begin
                            externalmanualmatchto4d(-1, nclipbox*2);
                            matchperformed := true;
                            alignmentmode.value := 2;
                            correctionapprovalby := \'\';
                          end;
                          if not radiobuttoncurrentframe.checked then
                          begin
                          if alignmentmode.value=0 then
                            appliedclipboxmatchmethod := \'manual\'
                          else if alignmentmode.value=1 then
                            appliedmaskmatchmethod := \'manual\';
                          end;
                          manualmatchactive := false;
                          if (not testmode) and (alignmentmode.value\<\>2) then
                            invalidatecorrection;
                        end;
                        if memomaskclipboxdifference.visible or memoclipboxcorrectiondifference.visible then
                        begin
                          if alignmentmode.value=1 then
                          begin
                            end
                          else if alignmentmode.value=2 then
                          begin
                            limits1 := unpackregistration(-4, -1, dx, dy, dz, drx, dry, drz, s, false, true, false);
                            if colorstringgrid1.cells[1,1] \<\> dx then colorstringgrid1.cells[1,1] := dx;
                            if colorstringgrid1.cells[1,2] \<\> dy then colorstringgrid1.cells[1,2] := dy;
                            if colorstringgrid1.cells[1,3] \<\> dz then colorstringgrid1.cells[1,3] := dz;
                            if colorstringgrid1.cells[1,4] \<\> drx then colorstringgrid1.cells[1,4] := drx;
                            if colorstringgrid1.cells[1,5] \<\> dry then colorstringgrid1.cells[1,5] := dry;
                            if colorstringgrid1.cells[1,6] \<\> drz then colorstringgrid1.cells[1,6] := drz;
                            if comboboxregistrationprotocol.itemindex\>=2 then
                            begin
                              colorstringgrid1.cellprops[1,1].color := ord(((limits1 and $003))\<\>0) * 255;
                              colorstringgrid1.cellprops[1,2].color := ord(((limits1 and $00c))\<\>0) * 255;
                              colorstringgrid1.cellprops[1,3].color := ord(((limits1 and $030))\<\>0) * 255;
                              colorstringgrid1.cellprops[1,4].color := ord(((limits1 and $0c0))\<\>0) * 255;
                              colorstringgrid1.cellprops[1,5].color := ord(((limits1 and $300))\<\>0) * 255;
                              colorstringgrid1.cellprops[1,6].color := ord(((limits1 and $c00))\<\>0) * 255;
                            end;
                            for i:=1 to 6 do
                              colorstringgrid1.cellprops[1,i].style := [tfontstyle(ord(colorstringgrid1.cellprops[1,i].color = clred)*ord(fsbold))];
                            memomaskclipboxdifference.lines.text := format(\'clipbox\'#13\'- correction\'#13#13\'tx = %s\'#13\'ty = %s\'#13\'tz = %s\'#13\'rx = %s\'#13\'ry = %s\'#13\'rz = %s\', [dx, dy, dz, drx, dry, drz]);
                            memomaskclipboxdifference.hint := \'\';
                          end;
                        end;
                        if memomaskclipboxdifference.visible or memoclipboxcorrectiondifference.visible then
                        begin
                          limits2 := unpackregistration(nclipbox, -5, dx, dy, dz, drx, dry, drz, s, false, true, false);
                          if colorstringgrid1.cells[2,1] \<\> dx then colorstringgrid1.cells[2,1] := dx;
                          if colorstringgrid1.cells[2,2] \<\> dy then colorstringgrid1.cells[2,2] := dy;
                          if colorstringgrid1.cells[2,3] \<\> dz then colorstringgrid1.cells[2,3] := dz;
                          if colorstringgrid1.cells[2,4] \<\> drx then colorstringgrid1.cells[2,4] := drx;
                          if colorstringgrid1.cells[2,5] \<\> dry then colorstringgrid1.cells[2,5] := dry;
                          if colorstringgrid1.cells[2,6] \<\> drz then colorstringgrid1.cells[2,6] := drz;
                          colorstringgrid1.cellprops[2,1].color := ord(((limits2 and $003))\<\>0) * 255;
                          colorstringgrid1.cellprops[2,2].color := ord(((limits2 and $00c))\<\>0) * 255;
                          colorstringgrid1.cellprops[2,3].color := ord(((limits2 and $030))\<\>0) * 255;
                          colorstringgrid1.cellprops[2,4].color := ord(((limits2 and $0c0))\<\>0) * 255;
                          colorstringgrid1.cellprops[2,5].color := ord(((limits2 and $300))\<\>0) * 255;
                          colorstringgrid1.cellprops[2,6].color := ord(((limits2 and $c00))\<\>0) * 255;
                          for i:=1 to 6 do
                            colorstringgrid1.cellprops[2,i].style := [tfontstyle(ord(colorstringgrid1.cellprops[2,i].color = clred)*ord(fsbold))];
                          memoclipboxcorrectiondifference.lines.text := format(\'mask\'#13\'- correction\'#13#13\'tx = %s\'#13\'ty = %s\'#13\'tz = %s\'#13\'rx = %s\'#13\'ry = %s\'#13\'rz = %s\', [dx, dy, dz, drx, dry, drz]);
                          memoclipboxcorrectiondifference.hint := \'\';
                        end;
                      end;
                      machine_to_machineadjust.make;
                      if machine_to_machineadjust.newerthan(quirtviewerupdcoronal.viewtransform) then
                      begin
                        t := ttransform.create;
                        t.assign(machine_to_machineadjust);
                        t.invert;
                        t.gettranslation(tx, ty, tz);
                        t.getrotationafterscaling(rx, ry, rz);
                        tx := -tx;
                        ty := -ty;
                        tz := -tz;
                        rx := -rx;
                        ry := -ry;
                        rz := -rz;
                        locktrackerupdate := true;
                        trackbartranslationlr.position := round(-tx * 10);
                        trackbartranslationcc.position := round(-ty * 10);
                        trackbartranslationap.position := round( tz * 10);
                        trackbarrotationlr.position := round( rx * 4);
                        trackbarrotationcc.position := round(-ry * 4);
                        trackbarrotationap.position := round( rz * 4);
                        edittranslationlr.text := floattostrf(-tx, fffixed, 5, 2);
                        edittranslationcc.text := floattostrf(-ty, fffixed, 5, 2);
                        edittranslationap.text := floattostrf(-tz, fffixed, 5, 2);
                        if not iec_angle_convention then
                        begin
                          editrotationlr.text := floattostrf( rx, fffixed, 5, 1);
                          editrotationcc.text := floattostrf(-ry, fffixed, 5, 1);
                          editrotationap.text := floattostrf( rz, fffixed, 5, 1);
                        end
                        else
                        begin
                          if rx\>-0.05 then
                            editrotationlr.text := floattostrf( rx, fffixed, 5, 1)
                          else
                            editrotationlr.text := floattostrf( rx + 360, fffixed, 5, 1);
                          if ry\<0.05 then
                            editrotationcc.text := floattostrf(-ry, fffixed, 5, 1)
                          else
                            editrotationcc.text := floattostrf(-ry + 360, fffixed, 5, 1);
                          if rz\>-0.05 then
                            editrotationap.text := floattostrf( rz, fffixed, 5, 1)
                          else
                            editrotationap.text := floattostrf( rz + 360, fffixed, 5, 1);
                        end;
                        locktrackerupdate := false;
                        t.free;
                      end;
                      if (formstyle \<\> fsstayontop) and active then
                      begin
                        tc := findvclwindow(cursorposition);
                        if tc=quirtviewer1 then quirtviewer1.setfocus;
                        if tc=quirtviewerupdcoronal then quirtviewerupdcoronal.setfocus;
                        if tc=quirtviewerupdsagittal then quirtviewerupdsagittal.setfocus;
                        if tc=quirtviewerupdtransversal then quirtviewerupdtransversal.setfocus;
                      end;
                      if xviischildwindow and (allowautofocus or quirtviewerupdcoronal.focused or
                        quirtviewerupdtransversal.focused or quirtviewerupdsagittal.focused)  then
                      begin
                        tc := findvclwindow(cursorposition);
                        if tc=quirtviewer1 then quirtviewer1.setfocus;
                        if tc=quirtviewerupdcoronal then quirtviewerupdcoronal.setfocus;
                        if tc=quirtviewerupdsagittal then quirtviewerupdsagittal.setfocus;
                        if tc=quirtviewerupdtransversal then quirtviewerupdtransversal.setfocus;
                      end;
                      quirtviewerupdtransversal.grid.make;
                      quirtviewerupdcoronal.grid.make;
                      quirtviewerupdsagittal.grid.make;
                      if quirtviewerupdtransversal.grid.ndim \<\> 2  then
                        quirtviewerupdtransversal.slicedir.value := 1
                      else
                        quirtviewerupdtransversal.slicedir.value := 3;
                      if quirtviewerupdcoronal.grid.ndim \<\> 2  then
                        quirtviewerupdcoronal.slicedir.value := 2
                      else
                        quirtviewerupdcoronal.slicedir.value := 3;
                      if quirtviewerupdsagittal.grid.ndim \<\> 2  then
                        quirtviewerupdsagittal.slicedir.value := 3
                      else
                        quirtviewerupdsagittal.slicedir.value := 3;
                      if quirtviewerupdcoronal.markerdots[1].empty then
                        s := \'\'
                      else
                        s := #10 + #27+chr(255)+#0+#0 + marker_overlay;
                      if      (quirtviewerupdcoronal.grid.ndim=2) and (quirtviewerupdcoronal.field[1].ndim=2) then
                        quirtviewerupdcoronal.text[4].value := text_planar + s
                      else if (quirtviewerupdcoronal.grid.ndim=2) and (quirtviewerupdcoronal.field[1].ndim=4) then
                        quirtviewerupdcoronal.text[4].value := text_motion + s
                      else
                        quirtviewerupdcoronal.text[4].value := format(slice_overlay, [quirtviewerupdcoronal.slice.value, quirtviewerupdcoronal.grid.dimensions[quirtviewerupdcoronal.slicedir.value-1]]) + s;
                      if      (quirtviewerupdsagittal.grid.ndim=2) and (quirtviewerupdsagittal.field[1].ndim=2) then
                        quirtviewerupdsagittal.text[3].value := text_planar
                      else if (quirtviewerupdsagittal.grid.ndim=2) and (quirtviewerupdsagittal.field[1].ndim=4) then
                        quirtviewerupdsagittal.text[3].value := text_motion
                      else
                        quirtviewerupdsagittal.text[3].value := format(slice_overlay, [quirtviewerupdsagittal.slice.value, quirtviewerupdsagittal.grid.dimensions[quirtviewerupdsagittal.slicedir.value-1]]);
                      if      (quirtviewerupdtransversal.grid.ndim=2) and (quirtviewerupdtransversal.field[1].ndim=2) then
                        quirtviewerupdtransversal.text[2].value := text_planar
                      else if (quirtviewerupdtransversal.grid.ndim=2) and (quirtviewerupdtransversal.field[1].ndim=4) then
                        quirtviewerupdtransversal.text[2].value := text_motion
                      else
                        quirtviewerupdtransversal.text[2].value := format(slice_overlay, [quirtviewerupdtransversal.slice.value, quirtviewerupdtransversal.grid.dimensions[quirtviewerupdtransversal.slicedir.value-1]]);
                      if not enabletestmode then
                      begin
                        if quirtviewerupdcoronal.grid.ndim = 2  then
                          quirtviewerupdcoronal.text[1].value := \'\'
                        else
                          quirtviewerupdcoronal.text[1].value := overlaycor;
                        if quirtviewerupdsagittal.grid.ndim = 2  then
                          quirtviewerupdsagittal.text[1].value := \'\'
                        else
                          quirtviewerupdsagittal.text[1].value := overlaysag;
                        if quirtviewerupdtransversal.grid.ndim = 2  then
                          quirtviewerupdtransversal.text[1].value := \'\'
                        else
                          quirtviewerupdtransversal.text[1].value := overlaytrans;
                      end
                      else
                      begin
                        if quirtviewerupdcoronal.grid.ndim = 2  then
                          quirtviewerupdcoronal.text[1].value := \'\'
                        else
                          quirtviewerupdcoronal.text[1].value := overlaycor + #10+ #27+ chr(255) + #1+ #1+ copy(xvi_version, 1, pos(\'(\', xvi_version) - 2);
                        if quirtviewerupdsagittal.grid.ndim = 2  then
                          quirtviewerupdsagittal.text[1].value := \'\'
                        else
                          quirtviewerupdsagittal.text[1].value := overlaysag + #10+ #27+ chr(255) + #1+ #1+ copy(xvi_version, 1, pos(\'(\', xvi_version) - 2);
                        if quirtviewerupdtransversal.grid.ndim = 2  then
                          quirtviewerupdtransversal.text[1].value := \'\'
                        else
                          quirtviewerupdtransversal.text[1].value := overlaytrans + #10+ #27+ chr(255) + #1+ #1+ copy(xvi_version, 1, pos(\'(\', xvi_version) - 2);
                      end;
                      quirtviewerupdcoronal.viewercaption.value     := overlaycor   + \' - \';
                      quirtviewerupdsagittal.viewercaption.value    := overlaysag   + \' - \';
                      quirtviewerupdtransversal.viewercaption.value := overlaytrans + \' - \';
                      myzoom := quirtviewerupdcoronal.zoom.value;
                      inc(countmakes);
                      v := nil;
                      if machine_to_machineadjust.ischangedby is tlightquirtviewerupd then
                        v := machine_to_machineadjust.ischangedby as tlightquirtviewerupd
                      else if prevmachine_to_machineadjust.ischangedby is tlightquirtviewerupd then
                        v := prevmachine_to_machineadjust.ischangedby as tlightquirtviewerupd;
                      if ((online[1].data.ndim=2) and (reversemotion.value=0)) then
                        if assigned(v) then
                         if machine_to_machineadjust.newerthan(v.viewtransform) then
                          begin
                            v.interpolate.value := 0;
                            v.make;
                            countmakes:=0;
                          end;
                      if (countmakes\>8) or (online[1].data.ndim\>2) or (reversemotion.value\<\>0) then
                      begin
                        quirtviewerupdcoronal.interpolate.value := 1;
                        quirtviewerupdsagittal.interpolate.value := 1;
                        quirtviewerupdtransversal.interpolate.value := 1;
                        quirtviewerupdsagittal.make;
                        quirtviewerupdcoronal.make;
                        quirtviewerupdtransversal.make;
                      end;
                      if checkboxrecordform.checked and (avihandle\>=0) then
                      begin
                        timer1.enabled := false;
                        formimage := getformimage;
                        formimage.pixelformat := pf24bit;
                        pixmap := tavsfield.createas(\'field 2d 3-vector byte\', [formimage.width, formimage.height]);
                        for i := 0 to formimage.height - 1 do
                          move( formimage.scanline[i]^,
                            pchar(cardinal(pixmap.data)+ cardinal(i * formimage.width * 3))^, formimage.width * 3);
                        formimage.free;
                        avi_write(pixmap, avihandle);
                        pixmap.free;
                        inc(avicount);
                        timer1.enabled := true;
                      end;
                    end;
                    dec(form1timer1enabled);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_174()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.changemachine_to_machineadjust(sender: tobject);
                  var     g, u: tavsfield;
                          f: ttransform;
                          rx, ry, rz: single;
                          i : integer;
                          v : tlightquirtviewerupd;
                  begin
                    if machine_to_machineadjust.ischangedby\<\>nil then
                    begin
                      begin
                        if not testmode and (alignmentmode.value\<\>2) then
                          invalidatecorrection;
                        matchadjusted := true;
                        end;
                      if alignmentmode.value=0 then
                        lastclipboxmatchresult := \'\'
                      else if alignmentmode.value=1 then
                        lastmaskmatchresult    := \'\';
                      manualmatchactive := true;
                    end;
                    v := nil;
                    if (machine_to_machineadjust.ischangedby is tlightquirtviewerupd) and
                       machine_to_machineadjust.newerthan(prevmachine_to_machineadjust) then
                    begin
                      v := machine_to_machineadjust.ischangedby as tlightquirtviewerupd;
                      machine_to_machineadjust.enabled := false;
                      f := ttransform.create;
                      u := tavsfield.create;
                      g := tavsfield.create;
                      if (comboboxmatch.text=match_man_rot_mrk) and not quirtviewerupdcoronal.markerdots[1].empty then i:=1
                      else                                                                                             i:=4;
                      transform_math(machine_to_machineadjust, prevmachine_to_machineadjust, f, false, true);
                      f.getrotationafterscaling(rx,ry,rz);
                      if (i=1) or ((abs(rx)+abs(ry)+abs(rz)) \> 1e-4) then
                      begin
                        transform_math(prevmachine_to_machineadjust, nil, g, true);
                        dotxfm(quirtviewerupdcoronal.markerdots[i], g, u);
                                                                                                              dotxfm(u, f, g);
                        eulerxfm(g, 0, 0, 0,
                            u.coordinate[0,0]-g.coordinate[0,0],
                            u.coordinate[1,0]-g.coordinate[1,0],
                            u.coordinate[2,0]-g.coordinate[2,0]);
                        transform_math(f, g, f);
                        transform_math(f, prevmachine_to_machineadjust, machine_to_machineadjust);
                      end;
                      f.free;
                      g.free;
                      u.free;
                      machine_to_machineadjust.enabled := true;
                    end;
                    prevmachine_to_machineadjust.assign(machine_to_machineadjust);
                    prevmachine_to_machineadjust.ischangedby := v;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_175()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.invalidatecorrection;
                  var f : tavsfield;
                      i : integer;
                  begin
                    labelcomputedlat2.caption := \'-\';
                    labelcomputedlong2.caption := \'-\';
                    labelcomputedheight2.caption := \'-\';
                    labelcomputedpitch2.caption := \'-\';
                    labelcomputedroll2.caption := \'-\';
                    labelcomputedyaw2.caption := \'-\';
                    labelcomputedlat2.hint := \'\';
                    labelcomputedlong2.hint := \'\';
                    labelcomputedheight2.hint := \'\';
                    labelcomputedpitch2.hint := \'\';
                    labelcomputedroll2.hint := \'\';
                    labelcomputedyaw2.hint := \'\';
                    labelcomputedlat2.enabled := false;
                    labelcomputedlong2.enabled := false;
                    labelcomputedheight2.enabled := false;
                    labelcomputedpitch2.enabled := false;
                    labelcomputedroll2.enabled := false;
                    labelcomputedyaw2.enabled := false;
                    if transform4d.getvalue([0,2*nclipbox,3,3])\>0.99 then
                    begin
                      f := tavsfield.createas(\'field 4d float\', [4, 4, 1, 1]);
                      field_setc(f,f,-1);
                      for i:=0 to max(0, min(onlinecube.dimensions[3]-1, transform4d.dimensions[3]-1)) do
                        field_insert2(transform4d, f, transform4d, 0, 0, 2*nclipbox, i);
                      invalidateregistrationbackup(2*nclipbox, 3*nclipbox-1);
                      f.free;
                    end;
                    for i:=1 to 6 do
                      colorstringgrid1.cellprops[3,i].box.checked := false;
                    if (comboboxcorrectionprotocol.text = correction_from_clipbox) then trackbarweight.position := 0
                    else trackbarweight.position := trackbarweight.max;
                    correctionapprovalby := \'\';
                    convertedtocorrections := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_176()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.changetransform4d(sender: tobject);
                  begin
                    buttonelektaaccept.caption := button_elekta_accept;
                    alignmentchanged := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_177()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.pagecontrol1change(sender: tobject);
                  begin
                    timer1timer(self);
                    if pagecontrol1.activepage=tabsheet4 then
                    begin
                      if gneedtogglebuttonloadreference then
                        togglebuttonloadreference;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_178()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.quirtviewerupdcoronalpanchanged(sender: tobject; x,
                    y: integer);
                  var ix, iy: integer;
                  begin
                    if not assigned(quirtviewerupdsagittal.grid) then exit;
                    quirtviewerupdsagittal.grid.make;
                    if quirtviewerupdsagittal.grid.ndim=2 then
                    begin
                      ix := round((quirtviewerupdsagittal.width -2)/2 - myzoom*quirtviewerupdsagittal.grid.dimensions[1]/2);
                      iy := round((quirtviewerupdsagittal.height-2)/2 - myzoom*quirtviewerupdsagittal.grid.dimensions[0]/2);
                    end
                    else
                    begin
                      ix := round((quirtviewerupdsagittal.width -2)/2 - myzoom*quirtviewerupdsagittal.grid.dimensions[2]/2);
                      iy := round((quirtviewerupdsagittal.height-2)/2 - myzoom*quirtviewerupdsagittal.grid.dimensions[0]/2);
                    end;
                    quirtviewerupdsagittal.panx.value := 99999;
                    quirtviewerupdsagittal.pany.value := 99999;
                    quirtviewerupdsagittal.panx.value := ix;
                    quirtviewerupdsagittal.pany.value := iy;
                    quirtviewerupdsagittal.zoom.value := myzoom;
                    quirtviewerupdcoronal.grid.make;
                    ix := round((quirtviewerupdcoronal.width -2)/2 - myzoom*quirtviewerupdcoronal.grid.dimensions[1]/2);
                    iy := round((quirtviewerupdcoronal.height-2)/2 - myzoom*quirtviewerupdcoronal.grid.dimensions[0]/2);
                    quirtviewerupdcoronal.panx.value := 99999;
                    quirtviewerupdcoronal.pany.value := 99999;
                    quirtviewerupdcoronal.panx.value := ix;
                    quirtviewerupdcoronal.pany.value := iy;
                    quirtviewerupdcoronal.zoom.value := myzoom;
                    quirtviewerupdtransversal.grid.make;
                    if quirtviewerupdtransversal.grid.ndim=2 then
                    begin
                      ix := round((quirtviewerupdtransversal.width -2)/2 - myzoom*quirtviewerupdtransversal.grid.dimensions[1]/2);
                      iy := round((quirtviewerupdtransversal.height-2)/2 - myzoom*quirtviewerupdtransversal.grid.dimensions[0]/2);
                    end
                    else
                    begin
                      ix := round((quirtviewerupdtransversal.width -2)/2 - myzoom*quirtviewerupdtransversal.grid.dimensions[1]/2);
                      iy := round((quirtviewerupdtransversal.height-2)/2 - myzoom*quirtviewerupdtransversal.grid.dimensions[2]/2);
                    end;
                    quirtviewerupdtransversal.panx.value := 99999;
                    quirtviewerupdtransversal.pany.value := 99999;
                    quirtviewerupdtransversal.panx.value := ix;
                    quirtviewerupdtransversal.pany.value := iy;
                    quirtviewerupdtransversal.zoom.value := myzoom;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_179()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.quirtviewerupdcoronalactiveclipboxchanged(sender: tobject);
                  begin
                   if (quirtviewerupdcoronal.activeclipbox.value \<\> 0) and (alignmentmode.value=0) then
                     begin
                       activeregion.value :=  quirtviewerupdcoronal.activeclipbox.value-1;
                       updownrois.position := activeregion.value;
                     end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_180()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonzoomclick(sender: tobject);
                  begin
                    myzoom := quirtviewerupdcoronal.zoom.value;
                    if sender=buttonzoomout then
                    begin
                      if      myzoom\>2.501 * zoomfix then myzoom := 2.5 * zoomfix
                      else if myzoom\>2.001 * zoomfix then myzoom := 2   * zoomfix
                      else if myzoom\>1.501 * zoomfix then myzoom := 1.5 * zoomfix
                      else if myzoom\>1.001 * zoomfix then myzoom := 1   * zoomfix
                      else if myzoom\>0.501 * zoomfix then myzoom := 0.5 * zoomfix;
                    end
                    else
                    begin
                      if      myzoom\<0.499 * zoomfix then myzoom := 0.5 * zoomfix
                      else if myzoom\<0.999 * zoomfix then myzoom := 1   * zoomfix
                      else if myzoom\<1.499 * zoomfix then myzoom := 1.5 * zoomfix
                      else if myzoom\<1.999 * zoomfix then myzoom := 2   * zoomfix
                      else if myzoom\<2.499 * zoomfix then myzoom := 2.5 * zoomfix
                      else if myzoom\<2.999 * zoomfix then myzoom := 3   * zoomfix;
                    end;
                    quirtviewerupdcoronalpanchanged(self, 0, 0);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_181()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttongenerateanglefilesclick(sender: tobject);
                  var
                    i: integer;
                    ini: tqinifile;
                    stgtdir: string;
                    ssection: string;
                    flex: tavsfield;
                  begin
                    stgtdir := edit1.text + \'\\patient_\' + patientid + \'\\images\\img_\' +
                               trimright(queryscans.fieldbyname(\'dicom_uid\').asstring) + \'\\reconstruction\\\';
                    queryframes.disablecontrols;
                    queryframes.first;
                    i:= 0;
                    while not queryframes.eof do
                    begin
                      ssection := format(\'%.4d\', [i]);
                      ini := tqinifile.create(stgtdir + \'angle.\' + ssection);
                      ini.erasesection(ssection);
                      ini.writestring(ssection, \'projectiondatafile\',
                        format(\'%.8x.his\', [strtointdef(queryframes.fieldbyname(\'dbid\').asstring, 0)]));
                      ini.writestring(ssection, \'angle\', queryframes.fieldbyname(\'proj_ang\').asstring);
                      queryframes.next;
                      if queryframes.eof then
                        ini.writestring(ssection, \'status\', \'1\')
                      else
                        ini.writestring(ssection, \'status\', \'0\');
                      ini.free;
                      inc(i);
                    end;
                    queryframes.first;
                    queryframes.enablecontrols;
                    flex := tavsfield.create;
                    createflexmapfromframedb(flex);
                    write_xdr(flex, stgtdir + \'flex.xdr\');
                    flex.free;
                    showmessage(generated_angle_and_flex + stgtdir)
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_182()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttongotoisocclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenu1.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_183()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.gotoisocenterclick(sender: tobject);
                  begin
                    quirtviewerupdsagittal.slice.maximum := 2000;
                    quirtviewerupdcoronal.slice.maximum := 2000;
                    quirtviewerupdtransversal.slice.maximum := 2000;
                    quirtviewerupdsagittal.slice.value :=  quirtviewerupdsagittal.grid.nearestpixel[2,0];
                    quirtviewerupdcoronal.slice.value := quirtviewerupdcoronal.grid.nearestpixel[1, 0];
                    quirtviewerupdtransversal.slice.value := quirtviewerupdtransversal.grid.nearestpixel[0, 0];
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_184()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.gotocorrectionreferencepointclick(sender: tobject);
                  begin
                    correctionreferencepoint.ischangedby := self;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_185()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.gotomarkerclick(sender: tobject);
                  begin
                    quirtviewerupdcoronal.markerdots[1].ischangedby := self;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_186()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.viewpoint1click(sender: tobject);
                  begin
                    quirtviewerupdcoronal.markerdots[3].ischangedby := self;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_187()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.plannedisoc1click(sender: tobject);
                  begin
                    quirtviewerupdcoronal.markerdots[4].ischangedby := self;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_188()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.centerofclipbox1click(sender: tobject);
                  begin
                    if alignmentmode.value=0 then
                    begin
                      quirtviewerupdcoronal.clipbox[activeregion.value+1].ischangedby := self;
                      quirtviewerupdcoronal.activeclipbox.value :=  activeregion.value+1;
                    end
                    else
                      quirtviewerupdcoronal.clipbox[1].ischangedby := self;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_189()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.centerofmask1click(sender: tobject);
                  begin
                    if referencemask.empty then exit;
                    visitcenterofmask;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_190()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.changeclipbox(sender: tobject);
                  var t, s, clipboxsender: tavsfield;
                  begin
                    clipboxsender := tavsfield(sender);
                    if clipboxsender.empty or (clipboxsender.ischangedby=nil) then exit;
                    if onlinecube.empty or (onlinecube.ndim=2) then exit;
                    t := tavsfield.create;
                    s := tavsfield.create;
                    if reversemotion.value\<\>0 then
                      eulerxfm(s)
                    else
                      transform_math(machine_to_machineadjust, nil, s, true);
                    cropbox_transform(clipboxsender, s, t);
                    if clipboxsender.ischangedby\<\>quirtviewerupdcoronal then quirtviewerupdcoronal.slice.value :=
                      quirtviewerupdcoronal.grid.nearestpixel[1, -(t.getvalue([4]) + t.getvalue([5]))/2];
                    if clipboxsender.ischangedby\<\>quirtviewerupdtransversal then quirtviewerupdtransversal.slice.value :=
                      quirtviewerupdtransversal.grid.nearestpixel[0, -(t.getvalue([2]) + t.getvalue([3]))/2];
                    if clipboxsender.ischangedby\<\>quirtviewerupdsagittal then quirtviewerupdsagittal.slice.value :=
                      quirtviewerupdsagittal.grid.nearestpixel[2, (t.getvalue([0]) + t.getvalue([1]))/2];
                    if (clipboxsender.ischangedby=quirtviewerupdcoronal) or
                       (clipboxsender.ischangedby=quirtviewerupdtransversal) or
                       (clipboxsender.ischangedby=quirtviewerupdsagittal) then
                    begin
                      makeregistrationbackup(0, nclipbox-1, 0, 9999);
                      invalidatecorrection;
                    end;
                    t.free;
                    s.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_191()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.changeclipboxtext(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_192()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonloadscanclick(sender: tobject);
                  var filename, t, uid, es: string;
                      save: tcursor;
                      oldres, i,j: integer;
                  begin
                    needloadscan := false;
                    if onlinecube.veclen\<\>0 then
                      oldres := onlinecube.dimensions[1]
                    else
                      oldres := 0;
                    if assigned(sf) then
                    begin
                      sl.caption := wait_loadloc;
                      sl.update;
                      sf.update;
                    end;
                    es  := exportedscan;
                    uid := scanuid;
                    if avlstate\>0 then
                    begin
                      if onlineoverlaystring\<\>\'\' then
                        quirtviewerupdtransversal.text[3].value := onlineoverlaystring
                      else
                        quirtviewerupdtransversal.text[3].value := online_overlay + scandate;
                    end;
                    buttonresetmatchclick(self);
                    begin
                      if not online[1].exists(reconfilebase, scanuid, \'image1\') and
                         not online[1].exists(reconfilebase, scanuid, \'scan\') then
                      begin
                        showmessage(recon_notfound);
                        exit;
                      end;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    try
                      if online[1].exists(reconfilebase, scanuid, \'image1\') then
                      begin
                        online[1].load(reconfilebase, scanuid, \'image1\');
                        online[2].load(reconfilebase, scanuid, \'image2\');
                        online[3].load(reconfilebase, scanuid, \'image3\');
                        reference[1].processing.value := 411;
                        online[1].processing.value := 411;
                        online[2].processing.value := 411;
                        online[3].processing.value := 411;
                        online[1].connectviewer(quirtviewerupdtransversal, 1);
                        online[2].connectviewer(quirtviewerupdsagittal, 1);
                        online[3].connectviewer(quirtviewerupdcoronal, 1);
                      end
                      else
                      begin
                        if online[1].exists(reconfilebase, scanuid, \'scan\') then
                          online[1].load(reconfilebase, scanuid, \'scan\')
                        else
                          online[1].load(filename, \'\', \'\');
                        if online[1].tomachine.empty then
                          online[1].tomachine.makerotation(270, 0, 270);
                        online[1].processing.value := 0;
                        reference[1].processing.value := 0;
                        online[1].connectviewer(quirtviewerupdsagittal, 1);
                        online[1].connectviewer(quirtviewerupdtransversal, 1);
                        online[1].connectviewer(quirtviewerupdcoronal, 1);
                      end;
                      if onlinecube.ndim=4 then
                      begin
                        t := online[1].readheader(\'#$$ph\');
                        if length(t) \<\> 0 then
                        begin
                          t := trimleft(t)+\' \';
                          field_create(phasehist,\'field 1d float\',onlinecube.dimensions[3]);
                          for i := 0 to onlinecube.dimensions[3]-1 do
                          begin
                            j := pos(\' \', t);
                            phasehist.setvalue([i],safestrtofloat(copy(t,0,j-1)));
                            t := trimleft(copy(t,j,250));
                          end;
                        end
                        else
                        begin
                          showmessage(warning_nophasehist);
                          field_create(phasehist,\'field 1d float\',onlinecube.dimensions[3]);
                          field_setc(phasehist,phasehist,1/phasehist.dimensions[0]);
                        end;
                      end;
                    finally
                      screen.cursor := save;
                    end;
                    quirtviewerupdtransversal.level[1].value       := 1000;
                    quirtviewerupdtransversal.level[1].maximum     := 2000;
                    quirtviewerupdtransversal.level[1].minimum     := 0;
                    quirtviewerupdtransversal.window[1].value      := 500;
                    quirtviewerupdtransversal.window[1].maximum     := 1000;
                    quirtviewerupdtransversal.window[1].minimum     := 0;
                    if oldres \<\> onlinecube.dimensions[1] then
                    begin
                      if onlinecube.dimensions[1]\<=128      then myzoom := 3    * zoomfix
                      else if onlinecube.dimensions[1]\<=256 then myzoom := 1.5  * zoomfix
                      else if onlinecube.dimensions[1]\<=400 then myzoom := 1.2  * zoomfix
                      else if onlinecube.dimensions[1]\<=512 then myzoom := 0.75 * zoomfix
                      else                                       myzoom := 1    * zoomfix;
                      quirtviewerupdcoronalpanchanged(self, 0, 0);
                      gotoisocenterclick(self);
                      viewpoint1click(self);
                    end;
                    scanuid := uid;
                    exportedscan := es;
                    if onlinecube.ndim=4 then buttonplay4dclick(bitbtnplaygreen);
                    comboboxregistrationprotocolchange(nil);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_193()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsavescanclick(sender: tobject);
                  var section: string;
                      i: tqinifile;
                  begin
                    if not saveonlinescan then exit;
                    if readonly then exit;
                    buttonloadscan.enabled := true;
                    quirtviewerupdtransversal.text[3].value := viewtext_online + scandate;
                    if not (sender=buttonreconstruct) then
                    begin
                      if synergymode then i := tqinifile.create(adminfilebase + plansopuid + \'.xvi\')
                      else i := tqinifile.create(adminfilebase + treatmentuid + \'.xvi\');
                      section := scanuid + \' \' + formatdatetime(\'yyyymmdd hh:nn:ss\', now) + \'.recon\';
                      i.erasesection(section);
                      i.writestring (section, \'version\',       xvi_version);
                      i.writestring (section, \'datetime\',      formatdatetime(\'yyyymmdd; hh:nn:ss\', now));
                      i.writestring (section, \'patientid\',     patientid);
                      i.writestring (section, \'treatmentid\',   treatmentid);
                      i.writestring (section, \'portid\',        portid);
                      i.writestring (section, \'scanuid\',       scanuid);
                      i.writestring (section, \'scandate\',      scandate);
                      i.writestring (section, \'scantime\',      scantime);
                      i.writestring (section, \'reconstruction\',scanuid + \'.scan\');
                      i.writestring (section, \'gain\',          gainfilename);
                      i.writestring (section, \'offset\',        offsetfilename);
                      i.writestring (section, \'badmap\',        \'\');
                      i.writestring (section, \'flexmap\',       flexmapfilename);
                      i.writestring (section, \'acqpars\',       acqpars);
                      i.writeinteger(section, \'recon_dimx\',    onlinecube.dimensions[0]);
                      i.writeinteger(section, \'recon_dimy\',    onlinecube.dimensions[1]);
                      i.writeinteger(section, \'recon_dimz\',    onlinecube.dimensions[2]);
                      i.writefloat  (section, \'recon_firstx\',  onlinecube.coordinate[0, 0]);
                      i.writefloat  (section, \'recon_firsty\',  onlinecube.coordinate[1, 0]);
                      i.writefloat  (section, \'recon_firstz\',  onlinecube.coordinate[2, 0]);
                      i.writefloat  (section, \'recon_lastx\',   onlinecube.coordinate[0, onlinecube.dimensions[0]-1]);
                      i.writefloat  (section, \'recon_lasty\',   onlinecube.coordinate[1, onlinecube.dimensions[1]-1]);
                      i.writefloat  (section, \'recon_lastz\',   onlinecube.coordinate[2, onlinecube.dimensions[2]-1]);
                      i.writestring (section, \'*\',            \'*****************************************************************\');
                      i.writestring (section, \'#\',            \'\');
                      i.updatefile;
                      i.free;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_194()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.saveonlinescan: boolean;
                  var fileheader, t1: string;
                      save: tcursor;
                      t: ttransform;
                      j: integer;
                  begin
                    result := false;
                    fileheader := #10 + \'kv=\'   + inttostr(scankv)+
                                   #10 + \'ma=\'   + inttostr(scanma)+
                                   #10 + \'ms=\'   + inttostr(scanms)+
                                   #10 + \'date=\' + copy(scandate, 1, 8)+
                                   #10 + \'time=\' + copy(scantime, 1, 6)+
                                   #10 + \'cd=\'   + caldir;
                    if true then
                    begin
                      fileheader := fileheader + #10 + \'df=\'   + offsetfilename;
                      t := ttransform.create;
                      t.assign(machine_to_siddon);
                      t.postmultiply(online_to_machine);
                      display_xfm(t, t1, 4);
                      for j:=1 to length(t1) do if t1[j]=#10 then t1[j]:=\' \';
                      fileheader := fileheader + #10 + \'#$$scantosiddon=\'+t1+#10+\'#$$matchtosiddon=\'+t1+#10;
                      t.free;
                      if (onlinecube.ndim=4) and (not phasehist.empty) then
                        fileheader := fileheader + #10 +\'#$$ph=\' + trimright(writematrix(phasehist, false));
                    end;
                    if ((online[1].data.ndim=2) and online[1].exists(reconfilebase, scanuid, \'image1\')) or
                       ((online[1].data.ndim\>2) and online[1].exists(reconfilebase, scanuid, \'scan\'))  then
                    begin
                      if messagedlg(recon_replace, mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                        exit;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    try
                      sysutils.forcedirectories(extractfilepath(reconfilebase));
                      if online[1].data.ndim=2 then
                      begin
                        online[1].delete(reconfilebase, scanuid, \'scan\');
                        online[1].save(reconfilebase, scanuid, \'image1\');
                        online[2].save(reconfilebase, scanuid, \'image2\');
                        online[3].save(reconfilebase, scanuid, \'image3\');
                      end
                      else
                      begin
                        online[1].delete(reconfilebase, scanuid, \'image1\');
                        online[1].delete(reconfilebase, scanuid, \'image2\');
                        online[1].delete(reconfilebase, scanuid, \'image3\');
                        online[1].headerstring := fileheader;
                        online[1].save(reconfilebase, scanuid, \'scan\');
                        online[1].headerstring := \'\';
                      end;
                    finally
                      screen.cursor := save;
                    end;
                    buttonloadscan.enabled := true;
                    quirtviewerupdtransversal.text[3].value := viewtext_online + scandate;
                    result := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_195()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.trackbartranslationlrchange(sender: tobject);
                  var t: ttransform;
                  var tx, ty, tz, rx, ry, rz: single;
                  begin
                    if locktrackerupdate then exit;
                    if safestrtofloat(edittranslationlr.text)\>1000 then edittranslationlr.text:=\'1000\';
                    if safestrtofloat(edittranslationlr.text)\<-1000 then edittranslationlr.text:=\'-1000\';
                    if safestrtofloat(edittranslationcc.text)\>1000 then edittranslationcc.text:=\'1000\';
                    if safestrtofloat(edittranslationcc.text)\<-1000 then edittranslationcc.text:=\'-1000\';
                    if safestrtofloat(edittranslationap.text)\>1000 then edittranslationap.text:=\'1000\';
                    if safestrtofloat(edittranslationap.text)\<-1000 then edittranslationap.text:=\'-1000\';
                    if not iec_angle_convention then
                    begin
                      if safestrtofloat(editrotationlr.text)\>180 then editrotationlr.text:=\'180\';
                      if safestrtofloat(editrotationlr.text)\<-180 then editrotationlr.text:=\'-180\';
                      if safestrtofloat(editrotationcc.text)\>180 then editrotationcc.text:=\'180\';
                      if safestrtofloat(editrotationcc.text)\<-180 then editrotationcc.text:=\'-180\';
                      if safestrtofloat(editrotationap.text)\>180 then editrotationap.text:=\'180\';
                      if safestrtofloat(editrotationap.text)\<-180 then editrotationap.text:=\'-180\';
                    end
                    else
                    begin
                      if safestrtofloat(editrotationlr.text)\>360 then editrotationlr.text:=\'360\';
                      if safestrtofloat(editrotationlr.text)\<0 then editrotationlr.text:=\'0\';
                      if safestrtofloat(editrotationcc.text)\>360 then editrotationcc.text:=\'360\';
                      if safestrtofloat(editrotationcc.text)\<0 then editrotationcc.text:=\'0\';
                      if safestrtofloat(editrotationap.text)\>360 then editrotationap.text:=\'360\';
                      if safestrtofloat(editrotationap.text)\<0 then editrotationap.text:=\'0\';
                    end;
                    t := ttransform.create;
                    rx := 0;
                    ry := 0;
                    rz := 0;
                    tx := -safestrtofloat(edittranslationlr.text);
                    ty := -safestrtofloat(edittranslationcc.text);
                    tz := -safestrtofloat(edittranslationap.text);
                    if checkboxenablerotation.checked then
                    begin
                      rx :=  safestrtofloat(editrotationlr.text);
                      ry := -safestrtofloat(editrotationcc.text);
                      rz :=  safestrtofloat(editrotationap.text);
                    end;
                    if sender is ttrackbar then
                    begin
                      if (sender as ttrackbar).tag=1 then tx := trackbartranslationlr.position / -10;
                      if (sender as ttrackbar).tag=2 then ty := trackbartranslationcc.position / -10;
                      if (sender as ttrackbar).tag=3 then tz := trackbartranslationap.position / 10;
                      if checkboxenablerotation.checked then
                      begin
                        if (sender as ttrackbar).tag=4 then rx := trackbarrotationlr.position /  4;
                        if (sender as ttrackbar).tag=5 then ry := trackbarrotationcc.position / -4;
                        if (sender as ttrackbar).tag=6 then rz := trackbarrotationap.position /  4;
                      end;
                    end;
                    tx := -tx;
                    ty := -ty;
                    tz := -tz;
                    rx := -rx;
                    ry := -ry;
                    rz := -rz;
                    t.maketranslationafterrotation(tx, ty, tz, rx, ry, rz);
                    t.invert;
                    tx := -tx;
                    ty := -ty;
                    tz := -tz;
                    rx := -rx;
                    ry := -ry;
                    rz := -rz;
                    locktrackerupdate := true;
                    if sender is ttrackbar then
                    begin
                      if (sender as ttrackbar).tag=1 then edittranslationlr.text := floattostrf(-tx, fffixed, 5, 2);
                      if (sender as ttrackbar).tag=2 then edittranslationcc.text := floattostrf(-ty, fffixed, 5, 2);
                      if (sender as ttrackbar).tag=3 then edittranslationap.text := floattostrf(-tz, fffixed, 5, 2);
                      if checkboxenablerotation.checked then
                      begin
                        if (sender as ttrackbar).tag=4 then
                        begin
                          if (iec_angle_convention) and (rx\<-0.005) then
                            editrotationlr.text := floattostrf( rx + 360, fffixed, 5, 1)
                          else
                            editrotationlr.text := floattostrf( rx, fffixed, 5, 1)
                        end;
                        if (sender as ttrackbar).tag=5 then
                        begin
                          if (iec_angle_convention) and (ry\>0.005) then
                            editrotationcc.text := floattostrf(-ry + 360, fffixed, 5, 1)
                          else
                            editrotationcc.text := floattostrf(-ry, fffixed, 5, 1);
                        end;
                        if (sender as ttrackbar).tag=6 then
                        begin
                          if (iec_angle_convention) and (rz\<-0.005) then
                            editrotationap.text := floattostrf( rz + 360, fffixed, 5, 1)
                          else
                            editrotationap.text := floattostrf( rz, fffixed, 5, 1);
                        end;
                      end;
                    end
                    else if sender is tedit then
                    begin
                      if (sender as tedit).tag=1 then trackbartranslationlr.position := round(-tx * 10);
                      if (sender as tedit).tag=2 then trackbartranslationcc.position := round(-ty * 10);
                      if (sender as tedit).tag=3 then trackbartranslationap.position := round( tz * 10);
                      if checkboxenablerotation.checked then
                      begin
                        if (sender as tedit).tag=4 then trackbarrotationlr.position := round( rx * 4);
                        if (sender as tedit).tag=5 then trackbarrotationcc.position := round(-ry * 4);
                        if (sender as tedit).tag=6 then trackbarrotationap.position := round( rz * 4);
                      end;
                    end;
                    locktrackerupdate := false;
                    machine_to_machineadjust.assign(t);
                    if not ( (sender = edittranslationlr) or (sender = edittranslationcc) or (sender = edittranslationap) or
                           (sender = editrotationlr) or (sender = editrotationcc) or (sender = editrotationap) ) then
                       machine_to_machineadjust.ischangedby := sender;
                    quirtviewerupdcoronal.viewtransform.make;
                    quirtviewerupdsagittal.viewtransform.make;
                    quirtviewerupdtransversal.viewtransform.make;
                    t.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_196()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.edittranslationlrexit(sender: tobject);
                  begin
                    if locktrackerupdate then exit;
                    machine_to_machineadjust.ischangedby := sender;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_197()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.edittranslationlrkeydown(sender: tobject; var key: word;
                    shift: tshiftstate);
                  begin
                    timer4d.enabled := false;
                    if key=vk_return then edittranslationlrexit(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_198()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updowntranslationlrclick(sender: tobject; button: tudbtntype);
                  var incr, v: double;
                  begin
                    if button=btnext then incr := 0.1 else incr := -0.1;
                    if sender=updowntranslationlr then edittranslationlr.text := format(\'%.2f\', [safestrtofloat(edittranslationlr.text)+incr]);
                    if sender=updowntranslationcc then edittranslationcc.text := format(\'%.2f\', [safestrtofloat(edittranslationcc.text)+incr]);
                    if sender=updowntranslationap then edittranslationap.text := format(\'%.2f\', [safestrtofloat(edittranslationap.text)+incr]);
                    if button=btnext then incr := 1 else incr := -1;
                    if not iec_angle_convention then
                    begin
                      if sender=updownrotationlr then editrotationlr.text := format(\'%.1f\', [safestrtofloat(editrotationlr.text)+incr]);
                      if sender=updownrotationcc then editrotationcc.text := format(\'%.1f\', [safestrtofloat(editrotationcc.text)+incr]);
                      if sender=updownrotationap then editrotationap.text := format(\'%.1f\', [safestrtofloat(editrotationap.text)+incr]);
                    end
                    else
                    begin
                      v := 0;
                      if sender=updownrotationlr then v := safestrtofloat(editrotationlr.text)+incr + 360;
                      if sender=updownrotationcc then v := safestrtofloat(editrotationcc.text)+incr + 360;
                      if sender=updownrotationap then v := safestrtofloat(editrotationap.text)+incr + 360;
                      while v\>360 do v := v-360;
                      if sender=updownrotationlr then editrotationlr.text := format(\'%.1f\', [v]);
                      if sender=updownrotationcc then editrotationcc.text := format(\'%.1f\', [v]);
                      if sender=updownrotationap then editrotationap.text := format(\'%.1f\', [v]);
                    end;
                    manualmatchactive := true;
                    matchadjusted := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_199()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.checkboxenablerotationclick(sender: tobject);
                  begin
                    trackbartranslationlrchange(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_200()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonresetmatchclick(sender: tobject);
                  var
                    f : tavsfield;
                    activereg: integer;
                  begin
                    invalidatecorrection;
                    if alignmentmode.value=0 then
                      activereg := activeregion.value
                    else
                      activereg := nclipbox+maskactiveregion.value;
                    if (radiobuttoncurrentroi.checked or radiobuttoncurrentframe.checked) and (sender = buttonresetmatch) then
                    begin
                      case 2*ord(radiobuttoncurrentroi.checked) + ord(radiobuttoncurrentframe.checked) of
                        2: begin
                             eulerxfm(machine_to_machineadjust);
                              externalmanualmatchto4d(-1, activereg);
                              makeregistrationbackup(activereg, activereg, 0, 9999);
                           end;
                        1: begin
                             eulerxfm(machine_to_machineadjust);
                             externalmanualmatchto4d(quirtviewerupdcoronal.frame.value, activereg);
                             makeregistrationbackup(alignmentmode.value*nclipbox, alignmentmode.value*nclipbox + nclipbox-1, quirtviewerupdcoronal.frame.value, quirtviewerupdcoronal.frame.value);
                           end;
                        3: begin
                             eulerxfm(machine_to_machineadjust);
                             externalmanualmatchto4d(quirtviewerupdcoronal.frame.value, activereg);
                             makeregistrationbackup(activereg, activereg, quirtviewerupdcoronal.frame.value, quirtviewerupdcoronal.frame.value);
                           end;
                      end;
                      exit;
                    end;
                    eulerxfm(machine_to_machineadjust);
                    if (sender = buttonresetmatch) and not transform4d.empty then
                    begin
                      f := tavsfield.create;
                      field_create(f, \'field 4d float\', 4, 4, nclipbox, max(onlinecube.dimensions[3], 1));
                      field_setc(f,f,-1);
                      field_insert2(transform4d, f, transform4d, 0, 0, alignmentmode.value*nclipbox, 0);
                      f.free;
                      makeregistrationbackup(alignmentmode.value * nclipbox, alignmentmode.value * nclipbox + nclipbox -1, 0, 9999);
                    end;
                    comboboxtransformmode.itemindex := 0;
                    quirtviewerupdcoronal.warp[1].clear;
                    quirtviewerupdcoronal.warp[6].clear;
                    quirtviewerupdcoronal.viewwarp.clear;
                    oldmachine_to_machineadjust.clear;
                    if (sender \<\> buttonresetmatch) or (comboboxregistrationprotocol.itemindex in [0,1,4,5]) then
                    begin
                      transform4d.clear;
                      makeregistrationbackup(0, 9999, 0, 9999);
                    end
                    else
                    begin
                      if alignmentmode.value=0 then
                      begin
                        if messagedlg(message_reset_maskaswell, mtconfirmation, [mbyes, mbno], 0) = mryes then
                        begin
                          transform4d.clear;
                          makeregistrationbackup(0, 9999, 0, 9999);
                        end;
                      end;
                      if alignmentmode.value=1 then
                      begin
                        if messagedlg(message_reset_clipboxaswell, mtconfirmation, [mbyes, mbno], 0) = mryes then
                        begin
                          transform4d.clear;
                          makeregistrationbackup(0, 9999, 0, 9999);
                        end;
                        tabcontrol1.tabindex := 0;
                        tabcontrol1change(self);
                      end;
                    end;
                    vistransform4d2.clear;
                    lastmatchresult := \'\';
                    lastclipboxmatchresult := \'\';
                    lastmaskmatchresult    := \'\';
                    onlinetoreftransformmatched := \'\';
                    matchadjusted   := false;
                    matchrotation   := true;
                    bonetumormatchstatus := 0;
                    loadbonematch.checked:=false;
                    loadtumormatch.checked := false;
                    loadacceptedmatch.checked := false;
                    loadedalignmentdatachanged := true;
                    convertedtocorrections := false;
                    converted4dtomean := false;
                    edittranslationlr.imename := \'\';
                    edittranslationcc.imename := \'\';
                    edittranslationap.imename := \'\';
                    editrotationlr.imename := \'\';
                    editrotationcc.imename := \'\';
                    editrotationap.imename := \'\';
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_201()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.savesettings(i: tqinifile; mode: safesettingmode; initials: string; approval : boolean = false);
                  var tx, ty, tz, rx, ry, rz: string;
                      a, x: tavsfield;
                      s, t, section, str1: string;
                      j, k: integer;
                      t1: ttransform;
                      date_time :  tdatetime;
                  begin
                    date_time := now;
                    if mode in  [elektaref, elektaalign, elektareconalign, avlref, avlstrippedref, avlalign, avlrefr, avlalignr] then
                    begin
                      if mode in [elektaref, elektaalign, elektareconalign] then
                        section := \'reference\'
                      else if mode in [avlref, avlstrippedref] then
                        section := \'xvi\'
                      else if mode in [avlalign] then
                      begin
                        if comboboxregistrationprotocol.itemindex in [4,5] then
                          section := scanuid + \'.alignart\'
                        else
                          section := scanuid + \'.align\';
                      end
                      else if mode in [avlalignr] then
                      begin
                        if comboboxregistrationprotocol.itemindex in [4,5] then
                          section := scanuid + \'.alignart\' + \'.research.\' + formatdatetime(\'yyyymmdd_hhnnss\', date_time)
                        else
                          section := scanuid + \'.align\' + \'.research.\' + formatdatetime(\'yyyymmdd_hhnnss\', date_time);
                      end
                      else if mode in [avlrefr] then
                      begin
                        s := sectionselector(i, \'xvi\' , avlrefr);
                        if s=\'\' then exit;
                        j := pos(#13,s);
                        section := copy(s,0,j-1);
                        initials := copy(s,j+1,250);
                      end;
                      if i.sectionexists(section) then
                      begin
                        str1 := i.readstring(section, \'datetime\', formatdatetime(\'yyyymmdd_hhnnss\', now));
                        inifilecopysection(i, section, section + \'.\' + str1);
                        i.erasesection(section);
                      end;
                    end;
                    if mode in  [elektaref] then
                    begin
                      i.writebool(  \'reference\', \'referenceapprovalstatus\', approval);
                      i.writestring(\'reference\', \'referenceapprovaldate\', formatdatetime(\'yyyymmdd\', date_time));
                      i.writestring(\'reference\', \'referenceapprovaltime\', formatdatetime(\'hh:nn:ss\', date_time));
                      i.writestring(\'reference\', \'referenceapprovalby\',   initials);
                    end;
                    if mode in  [elektarecon, elektareconalign] then
                    begin
                      i.writebool(  \'reconstruction\', \'reconstructionapprovalstatus\',  approval);
                      i.writebool(  \'reconstruction\', \'reconstructioncompletedstatus\', reconstructioncompletedstatus);
                      i.writestring(\'reconstruction\', \'reconstructiondate\',            formatdatetime(\'yyyymmdd\', date_time));
                      i.writestring(\'reconstruction\', \'reconstructiontime\',            formatdatetime(\'hh:nn:ss\', date_time));
                    end;
                    if mode in [elektaref, elektaalign, elektareconalign, avlref, avlstrippedref, avlalign, avlrefr, avlalignr] then
                    begin
                      if mode in [elektaref, elektaalign, elektareconalign] then
                        i.writestring (section, \'avlversion\',  xvi_version)
                      else
                        i.writestring (section, \'version\',  xvi_version);
                      i.writestring (section, \'datetime\',    formatdatetime(\'yyyymmdd; hh:nn:ss\', date_time));
                      if mode in [avlref, avlalign, avlrefr, avlalignr] then
                        i.writestring (section, \'signature\',   initials)
                      else if mode in [avlstrippedref] then
                        i.writestring (\'xvi\', \'signature\',       i.readstring (\'xvi\', \'signature\',\'\') + \' modified by \' + initials);
                      if mode in [avlrefr] then
                        i.writestring(section, \'referencecomment\', initials);
                      i.writebool   (section, \'showscan\',        checkboxscan.checked);
                      i.writebool   (section, \'showallscan\',     showall1.checked);
                      if (not beamdots.empty) and (beamdots.dimensions[0]\>1) then
                        i.writebool   (section, \'showplan\',        checkboxplan.checked);
                      i.writebool   (section, \'showdelineation\', checkboxdelineation.checked);
                      i.writebool   (section, \'showroi\',         checkboxroi.checked);
                      if not referencemask.empty then
                      begin
                        i.writebool   (section, \'showmask\',        checkboxreferencemask.checked);
                        i.writefloat  (section, \'maskmargin\',      maskmargin);
                        i.writestring (section, \'maskdelineation\', maskdelineation);
                        i.writeinteger(section, \'masklevel\',       masklevel);
                        i.writeinteger(section, \'maskwindow\',      maskwindow);
                        i.writestring (section, \'maskid\',          maskid);
                        i.writebool   (section, \'maskedited\',      maskedited);
                      end;
                    i.writeinteger(section, \'sliceaveraging\',  comboboxsliceaveraging.itemindex);
                      if mode in [elektaalign, elektareconalign, avlalign, avlalignr] then
                      begin
                        i.writestring (section, \'registrationprotocol\',   appliedcorrectionprotocol);
                        i.writestring (section, \'correctionfromprotocol\', appliedcorrectionfrom);
                        i.writestring (section, \'correctionbyprotocol\',   appliedcorrectionby);
                        i.writestring (section, \'clipboxmatchmethod\', appliedclipboxmatchmethod);
                        i.writestring (section, \'maskmatchmethod\',    appliedmaskmatchmethod);
                      end
                      else if mode in [elektaref, avlref, avlrefr] then
                      begin
                        i.writestring (section, \'registrationprotocol\',   comboboxregistrationprotocol.mappedtext);
                        i.writestring (section, \'correctionfromprotocol\', comboboxcorrectionprotocol.mappedtext);
                        i.writestring (section, \'clipboxmatchmethod\', comboboxclipboxmatch.mappedtext);
                        i.writestring (section, \'maskmatchmethod\',    comboboxmaskmatch.mappedtext);
                        i.writestring (section, \'correctionbyprotocol\',   comboboxcorrectionby.mappedtext);
                      end
                      else if mode in [avlstrippedref] then
                      begin
                        i.writestring (section, \'clipboxmatchmethod\', comboboxclipboxmatch.mappedtext);
                        i.writestring (section, \'maskmatchmethod\',    comboboxmaskmatch.mappedtext);
                      end;
                      if mode in [avlref, avlalign, avlrefr, avlalignr, elektaref] then
                      begin
                        i.deletekey (section, \'clipboxtranslationlimitsidentical\');
                        i.deletekey (section, \'clipboxrotationlimitsidentical\');
                        i.deletekey (section, \'masktranslationlimitsidentical\');
                        i.deletekey (section, \'maskrotationlimitsidentical\');
                        if comboboxregistrationprotocol.itemindex in [0, 2, 3, 4] then
                        begin
                        i.writebool (section, \'clipboxtranslationlimitsidentical\', colorstringgrid2.cellprops[1,0].box.checked);
                        i.writebool (section, \'clipboxrotationlimitsidentical\', colorstringgrid2.cellprops[1,4].box.checked);
                        end;
                        if comboboxregistrationprotocol.itemindex in [1, 2, 3, 5] then
                        begin
                        i.writebool (section, \'masktranslationlimitsidentical\', colorstringgrid3.cellprops[1,0].box.checked);
                        i.writebool (section, \'maskrotationlimitsidentical\', colorstringgrid3.cellprops[1,4].box.checked);
                        end;
                        i.deletekey (section, \'clipboxtranslationwarnlimit\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitright\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitleft\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitinf\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitsup\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitpost\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitant\');
                        i.deletekey (section, \'clipboxrotationwarnlimit\');
                        i.deletekey (section, \'clipboxrotationwarnlimitlr_cc\');
                        i.deletekey (section, \'clipboxrotationwarnlimitlr_cw\');
                        i.deletekey (section, \'clipboxrotationwarnlimitsi_cc\');
                        i.deletekey (section, \'clipboxrotationwarnlimitsi_cw\');
                        i.deletekey (section, \'clipboxrotationwarnlimitap_cc\');
                        i.deletekey (section, \'clipboxrotationwarnlimitap_cw\');
                        if comboboxregistrationprotocol.itemindex in [0, 2, 3, 4] then
                        begin
                        if  colorstringgrid2.cellprops[1,0].box.checked then
                          begin
                            i.writestring (section, \'clipboxtranslationwarnlimit\', colorstringgrid2.cells[2,1]);
                          end
                        else
                        begin
                          i.writestring (section, \'clipboxtranslationwarnlimitright\', colorstringgrid2.cells[1,1]);
                          i.writestring (section, \'clipboxtranslationwarnlimitleft\', colorstringgrid2.cells[2,1]);
                          i.writestring (section, \'clipboxtranslationwarnlimitinf\', colorstringgrid2.cells[1,2]);
                          i.writestring (section, \'clipboxtranslationwarnlimitsup\', colorstringgrid2.cells[2,2]);
                          i.writestring (section, \'clipboxtranslationwarnlimitpost\', colorstringgrid2.cells[1,3]);
                          i.writestring (section, \'clipboxtranslationwarnlimitant\', colorstringgrid2.cells[2,3]);
                        end;
                        if  colorstringgrid2.cellprops[1,4].box.checked then
                          begin
                            i.writestring (section, \'clipboxrotationwarnlimit\',    colorstringgrid2.cells[2,5]);
                          end
                        else
                        begin
                          i.writestring (section, \'clipboxrotationwarnlimitlr_cc\', colorstringgrid2.cells[1,5]);
                          i.writestring (section, \'clipboxrotationwarnlimitlr_cw\', colorstringgrid2.cells[2,5]);
                          i.writestring (section, \'clipboxrotationwarnlimitsi_cc\', colorstringgrid2.cells[1,6]);
                          i.writestring (section, \'clipboxrotationwarnlimitsi_cw\', colorstringgrid2.cells[2,6]);
                          i.writestring (section, \'clipboxrotationwarnlimitap_cc\', colorstringgrid2.cells[1,7]);
                          i.writestring (section, \'clipboxrotationwarnlimitap_cw\', colorstringgrid2.cells[2,7]);
                        end;
                        end;
                        i.deletekey (section, \'masktranslationwarnlimit\');
                        i.deletekey (section, \'masktranslationwarnlimitright\');
                        i.deletekey (section, \'masktranslationwarnlimitleft\');
                        i.deletekey (section, \'masktranslationwarnlimitinf\');
                        i.deletekey (section, \'masktranslationwarnlimitsup\');
                        i.deletekey (section, \'masktranslationwarnlimitpost\');
                        i.deletekey (section, \'masktranslationwarnlimitant\');
                        i.deletekey (section, \'maskrotationwarnlimit\');
                        i.deletekey (section, \'maskrotationwarnlimitlr_cc\');
                        i.deletekey (section, \'maskrotationwarnlimitlr_cw\');
                        i.deletekey (section, \'maskrotationwarnlimitsi_cc\');
                        i.deletekey (section, \'maskrotationwarnlimitsi_cw\');
                        i.deletekey (section, \'maskrotationwarnlimitap_cc\');
                        i.deletekey (section, \'maskrotationwarnlimitap_cw\');
                        if comboboxregistrationprotocol.itemindex in [1, 2, 3, 5] then
                        begin
                        if  colorstringgrid3.cellprops[1,0].box.checked then
                          begin
                            i.writestring (section, \'masktranslationwarnlimit\',    colorstringgrid3.cells[2,1]);
                          end
                        else
                        begin
                          i.writestring (section, \'masktranslationwarnlimitright\', colorstringgrid3.cells[1,1]);
                          i.writestring (section, \'masktranslationwarnlimitleft\', colorstringgrid3.cells[2,1]);
                          i.writestring (section, \'masktranslationwarnlimitinf\', colorstringgrid3.cells[1,2]);
                          i.writestring (section, \'masktranslationwarnlimitsup\', colorstringgrid3.cells[2,2]);
                          i.writestring (section, \'masktranslationwarnlimitpost\', colorstringgrid3.cells[1,3]);
                          i.writestring (section, \'masktranslationwarnlimitant\', colorstringgrid3.cells[2,3]);
                        end;
                        if  colorstringgrid3.cellprops[1,4].box.checked then
                          begin
                            i.writestring (section, \'maskrotationwarnlimit\',       colorstringgrid3.cells[2,5]);
                          end
                        else
                        begin
                          i.writestring (section, \'maskrotationwarnlimitlr_cc\', colorstringgrid3.cells[1,5]);
                          i.writestring (section, \'maskrotationwarnlimitlr_cw\', colorstringgrid3.cells[2,5]);
                          i.writestring (section, \'maskrotationwarnlimitsi_cc\', colorstringgrid3.cells[1,6]);
                          i.writestring (section, \'maskrotationwarnlimitsi_cw\', colorstringgrid3.cells[2,6]);
                          i.writestring (section, \'maskrotationwarnlimitap_cc\', colorstringgrid3.cells[1,7]);
                          i.writestring (section, \'maskrotationwarnlimitap_cw\', colorstringgrid3.cells[2,7]);
                        end;
                      end;
                      end;
                      case comboboxdisplaymode.itemindex of
                        0: s := \'greenpurple\';
                        1: s := \'cut\';
                        2: s := \'onlineonly\';
                        3: s := \'referenceonly\';
                      end;
                      i.writestring(section, \'displaymode\', s);
                      k := 1;
                      if not delineationdotslut.empty then
                      for j:=0 to delineationdotslut.dimensions[0]-1 do
                      begin
                          dil_get_name(delineationdotslut, s, j);
                          if (s\<\>\'\') and (round(delineationdotslut.getvalue([j, 27]))=0) then
                          begin
                           i.writestring(section, \'displaystructure\'+inttostr(k), s);
                           inc(k);
                          end
                          else
                          begin
                           i.writestring(section, \'displaystructure\'+inttostr(k), \'.\');
                           inc(k);
                          end;
                      end;
                      if k=1 then i.writestring(section, \'displaystructure\'+inttostr(k), \'-- none --\');
                      for j:=1 to high(online) do
                        if not online[j].data.empty then
                        begin
                          i.writeinteger(section, \'online\'+inttostr(j)+\'.level\',  round(online[j].level.value));
                          i.writeinteger(section, \'online\'+inttostr(j)+\'.window\', round(online[j].window.value));
                        end;
                      if (onlinecube.empty or (onlinecube.veclen=0)) then
                      begin
                        i.writeinteger(section, \'online1.level\',   round(reference[1].level.value));
                        i.writeinteger(section, \'online1.window\',  round(reference[1].window.value));
                      end;
                      for j:=1 to high(reference) do
                        if not reference[j].data.empty then
                        begin
                          i.writeinteger(section, \'reference\'+inttostr(j)+\'.level\',  round(reference[j].level.value));
                          i.writeinteger(section, \'reference\'+inttostr(j)+\'.window\', round(reference[j].window.value));
                        end;
                      i.writefloat  (section, \'zoom\', myzoom * 0.1 / abs(quirtviewerupdtransversal.grid.coordinate[0, 1] - quirtviewerupdtransversal.grid.coordinate[0, 0]));
                      a := tavsfield.createas(\'field 1d 3-space irregular\', [1]);
                      x := tavsfield.create;
                      a.coordinate[0,0] := quirtviewerupdtransversal.grid.coordinate[0, quirtviewerupdtransversal.slice.value];
                      a.coordinate[1,0] := quirtviewerupdcoronal.grid.coordinate[1, quirtviewerupdcoronal.slice.value];
                      a.coordinate[2,0] := quirtviewerupdsagittal.grid.coordinate[2, quirtviewerupdsagittal.slice.value];
                      x.assign(quirtviewerupdcoronal.viewtransform);
                      transform_math(x, nil, x, true);
                      dotxfm(a, x, a);
                      i.writefloat  (section, \'viewpointx\', a.coordinate[0,0]);
                      i.writefloat  (section, \'viewpointy\', a.coordinate[1,0]);
                      i.writefloat  (section, \'viewpointz\', a.coordinate[2,0]);
                      a.free;
                      x.free;
                      i.deletekey  (\'xvi\', \'markerset\');
                      i.deletekey  (\'xvi\', \'markerx\');
                      i.deletekey  (\'xvi\', \'markery\');
                      i.deletekey  (\'xvi\', \'markerz\');
                      i.deletekey  (section, \'markerset\');
                      i.deletekey  (section, \'markerx\');
                      i.deletekey  (section, \'markery\');
                      i.deletekey  (section, \'markerz\');
                      if not quirtviewerupdcoronal.markerdots[1].empty then
                      begin
                        i.writebool  (\'xvi\', \'markerset\', true);
                        i.writefloat  (\'xvi\', \'markerx\', quirtviewerupdcoronal.markerdots[1].coordinate[0,0]);
                        i.writefloat  (\'xvi\', \'markery\', quirtviewerupdcoronal.markerdots[1].coordinate[1,0]);
                        i.writefloat  (\'xvi\', \'markerz\', quirtviewerupdcoronal.markerdots[1].coordinate[2,0]);
                      end;
                    i.deletekey  (section, \'clip1x1\');
                      i.deletekey  (section, \'clip1x2\');
                      i.deletekey  (section, \'clip1y1\');
                      i.deletekey  (section, \'clip1y2\');
                      i.deletekey  (section, \'clip1z1\');
                      i.deletekey  (section, \'clip1z2\');
                      i.deletekey  (section, \'clip1locked\');
                      if not clipbox[1].empty then
                      begin
                      end;
                      clipboxlist.make;
                      for j:=1 to nclipbox do
                      begin
                        i.deletekey(section, \'clip\'+inttostr(j));
                        if clipbox[j].empty then continue;
                        s := format(\'%f, %f, %f, %f, %f, %f, %s, %f, %s\',
                        [clipbox[j].getvalue([0]), clipbox[j].getvalue([1]), clipbox[j].getvalue([2]),
                         clipbox[j].getvalue([3]), clipbox[j].getvalue([4]), clipbox[j].getvalue([5]),
                         cbnames[j-1],
                         cbweights[j],
                         \'bone\']);
                        i.writestring(section, \'clip\'+inttostr(j),  s);
                      end;
                      i.writebool   (section, \'clipboxlocked\', clipbox[1].locked);
                      if mode in [elektaref, elektaalign, elektareconalign] then
                      begin
                        x := tavsfield.create;
                        t1 := ttransform.create;
                        t1.makerotation(270, 0, 270); t1.invert;
                        i.deletekey  (section, \'clipboxx1\');
                        i.deletekey  (section, \'clipboxx2\');
                        i.deletekey  (section, \'clipboxy1\');
                        i.deletekey  (section, \'clipboxy2\');
                        i.deletekey  (section, \'clipboxz1\');
                        i.deletekey  (section, \'clipboxz2\');
                        i.deletekey  (section, \'clipboxlocked\');
                      t1.free;
                        x.free;
                      end;
                      if not (mode in [avlstrippedref]) then
                      begin
                        i.writefloat  (section, \'isocx\',  machine_to_siddon.getvalue([3, 0]));
                        i.writefloat  (section, \'isocy\',  machine_to_siddon.getvalue([3, 1]));
                        i.writefloat  (section, \'isocz\',  machine_to_siddon.getvalue([3, 2]));
                        i.writeinteger(section, \'correctionreferencepointmode\',strtoint(correctionreferencepoint.debugname));
                        i.writefloat  (section, \'correctionreferencepointx\',   correctionreferencepoint.coordinate[0,0]);
                        i.writefloat  (section, \'correctionreferencepointy\',   correctionreferencepoint.coordinate[1,0]);
                        i.writefloat  (section, \'correctionreferencepointz\',   correctionreferencepoint.coordinate[2,0]);
                        i.writestring (section, \'correctionreferencepointstructure\', correctionreferencepointstructure);
                      end;
                    end;
                    if mode in  [elektaalign, elektareconalign, avlalign, avlalignr] then
                    begin
                      if mode in [elektaalign, elektareconalign] then
                      begin
                        section := \'alignment\';
                        if i.sectionexists(section) then
                        begin
                          str1 := i.readstring(section, \'datetime\', formatdatetime(\'yyyymmdd_hhnnss\', now));
                          inifilecopysection(i, section, section + \'.\' + str1);
                          i.erasesection(section);
                        end;
                      end;
                      i.writebool(  section, \'alignmentapprovalstatus\',  approval);
                      i.writestring(section, \'alignmentapprovaldate\',    formatdatetime(\'yyyymmdd\', date_time));
                      i.writestring(section, \'alignmentapprovaltime\',    formatdatetime(\'hh:nn:ss\', date_time));
                      i.writestring(section, \'alignmentapprovalby\',      initials);
                      i.writebool(  section, \'correctionapprovalstatus\',  approval);
                      i.writestring(section, \'correctionapprovaldate\',    formatdatetime(\'yyyymmdd\', date_time));
                      i.writestring(section, \'correctionapprovaltime\',    formatdatetime(\'hh:nn:ss\', date_time));
                      if (correctionapprovalby=\'\') or (correctionapprovalby=\'*\') then correctionapprovalby := initials;
                      i.writestring(section, \'correctionapprovalby\',      correctionapprovalby);
                      if mode in [elektaalign, elektareconalign] then
                        i.writestring (section, \'avlversion\',  xvi_version)
                      else
                        i.writestring (section, \'version\',  xvi_version);
                      i.writestring (section, \'datetime\',    formatdatetime(\'yyyymmdd; hh:nn:ss\', date_time));
                      if mode in [avlalign, avlalignr] then
                      begin
                        i.writestring (section, \'reconstruction\',  scanuid + \'.scan\');
                        i.writestring (section, \'scandate\',      scandate);
                        i.writestring (section, \'scantime\',      scantime);
                      end;
                      for k:=1 to nclipbox do
                      begin
                        if (i.readstring(section, \'align.clip\'+inttostr(k), \'\') = \'\') then break;
                        i.deletekey   (section, \'align.clip\'+inttostr(k));
                        for j:=0 to 100 do
                        begin
                          if (i.readstring(section, \'align.clip\'+inttostr(k)+\'.frame\'+inttostr(j), \'\') = \'\') then break;
                          i.deletekey   (section, \'align.clip\'+inttostr(k)+\'.frame\'+inttostr(j));
                        end;
                      end;
                      for k:=1 to nclipbox do
                      begin
                        if (i.readstring(section, \'align.mask\'+inttostr(k), \'\') = \'\') then break;
                        i.deletekey   (section, \'align.mask\'+inttostr(k));
                        for j:=0 to 100 do
                        begin
                          if (i.readstring(section, \'align.mask\'+inttostr(k)+\'.frame\'+inttostr(j), \'\') = \'\') then break;
                          i.deletekey   (section, \'align.mask\'+inttostr(k)+\'.frame\'+inttostr(j));
                        end;
                      end;
                      for k:=1 to nclipbox do
                      begin
                        unpackregistration(k-1, -1, tx, ty, tz, rx, ry, rz, s);
                        if s\<\>\'\' then i.writestring (section, \'align.clip\'+inttostr(k), s);
                        if (pos(match_substring_4d, appliedclipboxmatchmethod)\>0) and (scanis4d) then
                          for j:=0 to onlinecube.dimensions[3]-1 do
                        begin
                          unpackregistration(k-1, j, tx, ty, tz, rx, ry, rz, s);
                          if s\<\>\'\' then i.writestring (section, \'align.clip\'+inttostr(k)+\'.frame\'+inttostr(j), s);
                        end;
                      end;
                      for k:=1 to nclipbox do
                      begin
                        unpackregistration(nclipbox+k-1, -1, tx, ty, tz, rx, ry, rz, s);
                        if s\<\>\'\' then i.writestring (section, \'align.mask\'+inttostr(k), s);
                        if (pos(match_substring_4d, appliedmaskmatchmethod)\>0) and (scanis4d) then
                          for j:=0 to onlinecube.dimensions[3]-1 do
                        begin
                          unpackregistration(nclipbox+k-1, j, tx, ty, tz, rx, ry, rz, s);
                          if s\<\>\'\' then i.writestring (section, \'align.mask\'+inttostr(k)+\'.frame\'+inttostr(j), s);
                        end;
                      end;
                      unpackregistration(2*nclipbox, 0, tx, ty, tz, rx, ry, rz, s);
                      if s\<\>\'\' then i.writestring (section, \'align.correction\', s);
                      i.writestring (section, \'couchshiftlat\',        labelcomputedlat2.caption);
                      i.writestring (section, \'couchshiftlong\',       labelcomputedlong2.caption);
                      i.writestring (section, \'couchshiftheight\',     labelcomputedheight2.caption);
                      i.writestring (section, \'couchpitch\',      labelcomputedpitch2.caption);
                      i.writestring (section, \'couchroll\',       labelcomputedroll2.caption);
                      i.writestring (section, \'couchyaw\',        labelcomputedyaw2.caption);
                      t1 := ttransform.create;
                      t1.assign(online_to_machine);
                      transform_math(t1, reference_to_machine, t1, false, true, false);
                      t := t1.asstring;
                      for j:=1 to length(t) do
                      begin
                        if t[j]=#10 then t[j] := \' \';
                        if t[j]=#13 then t[j] := \' \';
                      end;
                      i.writestring (section, \'onlinetoreftransformunmatched\', t);
                      t1.assign(online_to_machine);
                      t1.premultiply(machine_to_machineadjust);
                      transform_math(t1, reference_to_machine, t1, false, true, false);
                      t := t1.asstring;
                      for j:=1 to length(t) do
                      begin
                        if t[j]=#10 then t[j] := \' \';
                        if t[j]=#13 then t[j] := \' \';
                      end;
                      i.writestring (section, \'onlinetoreftransformcorrection\', t);
                      if mode in [elektaalign, elektareconalign] then
                      begin
                        t := lastmatchresult;
                        for j:=1 to length(t) do
                        begin
                          if t[j]=#10 then t[j] := \';\';
                          if t[j]=#13 then t[j] := \' \';
                        end;
                        i.writebool   (section, \'matchadjusted\', matchadjusted);
                      end
                      else if mode in [avlalign, avlalignr] then
                      begin
                        if (appliedcorrectionprotocol = \'clipbox\') or
                           (appliedcorrectionprotocol = \'clipbox --\> mask\') then
                          i.writestring (section, \'clipboxmatchmessage\', lastclipboxmatchresult);
                        if (appliedcorrectionprotocol = \'mask\') or
                           (appliedcorrectionprotocol = \'clipbox --\> mask\') or
                           (appliedcorrectionprotocol = \'clipbox & art\') then
                          i.writestring (section, \'maskmatchmessage\', lastmaskmatchresult);
                        i.writebool   (section, \'matchadjusted\', matchadjusted);
                        i.writebool   (section, \'prerotate\', matchprerotate);
                        i.writebool   (section, \'rotatearoundmarker\', matchrotmark);
                        i.writestring (section, \'reconstructedscansdirectory\',  reconfilebase);
                        i.writestring (section, \'administrativefilesdirectory\', adminfilebase);
                        i.writestring (section, \'referencecachedirectory\',      cachefilebase);
                        i.deletekey   (section, \'*\');
                        i.deletekey   (section, \'#\');
                        i.writestring (section, \'*\',            \'*****************************************************************\');
                        i.writestring (section, \'#\',            \'\');
                      end;
                      t1.free;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_202()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.confirmmatch(inifilename, section, initials : string);
                  var matchname : string;
                      i : tqinifile;
                      apprvby : string;
                  begin
                        i := tqinifile.create(inifilename);
                        matchname := i.readstring(section, \'matchmethod\', \'\');
                        matchname := i.readstring(section, \'match\', matchname) + \', \' + initials;
                        i.writestring(section, \'match\', matchname);
                        apprvby := i.readstring(section, \'alignmentapprovalby\', \'\');
                        i.writestring (section, \'alignmentapprovalby\', apprvby + \', \' + initials);
                        apprvby := i.readstring(section, \'correctionapprovalby\', \'\');
                        i.writestring (section, \'correctionapprovalby\', apprvby + \', \' + initials);
                        initials := i.readstring(section, \'signature\', \'\') + \', \' + initials;
                        i.writestring (section, \'signature\',     initials);
                        writematchresultlogfile(initials);
                        i.updatefile;
                        i.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_203()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.inifilecopysection(i: tqinifile; sourcesectionname, destinationsectionname : string);
                  var sectionitems : tstringlist;
                      k : integer;
                      key : string;
                  begin
                    if not i.sectionexists(sourcesectionname) then
                      exit;
                    sectionitems := tstringlist.create;
                    i.readsection(sourcesectionname, sectionitems);
                    for k:= 0 to sectionitems.count-1 do
                    begin
                      key := i.readstring(sourcesectionname,sectionitems[k],\'\');
                      i.writestring(destinationsectionname,sectionitems[k],key);
                    end;
                    sectionitems.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_204()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.writematch(matchname :string; machinetomachineadjust :ttransform; matchonly :boolean);
                  var t1, t3, t4, avlreftopatientsiddon: ttransform;
                      t2 : tavsfield;
                      j  : integer;
                      matchfile, text : string;
                      f: textfile;
                      t5 : tavsfield;
                      t6 : ttransform;
                  begin
                    j := pos(\':\', patienturl);
                    if j\>0 then
                    begin
                      if datatype=\'quirt\' then
                        matchfile := datapath + \'images\\\' + copy(patienturl, j+1, 250) + \'\\\' + copy(patienturl, j+1, 250) + \'.mat\'
                      else
                        matchfile := datapath + copy(patienturl, j+1, 250) + \'\\\' + copy(patienturl, j+1, 250) + \'.mat\';
                    end
                    else
                    begin
                      showmessage(invalid_pat_url + patienturl);
                      exit;
                    end;
                    if not fileexists(matchfile) then
                    begin
                      showmessage(creating_matchfile + matchfile);
                      assignfile(f, matchfile);
                      rewrite(f);
                      writeln(f, \'match file created by xvi: \' + datetostr(date) + \' \' + timetostr(time));
                      closefile(f);
                    end;
                    t1 := ttransform.create;
                    t2 := tavsfield.create;
                    t3 := ttransform.create;
                    t4 := ttransform.create;
                    t5 := tavsfield.create;
                    t6 := ttransform.create;
                    t1.assign(reference_to_machine);
                    t1.invert;
                    t1.postmultiply(machinetomachineadjust);
                    t1.postmultiply(online_to_machine);
                    t3.assign(online_to_machine);
                    t3.premultiply(machine_to_siddon);
                    t4.assign(reference_to_siddon);
                    avlreftopatientsiddon := ttransform.create;
                    avlreftopatientsiddon.assign(reference_to_patient);
                    assignfile(f, matchfile);
                    append(f);
                    writeln(f, \'*******************************************************\');
                    writeln(f, \'match      : \' + matchname);
                    writeln(f, \'computed on: \' + formatdatetime(\'yyyymmdd; hh:nn:ss\', now));
                    writeln(f, \'version    : \' + \'xvi generated match \' + xvi_version);
                    writeln(f, \'\');
                    writeln(f, \'patientid    : \' + patientid);
                    writeln(f, \'treatmentid  : \' + treatmentid);
                    writeln(f, \'treatmentuid : \' + treatmentuid);
                    writeln(f, \'portid       : \' + portid);
                    writeln(f, \'portuid      : \' + portuid);
                    writeln(f, \'scanuid      : \' + scanuid);
                    writeln(f, \'scandate     : \' + scandate);
                    writeln(f, \'scantime     : \' + scantime);
                    writeln(f, \'\');
                    writeln(f, \'ct scan    : \' + scanurl);
                    writeln(f, \'actual transformation (ct to siddon)  :\');
                    writeln(f, writematrix(avlreftopatientsiddon, false));
                    writeln(f, \'\');
                    writeln(f, \'mri                  : \' + exportedscan);
                    if datatype\<\>\'quirt\' then
                      writeln(f, \'orientation          : axial\')
                    else
                      writeln(f, \'orientation          : coronal\');
                    writeln(f, \'actual transformation (mri to siddon) :\');
                    if datatype\<\>\'quirt\' then
                    begin
                     t3.invert;
                     shuffle_transform(t3, t3, shuffle_transform_kslice, false, true, false, false, 3);
                     t3.invert;
                     t1.invert;
                     shuffle_transform(t1, t1, shuffle_transform_kslice, false, true, false, false, 3);
                     t1.invert;
                    end;
                    writeln(f, writematrix(t3, false));
                    writeln(f, \'\');
                    writeln(f, \'transformation (mri to ct in scan coordinate system)    :\');
                    writeln(f, writematrix(t1, false));
                    writeln(f, \'\');
                    if matchonly then
                    begin
                      closefile(f);
                      t1.free;
                      t2.free;
                      t3.free;
                      t4.free;
                      t5.free;
                      t6.free;
                      avlreftopatientsiddon.free;
                      exit;
                    end;
                    writeln(f, \'*******************************************************\');
                    writeln(f, \'3d setup error:      \' + matchname);
                    writeln(f, \'computed on:         \' + formatdatetime(\'yyyymmdd; hh:nn:ss\', now));
                    writeln(f, \'version:             \' + xvi_version);
                    writeln(f, \'\');
                    writeln(f, \'patientid    : \' + patientid);
                    writeln(f, \'treatmentid  : \' + treatmentid);
                    writeln(f, \'treatmentuid : \' + treatmentuid);
                    writeln(f, \'portid       : \' + portid);
                    writeln(f, \'portuid      : \' + portuid);
                    writeln(f, \'scanuid      : \' + scanuid);
                    writeln(f, \'scandate     : \' + scandate);
                    writeln(f, \'scantime     : \' + scantime);
                    writeln(f, \'\');
                    writeln(f, \'reference scan:      \' + scanurl);
                    writeln(f, \'reference scan date: \' + \'unknown\');
                    writeln(f, \'reference scan time: \' + \'unknown\');
                    writeln(f, \'reference scan to siddon:\');;
                    writeln(f, writematrix(reference_to_siddon, false));
                    writeln(f, \'\');
                    writeln(f, \'on-line scan:        \' + exportedscan);
                    writeln(f, \'on-line scan in xvi: \' + scanuid + \'.scan\');
                    writeln(f, \'on-line scan date:   \' + copy(scandate, 3, 6));
                    writeln(f, \'on-line scan time:   \' + copy(scantime, 0, 2)+\':\'+copy(scantime, 3, 2)+\':\'+copy(scantime, 5, 2));
                    writeln(f, \'on-line scan to siddon:\');
                    writeln(f, writematrix(online_to_machine, false));
                    writeln(f, \'\');
                    writeln(f, \'current match:       \' + matchname);
                    writeln(f, \'\');
                    writeln(f, \'transformation (on-line to reference in scan coordinate system)    :\');
                    writeln(f, writematrix(t1, false));
                    if synergymode then writeln(f, \'xvi info  : \' + adminfilebase + plansopuid + \'.xvi\')
                    else                writeln(f, \'xvi info  : \' + adminfilebase + treatmentuid + \'.xvi\');
                    writeln(f, \'plan      : \' + planurl);
                    writeln(f, \'beam      : \' + beamurl);
                    writeln(f, \'beam_to_siddon :\');
                    writeln(f, writematrix(machine_to_siddon, false));
                    t1.assign(machinetomachineadjust);
                    t1.invert;
                    writeln(f, \'reference to actual patient setup in siddon coordinates:\');
                    writeln(f, writematrix(t1, false));
                    euler_components(t1, t2, text, 0.002);
                    writeln(f, \'transformation description in siddon coordinates (+x=left, +y=superior, +z=anterior):\');
                    for j:=1 to length(text) do
                      if text[j]=#10 then writeln(f, \'\') else write(f, text[j]);
                    writeln(f);
                    closefile(f);
                    t1.free;
                    t2.free;
                    t3.free;
                    t4.free;
                    t5.free;
                    t6.free;
                    avlreftopatientsiddon.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_205()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonwritematchclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_206()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonreadmatchclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_207()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.matchfileselectionfill;
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_208()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonloadmatchclick(sender: tobject);
                  var section, uid, filename: string;
                      ini: tinifiles;
                      save: tcursor;
                  begin
                    section := scanuid + \'.align\';
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    buttonresetmatchclick(self);
                    manualmatchactive := false;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    if avlstate\>0 then filename := paramstr2
                    else               filename := adminfilebase + uid + \'.xvi\';
                    if sectiontoload=\'none\' then
                      ini := tinifiles.create([filename])
                    else
                      begin
                        if (avlstate=3) and (sectiontoload\<\>\'none\') then
                          ini := tinifiles.create([filename, filename + \'.xvi\'])
                        else
                          ini := tinifiles.create([filename + \'.xvi\', filename]);
                      end;
                      loadmatch(ini, section, nil);
                    labelcomputedlat2.enabled := true;
                    labelcomputedlong2.enabled := true;
                    labelcomputedheight2.enabled := true;
                    activesettingstolistview(ini, false);
                    ini.free;
                    alignmentchanged := false;
                    manualmatchactive := false;
                    screen.cursor := save;
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_209()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.packregistration(i: tinifiles; section: string; frame, region: integer);
                  var s: string;
                      tx, ty, tz, rx, ry, rz: single;
                      t: ttransform;
                  begin
                    if region\<nclipbox then
                      s:= \'align.clip\' + inttostr(region+1)
                    else if region\<2*nclipbox then
                      s:= \'align.mask\' + inttostr(region-nclipbox+1)
                    else
                      s:= \'align.correction\';
                    if frame\>=0 then s := s + \'.frame\'+inttostr(frame);
                    if assigned(i) then
                      s := i.readstring(section, s, \'\')
                    else
                      s := section;
                    if s=\'\' then exit;
                    tx := valuefromstr(s, 1);
                    ty := valuefromstr(s, 2);
                    tz := valuefromstr(s, 3);
                    rx := -valuefromstr(s, 4);
                    ry :=  valuefromstr(s, 5);
                    rz := -valuefromstr(s, 6);
                    t := ttransform.create;
                    t.maketranslationafterrotation(tx,ty,tz,rx,ry,rz);
                    t.invert;
                    machine_to_machineadjust.assign(t);
                    t.free;
                    externalmanualmatchto4d(frame, region);
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_210()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.loadmatch(i: tinifiles; section : string; f: ttransform);
                  var s: string;
                      tx, ty, tz, rx, ry, rz :single;
                      t    : ttransform;
                      j,k    : integer;
                      load4dtransform : boolean;
                  begin
                    if not i.sectionexists(section) then
                    begin
                      section := \'alignment\';
                      if not i.sectionexists(section) then
                      begin
                        if avlstate\<=0 then showmessage(alignsection_error);
                        quirtviewerupdcoronal.text[2].value := #27 + #1 + chr(255) + #1 + text_noprevious;
                        exit;
                      end;
                    end;
                    if avlstate\<=0 then
                    begin
                      if (fixscanurl(i.readstring (section, \'scanurl\', \'\'))\<\> fixscanurl(scanurl)) or
                         (i.readstring (section, \'planurl\', \'\')\<\> planurl) or
                         (i.readstring (section, \'beamurl\', \'\')\<\> beamurl) then
                      begin
                        showmessage(reference_error);
                        loadbonematch.checked:=false;
                        loadtumormatch.checked := false;
                        exit;
                      end;
                    end;
                    comboboxtransformmode.itemindex := 0;
                    s := i.readstring(section, \'matchmethod\', \'\');
                    if (((pos(match_4d, s)\>0) or (pos(match_manualcc, s)\>0)) and (alignmentmode.value = 1))
                        or (strcomp(pchar(match_4dmask), pchar(s))=0) then
                    begin
                      s := i.readstring (section, \'transformphase0\', \'\');
                      if (s = \'\') and (pos(match_manualcc, comboboxmatch.text)\>0) then
                        load4dtransform := false
                      else if (s = \'\') and (pos(match_4d, comboboxmatch.text)\>0) and (bonetumormatchstatus\<\>10) then
                      begin
                        showmessage(error_4dmatchnotfound);
                        load4dtransform := false;
                      end
                      else
                      begin
                        s := i.readstring (section, \'transformphase\'+inttostr(onlinecube.dimensions[3]), \'\');
                        if (s \<\> \'\') then
                        begin
                          showmessage(error_4dmatchphases);
                          load4dtransform := false;
                        end
                        else
                          load4dtransform := true;
                      end;
                    end
                    else
                      load4dtransform := false;
                    if load4dtransform then
                    begin
                      for k := 0 to onlinecube.dimensions[3]-1 do
                      begin
                        s := i.readstring (section, \'transformphase\'+inttostr(k), \'\');
                        if s = \'\' then
                        begin
                          showmessage(error_4dmatchread);
                          transform4d.clear;
                          makeregistrationbackup(0, 9999, 0, 9999);
                          break;
                        end
                        else
                        begin
                          stringtotransform(s,machine_to_machineadjust);
                          externalmanualmatchto4d(k, nclipbox);
                        end;
                      end;
                      convertedtocorrections := false;
                      converted4dtomean := false;
                    end;
                    correctionapprovalby := i.readstring (section, \'correctionapprovalby\',    \'\');
                    tx := i.readfloat (section, \'translationlr\', 0);
                    ty := i.readfloat (section, \'translationcc\', 0);
                    tz := i.readfloat (section, \'translationap\', 0);
                    tx := i.readfloat (section, \'matchtranslationlr\', tx);
                    ty := i.readfloat (section, \'matchtranslationcc\', ty);
                    tz := i.readfloat (section, \'matchtranslationap\', tz);
                    tx := i.readfloat (section, \'alignmenttranslationlr\', tx);
                    ty := i.readfloat (section, \'alignmenttranslationcc\', ty);
                    tz := i.readfloat (section, \'alignmenttranslationap\', tz);
                    rx := -i.readfloat (section, \'rotationlr\', 0);
                    ry :=  i.readfloat (section, \'rotationcc\', 0);
                    rz := -i.readfloat (section, \'rotationap\', 0);
                    rx := -i.readfloat (section, \'matchrotationlr\', -rx);
                    ry := i.readfloat (section, \'matchrotationcc\', ry);
                    rz := -i.readfloat (section, \'matchrotationap\', -rz);
                    rx := -i.readfloat (section, \'alignmentrotationlr\', -rx);
                    ry := i.readfloat (section, \'alignmentrotationcc\', ry);
                    rz := -i.readfloat (section, \'alignmentrotationap\', -rz);
                    labelcomputedlat2.caption := i.readstring (section, \'couchshiftlat\', \'-\');
                    labelcomputedlong2.caption := i.readstring (section, \'couchshiftlong\', \'-\');
                    labelcomputedheight2.caption := i.readstring (section, \'couchshiftheight\', \'-\');
                    if safestrtofloat(labelcomputedlat2.caption)\>0    then labelcomputedlat2.hint    := hint_right else labelcomputedlat2.hint    := hint_left;
                    if safestrtofloat(labelcomputedlong2.caption)\>0   then labelcomputedlong2.hint   := hint_in    else labelcomputedlong2.hint   := hint_out;
                    if iec_linear_convention in [0, 1, 3] then
                      if safestrtofloat(labelcomputedheight2.caption)\<0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down
                    else
                      if safestrtofloat(labelcomputedheight2.caption)\>0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down;
                    labelcomputedpitch2.caption :=  i.readstring (\'alignment\', \'couchpitch\',  \'-\');
                    labelcomputedroll2.caption :=  i.readstring (\'alignment\', \'couchroll\',  \'-\');
                    labelcomputedyaw2.caption :=  i.readstring (\'alignment\', \'couchyaw\',  \'-\');
                    t := ttransform.create;
                    t.maketranslationafterrotation(tx,ty,tz,rx,ry,rz);
                    t.invert;
                    if assigned(f) then
                    begin
                      f.assign(t);
                      t.free;
                      exit;
                    end;
                    if onlinecube.ndim=3 then
                      for j:=2*nclipbox downto 0 do
                        packregistration(i, section, -1, j)
                    else
                    begin
                      for k:=-1 to max(onlinecube.dimensions[3]-1, -1) do
                        packregistration(i, section, k, 2*nclipbox);
                      for k:=-1 to max(onlinecube.dimensions[3]-1, -1) do
                        packregistration(i, section, k, nclipbox);
                      for k:=-1 to max(onlinecube.dimensions[3]-1, -1) do
                        packregistration(i, section, k, 0);
                    end;
                    edittranslationlr.imename := \'\';
                    edittranslationcc.imename := \'\';
                    edittranslationap.imename := \'\';
                    editrotationlr.imename := \'\';
                    editrotationcc.imename := \'\';
                    editrotationap.imename := \'\';
                    loadedalignmentdatachanged := false;
                    convertedtocorrections := false;
                    if loadacceptedmatch.checked then
                      converted4dtomean := true
                    else
                      converted4dtomean := false;
                    t.free;
                    s := i.readstring (section, \'alignmentapprovalby\', \'xxnonexx\');
                    if s=\'xxnonexx\' then
                      quirtviewerupdcoronal.text[2].value := #27 + #1 + chr(255) + #1 + text_noprevious
                    else
                    begin
                      if length(s) \> 40 then
                        quirtviewerupdcoronal.text[2].value := #27 + chr(255) + #1 + #1 + \'matched by: \' + copy(s, 1, 40) + \'...\'
                      else
                        quirtviewerupdcoronal.text[2].value := #27 + chr(255) + #1 + #1 + \'matched by: \' + s;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_211()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.loadcorrection(i: tinifiles; section : string; f: ttransform);
                  var t    : ttransform;
                      tx, ty, tz, rx, ry, rz : single;
                  begin
                    if not i.sectionexists(section) then
                      exit;
                    tx := safestrtofloat(i.readstring(section, \'correctiontranslationlr\', \'-999\'));
                    ty := safestrtofloat(i.readstring(section, \'correctiontranslationcc\', \'-999\'));
                    tz := safestrtofloat(i.readstring(section, \'correctiontranslationap\', \'-999\'));
                    rx := -safestrtofloat(i.readstring(section, \'correctionrotationlr\', \'-999\'));
                    ry := safestrtofloat(i.readstring(section, \'correctionrotationcc\', \'-999\'));
                    rz := -safestrtofloat(i.readstring(section, \'correctionrotationap\', \'-999\'));
                    t := ttransform.create;
                    t.maketranslationafterrotation(tx,ty,tz,rx,ry,rz);
                    t.invert;
                    if assigned(f) then
                      f.assign(t)
                    else
                      machine_to_machineadjust.assign(t);
                    t.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_212()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonread4dtransformclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_213()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonloadmatchmousedown(sender: tobject;
                    button: tmousebutton; shift: tshiftstate; x, y: integer);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_214()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.trackbartranslationlrkeydown(sender: tobject;
                    var key: word; shift: tshiftstate);
                  begin
                    if key=vk_up then edittranslationcc.text := floattostrf(safestrtofloat(edittranslationcc.text)+0.1, fffixed, 5, 2);
                    if key=vk_down then edittranslationcc.text := floattostrf(safestrtofloat(edittranslationcc.text)-0.1, fffixed, 5, 2);
                    if key=vk_up   then key := 0;
                    if key=vk_down then key := 0;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_215()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.trackbartranslationcckeydown(sender: tobject;
                    var key: word; shift: tshiftstate);
                  begin
                    if key=vk_right  then edittranslationlr.text := floattostrf(safestrtofloat(edittranslationlr.text)+0.1, fffixed, 5, 2);
                    if key=vk_left   then edittranslationlr.text := floattostrf(safestrtofloat(edittranslationlr.text)-0.1, fffixed, 5, 2);
                    if key=vk_left  then key := 0;
                    if key=vk_right then key := 0;
                    if key=vk_up    then key := vk_right;
                    if key=vk_down  then key := vk_left;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_216()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.detectmarkers1click(sender: tobject);
                  begin
                    markerdetectionsettingsdlg.show;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_217()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.viewerhelp1click(sender: tobject);
                  begin
                    if quirtviewerupdsagittal.showhelp.value \<\> ord(viewerhelp1.checked) then exit;
                    if quirtviewerupdsagittal.showhelp.value=0 then
                    begin
                      quirtviewerupdtransversal.showhelp := nil;
                      quirtviewerupdcoronal.showhelp  := nil;
                    end;
                    quirtviewerupdsagittal.showhelp.value := 1-quirtviewerupdsagittal.showhelp.value;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_218()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.print1click(sender: tobject);
                  var
                    formimage: tbitmap;
                    info: pbitmapinfo;
                    infosize: dword;
                    image: pointer;
                    imagesize: dword;
                    bits: hbitmap;
                    dibwidth, dibheight: longint;
                    printwidth, printheight: longint;
                  begin
                    printer.orientation := polandscape;
                    printer.begindoc;
                    try
                      formimage := getformimage;
                      formimage.canvas.font.size := -14;
                      formimage.canvas.pen.style := psclear;
                      formimage.canvas.rectangle(panelelektamode.left+6, panelelektamode.top+8, panelelektamode.left+6 + panelelektamode.width-4, panelelektamode.top+8 + panelelektamode.height - 4);
                      formimage.canvas.textout(panelelektamode.left + 14, panelelektamode.top + 20, caption);
                      canvas.lock;
                      try
                        bits := formimage.handle;
                        getdibsizes(bits, infosize, imagesize);
                        info := allocmem(infosize);
                        try
                          image := allocmem(imagesize);
                          try
                            getdib(bits, 0, info^, image^);
                            dibwidth := info^.bmiheader.biwidth;
                            dibheight := info^.bmiheader.biheight;
                            case printscale of
                              poproportional:
                                begin
                                  printwidth := muldiv(dibwidth, getdevicecaps(printer.handle,
                                    logpixelsx), pixelsperinch);
                                  printheight := muldiv(dibheight, getdevicecaps(printer.handle,
                                    logpixelsy), pixelsperinch);
                                end;
                              poprinttofit:
                                begin
                                  printwidth := muldiv(dibwidth, printer.pageheight, dibheight);
                                  if printwidth \< printer.pagewidth  then
                                    printheight := printer.pageheight
                                  else
                                  begin
                                    printwidth := printer.pagewidth;
                                    printheight := muldiv(dibheight, printer.pagewidth, dibwidth);
                                  end;
                                end;
                              else
                                printwidth := dibwidth;
                                printheight := dibheight;
                            end;
                            stretchdibits(printer.canvas.handle, 0, 0, printwidth, printheight, 0, 0,
                              dibwidth, dibheight, image, info^, dib_rgb_colors, srccopy);
                          finally
                            freemem(image, imagesize);
                          end;
                        finally
                          freemem(info, infosize);
                        end;
                      finally
                        canvas.unlock;
                        formimage.free;
                      end;
                    finally
                      printer.enddoc;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_219()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.saveas1click(sender: tobject);
                  var formimage: tbitmap;
                      s: tsavedialog;
                      avifps, i, j: integer;
                      pixmap: tavsfield;
                  begin
                    if timer4d.enabled then
                    begin
                      avihandle := -1;
                      s := tsavedialog.create(self);
                      s.filter := saveasfilter_movie;
                      s.options := [ofoverwriteprompt, ofnochangedir];
                      s.defaultext := \'avi\';
                      if s.execute then
                      begin
                        avifps := 1000 div timer4d.tag;
                        formimage := getformimage;
                        formimage.pixelformat := pf24bit;
                        pixmap := tavsfield.createas(\'field 2d 3-vector byte\', [formimage.width, formimage.height]);
                        for i := 0 to formimage.height - 1 do
                          move( formimage.scanline[i]^,
                                pbyte(cardinal(pixmap.data)+ cardinal(i * formimage.width * 3))^, formimage.width * 3);
                        avi_creat(pixmap, avihandle, s.filename, avifps, avicodec);
                        for j:=0 to max(onlinecube.dimensions[3]-1, 0) do
                        begin
                          quirtviewerupdcoronal.frame.value := j;
                          timer1timer(self);
                          formimage := getformimage;
                          formimage.pixelformat := pf24bit;
                          for i := 0 to formimage.height - 1 do
                            move( formimage.scanline[i]^,
                                  pbyte(cardinal(pixmap.data)+ cardinal(i * formimage.width * 3))^, formimage.width * 3);
                          avi_write(pixmap, avihandle);
                        end;
                        formimage.free;
                        pixmap.free;
                        avi_close(avihandle);
                        avihandle := -1;
                      end;
                    end
                    else
                      begin
                      avihandle := -1;
                      s := tsavedialog.create(self);
                      s.filter := saveasfilter_image;
                      s.options := [ofoverwriteprompt, ofnochangedir];
                      s.defaultext := \'tif\';
                      if s.execute then
                      begin
                        formimage := getformimage;
                        formimage.pixelformat := pf24bit;
                        formimage.canvas.font.size := -14;
                        formimage.canvas.pen.style := psclear;
                        formimage.canvas.rectangle(panelelektamode.left+6, panelelektamode.top+8, panelelektamode.left+6 + panelelektamode.width-4, panelelektamode.top+8 + panelelektamode.height - 4);
                        formimage.canvas.textout(panelelektamode.left + 14, panelelektamode.top + 20, caption);
                        pixmap := tavsfield.createas(\'field 2d 3-vector byte\', [formimage.width, formimage.height]);
                        for i := 0 to formimage.height - 1 do
                          move( formimage.scanline[i]^,
                            pchar(cardinal(pixmap.data)+ cardinal(i * formimage.width * 3))^, formimage.width * 3);
                        field_tiff(pixmap, s.filename);
                        formimage.free;
                        pixmap.free;
                      end;
                    end
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_220()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.checkboxadvancedoptionsclick(sender: tobject);
                  begin
                    paneladvancedoptions.visible := checkboxadvancedoptions.checked;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_221()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.formkeydown(sender: tobject; var key: word;
                    shift: tshiftstate);
                  const
                    bshowinghints: boolean=false;
                  begin
                    if (key=vk_f3) and (shift=[]) then
                    begin
                      if comboboxdisplaymode.itemindex=2 then
                        comboboxdisplaymode.itemindex := 3
                      else
                        comboboxdisplaymode.itemindex := 2;
                    end;
                    if (key=vk_f2) and (shift=[]) then
                    begin
                      if comboboxdisplaymode.itemindex=0 then
                        comboboxdisplaymode.itemindex := 1
                      else
                        comboboxdisplaymode.itemindex := 0;
                    end;
                    if (key=vk_f4) and (shift=[]) then
                    begin
                      if myzoom\>2.501 * zoomfix then
                      begin
                        myzoom := 0.5 * zoomfix;
                        quirtviewerupdcoronalpanchanged(self, 0, 0);
                      end
                      else
                        buttonzoomclick(buttonzoom);
                    end;
                    if (key=vk_f5) and (shift=[]) then
                    begin
                      bitbtnpresetlevelwindowsclick(self);
                    end;
                    if (key=vk_f6) and (shift=[]) then
                    begin
                      buttongotoisocclick(self);
                    end;
                    if (key=vk_f7) and (shift=[]) then
                    begin
                      bitbtnback4dclick(self);
                    end;
                    if (key=vk_f8) and (shift=[]) then
                    begin
                      bitbtnfwd4dclick(self);
                    end;
                    if key=vk_space then
                    begin
                      comboboxdisplaymode.itemindex := 1;
                    end;
                    if enabletestmode then
                    begin
                      if (key=ord(\'h\')) and (shift=[ssshift, ssalt, ssctrl]) then
                      begin
                        key := 0;
                        if not bshowinghints then
                        begin
                          buildhintlist;
                          showallhints;
                          bshowinghints := true
                        end
                        else
                        begin
                          hideallhints;
                          form1.show;
                          destroyhintlist;
                          bshowinghints := false;
                        end;
                      end
                      else if (key=ord(\'t\')) and (shift=[ssshift, ssalt, ssctrl]) then
                      begin
                        key := 0;
                        testmode := not testmode;
                      end
                      else if (key=ord(\'3\')) and (shift=[ssshift, ssalt, ssctrl]) then
                        groworshrinklabels30pct
                      else if (key=ord(\'p\')) and (shift=[ssshift, ssalt, ssctrl]) then
                      begin
                        if not assigned(gformarray[0]) then
                        begin
                          if not timerpopup1.enabled then
                            showallpopupmenus;
                          timerpopup1.enabled := false;
                        end;
                        showallpopupmenusasforms;
                        key := 0;
                        end
                      else if (key=ord(\'u\')) and (shift=[ssshift, ssalt, ssctrl]) then
                      begin
                        showuniformity;
                        key := 0;
                      end
                    end
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_222()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.checkboxreversemotionclick(sender: tobject);
                  begin
                    reversemotion.value := ord(checkboxreversemotion.checked);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_223()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.setregistrationparameters(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_224()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.simplex1lowerfuncval(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_225()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonmatchclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_226()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure dicom_fixpatientname(patientname: string; var device: string; var haspatient: boolean);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_227()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.treereader(data: tavsfield; url: string; parameter: string);
                  var i, j: integer;
                      t, device: string;
                      ok: boolean;
                  begin
                    i := pos(\':\', patienturl);
                    if i\>0 then t := copy(patienturl, i+1, 250) else t:=\'\';
                    j := pos(\':\', url);
                    if j\>0 then url := copy(url, j+1, 500) else url := \'\';
                    j := pos(\':\', url);
                    if j\>0 then url := copy(url, j+1, 500);
                    if      importdatatype=\'pinnacle\' then read_pinnacle(data, importdatapath + t, url, parameter, t)
                    else if importdatatype=\'dicom\'    then
                    begin
                    end
                    else showmessage(reader_error + datatype);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_228()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.treeselector(patienturl: string; itemtype: string): string;
                  var f: tavsfield;
                      i, j, depth: integer;
                      selector: tform;
                      g: tlistbox;
                      s: tstringlist;
                      b1, b2: tbutton;
                      urls:    array[1..10] of string;
                      aliases: array[1..10] of string;
                      id, name, modality, full, alias: string;
                  begin
                    j := pos(\':\', patienturl);
                    f := tavsfield.create;
                    treereader(f, copy(patienturl, j+1, 250), \'\');
                    s := tstringlist.create;
                    selector := tform.create(self);
                    selector.position := podesigned;
                      selector.borderstyle := bssizetoolwin;
                    selector.formstyle   := fsstayontop;
                    selector.caption := select_caption + itemtype;
                    selector.onclose := closeselector;
                    selector.autoscroll := false;
                    selector.keypreview := true;
                    selector.left   := 0;
                    selector.top    := 0;
                    g := tlistbox.create(selector);
                    g.parent := selector;
                    g.top    := 4;
                    g.left  := 4;
                    g.width  := 400;
                    g.height := 400;
                    depth := 1;
                    for i:=0 to f.dimensions[1]-1 do
                    begin
                      id       := f.getstring([i, 0]);
                      name     := f.getstring([i, 1]);
                      modality := f.getstring([i, 2]);
                      alias    := name;
                      j := pos(\'depth=\', id); if j\>0 then depth := strtoint(copy(id, j+6, 1));
                      j := pos(\'alias=\', id); if j\>0 then alias := copy(id, j+6, 499);
                      j := pos(\'~\', id);      if j\>0 then alias := copy(alias, 1, j-1);
                      urls[depth] := name + \'.\' + modality;
                      aliases[depth] := alias;
                      full := \'\';
                      for j:=1 to depth do
                        if urls[j]\<\>\'\' then
                          full := full + urls[j] + \'\\\';
                       full := copy(full, 1, length(full)-1);
                      alias := \'\';
                      for j:=2 to depth do
                        if aliases[j]\<\>\'\' then
                          alias := alias + aliases[j] + \'; \';
                       alias := copy(alias, 1, length(alias)-2);
                      if (itemtype=\'\') or (itemtype=modality) then
                      begin
                        g.items.add(alias);
                        s.add(full);
                      end;
                    end;
                    if itemtype=\'structure\' then
                      g.multiselect := true;
                    selector.clientwidth  := g.width + 8;
                    selector.clientheight := g.height + 20 + 6 + 40;
                    g.anchors:= [aktop, akleft, akright, akbottom];
                    b1 := tbutton.create(selector);
                    b1.parent := selector;
                    b1.top    := g.height + 20 + 6;
                    b1.left  := g.width div 2 + 4 - 110;
                    b1.anchors:= [akleft, akbottom];
                    b1.cancel := true;
                    b1.caption := cancel_caption;
                    b1.onclick := cancelclicked;
                    b2 := tbutton.create(selector);
                    b2.parent := selector;
                    b2.top    := g.height + 20 + 6;
                    b2.left  := g.width div 2 + 4 + 60;
                    b2.anchors:= [akleft, akbottom];
                    b2.default := true;
                    b2.caption := ok_caption;
                    b2.onclick := okclicked;
                    g.ondblclick := okclicked;
                    if s.count = 1 then
                    begin
                      g.selected[0] := true;
                      selector.modalresult := mrok;
                    end
                    else
                      selector.showmodal;
                    result := \'\';
                    if (selector.modalresult = mrok) then
                    for i:=0 to g.items.count-1 do
                      if g.selected[i] then
                        if itemtype\<\>\'structure\' then
                          result := patienturl + \':\' + s[i]
                        else
                        begin
                          if result=\'\' then
                            result := patienturl + \':\' + s[i]
                          else
                          begin
                            j := pos(\'structset\',s[i]);
                            if j\>0 then
                            begin
                              name := copy(s[i],j+10,500);
                              result := result + \',\' + name;
                            end;
                          end;
                        end;
                    selector.destroy;
                    f.free;
                    s.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_229()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.stationselector(inifilename: string; stationname: string = \'\'): string;
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_230()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.sectionselector(inifile: tqinifile; sectionbase: string; mode: safesettingmode; selectorcaption :string ): string;
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_231()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.cancelclicked(sender: tobject);
                  begin
                    (((sender as tbutton).parent) as tform).close;
                    (((sender as tbutton).parent) as tform).modalresult := mrcancel;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_232()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.okclicked(sender: tobject);
                  begin
                    (((sender as twincontrol).parent) as tform).close;
                    (((sender as twincontrol).parent) as tform).modalresult := mrok;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_233()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.closeselector(sender: tobject; var action: tcloseaction);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_234()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonclinicalpatientclick(sender: tobject);
                  var t, device: string;
                      i: integer;
                      inifile: tqinifile;
                      ok: boolean;
                      selector: tform;
                      g       : tlistbox;
                      b1, b2: tbutton;
                      dicomlist: tavsfield;
                  begin
                    if not selectinputdatasource then exit;
                    i := pos(\':\', patienturl);
                    if i\>0 then t := copy(patienturl, 2, i-3) else t := \'xvi\';
                    inifile := tqinifile.create(getfullinifilename(\'datasources.ini\'));
                    datasource := inifile.readstring(t, \'device\', \'\');
                    inifile.free;
                    i := pos(\':\', datasource);
                    if i\>0 then
                    begin
                      importdatatype := uppercase(copy(datasource, 1, i-1));
                      importdatapath := copy(datasource, i+1, 250);
                      importdatapath := includetrailingpathdelimiter(importdatapath);
                    end;
                    dicomlist := nil;
                    if importdatatype=\'pinnacle\' then
                    begin
                      if not selectdirectory(select_dir_dlg, importdatapath, t) then exit;
                      t := copy(t, length(importdatapath)+1, 250);
                      patienturl := \'[xvi]:\' + t;
                      referencedatachanged := true;
                    end
                    else if importdatatype=\'dicom\' then
                    begin
                      t := inputbox(\'search for\', \'patient id or name\', \'\');
                      if t=\'\' then exit;
                      dicomlist := tavsfield.create;
                      end
                    else if importdatatype\<\>\'\' then
                    begin
                    end;
                    if assigned(dicomlist) then
                    begin
                      selector := tform.create(self);
                      selector.position := podesigned;
                      selector.borderstyle := bssizetoolwin;
                      selector.formstyle   := fsstayontop;
                      selector.caption := select_caption + \'patient\';
                      selector.onclose := closeselector;
                      selector.autoscroll := false;
                      selector.keypreview := true;
                      selector.left   := 0;
                      selector.top    := 0;
                      g := tlistbox.create(selector);
                      g.parent := selector;
                      g.top    := 4;
                      g.left  := 4;
                      g.width  := 400;
                      g.height := 400;
                      for i:=1 to dicomlist.dimensions[1]-1 do
                        g.items.add(dicomlist.getstring([i,0]) + \' \' + dicomlist.getstring([i,1]));
                      selector.clientwidth  := g.width + 8;
                      selector.clientheight := g.height + 20 + 6 + 40;
                      g.anchors:= [aktop, akleft, akright, akbottom];
                      b1 := tbutton.create(selector);
                      b1.parent := selector;
                      b1.top    := g.height + 20 + 6;
                      b1.left  := g.width div 2 + 4 - 110;
                      b1.anchors:= [akleft, akbottom];
                      b1.cancel := true;
                      b1.caption := cancel_caption;
                      b1.onclick := cancelclicked;
                      b2 := tbutton.create(selector);
                      b2.parent := selector;
                      b2.top    := g.height + 20 + 6;
                      b2.left  := g.width div 2 + 4 + 60;
                      b2.anchors:= [akleft, akbottom];
                      b2.default := true;
                      b2.caption := ok_caption;
                      b2.onclick := okclicked;
                      g.ondblclick := okclicked;
                      selector.showmodal;
                      if (selector.modalresult = mrok) then
                      for i:=0 to g.items.count-1 do
                        if g.selected[i] then
                          patienturl := \'[xvi]\' + \':\' + dicomlist.getstring([i+1,0]);
                      selector.destroy;
                      referencedatachanged := true;
                      dicomlist.free;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_235()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.selectinputdatasource: boolean;
                  begin
                    result := false;
                    if popupmenuselectdatasource.items.count \<= 1 then
                    begin
                      result := true;
                      exit;
                    end;
                    timer1.enabled := false;
                    popupmenuselectdatasource.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                    application.processmessages;
                    if popupmenuselectdatasource.tag \<\> 0 then
                      result := true;
                    popupmenuselectdatasource.tag := 0;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_236()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.setinputdatasourceclick(sender: tobject);
                  var
                    u: string;
                    i: integer;
                    rtdatasourceinifile: trtdatasourceinifile;
                  begin
                      u := striphotkey((sender as tmenuitem).caption);
                      if u\<\>\'\' then
                      begin
                        i := pos(\':\', patienturl);
                        if i\>0 then
                        begin
                          patienturl := \'[\' + u + \']:\' + copy(patienturl, i+1, length(patienturl));
                          rtdatasourceinifile := trtdatasourceinifile.create();
                          importdatatype := rtdatasourceinifile.device(u);
                          rtdatasourceinifile.free;
                        end
                        else
                          patienturl := \'[\' + u + \']:\';
                      end
                      else exit;
                      popupmenuselectdatasource.tag := 1;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_237()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsetscanclick(sender: tobject);
                  var save  : tcursor;
                      t     : string;
                      f, g  : single;
                      j     : integer;
                      uid   : string;
                      begin
                    j := 1;
                    if (getkeystate(vk_lshift) and $8000)\<\>0 then j:=2;
                    if assigned(sender) then
                    begin
                      if planurl=\'fake\' then planurl := \'\';
                      if (scanurl=\'\') and (planurl=\'\') then
                      begin
                        buttonclinicalpatientclick(nil);
                      end;
                      if patienturl=\'\' then exit;
                      if (datatype=\'pinnacle\') or (datatype=\'dicom\') then
                      begin
                        t := treeselector(patienturl, \'scan\');
                        if t=\'\' then exit;
                        scanurl := t;
                      end
                      else
                        exit;
                      referencedatachanged := true;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if                 reference[1].exists(cachefilebase, treatmentuid,  \'ref\')     then uid := treatmentuid;
                    if synergymode and reference[1].exists(cachefilebase, scanseriesuid, \'ref\')     then uid := scanseriesuid;
                    if synergymode and reference[1].exists(cachefilebase, plansopuid,    \'ref\')     then uid := plansopuid;
                    if sender=nil then
                    begin
                      reference[1].load(cachefilebase, uid, \'ref\');
                      if online[1].processing.value=411 then reference[1].processing.value := 411;
                      if reference[1].topatient.empty then
                      begin
                        reference_to_patient.assign(reference_to_siddon);
                        timer1.enabled := false;
                        showmessage(orientation_warn);
                        timer1.enabled := true;
                      end;
                      if reference[1].tosiddon.empty then
                        reference[1].clear
                      else
                      begin
                        end;
                      reference[2].load(cachefilebase, uid, \'ref2\');
                    end
                    else
                    begin
                      if (datatype\<\>\'pinnacle\') and (datatype\<\>\'dicom\') and (datatype\<\>\'\') and (avlstate\<0) then
                      begin
                      end
                      else if datatype\<\>\'\' then
                      begin
                        treereader(reference[j].data     , scanurl, \'\');
                        treereader(reference[j].topatient, scanurl, \'bostonscantosiddonpatient\');
                        treereader(reference[j].tosiddon , scanurl,
                          \'bostonscantosiddonworld\');
                        treereader(reference[j].properties,scanurl, \'all\');
                      end;
                    end;
                    if onlinecube.empty then
                    begin
                      field_create(onlinecube, \'field 3d 0-vector byte\', 256, 256, 256);
                      case defaultfov of
                        76:  modify_extents(onlinecube, onlinecube, 0.2,   0.2,   0.2);
                        77:  modify_extents(onlinecube, onlinecube, 0.156, 0.156, 0.156);
                        83:  modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                        else
                        begin
                          f := abs(onlinecube.coordinate[1, 0] - onlinecube.coordinate[1, onlinecube.dimensions[1]-1]);
                          g := abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]);
                          g := max(abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]), g);
                          g := max(abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]), g);
                          f := max(f, 1);
                          g := max(g, 1);
                          modify_extents(onlinecube, onlinecube, g/f, g/f, g/f);
                        end;
                      end;
                      myzoom := 1.5 * zoomfix;
                      quirtviewerupdcoronalpanchanged(self, 0, 0);
                      quirtviewerupdsagittal.level[1].value := 1000;
                      quirtviewerupdsagittal.window[1].value := 500;
                      quirtviewerupdtransversal.level[1].maximum     := 2000;
                      quirtviewerupdtransversal.level[1].minimum     := 0;
                      quirtviewerupdtransversal.window[1].maximum     := 1000;
                      quirtviewerupdtransversal.window[1].minimum     := 0;
                    end;
                    quirtviewerupdsagittal.level[2].value := 1000;
                    quirtviewerupdsagittal.window[2].value := 500;
                    quirtviewerupdtransversal.level[2].maximum     := 2000;
                    quirtviewerupdtransversal.level[2].minimum     := 0;
                    quirtviewerupdtransversal.window[2].maximum     := 1000;
                    quirtviewerupdtransversal.window[2].minimum     := 0;
                    if planurl=\'fake\' then
                    begin
                      reference_to_siddon. makerotation(270, 0, 270);
                      reference_to_patient.makerotation(270, 0, 270);
                    end;
                    if referenceoverlaystring\<\>\'\' then
                      quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + referenceoverlaystring
                    else
                    begin
                        quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + ref_overlay + scanurl;
                    end;
                    if not reference[2].data.empty then
                    begin
                      field_overlay_lut(reference[2].externallut, \'blackbluegreenyellowred\', 0, round(reference[2].data.maximum), -1, 100, 32);
                    end;
                    screen.cursor := save;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_238()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsetplanclick(sender: tobject);
                  var save:   tcursor;
                      t:      string;
                      fdum:   tavsfield;
                      i, j:   integer;
                      uid:    string;
                  begin
                    if assigned(sender) then
                    begin
                      if (scanurl=\'\') and (planurl=\'\') then
                      begin
                        buttonclinicalpatientclick(nil);
                      end;
                      if patienturl=\'\' then exit;
                      if (datatype=\'pinnacle\') or (datatype=\'dicom\') then
                      begin
                        t := treeselector(patienturl, \'beam\');
                        if t=\'\' then exit;
                        beamurl := t;
                        planurl := \'\';
                      end
                      else
                        exit;
                      referencedatachanged := true;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if planurl=\'fake\' then
                    begin
                      field_create(beamdots, \'field 1d 3-space irregular\', 1);
                      beamindex.clear;
                      machine_to_siddon.makeidentity;
                    end
                    else
                    begin
                      if fileexists(cachefilebase + treatmentuid  + \'.beams\') then uid := treatmentuid;
                      if synergymode and fileexists(cachefilebase + scanseriesuid + \'.beams\') then uid := scanseriesuid;
                      if synergymode and fileexists(cachefilebase + plansopuid    + \'.beams\') then uid := plansopuid;
                      if fileexists(cachefilebase + uid + \'.beams\') and (sender=nil) then
                        vrml_read(beamdots, beamindex, beamlut, cachefilebase + uid + \'.beams\')
                      else
                      begin
                        if (datatype\<\>\'pinnacle\') and (datatype\<\>\'dicom\') and (datatype\<\>\'\') and (avlstate\<0) and (sender \<\> nil) then
                        begin
                        end
                        else
                        begin
                          field_create(beamdots, \'field 1d 3-space irregular\', 1);
                          beamindex.clear;
                        end;
                      end;
                      field_create(beamlut, \'field 1d 256-vector byte\', 256);
                      for i:=0 to 255 do
                      begin
                        beamlut.setvalue([i,0], 255);
                        beamlut.setvalue([i,1],   0);
                        beamlut.setvalue([i,2],   0);
                        beamlut.setvalue([i,3], 255);
                      end;
                      if (not beamdots.empty) or (datatype\<\>\'quirt\') then
                      begin
                        if assigned(sender) then
                        begin
                          if (datatype=\'pinnacle\') or (datatype=\'dicom\') then
                          begin
                            treereader(machine_to_siddon, beamurl, \'\');
                            treereader(machine_to_siddon, beamurl, \'bostonscantosiddonworld\');
                          end
                          else if datatype\<\>\'\' then
                          begin
                          end;
                          for i:=0 to 2 do
                            for j:=0 to 2 do
                              if i=j then machine_to_siddon.setvalue([i,j], 1)
                              else        machine_to_siddon.setvalue([i,j], 0);
                        end;
                        if not beamdots.empty then
                        begin
                          fdum := tavsfield.create;
                          transform_math(machine_to_siddon, nil, fdum, true);
                          dotxfm(beamdots, fdum, beamdots);
                          fdum.free;
                        end;
                      end;
                    end;
                    screen.cursor := save;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_239()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsetroiclick(sender: tobject);
                  begin
                    checkboxroi.checked := true;
                    showmessage(roi_message);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_240()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonscanclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenuscan.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_241()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.showall1click(sender: tobject);
                  begin
                    if reference[1].data.empty then exit;
                    showall1.checked := not showall1.checked;
                    quirtviewerupdcoronal.grid.forceupdate;
                    quirtviewerupdtransversal.grid.forceupdate;
                    quirtviewerupdsagittal.grid.forceupdate;
                    quirtviewerupdcoronal.grid.make;
                    quirtviewerupdtransversal.grid.make;
                    quirtviewerupdsagittal.grid.make;
                    gotoisocenterclick(self);
                    myzoom := min((quirtviewerupdcoronal.width-2) / max(quirtviewerupdcoronal.grid.dimensions[1], 1),
                                  (quirtviewerupdcoronal.height-2) / max(quirtviewerupdcoronal.grid.dimensions[0], 1));
                    quirtviewerupdcoronalpanchanged(self, 0, 0);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_242()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonclipbmarkersclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenuclipboxmarkers.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_243()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonclipboxclick(sender: tobject);
                  var
                    i : integer;
                  begin
                    menushowunlockpresentclipbox.visible := not clipbox[2].empty;
                    clipboxlockedstatus(true);
                    for i := 1 to popupmenuclipbox.items.count - 1 do
                    begin
                      if popupmenuclipbox.items.items[i].name = \'setclipboxweights\' then
                      begin
                        popupmenuclipbox.items.items[i].visible := false ;
                        popupmenuclipbox.items.items[i].enabled := false ;
                        break;
                      end;
                    end;
                    timer1.enabled := false;
                    popupmenuclipbox.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_244()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.clipboxlockedstatus(flag : boolean);
                  var c, i : integer;
                  begin
                    if flag then
                    begin
                      c := 0;
                      for i:= 1 to nclipbox do
                        if not clipbox[i].empty then inc(c);
                    end
                    else c := 2;
                    if (c \> 1) then
                    begin
                      menushowunlockpresentclipbox.enabled := true;
                      if menuclipboxlocked.checked then
                      begin
                        if striphotkey(menushowunlockpresentclipbox.caption) = menu_menushowall_caption then
                           menushowunlockpresentclipbox.caption := menu_menuunlockpresent_caption;
                        if striphotkey(menushowunlockpresentclipbox.caption) = menu_menushowpresent_caption then
                           menushowunlockpresentclipbox.caption := menu_menuunlockpresent_caption;
                      end
                      else
                      begin
                        if striphotkey(menushowunlockpresentclipbox.caption) = menu_menulockall_caption then
                           menushowunlockpresentclipbox.caption := menu_menushowpresent_caption;
                        if striphotkey(menushowunlockpresentclipbox.caption) = menu_menuunlockpresent_caption then
                           menushowunlockpresentclipbox.caption := menu_menushowpresent_caption;
                      end;
                    end
                    else
                    begin
                      menushowunlockpresentclipbox.enabled := false;
                      if menuclipboxlocked.checked then menushowunlockpresentclipbox.caption := menu_menuunlockpresent_caption
                      else menushowunlockpresentclipbox.caption := menu_menushowpresent_caption;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_245()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.checkboxroiclick(sender: tobject);
                  begin
                    if clipbox[1].empty then
                    begin
                      field_create(clipbox[1], \'field 1d float\', 6);
                      clipbox[1].setvalue([0],-10);
                      clipbox[1].setvalue([2], 10);
                      clipbox[1].setvalue([4],-10);
                      clipbox[1].setvalue([1], 10);
                      clipbox[1].setvalue([3],-10);
                      clipbox[1].setvalue([5], 10);
                      clipbox[1].blanking := true;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_246()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.getdelineationurl(db: string): string;
                  begin
                    result := \'\';
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_247()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.getdescriptiontext(sender: tfield; var text: string;
                    displaytext: boolean);
                  begin
                    text := sender.asstring;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_248()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsetdelineationclick(sender: tobject);
                  var
                    save: tcursor;
                    s, t: string;
                    i, j, r, g, b: integer;
                    busedisplaystructure: boolean;
                    uid, filename, section:   string;
                    h       : tinifiles;
                    tempdots, tempdots2, tempindex: tavsfield;
                    allblack: boolean;
                    dots, index, lut: tavsfield;
                    checkedcount: integer;
                  begin
                    if assigned(sender) then
                    begin
                      if patienturl=\'\' then exit;
                      if (datatype=\'pinnacle\') or (datatype=\'dicom\') then
                      begin
                        t := treeselector(patienturl, \'structure\');
                        if t=\'\' then exit;
                        delineationurl := t;
                      end
                      else
                        exit;
                      referencedatachanged := true;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if fileexists(cachefilebase + treatmentuid  + \'.delineation\') then uid := treatmentuid;
                    if synergymode and fileexists(cachefilebase + scanseriesuid + \'.delineation\') then uid := scanseriesuid;
                    if synergymode and fileexists(cachefilebase + plansopuid    + \'.delineation\') then uid := plansopuid;
                    if fileexists(cachefilebase + uid + \'.delineation\') and (sender=nil) then
                    begin
                      vrml_read(delineationdots, delineationindex, delineationdotslut, cachefilebase + uid + \'.delineation\');
                      if fatlines1.checked then
                      for i := 0 to delineationdotslut.dimensions[0]-1 do
                        dil_set_width(delineationdotslut, delineationdotslut, i, 20);
                      if fileexists(cachefilebase + uid + \'.delineation.orientation\') and (sender=nil) then
                      begin
                        read_xdr(delineationtransform, cachefilebase + uid + \'.delineation.orientation\');
                        transform_math(delineationtransform, machine_to_siddon, delineationtransform, false, true);
                      end
                      else
                        transform_math(reference_to_siddon, machine_to_siddon, delineationtransform, false, true);
                    end
                    else
                    begin
                      if (datatype\<\>\'pinnacle\') and (datatype\<\>\'dicom\') and (datatype\<\>\'\') and (avlstate\<0) then
                      begin
                      end
                      else if datatype\<\>\'\' then
                      begin
                        j := pos(\',\',delineationurl);
                        if j\> 0 then
                        begin
                          t := copy(delineationurl,j+1,500);
                          delineationurl := copy(delineationurl,0,j-1)
                        end;
                        tempdots := tavsfield.create;
                        treereader(delineationdots, delineationurl, \'\');
                        dots_to_line(delineationdots, delineationindex,false,2);
                        cnt_clean(delineationdots, delineationindex,delineationdots, delineationindex);
                        cnt_cicade(delineationdots, delineationindex, tempdots);
                        surf2_contours(tempdots,delineationdots, delineationindex);
                        field_to_byte(delineationdots,delineationdots);
                        tempdots.free;
                        treereader(delineationtransform, delineationurl, \'bostonscantosiddonworld\');
                        transform_math(delineationtransform, machine_to_siddon, delineationtransform, false, true);
                        field_create(delineationdotslut, \'field 1d 256-vector byte\', 256);
                        for i:=0 to 255 do
                        begin
                          delineationdotslut.setvalue([i, 0], 255);
                          delineationdotslut.setvalue([i, 1], 255);
                          delineationdotslut.setvalue([i, 2], 0);
                          delineationdotslut.setvalue([i, 3], 0);
                          delineationdotslut.setvalue([i, 4], 10);
                          delineationdotslut.setvalue([i, 5], 5);
                        end;
                        dil_set_name(delineationdotslut,delineationdotslut,0,memo_typeunknown);
                        if j\>0 then
                        begin
                          tempdots := tavsfield.create;
                          tempdots2 := tavsfield.create;
                          tempindex := tavsfield.create;
                          j := pos(\'structset\',delineationurl);
                          s := copy(delineationurl,0,j+9);
                          i := 1;
                          repeat
                            j := pos(\',\',t);
                            if j\>0 then
                            begin
                              delineationurl := s + copy(t,0,j-1);
                              t := copy(t,j+1,500);
                            end
                            else
                            begin
                              delineationurl := s+t;
                              t := \'\';
                            end;
                            treereader(tempdots, delineationurl, \'\');
                            dots_to_line(tempdots, tempindex,false,2);
                            cnt_clean(tempdots, tempindex,tempdots, tempindex);
                            cnt_cicade(tempdots, tempindex, tempdots2);
                            surf2_contours(tempdots2,tempdots, tempindex);
                            field_to_byte(tempdots,tempdots);
                            dil_add(delineationdots,delineationindex,delineationdotslut,tempdots,tempindex,delineationdotslut,delineationdots,delineationindex,delineationdotslut);
                            dil_set_name(delineationdotslut,delineationdotslut,i,memo_typeunknown+inttostr(i));
                            delineationdotslut.setvalue([i, 1], 255);
                            delineationdotslut.setvalue([i, 2], 0);
                            delineationdotslut.setvalue([i, 3], 0);
                            delineationdotslut.setvalue([i, i mod 3 + 1], 255);
                            i := i +1;
                          until t=\'\';
                          tempdots.free;
                          tempdots2.free;
                          tempindex.free;
                        end;
                      end;
                    end;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    if avlstate\>0 then filename := paramstr2
                    else               filename := adminfilebase + uid + \'.xvi\';
                    if (avlstate=3) and (sectiontoload\<\>\'none\') then
                      h := tinifiles.create([filename, filename + \'.xvi\'])
                    else
                      h := tinifiles.create([filename + \'.xvi\', filename]);
                    if (strcomp(pchar(filename),pchar(paramstr2))=0) then
                      section  := \'reference\'
                    else
                      section  := \'xvi\';
                    s := \'\';
                    busedisplaystructure := false;
                    if fileexists(cachefilebase + uid + \'.delineation\') and (sender=nil) then
                      s := h.readstring(section, \'displaystructure\'+inttostr(1), \'\');
                    if s\<\>\'\' then
                    begin
                      busedisplaystructure := true;
                      for i:=0 to delineationdotslut.dimensions[0]-1 do
                        delineationdotslut.setvalue([i, 27], 1);
                    end;
                    popupmenustructures.items.clear;
                    createmask1.clear;
                    refpointatcenterofdelineation.clear;
                    dots := tavsfield.create;
                    index := tavsfield.create;
                    lut := tavsfield.create;
                    if not delineationdots.empty then
                    begin
                      allblack := true;
                      checkedcount := 0;
                      for i:=0 to delineationdotslut.dimensions[0]-1 do
                      begin
                        dil_get_name(delineationdotslut, t, i);
                        if t\<\>\'\' then
                        begin
                          dil_get_color(delineationdotslut, j, r, g, b, i);
                          if (r+g+b)\>10 then allblack := false;
                          popupmenustructures.items.add(tmenuitem.create(self));
                          popupmenustructures.items.items[popupmenustructures.items.count-1].caption := t;
                          popupmenustructures.items.items[popupmenustructures.items.count-1].onclick := menustructuresclick;
                          if ((popupmenustructures.items.count - 1 = delineationdotslut.dimensions[0] div 2) and
                              (delineationdotslut.dimensions[0] \> 14)) then popupmenustructures.items.items[popupmenustructures.items.count-1].break := mbbarbreak;
                          dil_select(delineationdots, delineationindex, delineationdotslut,
                            dots, index, lut, i);
                          popupmenustructures.items.items[popupmenustructures.items.count-1].enabled := dots.dimensions[0]\>2;
                          createmask1.add(tmenuitem.create(self));
                          createmask1.items[createmask1.count-1].caption := t;
                          createmask1.items[createmask1.count-1].onclick := buttonsetreferencemaskclick;
                          createmask1.items[createmask1.count-1].tag := 1;
                          createmask1.items[createmask1.count-1].enabled  := dots.dimensions[0]\>2;
                          j := pos(t, maskdelineation);
                          if j\>1 then if not (ansichar(maskdelineation[j-1]) in [\'[\', \'|\']) then j:=0;
                          if j\>0 then
                          begin
                            r := j + length(t);
                            if r\<length(maskdelineation) then if maskdelineation[r]\<\>\'|\' then j:=0;
                          end;
                          if j\>0 then createmask1.items[createmask1.count-1].checked := true;
                          refpointatcenterofdelineation.add(tmenuitem.create(self));
                          refpointatcenterofdelineation.items[popupmenustructures.items.count-1].caption := t;
                          refpointatcenterofdelineation.items[popupmenustructures.items.count-1].onclick := menustructurechoiceclick;
                          if ((refpointatcenterofdelineation.count - 1 = delineationdotslut.dimensions[0] div 2) and
                              (delineationdotslut.dimensions[0] \> 14)) then refpointatcenterofdelineation.items[refpointatcenterofdelineation.count-1].break := mbbarbreak;
                          refpointatcenterofdelineation.items[popupmenustructures.items.count-1].enabled := dots.dimensions[0]\>2;
                          if busedisplaystructure then
                          begin
                            j := 1;
                            repeat
                              s := h.readstring(section, \'displaystructure\'+inttostr(j), \'\');
                              j := j + 1;
                              if s=t then
                              begin
                                inc(checkedcount);
                                delineationdotslut.setvalue([i, 27], 0);
                                break;
                              end;
                            until s = \'\';
                          end;
                          popupmenustructures.items.items[popupmenustructures.items.count-1].checked :=
                            not boolean(round(delineationdotslut.getvalue([i, 27])))
                        end;
                      end;
                      if popupmenustructures.items.count\>0 then
                      begin
                        popupmenustructures.items.add(tmenuitem.create(self));
                        popupmenustructures.items.items[popupmenustructures.items.count-1].caption := \'-\';
                        popupmenustructures.items.items[popupmenustructures.items.count-1].onclick := nil;
                        popupmenustructures.items.add(tmenuitem.create(self));
                        popupmenustructures.items.items[popupmenustructures.items.count-1].tag := -1;
                        if checkedcount\>0 then
                          popupmenustructures.items.items[popupmenustructures.items.count-1].caption := popupmenu_structures_all_off
                        else
                          popupmenustructures.items.items[popupmenustructures.items.count-1].caption := popupmenu_structures_all_on;
                        popupmenustructures.items.items[popupmenustructures.items.count-1].onclick := menustructuresclick;
                      end;
                      activesettingstolistview(h, false);
                      h.free;
                      if allblack then
                        for i:=0 to delineationdotslut.dimensions[0]-1 do
                          dil_set_color(delineationdotslut, delineationdotslut, i, 255, 255, 0, 0);
                    end;
                    dots.free;
                    index.free;
                    lut.free;
                    if not delineationdots.empty then
                    begin
                      createmask1.add(tmenuitem.create(self));
                      createmask1.items[createmask1.count-1].caption := \'-\';
                      createmask1.add(tmenuitem.create(self));
                      createmask1.items[createmask1.count-1].caption := menu_mask_allvisible;
                      createmask1.items[createmask1.count-1].onclick := buttonsetreferencemaskclick;
                      createmask1.items[createmask1.count-1].tag := 0;
                    end;
                    createmask1.add(tmenuitem.create(self));
                    createmask1.items[createmask1.count-1].caption := menu_mask_empty;
                    createmask1.items[createmask1.count-1].onclick := buttonsetreferencemaskclick;
                    createmask1.items[createmask1.count-1].tag := 2;
                    createmask1.add(tmenuitem.create(self));
                    createmask1.items[createmask1.count-1].caption := \'-\';
                    createmask1.add(tmenuitem.create(self));
                    createmask1.items[createmask1.count-1].caption := margin_menu + format(\'%0.2f cm\', [maskmargin]);
                    createmask1.items[createmask1.count-1].enabled := false;
                    createmask1.add(tmenuitem.create(self));
                    if maskedited then createmask1.items[createmask1.count-1].caption := edited_menu
                    else               createmask1.items[createmask1.count-1].caption := not_edited_menu;
                    createmask1.items[createmask1.count-1].enabled := false;
                    createmask1.add(tmenuitem.create(self));
                    createmask1.items[createmask1.count-1].caption := signature_menu + referenceapprovalby;
                    createmask1.items[createmask1.count-1].enabled := false;
                    screen.cursor := save;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_249()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonstructuresclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenustructures.popup(buttonstructures.clientorigin.x + buttonstructures.width div 2,buttonstructures.clientorigin.y  + buttonstructures.height div 2);
                    timer1.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_250()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.menuclipboxlockedclick(sender: tobject);
                  var clipboxes, i :integer;
                  begin
                    clipboxes := 0;
                    for i:=1 to nclipbox do
                      if not clipbox[i].empty then inc(clipboxes) else break;
                    if clipboxes \> 1 then
                    begin
                      i := 1;
                      if activeregion.value+1 = i then
                        for i := 2 to clipboxes do
                          if not clipbox[i].empty then break;
                      clipbox[i].locked := not clipbox[i].locked;
                      menuclipboxlocked.checked := clipbox[i].locked;
                      clipboxlockedstatus(false);
                    end
                    else
                    begin
                      clipbox[1].locked := not clipbox[1].locked;
                      menuclipboxlocked.checked := clipbox[1].locked;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_251()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.menushowunlockpresentclipboxclick(sender: tobject);
                  begin
                    if menuclipboxlocked.checked then
                    begin
                      if striphotkey((sender as tmenuitem).caption) = menu_menuunlockpresent_caption then
                        (sender as tmenuitem).caption := menu_menulockall_caption
                      else (sender as tmenuitem).caption := menu_menuunlockpresent_caption
                    end
                    else
                    begin
                      if striphotkey((sender as tmenuitem).caption) = menu_menushowpresent_caption then
                        (sender as tmenuitem).caption := menu_menushowall_caption
                      else (sender as tmenuitem).caption := menu_menushowpresent_caption;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_252()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.menustructuresclick(sender: tobject);
                  var i, j: integer;
                      t, c: string;
                      allonoroff: boolean;
                      menuitem: tmenuitem;
                  begin
                    menuitem := (sender as tmenuitem);
                    c := striphotkey(menuitem.caption);
                    if abs(menuitem.tag) = 1 then
                      allonoroff := true
                    else
                    begin
                      allonoroff := false;
                      menuitem.checked := not menuitem.checked;
                    end;
                    if allonoroff then
                    begin
                      for j:=0 to popupmenustructures.items.count-1 do
                      begin
                        c := striphotkey(popupmenustructures.items[j].caption);
                        for i:=0 to delineationdotslut.dimensions[0]-1 do
                        begin
                          dil_get_name(delineationdotslut, t, i);
                          if t = c then
                          begin
                              delineationdotslut.setvalue([i, 27], ord(menuitem.tag\<\>1));
                              popupmenustructures.items.items[j].checked := menuitem.tag=1;
                              break;
                          end;
                        end;
                      end;
                      if menuitem.tag=1 then
                        menuitem.caption := popupmenu_structures_all_off
                      else
                        menuitem.caption := popupmenu_structures_all_on;
                      menuitem.tag := -menuitem.tag;
                    end
                    else
                    begin
                      for i:=0 to delineationdotslut.dimensions[0]-1 do
                      begin
                        dil_get_name(delineationdotslut, t, i);
                        if t = c then
                          delineationdotslut.setvalue([i, 27], ord(not menuitem.checked));
                      end;
                    end;
                    quirtviewerupdsagittal.make;
                    quirtviewerupdcoronal.make;
                    quirtviewerupdtransversal.make;
                    timer1.enabled := false;
                    popupmenustructures.popup(buttonstructures.clientorigin.x + buttonstructures.width div 2,buttonstructures.clientorigin.y  + buttonstructures.height div 2);
                    timer1.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_253()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.expandcontours(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_254()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsetdoseclick(sender: tobject);
                  var save:   tcursor;
                      t, uid, url: string;
                      i, j: integer;
                      machinetosiddon: tavsfield;
                  begin
                    if assigned(sender) then
                    begin
                      dosecube.clear;
                      url := patienturl;
                      if (scanurl=\'\') and (planurl=\'\') then
                      begin
                        t := patienturl;
                        buttonclinicalpatientclick(nil);
                        url := patienturl;
                        if patienturl=\'\' then exit;
                      end;
                      if (importdatatype=\'dicom\') then
                      begin
                        save := screen.cursor;
                        screen.cursor := crhourglass;
                        doseurl := \'\';
                        try
                          try
                        m := trtdatasourcemodality.create(studyurl);
                        urlset := m.selectbyname(\'dose\');
                        for i := 0 to urlset.nodecount-1 do
                        begin
                          m2 := trtdatasourcemodality.create(urlset.node[i].fullurl);
                          try
                            if (extractfilename(planurl)=m2.propertyvalue[\'referencedsopinstanceuid\']+\'.plan\') and
                                   (uppercase(m2.propertyvalue[\'dosesummationtype\'])\<\>\'beam\') and
                                   (uppercase(m2.propertyvalue[\'dosetype\'])=\'physical\') then
                            begin
                              doseurl := urlset.node[i].fullurl;
                              break;
                            end;
                          finally
                            m2.free;
                          end;
                        end;
                          except
                            doseurl := \'\';
                          end;
                        finally
                        freeandnil(urlset);
                        m.free;
                        end;
                        if (doseurl = \'\') then
                        begin
                          nfractions := 0;
                          screen.cursor := save;
                          showmessage(\'no valid dose file found\');
                          exit;
                      end
                        else
                        begin
                          m := trtdatasourcemodality.create(planurl);
                          nfractions := round(safestrtofloat(m.propertyvalue[\'numberoffractionsplanned\'], 0));
                          screen.cursor := save;
                        end;
                      end
                      else if (importdatatype=\'pinnacle\')  then
                      begin
                        t := treeselector(url, \'dose\');
                        if (t=\'\') or (t=url) then exit;
                        doseurl := t;
                      end
                      else
                        exit;
                      referencedatachanged := true;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if onlinecube.empty then
                    begin
                      field_create(onlinecube, \'field 3d 1-vector byte\', 256, 256, 256);
                      case defaultfov of
                        76:  modify_extents(onlinecube, onlinecube, 0.2,   0.2,   0.2);
                        77:  modify_extents(onlinecube, onlinecube, 0.156, 0.156, 0.156);
                        83:  modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                        else modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                      end;
                      myzoom := 1.5 * zoomfix;
                      quirtviewerupdcoronalpanchanged(self, 0, 0);
                      quirtviewerupdsagittal.level[1].value := 1000;
                      quirtviewerupdsagittal.window[1].value := 500;
                      quirtviewerupdtransversal.level[1].maximum     := 2000;
                      quirtviewerupdtransversal.level[1].minimum     := 0;
                      quirtviewerupdtransversal.window[1].maximum     := 1000;
                      quirtviewerupdtransversal.window[1].minimum     := 0;
                    end;
                    if                 dose[1].exists(cachefilebase, treatmentuid,  \'dose\') then uid := treatmentuid;
                    if synergymode and dose[1].exists(cachefilebase, scanseriesuid, \'dose\') then uid := scanseriesuid;
                    if synergymode and dose[1].exists(cachefilebase, plansopuid,    \'dose\') then uid := plansopuid;
                    if sender=nil then
                    begin
                      dose[1].load(cachefilebase, uid, \'dose\');
                      if dose[1].tosiddon.empty then dose[1].clear;
                    end
                    else
                    begin
                      if (importdatatype\<\>\'pinnacle\') and (importdatatype\<\>\'dicom\') and (importdatatype\<\>\'\') and (avlstate\<0) then
                      begin
                      end
                      else if importdatatype\<\>\'\' then
                      begin
                        treereader(dosecube       , doseurl, \'\');
                        treereader(dose_to_siddon,  doseurl, \'worldxfm\');
                        if (scanurl=\'\') and (planurl=\'\') then
                        begin
                          doseurl := treeselector(patienturl, \'beam\');
                          if doseurl\<\>\'\' then
                          begin
                          machinetosiddon := tavsfield.create;
                            treereader(machinetosiddon, doseurl, \'\');
                          treereader(machinetosiddon, doseurl, \'worldxfm\');
                          for i:=0 to 2 do
                            for j:=0 to 2 do
                              if i=j then machinetosiddon.setvalue([i,j], 1)
                              else        machinetosiddon.setvalue([i,j], 0);
                          transform_math(dose_to_siddon, machinetosiddon, dose_to_machine, false, true);
                          transform_math(dose_to_machine, machine_to_siddon, dose_to_siddon, false, false);
                          field_overlay_lut(doselut, \'blackbluegreenyellowred\', 0, round(dosecube.maximum), -1, 100, 32);
                          checkboxdose.checked := true;
                          showmessage(message_experimentaldoseimprt);
                          machinetosiddon.free;
                        end;
                      end;
                    end;
                    end;
                    if not dosecube.empty then
                    begin
                      field_overlay_lut(doselut, \'blackbluegreenyellowred\', 0, round(dosecube.maximum), -1, 100, 32);
                      checkboxdose.checked := true;
                    end;
                    screen.cursor := save;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_255()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.isodoselines1click(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_256()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.vizisodoselines(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_257()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.vizstructures;
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_258()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.showisodoselines1click(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_259()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.isodoselinesclear(sender: tobject);
                  var
                    i : integer;
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_260()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttondoseaccumulateclick(sender: tobject);
                  var w, s, t: tavsfield;
                      x: ttransform;
                      count, total: integer;
                  begin
                    if not doseaccu.empty then
                      if messagedlg(\'reset previous accumulated dose?\', mtconfirmation, [mbyes, mbno], 0) = mryes then
                        doseaccu.clear;
                    w := tavsfield.create;
                    s := tavsfield.create;
                    t := tavsfield.create;
                    x := ttransform.create;
                    total := 1;
                    if not transform4d.empty then total := transform4d.dimensions[3];
                    for count:=0 to total-1 do
                    begin
                      x.assign(dose_to_machine);
                      if not transform4d.empty then
                      begin
                        field_slice(transform4d, t, -1, -1, nclipbox*2, 0);
                        if t.getvalue([3,3])\>0.99 then
                          transform_math(x, t, x, false, true);
                        if (comboboxcorrectionprotocol.text = correction_from_clipbox) then
                          field_slice(transform4d, t, -1, -1, 0, count)
                        else
                          field_slice(transform4d, t, -1, -1, nclipbox, count);
                        if t.getvalue([3,3])\<0.99 then continue;
                        transform_math(x, t, x);
                      end;
                    if doseaccu.empty then
                        fieldxfm(dosecube, x, onlinecube, doseaccu, 0, 0, fieldxfm_3dfield)
                      else
                      begin
                        fieldxfm(dosecube, x, onlinecube, t, 0, 0, fieldxfm_3dfield);
                        field_add(doseaccu, t, doseaccu);
                      end;
                    end;
                    field_overlay_lut(doseacculut, \'blackbluegreenyellowred\', 0, round(doseaccu.maximum), -1, 100, 32);
                    t.free;
                    w.free;
                    s.free;
                    x.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_261()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttondoseclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenudose.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_262()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.clearmaskclick(sender: tobject);
                  var i: integer;
                  begin
                    if messagedlg(message_deletemask, mtconfirmation, [mbyes, mbno], 0) \<\> mryes then exit;
                    makeregistrationbackup(nclipbox, 2*nclipbox-1, 0, 9999);
                    invalidatecorrection;
                    maskedreference.clear;
                    referencemask.clear;
                    editmask.checked := false;
                    masklocked.checked := true;
                    maskid := \'\';
                    maskedited := false;
                    maskmargin := 0.0;
                    for i:=0 to createmask1.count-1 do
                      createmask1.items[i].checked := false;
                    createmask1.items[createmask1.count-3].caption := margin_menu + format(\'%0.2f cm\', [maskmargin]);
                    if maskedited then createmask1.items[createmask1.count-2].caption := edited_menu
                    else               createmask1.items[createmask1.count-2].caption := not_edited_menu;
                    createmask1.items[createmask1.count-1].caption := signature_menu + referenceapprovalby;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_263()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsetreferencemaskclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_264()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonmaskclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_265()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.editmaskclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_266()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updatechamferdotsreference(sender: tobject; var unchanged: boolean);
                  var dum1, dum2, dum3: tavsfield;
                      dumval, v2, m: integer;
                  begin
                    if not editmask.checked then
                    begin
                      chamferdotsreference.blanking := true;
                      exit;
                    end;
                    if (pos(match_substring_seed, comboboxmaskmatch.text)\>0) then
                    begin
                      dum1 := tavsfield.create;
                      dum2 := tavsfield.create;
                      dum3 := tavsfield.create;
                      field_findcropbox(referencemask,     dum2);
                      field_cropwithbox(reference[1].data, dum2, dum1);
                      field_cropwithbox(referencemask,     dum2, dum3);
                      field_mask(dum1, dum3, dum1);
                      m := (round(dum1.maximum));
                      field_mrthreshold(dum1, dum2, dumval, v2, dum3, -1, 11, 1, 0.2, 100, 100, false, false);
                      v2 := v2 + (m - v2) div 8;
                      createdotlist    (dum1, chamferdotsreference, v2, false, 1);
                      visboneseg(false);
                      dum1.free;
                      dum2.free;
                      dum3.free;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_267()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.readwritemask(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_268()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.changebrushsize(sender: tobject);
                  var k, t: integer;
                      scale : single;
                  begin
                    t := 5;
                    if assigned(sender) then
                    begin
                      for k := 0 to paintbrushsize.count-1 do
                        paintbrushsize.items[k].checked := false;
                      (sender as tmenuitem).checked := true;
                      t := (sender as tmenuitem).tag;
                    end
                    else
                    begin
                      for k := 0 to paintbrushsize.count-1 do
                        if paintbrushsize.items[k].checked = true then
                        begin
                          t := paintbrushsize.items[k].tag;
                          break;
                        end;
                    end;
                    scale := 0.1;
                    quirtviewerupdcoronal.paintbrushsize.value        := scale * t;
                    quirtviewerupdsagittal.paintbrushsize.value       := scale * t;
                    quirtviewerupdtransversal.paintbrushsize.value    := scale * t;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_269()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.strippedsavereference;
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_270()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsavereferenceclick(sender: tobject);
                  var filename, initials: string;
                      i: tqinifile;
                      save: tcursor;
                      flag: boolean;
                  begin
                    if synergymode then filename := adminfilebase + plansopuid   + \'.xvi\'
                    else                filename := adminfilebase + treatmentuid + \'.xvi\';
                      if fileexists(filename) then
                      begin
                        i := tqinifile.create(filename);
                        flag := i.sectionexists(\'xvi\');
                        i.free;
                        if flag then
                          if messagedlg(replace_ref, mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                            exit;
                      end;
                    if synergymode then
                      validaterefform.dicom(true)
                    else
                      validaterefform.dicom(importdatatype = \'dicom\');
                    validaterefidentnum := planurl;
                      if validaterefform.showmodal\<\>mrok then exit;
                    if (referencecube.empty or beamdots.empty) and not (validaterefform.editdataset.text=\'ignorechecks\') then
                    begin
                      showmessage(error_nkiincompletepreset);
                      exit;
                    end;
                    initials := validaterefform.editinitials.text;
                    referencedatachanged := false;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    i := tqinifile.create(filename);
                    savesettings(i,avlref,initials, true);
                    savereferencedata(avlref);
                    i.updatefile;
                    i.free;
                    screen.cursor := save;
                    buttonloadreference.enabled := true;
                    togglebuttonloadreference() ;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_271()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.savereferencedata(mode : safesettingmode);
                  var uid: string;
                      a, x: tavsfield;
                      eq : integer;
                  begin
                    if synergymode then uid := plansopuid
                    else                uid := treatmentuid;
                    if mode in [elektaref, avlref] then
                    begin
                      sysutils.forcedirectories(extractfilepath(cachefilebase));
                      dose[1].save(cachefilebase, uid, \'dose\');
                      if editmask.checked then
                        editmaskclick(self);
                      if not referencemask.empty then
                      begin
                        a := tavsfield.create;
                        field_to_short(referencemask, a);
                        write_xdr(a, cachefilebase + uid + \'.mask\',         \'\', \'\', 2);
                        write_xdr(reference_to_siddon, cachefilebase + uid + \'.mask.orientation\');
                        if maskid\<\>\'\' then
                        begin
                          write_xdr(a, cachefilebase + uid + \'.mask.\'+maskid, \'\', \'\', 2);
                          write_xdr(reference_to_siddon, cachefilebase + uid + \'.mask.orientation.\'+maskid, \'\', \'\', 2);
                        end;
                        a.free;
                      end
                      else
                      begin
                        if fileexists(cachefilebase + uid + \'.mask\') then
                          deletefile(cachefilebase + uid + \'.mask\');
                        if fileexists(cachefilebase + uid + \'.mask.orientation\') then
                          deletefile(cachefilebase + uid + \'.mask.orientation\');
                      end;
                    end;
                    if mode in [elektaalign,elektareconalign] then
                    begin
                      if editmask.checked then
                        editmaskclick(self);
                      if not referencemask.empty and fileexists(cachefilebase + uid + \'.mask\') then
                      begin
                        a := tavsfield.create;
                        x := tavsfield.create;
                        read_xdr(x, cachefilebase + uid + \'.mask\');
                        field_to_short(referencemask, a);
                        field_compare_data(a, x, eq);
                        if eq=0 then
                        begin
                          write_xdr(a, cachefilebase + uid + \'.mask.\'+maskid, \'\', \'\', 2);
                          write_xdr(reference_to_siddon, cachefilebase + uid + \'.mask.orientation.\'+maskid);
                        end;
                        a.free;
                        x.free;
                      end
                      else if not referencemask.empty then
                      begin
                        a := tavsfield.create;
                        field_to_short(referencemask, a);
                        write_xdr(a, cachefilebase + uid + \'.mask.\'+maskid, \'\', \'\', 2);
                        write_xdr(reference_to_siddon, cachefilebase + uid + \'.mask.orientation.\'+maskid);
                        a.free;
                      end;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_272()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.selectreferencesection(i : tinifiles; sender : tobject) : string;
                  var
                    uid, filename : string;
                  begin
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    if avlstate\>0 then filename := paramstr2
                    else               filename := adminfilebase + uid + \'.xvi\';
                    result := \'\';
                    if not i.sectionexists(\'xvi\') and not i.sectionexists(\'reference\') and not synergymode then
                    begin
                      showmessage(ref_section_error);
                      exit;
                      i.free;
                    end;
                    result := \'xvi\';
                    if i.sectionexists(\'reference\') then result := \'reference\';
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_273()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonloadreferenceclick(sender: tobject);
                  var filename, s, section: string;
                      i       : tinifiles;
                      save    : tcursor;
                      j       : integer;
                      x, y, z : single;
                      b, dummy : boolean;
                      uid, maskstorefilebase, maskfilename, maskorientationfilename : string;
                      sr       : tsearchrec;
                      masks    : tstringlist;
                  begin
                    needloadreference := false;
                    if assigned(sf) then
                    begin
                      sl.caption := wait_loadref;
                      sl.update;
                      sf.update;
                    end;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    if avlstate\>0 then filename := paramstr2
                    else               filename := adminfilebase + uid + \'.xvi\';
                    if not fileexists(filename)  then
                    begin
                      showmessage(ref_error+ \' : \' + filename);
                      exit;
                    end;
                    if sectiontoload=\'none\' then
                      i := tinifiles.create([cachefilebase + elektatreatmentuid + \'.ini.xvi\', filename])
                    else
                    begin
                      if (avlstate=3) and (sectiontoload\<\>\'none\') then
                        i := tinifiles.create([filename, cachefilebase + elektatreatmentuid + \'.ini.xvi\', filename + \'.xvi\'])
                      else
                        i := tinifiles.create([cachefilebase + elektatreatmentuid + \'.ini.xvi\', filename + \'.xvi\', filename]);
                    end;
                    section := selectreferencesection(i, sender) ;
                    if section = \'\' then
                    begin
                      i.free ;
                      exit;
                    end;
                    if not ((filename = paramstr2) and synergymode) then
                    begin
                      patienturl     := i.readstring (section, \'patienturl\',     \'\');
                      scanurl        := i.readstring (section, \'scanurl\',        \'\');
                      planurl        := i.readstring (section, \'planurl\',        \'\');
                      beamurl        := i.readstring (section, \'beamurl\',        \'\');
                      doseurl        := i.readstring (section, \'doseurl\',        \'\');
                      delineationurl := i.readstring (section, \'delineationurl\', \'\');
                    end;
                    maskmargin     := i.readfloat  (section, \'maskmargin\',     0.0);
                    maskdelineation:= i.readstring (section, \'maskdelineation\',\'\');
                    maskbodysite   := i.readstring (section, \'maskbodysite\',   \'prostate\');
                    masklevel      := i.readinteger(section, \'masklevel\',  1000);
                    maskwindow     := i.readinteger(section, \'maskwindow\',  1000);
                    maskid         := i.readstring (section, \'maskid\',  \'\');
                    maskedited     := i.readbool   (section, \'maskedited\',  false);
                    referenceapprovalby := i.readstring (section, \'referenceapprovalby\', \'\');
                    scanurl        := i.readstring (section, \'scanpresent\',        scanurl);
                    planurl        := i.readstring (section, \'planpresent\',        planurl);
                    beamurl        := i.readstring (section, \'beampresent\',        beamurl);
                    doseurl        := i.readstring (section, \'dosepresent\',        doseurl);
                    delineationurl := i.readstring (section, \'delineationpresent\', delineationurl);
                    s := i.readstring (section, \'reconstructionprotocol\', \'\');
                    comboboxprotocol.itemindex := comboboxprotocol.items.indexof(s);
                    checkboxscan.checked          := i.readbool   (section, \'showscan\',        checkboxscan.checked);
                    showall1.checked              := i.readbool   (section, \'showallscan\',     showall1.checked);
                    checkboxplan.checked          := i.readbool   (section, \'showplan\',        checkboxplan.checked);
                    checkboxplan.checked          := i.readbool   (section, \'showbeams\',       checkboxplan.checked);
                    checkboxdose.checked          := i.readbool   (section, \'showdose\',        checkboxdose.checked);
                    checkboxdelineation.checked   := i.readbool   (section, \'showdelineation\', checkboxdelineation.checked);
                    checkboxroi.checked           := i.readbool   (section, \'showroi\',         checkboxroi.checked);
                    checkboxroi.checked           := i.readbool   (section, \'showclipbox\',     checkboxroi.checked);
                    checkboxreferencemask.checked := i.readbool   (section, \'showmask\',        checkboxreferencemask.checked);
                    checkboxenablerotation.checked   := i.readbool   (section, \'enablerotation\',  checkboxenablerotation.checked);
                    comboboxsliceaveraging.itemindex := i.readinteger(section, \'sliceaveraging\',  comboboxsliceaveraging.itemindex);
                    s := lowercase(i.readstring(section, \'displaymode\',     \'greenpurple\'));
                    if      s=\'greenpurple\'   then comboboxdisplaymode.itemindex := 0
                    else if s=\'cut\'           then comboboxdisplaymode.itemindex := 1
                    else if s=\'onlineonly\'    then comboboxdisplaymode.itemindex := 2
                    else if s=\'referenceonly\' then comboboxdisplaymode.itemindex := 3
                    else    comboboxdisplaymode.itemindex := strtointdef(s, 0);
                    s := i.readstring (section, \'registrationprotocol\', \'clipbox\');
                    appliedcorrectionprotocol := s;
                    comboboxregistrationprotocol.itemindex := comboboxregistrationprotocol.indexofmapped(s);
                    if comboboxregistrationprotocol.itemindex=-1 then comboboxregistrationprotocol.itemindex := 0;
                    comboboxregistrationprotocolchange(nil);
                    s := i.readstring (section, \'correctionfromprotocol\',  \'clipbox\');
                    appliedcorrectionfrom := s;
                    comboboxcorrectionprotocol.itemindex := comboboxcorrectionprotocol.indexofmapped(s);
                    if comboboxcorrectionprotocol.itemindex=-1 then
                    begin
                      if (comboboxcorrectionprotocol.itemindex in [0,4]) then comboboxcorrectionprotocol.itemindex := comboboxcorrectionprotocol.indexofmapped(\'clipbox\')
                      else comboboxcorrectionprotocol.itemindex := comboboxcorrectionprotocol.indexofmapped(\'mask (mean if 4d)\')
                    end;
                    s := i.readstring (section, \'correctionbyprotocol\', nameof3dsystemmappedtext);
                    comboboxcorrectionby.itemindex := comboboxcorrectionby.indexofmapped(s);
                    comboboxcorrectionbychange(self);
                    if comboboxcorrectionby.itemindex=-1 then comboboxcorrectionby.itemindex := 0;
                    appliedcorrectionby := s;
                    s := lowercase(i.readstring(section, \'matchmethod\', match_bone));
                    comboboxmatch.itemindex := comboboxmatch.items.indexof(s);
                    setregistrationparameters(comboboxmatch);
                    if      s = \'bone\'       then s:= match_bonetr
                    else if s = \'grey value\' then s:= match_greytr
                    else if s = \'manual\'     then s:= match_manual;
                    s := i.readstring (section, \'clipboxmatchmethod\', s);
                    appliedclipboxmatchmethod := s;
                    comboboxclipboxmatch.itemindex := comboboxclipboxmatch.indexofmapped(s);
                    if comboboxclipboxmatch.itemindex=-1 then comboboxclipboxmatch.itemindex := 0;
                    s := i.readstring (section, \'maskmatchmethod\', \'grey value (t + r)\');
                    appliedmaskmatchmethod := s;
                    comboboxmaskmatch.itemindex := comboboxmaskmatch.indexofmapped(s);
                    if comboboxmaskmatch.itemindex=-1 then comboboxmaskmatch.itemindex := 0;
                    b := i.readbool (section, \'clipboxtranslationlimitsidentical\', true);
                    colorstringgrid2.cellprops[1,0].box.checked := b;
                    if b then
                    begin
                      s := i.readstring (section, \'clipboxtranslationwarnlimit\', \'0.0\');
                      colorstringgrid2.cells[2,1] := s;
                    end
                    else
                    begin
                      s := i.readstring (section, \'clipboxtranslationwarnlimitright\', \'0.0\');
                      colorstringgrid2.cells[1,1] := s;
                      s := i.readstring (section, \'clipboxtranslationwarnlimitleft\', \'0.0\');
                      colorstringgrid2.cells[2,1] := s;
                      s := i.readstring (section, \'clipboxtranslationwarnlimitinf\', \'0.0\');
                      colorstringgrid2.cells[1,2] := s;
                      s := i.readstring (section, \'clipboxtranslationwarnlimitsup\', \'0.0\');
                      colorstringgrid2.cells[2,2] := s;
                      s := i.readstring (section, \'clipboxtranslationwarnlimitpost\', \'0.0\');
                      colorstringgrid2.cells[1,3] := s;
                      s := i.readstring (section, \'clipboxtranslationwarnlimitant\', \'0.0\');
                      colorstringgrid2.cells[2,3] := s;
                    end;
                    b := i.readbool (section, \'clipboxrotationlimitsidentical\', true);
                    colorstringgrid2.cellprops[1,4].box.checked := b;
                    if b then
                    begin
                      s := i.readstring (section, \'clipboxrotationwarnlimit\', \'0.0\');
                      colorstringgrid2.cells[2,5] := s;
                    end
                    else
                    begin
                      s := i.readstring (section, \'clipboxrotationwarnlimitlr_cc\', \'0.0\');
                      colorstringgrid2.cells[1,5] := s;
                      s := i.readstring (section, \'clipboxrotationwarnlimitlr_cw\', \'0.0\');
                      colorstringgrid2.cells[2,5] := s;
                      s := i.readstring (section, \'clipboxrotationwarnlimitsi_cc\', \'0.0\');
                      colorstringgrid2.cells[1,6] := s;
                      s := i.readstring (section, \'clipboxrotationwarnlimitsi_cw\', \'0.0\');
                      colorstringgrid2.cells[2,6] := s;
                      s := i.readstring (section, \'clipboxrotationwarnlimitap_cc\', \'0.0\');
                      colorstringgrid2.cells[1,7] := s;
                      s := i.readstring (section, \'clipboxrotationwarnlimitap_cw\', \'0.0\');
                      colorstringgrid2.cells[2,7] := s
                    end;
                    b := i.readbool (section, \'masktranslationlimitsidentical\', true);
                    colorstringgrid3.cellprops[1,0].box.checked := b;
                    if b then
                    begin
                      s := i.readstring (section, \'masktranslationwarnlimit\', \'0.0\');
                      colorstringgrid3.cells[2,1] := s;
                    end
                    else
                    begin
                      s := i.readstring (section, \'masktranslationwarnlimitright\', \'0.0\');
                      colorstringgrid3.cells[1,1] := s;
                      s := i.readstring (section, \'masktranslationwarnlimitleft\', \'0.0\');
                      colorstringgrid3.cells[2,1] := s;
                      s := i.readstring (section, \'masktranslationwarnlimitinf\', \'0.0\');
                      colorstringgrid3.cells[1,2] := s;
                      s := i.readstring (section, \'masktranslationwarnlimitsup\', \'0.0\');
                      colorstringgrid3.cells[2,2] := s;
                      s := i.readstring (section, \'masktranslationwarnlimitpost\', \'0.0\');
                      colorstringgrid3.cells[1,3] := s;
                      s := i.readstring (section, \'masktranslationwarnlimitant\', \'0.0\');
                      colorstringgrid3.cells[2,3] := s;
                    end;
                    b := i.readbool (section, \'maskrotationlimitsidentical\', true);
                    colorstringgrid3.cellprops[1,4].box.checked := b;
                    if b then
                    begin
                      s := i.readstring (section, \'maskrotationwarnlimit\', \'0.0\');
                      colorstringgrid3.cells[2,5] := s;
                    end
                    else
                    begin
                      s := i.readstring (section, \'maskrotationwarnlimitlr_cc\', \'0.0\');
                      colorstringgrid3.cells[1,5] := s;
                      s := i.readstring (section, \'maskrotationwarnlimitlr_cw\', \'0.0\');
                      colorstringgrid3.cells[2,5] := s;
                      s := i.readstring (section, \'maskrotationwarnlimitsi_cc\', \'0.0\');
                      colorstringgrid3.cells[1,6] := s;
                      s := i.readstring (section, \'maskrotationwarnlimitsi_cw\', \'0.0\');
                      colorstringgrid3.cells[2,6] := s;
                      s := i.readstring (section, \'maskrotationwarnlimitap_cc\', \'0.0\');
                      colorstringgrid3.cells[1,7] := s;
                      s := i.readstring (section, \'maskrotationwarnlimitap_cw\', \'0.0\');
                      colorstringgrid3.cells[2,7] := s
                    end;
                    boxclick(colorstringgrid2.cellprops[1,0].box);
                    boxclick(colorstringgrid3.cellprops[1,0].box);
                    loadclipboxes(i, section, clipbox, cbnames, cbweights);
                    updateviewernamelabels() ;
                    x := i.readfloat(section, \'isocx\', -9999);
                    y := i.readfloat(section, \'isocy\', -9999);
                    z := i.readfloat(section, \'isocz\', -9999);
                    if (x\<-9990) or (y\<-9990) or (z\<-9990) then
                    begin
                      showmessage(isoc_error);
                      if avlstate\>0 then
                      begin
                        application.terminate;
                        exit;
                      end;
                    end;
                    if synergymode and buttonsavereference.visible then
                      if (abs(x - strtofloat(syn_isox)) \> 0.01) or
                         (abs(y - strtofloat(syn_isoy)) \> 0.01) or
                         (abs(z - strtofloat(syn_isoz)) \> 0.01) then
                         showmessage(error_nkiisocerror);
                    try
                      machine_to_siddon.maketranslation(x, y, z);
                    except
                      showmessage(isoc_error);
                      if avlstate\>0 then
                      begin
                        application.terminate;
                        exit;
                      end;
                    end;
                    if i.readbool(section,\'markerset\',false) then
                    begin
                      field_create(quirtviewerupdcoronal.markerdots[1], \'field 1d 3-space irregular 20-vector byte\', 1);
                      quirtviewerupdcoronal.markerdots[1].coordinate[0,0] := i.readfloat(section, \'markerx\', 0);
                      quirtviewerupdcoronal.markerdots[1].coordinate[1,0] := i.readfloat(section, \'markery\', 0);
                      quirtviewerupdcoronal.markerdots[1].coordinate[2,0] := i.readfloat(section, \'markerz\', 0);
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 0], ord(\'c\'));
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 1], 255);
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 2], 0);
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 3], 0);
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 4], ord(\'s\'));
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 5], ord(\'+\'));
                      quirtviewerupdcoronal.markerdots[1].ischangedby := nil;
                    end
                    else
                      quirtviewerupdcoronal.markerdots[1].clear;
                    x := i.readfloat(section, \'correctionreferencepointx\', -9999);
                    y := i.readfloat(section, \'correctionreferencepointy\', -9999);
                    z := i.readfloat(section, \'correctionreferencepointz\', -9999);
                    correctionreferencepointstructure := i.readstring (section, \'correctionreferencepointstructure\', \'\');
                    correctionreferencepoint.debugname := inttostr(i.readinteger(section, \'correctionreferencepointmode\', 0));
                    if (x\<-9990) or (y\<-9990) or (z\<-9990) then
                    begin
                      if not synergymode then
                      begin
                        showmessage(cor_ref_error);
                        if avlstate\>1 then
                          application.terminate;
                      end
                      else
                      begin
                        x := syn_crpx / 10;
                        y := syn_crpy / 10;
                        z := syn_crpz / 10;
                        if syn_crpm=\'isocenter\' then correctionreferencepoint.debugname := \'0\';
                        if syn_crpm=\'clipbox\'   then correctionreferencepoint.debugname := \'1\';
                        if syn_crpm=\'marker\'    then correctionreferencepoint.debugname := \'2\';
                        if syn_crpm=\'center of structures\' then correctionreferencepoint.debugname := \'3\';
                        if syn_crpm=\'mask\' then correctionreferencepoint.debugname := \'4\';
                      end;
                    end;
                    correctionreferencepoint.coordinate[0,0] := x;
                    correctionreferencepoint.coordinate[1,0] := y;
                    correctionreferencepoint.coordinate[2,0] := z;
                    b := true;
                    updatecorrectionreferencepoint(nil, b);
                    s := lowercase(inifile.readstring(section, \'fov\', \'small\'));
                    if s=\'small\'  then defaultfov := 83;
                    if s=\'medium\' then defaultfov := 77;
                    if s=\'large\'  then defaultfov := 76;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if (avlstate\>0) then
                    begin
                      if (scanurl\<\>\'0\')                   then buttonsetscanclick(nil);
                      if (planurl\<\>\'0\') or (beamurl\<\>\'0\') then buttonsetplanclick(nil);
                      if (delineationurl\<\>\'0\')            then buttonsetdelineationclick(nil);
                      if (doseurl\<\>\'0\')                   then buttonsetdoseclick(nil);
                    end
                    else if (synergymode) then
                    begin
                      buttonsetscanclick(nil);
                      if (planurl\<\>\'0\') or (beamurl\<\>\'0\') then buttonsetplanclick(nil);
                      buttonsetdelineationclick(nil);
                      buttonsetdoseclick(nil);
                    end
                    else
                    begin
                      if (scanurl\<\>\'\')                  then buttonsetscanclick(nil);
                      if (planurl\<\>\'\') or (beamurl\<\>\'\') then buttonsetplanclick(nil);
                      if (doseurl\<\>\'\')                  then buttonsetdoseclick(nil);
                      if (delineationurl\<\>\'\')           then buttonsetdelineationclick(nil);
                    end;
                    comboboxregistrationprotocolchange(nil);
                    for j:=1 to high(online) do
                    begin
                      online[j].level.maximum  := 2000;
                      online[j].level.minimum  := 0;
                      online[j].window.maximum := 1000;
                      online[j].window.minimum := 0;
                      online[j].level.value  := i.readinteger  (section, \'online\'+inttostr(j)+\'.level\',  round(online[j].level.value));
                      online[j].window.value := i.readinteger  (section, \'online\'+inttostr(j)+\'.window\', round(online[j].window.value));
                    end;
                    online[1].level.value  := i.readinteger  (section, \'onlinelevel\',   round(online[1].level.value));
                    online[1].window.value := i.readinteger  (section, \'onlinewindow\',  round(online[1].window.value));
                    for j:=1 to high(reference) do
                    begin
                      reference[j].level.maximum  := 2000;
                      reference[j].level.minimum  := 0;
                      reference[j].window.maximum := 1000;
                      reference[j].window.minimum := 0;
                      reference[j].level.value  := i.readinteger  (section, \'reference\'+inttostr(j)+\'.level\',  round(reference[j].level.value));
                      reference[j].window.value := i.readinteger  (section, \'reference\'+inttostr(j)+\'.window\', round(reference[j].window.value));
                    end;
                    reference[1].level.value := i.readinteger  (section, \'referencelevel\',   round(reference[1].level.value));
                    reference[1].window.value := i.readinteger  (section, \'referencewindow\', round(reference[1].window.value));
                    restore1.checked := true;
                    levels[0] := online[1].level.value;
                    levels[1] := online[1].window.value;
                    levels[2] := reference[1].level.value;
                    levels[3] := reference[1].window.value;
                    restore1.enabled := true;
                    myzoom := i.readfloat  (section, \'zoom\', 1.5 * zoomfix);
                    quirtviewerupdtransversal.grid.make;
                    myzoom :=
                      myzoom * abs(quirtviewerupdtransversal.grid.coordinate[0, 1] - quirtviewerupdtransversal.grid.coordinate[0, 0]) / 0.1;
                      quirtviewerupdcoronalpanchanged(self, 0, 0);
                    field_create(quirtviewerupdcoronal.markerdots[3], \'field 1d 3-space irregular 20-vector byte\', 1);
                    quirtviewerupdcoronal.markerdots[3].coordinate[0,0] := i.readfloat(section, \'viewpointx\', 0);
                    quirtviewerupdcoronal.markerdots[3].coordinate[1,0] := i.readfloat(section, \'viewpointy\', 0);
                    quirtviewerupdcoronal.markerdots[3].coordinate[2,0] := i.readfloat(section, \'viewpointz\', 0);
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 0], ord(\'c\'));
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 1], 0);
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 2], 0);
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 3], 0);
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 4], ord(\'y\'));
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 5], 1);
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 6], ord(\'s\'));
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 7], ord(\'.\'));
                    quirtviewerupdcoronal.markerdots[3].ischangedby := self;
                    activesettingstolistview(i, false);
                    i.free;
                    if fileexists(cachefilebase + treatmentuid  + \'.mask\') then uid := treatmentuid;
                    if synergymode and fileexists(cachefilebase + scanseriesuid + \'.mask\') then uid := scanseriesuid;
                    if synergymode and fileexists(cachefilebase + plansopuid    + \'.mask\') then uid := plansopuid;
                    maskstorefilebase := cachefilebase;
                    maskfilename := maskstorefilebase + uid + \'.mask\';
                    maskorientationfilename := maskfilename + \'.orientation\';
                    if sectiontoload\<\>\'none\' then
                      if fileexists(maskfilename + \'.\' + maskid) then
                      begin
                        maskfilename := maskstorefilebase + uid + \'.mask.\' + maskid;
                        maskorientationfilename := maskstorefilebase + uid + \'.mask\' + \'.orientation.\' +maskid;
                      end;
                    begin
                      if fileexists(maskfilename) then
                        read_xdr(referencemask, maskfilename)
                      else
                      begin
                        maskid:=\'0\';
                        maskedreference.clear;
                        referencemask.clear;
                        maskedreferencelut.clear;
                      end;
                      if fileexists(maskorientationfilename) then
                      begin
                        read_xdr(maskedreferencetransform, maskorientationfilename);
                        transform_math(maskedreferencetransform, machine_to_siddon, maskedreferencetransform, false, true);
                      end
                      else
                        transform_math(reference_to_siddon, machine_to_siddon, maskedreferencetransform, false, true);
                      if (avlstate=1) and (maskid\<\>\'\') then
                      begin
                        masks := tstringlist.create;
                        if findfirst(maskstorefilebase + uid + \'.mask.\'+\'*.*\', 0, sr) = 0 then
                        begin
                          if (length(sr.name) \> length(uid + \'.mask\')) and (pos(\'orientation\', sr.name)=0) then masks.add(sr.name);
                          while findnext(sr) = 0 do
                            if (length(sr.name) \> length(uid + \'.mask\')) and (pos(\'orientation\', sr.name)=0) then masks.add(sr.name);
                          findclose(sr);
                        end;
                        masks.sort;
                        if masks.count\>0 then
                          if copy(masks[masks.count-1], length(masks[masks.count-1])-14, 15)\>maskid then
                          begin
                            timer1.enabled := false;
                            if messagedlg(format(message_reviewmask, [copy(masks[masks.count-1], length(masks[masks.count-1])-14, 15)]), mtconfirmation, [mbyes, mbno], 0) = mryes then
                            begin
                              read_xdr(referencemask, maskstorefilebase + masks[masks.count-1]);
                              if fileexists(maskstorefilebase + masks[masks.count-1]+\'.orientation\') then
                              begin
                                read_xdr(maskedreferencetransform, maskstorefilebase + masks[masks.count-1]+\'.orientation\');
                                transform_math(maskedreferencetransform, machine_to_siddon, maskedreferencetransform, false, true);
                              end
                              else
                                transform_math(reference_to_siddon, machine_to_siddon, maskedreferencetransform, false, true);
                              maskid := copy(masks[masks.count-1], length(masks[masks.count-1])-14, 15);
                            end
                            else
                              if maskid=\'0\' then maskid := \'\';
                            timer1.enabled := true;
                          end;
                        masks.free;
                      end;
                      if not referencemask.empty then
                      begin
                        if referencemask.datatype =avs_type_byte then
                        begin
                          maskedreference.assign(referencecube);
                          field_mask(maskedreference, referencemask, maskedreference);
                          field_autocrop(maskedreference, maskedreference, 2);
                        end
                        else if round(referencemask.maximum)=255 then
                        begin
                          maskedreference.assign(referencecube);
                          field_to_byte(referencemask, referencemask);
                          field_mask(maskedreference, referencemask, maskedreference);
                          field_autocrop(maskedreference, maskedreference, 2);
                        end
                        else
                        begin
                          field_eqsc(referencemask,referencemask,0);
                          field_not(referencemask,referencemask);
                          field_addc(referencemask,referencemask,256);
                          maskedreference.assign(referencecube);
                          field_setc(maskedreference,maskedreference,0);
                          field_insertc(maskedreference,referencemask,referencemask);
                          field_to_byte(referencemask,referencemask);
                          read_xdr(maskedreference, maskstorefilebase + uid + \'.mask\');
                        end;
                      end;
                      if maskwindow\<1 then maskwindow := 1;
                      if masklevel-maskwindow\<0 then masklevel := maskwindow;
                      fillmaskedreferencelut;
                    end;
                    eulerxfm(machine_to_machineadjust);
                    transformdisplaymode.value := 0;
                    machine_to_machineadjust.ischangedby := sender;
                    lastmatchresult := \'\';
                    onlinetoreftransformmatched := \'\';
                    matchadjusted   := false;
                    matchrotation   := true;
                    if not quirtviewerupdcoronal.clipbox[1].empty then
                      quirtviewerupdcoronal.activeclipbox.value := 1;
                    referencedatachanged := false;
                    screen.cursor := save;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_274()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.loadclipboxes(i: tinifiles; section : string; var cbs: array of tavsfield; var namelist : tstringlist; var weightlist: array of single) ;
                  var
                    stringlist : tstringlist;
                    t1         : ttransform ;
                    s, jstr    : string  ;
                    j, jlow, jhigh : integer ;
                  begin
                    namelist.clear ;
                    for j := low(weightlist) to high(weightlist) do
                      weightlist[j] := 1 ;
                    s := i.readstring (section, \'clip1\', \'\');
                    jlow := low(cbs);
                    jhigh:= high(cbs) ;
                    if (s \<\> \'\') and (valuefromstr(s, 5, 0)\<\>valuefromstr(s, 6, 0)) then
                    begin
                      field_create(cbs[jlow], \'field 1d float\', 6);
                      cbs[jlow].setvalue([0], valuefromstr(s, 1, -10));
                      cbs[jlow].setvalue([1], valuefromstr(s, 2,  10));
                      cbs[jlow].setvalue([2], valuefromstr(s, 3, -10));
                      cbs[jlow].setvalue([3], valuefromstr(s, 4,  10));
                      cbs[jlow].setvalue([4], valuefromstr(s, 5, -10));
                      cbs[jlow].setvalue([5], valuefromstr(s, 6,  10));
                      cbs[jlow].locked     := i.readbool   (section, \'clip1locked\', false);
                      menuclipboxlocked.checked := cbs[jlow].locked;
                    end
                    else
                    begin
                      if i.readfloat  (section, \'clipboxx1\', -9999) \< -9998 then
                      begin
                        if i.readfloat  (section, \'clip1x1\', -9999) \< -9998 then
                        begin
                          if not synergymode then cbs[jlow].clear;
                        end
                        else
                        begin
                          field_create(cbs[jlow], \'field 1d float\', 6);
                          cbs[jlow].setvalue([0], i.readfloat  (section, \'clip1x1\', -10));
                          cbs[jlow].setvalue([1], i.readfloat  (section, \'clip1x2\',  10));
                          cbs[jlow].setvalue([2], i.readfloat  (section, \'clip1y1\', -10));
                          cbs[jlow].setvalue([3], i.readfloat  (section, \'clip1y2\',  10));
                          cbs[jlow].setvalue([4], i.readfloat  (section, \'clip1z1\', -10));
                          cbs[jlow].setvalue([5], i.readfloat  (section, \'clip1z2\',  10));
                          cbs[jlow].locked     := i.readbool   (section, \'clip1locked\', false);
                          menuclipboxlocked.checked := cbs[jlow].locked;
                        end;
                      end
                      else
                      begin
                        field_create(cbs[jlow], \'field 1d float\', 6);
                        cbs[jlow].setvalue([0], i.readfloat  (section, \'clipboxx1\', -10));
                        cbs[jlow].setvalue([1], i.readfloat  (section, \'clipboxx2\',  10));
                        cbs[jlow].setvalue([2], i.readfloat  (section, \'clipboxy1\', -10));
                        cbs[jlow].setvalue([3], i.readfloat  (section, \'clipboxy2\',  10));
                        cbs[jlow].setvalue([4], i.readfloat  (section, \'clipboxz1\', -10));
                        cbs[jlow].setvalue([5], i.readfloat  (section, \'clipboxz2\',  10));
                        t1 := ttransform.create;
                        t1.makerotation(270, 0, 270);
                        cropbox_transform(cbs[jlow], t1, cbs[jlow]);
                        t1.free;
                        cbs[jlow].locked     := i.readbool   (section, \'clipboxlocked\', false);
                        menuclipboxlocked.checked := cbs[jlow].locked;
                      end;
                      namelist.add(\'clipbox1\') ;
                      weightlist[low(weightlist)] := 1.0 ;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_275()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updateviewernamelabels() ;
                  var
                    j  : integer ;
                    newname: string ;
                  begin
                    if clipbox[2].empty then
                    begin
                      if quirtviewerupdcoronal.clipboxtext[1].value \<\>  (#27+chr(255)+#1+#1+\' \'+#10+\' \') then
                      begin
                        quirtviewerupdcoronal.clipboxtext[1].locked := false;
                        quirtviewerupdcoronal.clipboxtext[1].value :=  #27+chr(255)+#1+#1+\' \'+#10+\' \';
                        quirtviewerupdcoronal.clipboxtext[1].locked := true;
                      end;
                    end
                    else
                    begin
                      for j := 1 to cbnames.count do
                      begin
                        if cbnames[j-1]=\'\' then
                          cbnames[j-1]:=\' \';
                        newname :=  #27+chr(255)+#1+#1 + cbnames[j-1] + #10 + floattostrf(cbweights[j], fffixed, 5, 2);
                        if quirtviewerupdcoronal.clipboxtext[j].value \<\> newname then
                        begin
                          quirtviewerupdcoronal.clipboxtext[j].locked := false;
                          quirtviewerupdcoronal.clipboxtext[j].value := newname;
                          quirtviewerupdcoronal.clipboxtext[j].locked := true;
                        end;
                      end;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_276()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonclearreferenceclick(sender: tobject);
                  var i:integer;
                  begin
                    for i:=1 to nclipbox do
                    begin
                      quirtviewerupdcoronal.clipboxtext[i].locked :=  false ;
                      quirtviewerupdcoronal.clipboxtext[i].value := \'\' ;
                      clipbox[i].clear;
                      quirtviewerupdcoronal.clipboxtext[i].locked :=  true ;
                      cbweights[i] :=1 ;
                    end;
                    cbnames.clear ;
                    reference[1].clear;
                    dose[1].clear;
                    delineationdots.clear;
                    delineationindex.clear;
                    delineationindex.clear;
                    beamdots.clear;
                    beamindex.clear;
                    maskedreference.clear;
                    referencemask.clear;
                    maskedreferencelut.clear;
                    machine_to_siddon.makeidentity;
                    eulerxfm(machine_to_machineadjust);
                    transformdisplaymode.value := 0;
                    quirtviewerupdcoronal.warp[1].clear;
                    quirtviewerupdcoronal.warp[6].clear;
                    quirtviewerupdcoronal.viewwarp.clear;
                    quirtviewerupdcoronal.markerdots[3].clear;
                    field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                    correctionreferencepoint.debugname := \'0\';
                    correctionreferencepointstructure := \'\';
                    quirtviewerupdcoronal.text[3].value := \'\';
                    quirtviewerupdtransversal.text[4].value := \'\';
                    scanurl := \'\';
                    studyurl:= \'\';
                    planurl := \'\';
                    beamurl := \'\';
                    doseurl := \'\';
                    delineationurl := \'\';
                    maskmargin := 0;
                    maskdelineation := \'\';
                    comboboxprotocol.itemindex := 0;
                    referencedatachanged := true;
                    quirtviewerupdcoronal.markerdots[1].clear;
                    machine_to_machineadjust.ischangedby := sender;
                    lastmatchresult := \'\';
                    onlinetoreftransformmatched := \'\';
                    matchadjusted   := false;
                    matchrotation   := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_277()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonclearonlineclick(sender: tobject);
                  var f, g  : single;
                  begin
                    online[1].clear;
                    field_create(onlinecube, \'field 3d 0-vector byte\', 256, 256, 256);
                    case defaultfov of
                      76:  modify_extents(onlinecube, onlinecube, 0.2,   0.2,   0.2);
                      77:  modify_extents(onlinecube, onlinecube, 0.156, 0.156, 0.156);
                      83:  modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                      else
                      begin
                        f := abs(onlinecube.coordinate[1, 0] - onlinecube.coordinate[1, onlinecube.dimensions[1]-1]);
                        g := abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]);
                        g := max(abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]), g);
                        g := max(abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]), g);
                        f := max(f, 1);
                        g := max(g, 1);
                        modify_extents(onlinecube, onlinecube, g/f, g/f, g/f);
                      end;
                    end;
                    if online[1].tomachine.empty then
                       online[1].tomachine.makerotation(270, 0, 270);
                    myzoom := 1.5 * zoomfix;
                    phase.clear;
                    phasehist.clear;
                    transform4d.clear;
                    makeregistrationbackup(0, 9999, 0, 9999);
                    vistransform4d.clear;
                    vistransform4d2.clear;
                    quirtviewerupdcoronal.warp[1].clear;
                    quirtviewerupdcoronal.warp[6].clear;
                    quirtviewerupdcoronal.viewwarp.clear;
                    buttonresetmatchclick(self);
                    matchprerotate := false;
                    matchrotmark   := false;
                    match4dsingleframe := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_278()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttontoreferenceclick(sender: tobject);
                  var
                    crp2, clpbx2 : tavsfield;
                    refempty : boolean;
                  begin
                    if (getkeystate(vk_lshift) and $8000)\<\>0 then
                    begin
                      if referencecube.empty then
                        exit;
                      online_to_machine.assign(reference_to_machine);
                      field_to_uniform(referencecube,onlinecube);
                      online[1].connectviewer(quirtviewerupdsagittal, 1);
                      online[1].connectviewer(quirtviewerupdtransversal, 1);
                      online[1].connectviewer(quirtviewerupdcoronal, 1);
                      onlineurl := scanurl;
                      showmessage(nki_copiedreftoonline);
                      exit;
                    end;
                    crp2   := tavsfield.create;
                    clpbx2 := tavsfield.create;
                    if not referencecube.empty then
                    begin
                      field_copy(correctionreferencepoint, crp2);
                      field_copy(clipbox[1], clpbx2);
                      refempty := false;
                    end
                    else
                    begin
                      crp2.assign(correctionreferencepoint);
                      clpbx2.assign(clipbox[1]);
                      refempty := true;
                    end;
                    buttonclearreferenceclick(self);
                    referencedatachanged := true;
                    checkboxroi.checked := true;
                    menuclipboxlocked.checked := false;
                    if (onlinecube.ndim = 4) and ((getkeystate(vk_control) and $8000)\<\>0) then
                    begin
                      if quirtviewerupdcoronal.frame.value \<\> -1 then
                        field_slice(onlinecube, referencecube, -1, -1, -1, quirtviewerupdcoronal.frame.value)
                      else
                      begin
                        if not phasehist.empty then
                          field_ortho_wghtsum(onlinecube, phasehist, referencecube, field_ortho_wghtsum_udirection)
                        else
                          field_ortho_average(onlinecube, referencecube, field_ortho_average_udirection);
                      end;
                    end
                    else
                      referencecube.assign(onlinecube);
                    reference_to_siddon.assign(online_to_machine);
                    reference_to_patient.assign(online_to_machine);
                    dosecube.clear;
                    doseaccu.clear;
                    dose_to_siddon.clear;
                    dose_to_machine.clear;
                    quirtviewerupdsagittal.level[2].value := quirtviewerupdsagittal.level[1].value-100;
                    quirtviewerupdsagittal.window[2].value := quirtviewerupdsagittal.window[1].value;
                    field_create(beamdots, \'field 1d 3-space irregular\', 1);
                    beamindex.clear;
                    if not refempty then
                    begin
                      field_copy(crp2, correctionreferencepoint);
                      field_copy(clpbx2, clipbox[1]);
                    end
                    else
                    begin
                      correctionreferencepoint.assign(crp2);
                      clipbox[1].assign(clpbx2);
                    end;
                    crp2.clear;
                    clpbx2.clear;
                    buttonresetmatchclick(self);
                    if (comboboxregistrationprotocol.itemindex\<0) then
                      comboboxregistrationprotocol.itemindex:=0;
                    comboboxregistrationprotocolchange(nil);
                    if not fileexists(reconfilebase + scanuid + \'.scan\') then
                      showmessage(toref_warn1)
                    else
                      showmessage(toref_warn2);
                    if exportedscan = \'\' then
                      scanurl := \'xdr:\' + reconfilebase + scanuid + \'.scan\'
                    else
                      scanurl := exportedscan;
                    planurl := \'fake\';
                    beamurl := \'\';
                    doseurl := \'\';
                    if referenceoverlaystring\<\>\'\' then
                      quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + referenceoverlaystring
                    else
                      quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + ref_overlay + scandate;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_279()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.copyrefclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_280()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonexportclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_281()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.timericomtimer(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_282()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonzerocouchclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_283()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updown1update;
                  var filename: string;
                  begin
                    updown1.hint := format(updown_hint, [updown1.position+1, updown1.max+1]);
                    queryscans.locate(\'dbid\', scanlist[max(0,updown1.position)], []);
                    filename := reconfilebase + scanuid + \'.scan\';
                    if prevfile = filename then exit;
                    if online[1].exists(reconfilebase, scanuid, \'scan\') or
                       online[1].exists(reconfilebase, scanuid, \'image1\') then
                      needloadscan := true;
                      needloadmatch := true;
                    prevfile := filename;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_284()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updown1mousedown(sender: tobject; button: tmousebutton;
                    shift: tshiftstate; x, y: integer);
                  begin
                    if (ssshift in shift) and (x \< updown1.width div 2) then updown1.position := 0;
                    if (ssshift in shift) and (x \> updown1.width div 2) then updown1.position := updown1.max;
                    if (ssshift in shift) then updown1update;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_285()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updown1mouseup(sender: tobject; button: tmousebutton;
                    shift: tshiftstate; x, y: integer);
                  begin
                    updown1update;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_286()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updownplanselectionchangingex(sender: tobject;
                    var allowchange: boolean; newvalue: smallint; direction: tupdowndirection);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_287()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.timer4dtimer(sender: tobject);
                  var
                    nf : integer;
                  begin
                    if not timer1.enabled then exit;
                    if form1timer1enabled\>0 then exit;
                    if (not panelcontrol4d.visible) then
                    begin
                      bitbtnaverage4dclick(self);
                      exit;
                    end;
                    if (onlinecube.ndim\<\>4) and (referencecube.ndim\<\>4) then exit;
                    nf := onlinecube.dimensions[3];
                    if nf \< 1 then exit;
                    quirtviewerupdcoronal.frame.value    := (quirtviewerupdcoronal.frame.value + 1) mod nf;
                    if onlinecube.ndim = 4 then
                    begin
                      if phasehist.empty then
                        timer4d.interval := timer4d.tag
                      else
                        timer4d.interval := round(timer4d.tag*phasehist.getvalue([quirtviewerupdcoronal.frame.value])*phasehist.dimensions[0]);
                      if timer4d.interval \< 1 then timer4d.interval := 1;
                    end;
                    timer1timer(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_288()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonplay4dclick(sender: tobject);
                  var prevrev: integer;
                  begin
                    if (onlinecube.ndim\<\>4) and (referencecube.ndim\<\>4) then exit;
                    prevrev := reversemotion.value;
                    reversemotion.value := ord((sender as tbitbtn)=bitbtnplaygreen);
                    if (timer4d.enabled = false) and (timer4d.tag \<\> 0) then
                    begin
                      timer4d.enabled := true;
                      timer4d.interval := timer4d.tag;
                      exit;
                    end;
                    timer4d.enabled := true;
                    if (reversemotion.value\<\>prevrev) or
                    (((getkeystate(vk_lshift) or getkeystate(vk_rshift)) and $8000)\<\>0) then exit;
                    if onlinecube.ndim = 4 then
                    begin
                      case timer4d.tag of
                        0: timer4d.tag := 400;
                        400:  timer4d.tag := 150;
                        150:  timer4d.tag :=  50;
                        else  timer4d.tag :=  400;
                      end;
                      timer4d.interval := timer4d.tag;
                    end
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_289()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnplaypurplemousedown(sender: tobject;
                    button: tmousebutton; shift: tshiftstate; x, y: integer);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_290()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnplaypurplemouseup(sender: tobject; button: tmousebutton;
                    shift: tshiftstate; x, y: integer);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_291()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnstop4dclick(sender: tobject);
                  var average : boolean;
                  begin
                    reversemotion.value := 0;
                    if ((getkeystate(vk_lshift) or getkeystate(vk_rshift)) and $8000)\<\>0 then
                      average := true
                    else
                      average := false;
                    if average then
                    begin
                      if onlinecube.ndim = 4 then
                        timer4d.tag :=  0
                      else
                        timer4d.interval :=  9999;
                      if timer4d.enabled = true then timer4d.enabled := false;
                      quirtviewerupdcoronal.frame.value    := -1;
                    end
                    else
                      if timer4d.enabled then timer4d.enabled := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_292()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnfwd4dclick(sender: tobject);
                  var
                    nf : integer;
                  begin
                    reversemotion.value := 0;
                    if timer4d.enabled = true then timer4d.enabled := false;
                    if (onlinecube.ndim\<\>4) and (referencecube.ndim\<\>4) then exit;
                    nf := onlinecube.dimensions[3];
                    if nf \< 1 then exit;
                    if radiobuttoncurrentframe.checked and (quirtviewerupdcoronal.frame.value = nf-1) then exit;
                   quirtviewerupdcoronal.frame.value := (quirtviewerupdcoronal.frame.value + 1) mod nf;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_293()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnback4dclick(sender: tobject);
                  var
                    nf : integer;
                    i : integer;
                  begin
                    reversemotion.value := 0;
                    if timer4d.enabled = true then timer4d.enabled := false;
                    if (onlinecube.ndim\<\>4) and (referencecube.ndim\<\>4) then exit;
                    nf := onlinecube.dimensions[3];
                    if nf \< 1 then exit;
                    if (quirtviewerupdcoronal.frame.value \<= 0) then i := 9
                    else i := (quirtviewerupdcoronal.frame.value - 1) mod nf;
                    quirtviewerupdcoronal.frame.value    := i;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_294()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnaverage4dclick(sender: tobject);
                  begin
                    quirtviewerupdcoronal.frame.value := -1;
                    timer4d.enabled := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_295()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonstopstep4dclick(sender: tobject);
                  var average : boolean;
                  begin
                    if ((getkeystate(vk_lshift) or getkeystate(vk_rshift)) and $8000)\<\>0 then
                      average := true
                    else
                      average := false;
                    stopstep4d(average);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_296()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.stopstep4d(average : boolean = false);
                  begin
                    if average then
                    begin
                      if onlinecube.ndim = 4 then
                        timer4d.tag :=  0
                      else
                        timer4d.interval :=  9999;
                      if timer4d.enabled = true then timer4d.enabled := false;
                      quirtviewerupdcoronal.frame.value    := -1;
                    end
                    else if timer4d.enabled then timer4d.enabled := false
                    else                    timer4dtimer(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_297()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonreconstructmousedown(sender: tobject;
                    button: tmousebutton; shift: tshiftstate; x, y: integer);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_298()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.batchrecon(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_299()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.batchmatch(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_300()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.simplex2functionevaluation(sender: tobject;
                    evalpoint: array of double): double;
                  begin
                   result := 0;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_301()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.checkboxrecordformclick(sender: tobject);
                  var s : tsavedialog;
                      avifps: integer;
                      formimage: tbitmap;
                      pixmap: tavsfield;
                      i: integer;
                  begin
                    if checkboxrecordform.checked then
                    begin
                      avihandle := -1;
                      s := tsavedialog.create(self);
                      s.filter := saveasfilter_movie;
                      s.options := [ofoverwriteprompt, ofnochangedir];
                      s.defaultext := \'avi\';
                      if s.execute then
                      begin
                        avifps := strtointdef(inputbox(\'frame rate\', \'fps\', inttostr(5)), 5);
                        formimage := getformimage;
                        formimage.pixelformat := pf24bit;
                        pixmap := tavsfield.createas(\'field 2d 3-vector byte\', [formimage.width, formimage.height]);
                        for i := 0 to formimage.height - 1 do
                          move( formimage.scanline[i]^,
                            pchar(cardinal(pixmap.data)+ cardinal(i * formimage.width * 3))^, formimage.width * 3);
                        formimage.free;
                        avi_creat(pixmap, avihandle, s.filename, avifps, \'mp42\');
                        pixmap.free;
                        avicount := 1;
                      end
                      else
                        checkboxrecordform.checked := false;
                    end
                    else
                    begin
                      if avihandle\>=0 then avi_close(avihandle);
                      avihandle := -1;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_302()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsetcorrectionreferencepointclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenucorrectionreferencepoint.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_303()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updatecorrectionreferencepoint(sender: tobject;
                    var unchanged: boolean);
                  var x, y, z: single;
                      s: string;
                      i: integer;
                      dots, index, lut: tavsfield;
                  begin
                    case strtoint(correctionreferencepoint.debugname) of
                      0: begin
                         field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                           correctionreferencepoint.coordinate[0,0] := 0;
                           correctionreferencepoint.coordinate[1,0] := 0;
                           correctionreferencepoint.coordinate[2,0] := 0;
                           refpointatisocenter1.checked := true;
                           refpointatcenterofclipbox1.checked := false;
                           refpointatcenterofmask1.checked := false;
                           refpointatmarker.checked := false;
                           refpointatcenterofdelineation.checked := false;
                           correctionreferencepointstructure := \'\';
                           s := corr_ref_isoc;
                         end;
                      1: begin
                           if not unchanged then
                           begin
                             if clipbox[1].empty then exit;
                             field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                             correctionreferencepoint.coordinate[0,0] := (clipbox[1].getvalue([0]) + clipbox[1].getvalue([1]))/2;
                             correctionreferencepoint.coordinate[1,0] := (clipbox[1].getvalue([2]) + clipbox[1].getvalue([3]))/2;
                             correctionreferencepoint.coordinate[2,0] := (clipbox[1].getvalue([4]) + clipbox[1].getvalue([5]))/2;
                           end;
                           refpointatisocenter1.checked := false;
                           refpointatcenterofclipbox1.checked := true;
                           refpointatcenterofmask1.checked := false;
                           refpointatmarker.checked := false;
                           refpointatcenterofdelineation.checked := false;
                           correctionreferencepointstructure := \'\';
                           s := corr_ref_clipbox;
                         end;
                      2: begin
                           if not unchanged then
                           begin
                             field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                             if quirtviewerupdcoronal.markerdots[1].empty then
                             begin
                               correctionreferencepoint.coordinate[0,0] := 0;
                               correctionreferencepoint.coordinate[1,0] := 0;
                               correctionreferencepoint.coordinate[2,0] := 0;
                               s := corr_ref_marker_ns;
                             end
                             else
                             begin
                               correctionreferencepoint.coordinate[0,0] := quirtviewerupdcoronal.markerdots[1].coordinate[0,0];
                               correctionreferencepoint.coordinate[1,0] := quirtviewerupdcoronal.markerdots[1].coordinate[1,0];
                               correctionreferencepoint.coordinate[2,0] := quirtviewerupdcoronal.markerdots[1].coordinate[2,0];
                               s := corr_ref_marker;
                             end;
                           end
                           else
                           begin
                             x := correctionreferencepoint.coordinate[0,0];
                             y := correctionreferencepoint.coordinate[1,0];
                             z := correctionreferencepoint.coordinate[2,0];
                             if quirtviewerupdcoronal.markerdots[1].empty then s := corr_ref_marker_ns
                             else if (x = quirtviewerupdcoronal.markerdots[1].coordinate[0,0]) and
                                (y = quirtviewerupdcoronal.markerdots[1].coordinate[1,0]) and
                                (z = quirtviewerupdcoronal.markerdots[1].coordinate[2,0]) then
                                 s := corr_ref_marker
                             else s := corr_ref_marker_ch
                           end;
                           refpointatisocenter1.checked := false;
                           refpointatcenterofclipbox1.checked := false;
                           refpointatcenterofmask1.checked := false;
                           refpointatmarker.checked := true;
                           refpointatcenterofdelineation.checked := false;
                           correctionreferencepointstructure := \'\';
                         end;
                      3: begin
                           if not unchanged then
                           begin
                             dots  := tavsfield.create;
                             index := tavsfield.create;
                             lut   := tavsfield.create;
                             if not delineationdotslut.empty and (correctionreferencepointstructure\<\>\'\')then
                             for i:=0 to delineationdotslut.dimensions[0]-1 do
                             begin
                               dil_get_name(delineationdotslut, s, i);
                               if s=correctionreferencepointstructure then
                                 dil_select(delineationdots, delineationindex, delineationdotslut, dots, index, lut, i);
                             end;
                             x := 0; y:=0; z:=0;
                             field_center(dots, x, y, z, s);
                             correctionreferencepoint.coordinate[0,0] := x;
                             correctionreferencepoint.coordinate[1,0] := y;
                             correctionreferencepoint.coordinate[2,0] := z;
                             if dots.empty then
                             begin
                               showmessage(delineation_warning);
                               refpointatisocenter1.checked := true;
                               refpointatcenterofdelineation.checked := false;
                             end
                             else
                             begin
                               refpointatcenterofdelineation.checked := true;
                               dotxfm(correctionreferencepoint, reference_to_machine, correctionreferencepoint);
                             end;
                             dots.free;
                             index.free;
                             lut.free;
                           end
                           else
                             refpointatcenterofdelineation.checked := true;
                           s := corr_ref_delinea;
                           refpointatisocenter1.checked := false;
                           refpointatcenterofclipbox1.checked := false;
                           refpointatcenterofmask1.checked := false;
                           refpointatmarker.checked := false;
                         end;
                      4: begin
                           if not unchanged then
                           begin
                             mask_cog[1].make;
                             if mask_cog[1].coordinate[0,0]\<-9998 then exit;
                             field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                             correctionreferencepoint.coordinate[0,0] := mask_cog[1].coordinate[0,0];
                             correctionreferencepoint.coordinate[1,0] := mask_cog[1].coordinate[1,0];
                             correctionreferencepoint.coordinate[2,0] := mask_cog[1].coordinate[2,0];
                           end;
                           refpointatisocenter1.checked := false;
                           refpointatcenterofclipbox1.checked := false;
                           refpointatcenterofmask1.checked := true;
                           refpointatmarker.checked := false;
                           refpointatcenterofdelineation.checked := false;
                           correctionreferencepointstructure := \'\';
                           s := corr_ref_mask;
                         end;
                    end;
                    correctionreferencepoint.setvalue([0, 0], ord(\'c\'));
                    correctionreferencepoint.setvalue([0, 1], 0);
                    correctionreferencepoint.setvalue([0, 2], 255);
                    correctionreferencepoint.setvalue([0, 3], 255);
                    correctionreferencepoint.setvalue([0, 4], ord(\'y\'));
                    correctionreferencepoint.setvalue([0, 5],  50);
                    correctionreferencepoint.setvalue([0, 6], ord(\'s\'));
                    correctionreferencepoint.setvalue([0, 7], ord(\'*\'));
                    quirtviewerupdcoronal.text[3].value := #27+#1+chr(255)+chr(255)+s;
                      if unchanged then
                        correctionreferencepoint.ischangedby := nil
                      else
                        correctionreferencepoint.ischangedby := self;
                    unchanged := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_304()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.refpointatisocenter1click(sender: tobject);
                  var b:boolean;
                  begin
                    correctionreferencepoint.debugname := \'0\';
                    b := false;
                    updatecorrectionreferencepoint(nil, b);
                    referencedatachanged := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_305()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.refpointatcenterofclipbox1click(sender: tobject);
                  var b:boolean;
                  begin
                    correctionreferencepoint.debugname := \'1\';
                    b := false;
                    updatecorrectionreferencepoint(nil, b);
                    referencedatachanged := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_306()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.refpointatcenterofmaskclick(sender: tobject);
                  var b:boolean;
                  begin
                    correctionreferencepoint.debugname := \'4\';
                    b := false;
                    updatecorrectionreferencepoint(nil, b);
                    referencedatachanged := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_307()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.refpointatmarkerclick(sender: tobject);
                  var b:boolean;
                  begin
                    correctionreferencepoint.debugname := \'2\';
                    b := false;
                    updatecorrectionreferencepoint(nil, b);
                    referencedatachanged := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_308()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.refpointatcenterofdelineationclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_309()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.menustructurechoiceclick(sender: tobject);
                  var b:boolean;
                  begin
                    correctionreferencepointstructure := striphotkey((sender as tmenuitem).caption);
                    correctionreferencepoint.debugname := \'3\';
                    b := false;
                    updatecorrectionreferencepoint(nil, b);
                    referencedatachanged := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_310()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonconverttocorrectionclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_311()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonelektadismissclick(sender: tobject);
                  var i:  tqinifile;
                      initials : string;
                      outfile: string;
                      save: tcursor;
                  begin
                    if reconstructing then
                    begin
                      stopreconstructing := true;
                      exit;
                    end;
                    if match2inprogress then
                    begin
                      if assigned(m) then m.stop;
                      match2inprogress := false;
                      exit;
                    end;
                    if (avlstate in [3, 4]) and (sender=buttonelektaaccept) and (not correctionbyhexapod) then
                    begin
                      if (editrotationlr.text \<\> \'0.0\') or
                         (editrotationcc.text \<\> \'0.0\') or
                         (editrotationap.text \<\> \'0.0\') or
                         (labelcomputedlat2.caption = \'-\') then
                      begin
                        showmessage(unacceptable_corr);
                        exit;
                      end;
                    end;
                    if (avlstate in [1]) and (sender=buttonelektaaccept) and (comboboxregistrationprotocol.itemindex in [ 2, 3, 4]) then
                    begin
                      if (safestrtofloat(colorstringgrid2.cells[1,1]) \>= safestrtofloat(colorstringgrid2.cells[2,1])) or
                         (safestrtofloat(colorstringgrid2.cells[1,2]) \>= safestrtofloat(colorstringgrid2.cells[2,2])) or
                         (safestrtofloat(colorstringgrid2.cells[1,3]) \>= safestrtofloat(colorstringgrid2.cells[2,3])) or
                         (safestrtofloat(colorstringgrid2.cells[1,5]) \>= safestrtofloat(colorstringgrid2.cells[2,5])) or
                         (safestrtofloat(colorstringgrid2.cells[1,6]) \>= safestrtofloat(colorstringgrid2.cells[2,6])) or
                         (safestrtofloat(colorstringgrid2.cells[1,7]) \>= safestrtofloat(colorstringgrid2.cells[2,7])) then
                      begin
                        if messagedlg(unacceptable_clipboxlimits, mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                          exit;
                      end;
                    end;
                    if (avlstate in [1]) and (sender=buttonelektaaccept) and (comboboxregistrationprotocol.itemindex in [ 2, 3, 5]) then
                    begin
                      if (safestrtofloat(colorstringgrid3.cells[1,1]) \>= safestrtofloat(colorstringgrid3.cells[2,1])) or
                         (safestrtofloat(colorstringgrid3.cells[1,2]) \>= safestrtofloat(colorstringgrid3.cells[2,2])) or
                         (safestrtofloat(colorstringgrid3.cells[1,3]) \>= safestrtofloat(colorstringgrid3.cells[2,3])) or
                         (safestrtofloat(colorstringgrid3.cells[1,5]) \>= safestrtofloat(colorstringgrid3.cells[2,5])) or
                         (safestrtofloat(colorstringgrid3.cells[1,6]) \>= safestrtofloat(colorstringgrid3.cells[2,6])) or
                         (safestrtofloat(colorstringgrid3.cells[1,7]) \>= safestrtofloat(colorstringgrid3.cells[2,7])) then
                      begin
                        if messagedlg(unacceptable_masklimits, mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                          exit;
                      end;
                    end;
                    if (avlstate in [3, 4]) and (sender=buttonelektaaccept) and (correctionbyhexapod) and (not b6dofsystemhascrp) then
                    begin
                      if correctionreferencepoint.coordinate[0, 0]*correctionreferencepoint.coordinate[0, 0] +
                         correctionreferencepoint.coordinate[1, 0]*correctionreferencepoint.coordinate[1, 0] +
                         correctionreferencepoint.coordinate[2, 0]*correctionreferencepoint.coordinate[2, 0] \> 0.1 then
                      begin
                        if messagedlg(format(warning_hexapodisoc, [nameof6dofsystem]), mtconfirmation, [mbok, mbcancel], 0) \<\> mrok then
                          exit;
                      end;
                    end;
                    if (avlstate in [1]) and (sender=buttonelektaaccept) and (correctionbyhexapod) and (not b6dofsystemhascrp) then
                    begin
                      if correctionreferencepoint.coordinate[0, 0]*correctionreferencepoint.coordinate[0, 0] +
                         correctionreferencepoint.coordinate[1, 0]*correctionreferencepoint.coordinate[1, 0] +
                         correctionreferencepoint.coordinate[2, 0]*correctionreferencepoint.coordinate[2, 0] \> 0.1 then
                      begin
                        showmessage(format(error_hexapodisoc, [nameof6dofsystem]));
                        exit;
                      end;
                    end;
                    if ((avlstate = -1) or (avlstate in [1, 3, 4])) and referencemask.empty and (comboboxregistrationprotocol.itemindex in [1,2,3,5]) and (sender=buttonelektaaccept) then
                    begin
                      showmessage(unacceptable_emptymask);
                      exit;
                    end;
                    if (sender=buttonelektaaccept)and
                       (strcomp(pchar(confirm_caption),pchar(buttonelektaaccept.caption))\<\>0) and
                       (quirtviewerupdcoronal.text[2].value \<\> #27 + #1 + chr(255) + #1 + text_noprevious)
                       and (avlstate in [0, 3, 4])then
                      begin
                        if messagedlg(warning_regoverwrite  + copy(quirtviewerupdcoronal.text[2].value, 5, 99),
                                      mtconfirmation, [mbok, mbcancel], 0) \<\> mrok then
                        exit;
                      end;
                     if (sender=buttonelektaaccept)and
                       (referenceapprovalby \<\> \'\')
                       and (avlstate in [1])then
                      begin
                        if messagedlg(warning_refoverwrite  + referenceapprovalby,
                                      mtconfirmation, [mbok, mbcancel], 0) \<\> mrok then
                        exit;
                      end;
                      if (sender=buttonelektaaccept) and (avlstate in [1,3,4]) and (not synergymode) then
                    begin
                      if not inputquery(signature_dlg, initials_dlg, initials) then
                        exit
                      else if (initials=\'\') or (initials[1]=\'\'\'\') or (initials[1]=\'\"\') then
                      begin
                        repeat
                          if not inputquery(signature_dlg, initials_dlg, initials) then
                            exit
                        until (initials\<\>\'\') and (initials[1]\<\>\'\'\'\') and (initials[1]\<\>\'\"\');
                      end;
                    end;
                    if (avlstate in [3, 4]) and (sender=buttonelektaaccept) and (correctionbyhexapod) and (b6dofsystemhascrp) then
                    begin
                      showmessage(format(\'copy this data to hexapod: %s %s %s %s %s %s %.2f %.2f %.2f\',
                                  [edittranslationlr.text,edittranslationcc.text,edittranslationap.text,
                                   editrotationlr.text,editrotationcc.text,editrotationap.text,
                                   correctionreferencepoint.coordinate[0, 0], correctionreferencepoint.coordinate[1, 0], correctionreferencepoint.coordinate[2, 0]]));
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if (avlstate in [1,3,4]) and (sender=buttonelektaaccept) then
                    begin
                       case avlstate of
                       1: savereferencedata(elektaref);
                       3: savereferencedata(elektaalign);
                       4: savereferencedata(elektareconalign);
                       end;
                    end;
                    screen.cursor := save;
                    outfile := paramstr2 + \'.xvi\';
                    try
                      if fileexists(outfile) then
                        setfileattributes(pchar(outfile), file_attribute_normal);
                      i := tqinifile.create(outfile);
                    except
                       showmessage(\'except_exit_message\');
                       application.terminate;
                       exit;
                    end;
                    if sender\<\>buttonelektaaccept then
                    begin
                      i.writebool(\'status\', \'completionstatus\', true);
                      i.writebool(\'status\', \'approvalstatus\', sender\<\>buttonelektadismiss);
                      if avlstate in [0, 1] then
                      begin
                        try
                          application.terminate;
                        except
                        end;
                        i.free;
                        exit;
                      end;
                      if avlstate in [0, 3, 4] then
                      begin
                        try
                        except
                        end;
                        i.free;
                        application.terminate;
                        exit;
                      end;
                      if avlstate in [5] then
                      begin
                        i.free;
                        application.terminate;
                        exit;
                      end;
                    end;
                   case avlstate of
                      1: savesettings(i, elektaref, initials,true);
                      2: savesettings(i, elektarecon, initials,true);
                      3: savesettings(i, elektaalign, initials, true);
                      4: savesettings(i, elektareconalign, initials, true);
                      6: savesettings(i, elektarecon, initials, true);
                      else labelelektamode.caption := mode_unknown;
                    end;
                    writematchresultlogfile(initials);
                    i.writebool(\'status\', \'completionstatus\', true);
                    i.writebool(\'status\', \'approvalstatus\', sender\<\>buttonelektadismiss);
                    i.free;
                    application.terminate;
                    exit;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_312()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.writematchresultlogfile(signature: string);
                  var f: textfile;
                      x0, y0, z0 : real;
                      sx, sy, sz : real;
                      activeclipbox : integer;
                  begin
                    if matchresultlogfile=\'\' then exit;
                    activeclipbox := 1;
                    x0 := (clipbox[activeclipbox].getvalue([0])+clipbox[activeclipbox].getvalue([1]))/2;
                    y0 := (clipbox[activeclipbox].getvalue([2])+clipbox[activeclipbox].getvalue([3]))/2;
                    z0 := (clipbox[activeclipbox].getvalue([4])+clipbox[activeclipbox].getvalue([5]))/2;
                      sx := abs(clipbox[activeclipbox].getvalue([0])-clipbox[activeclipbox].getvalue([1]));
                    sy := abs(clipbox[activeclipbox].getvalue([2])-clipbox[activeclipbox].getvalue([3]));
                    sz := abs(clipbox[activeclipbox].getvalue([4])-clipbox[activeclipbox].getvalue([5]));
                    if not fileexists(matchresultlogfile) then
                    begin
                      sysutils.forcedirectories(extractfilepath(matchresultlogfile));
                      assignfile(f, matchresultlogfile);
                      rewrite(f);
                      writeln(f, \'patientid\', #9,
                                 \'treatmentuid\', #9,
                                 \'scanuid\', #9,
                                 \'scandate\', #9,
                                 \'signature\', #9,
                                 \'correctiontranslationlr\', #9,
                                 \'correctiontranslationcc\', #9,
                                 \'correctiontranslationap\', #9,
                                 \'correctionrotationlr\', #9,
                                 \'correctionrotationcc\', #9,
                                 \'correctionrotationap\', #9,
                                 \'alignmenttranslationlr\', #9,
                                 \'alignmenttranslationcc\', #9,
                                 \'alignmenttranslationap\', #9,
                                 \'alignmentrotationlr\', #9,
                                 \'alignmentrotationcc\', #9,
                                 \'alignmentrotationap\', #9,
                                 \'correctionmethod\', #9,
                                 \'couchshiftlat\', #9,
                                 \'couchshiftlong\', #9,
                                 \'couchshiftheight\', #9
                                 , \'correctionrefpointpositionlr\', #9
                                 , \'correctionrefpointpositioncc\', #9
                                 , \'correctionrefpointpositionap\', #9
                                 ,\'clipbox_nr\', #9
                                 ,\'clipboxpositionlr_(ref)\', #9
                                 ,\'clipboxpositioncc_(ref)\', #9
                                 ,\'clipboxpositionap_(ref)\', #9
                                 ,\'clipboxsizelr_(ref)\', #9
                                 ,\'clipboxsizecc_(ref)\', #9
                                 ,\'clipboxsizeap_(ref)\', #9
                                 ,\'match_date_time\', #9
                                 ,\'scantime\', #9
                                );
                    end
                    else
                    begin
                      assignfile(f, matchresultlogfile);
                      append(f);
                    end;
                      writeln(f, patientid, #9,
                                 treatmentuid, #9,
                                 scanuid, #9,
                                 scandate, #9,
                                 signature, #9,
                                 edittranslationlr.text, #9,
                                 edittranslationcc.text, #9,
                                 edittranslationap.text, #9,
                                 editrotationlr.text, #9,
                                 editrotationcc.text, #9,
                                 editrotationap.text, #9,
                                 edittranslationlr.imename, #9,
                                 edittranslationcc.imename, #9,
                                 edittranslationap.imename, #9,
                                 editrotationlr.imename, #9,
                                 editrotationcc.imename, #9,
                                 editrotationap.imename, #9,
                                 \'couchshift\', #9,
                                 labelcomputedlat2.caption, #9,
                                 labelcomputedlong2.caption, #9,
                                 labelcomputedheight2.caption, #9
                                 , format(\'%.3f\',[correctionreferencepoint.coordinate[0,0]]), #9
                                 , format(\'%.3f\',[correctionreferencepoint.coordinate[1,0]]), #9
                                 , format(\'%.3f\',[correctionreferencepoint.coordinate[2,0]]), #9
                                 , format(\'%d\',[activeclipbox]), #9
                                 , format(\'%.4f\',[x0]), #9
                                 , format(\'%.4f\',[y0]), #9
                                 , format(\'%.4f\',[z0]), #9
                                 , format(\'%.4f\',[sx]), #9
                                 , format(\'%.4f\',[sy]), #9
                                 , format(\'%.4f\',[sz]), #9
                                 , datetimetostr(now), #9
                              );
                    closefile(f);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_313()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.convertmatchclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_314()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.button3d2dclick(sender: tobject);
                  var
                    str1  : string;
                  begin
                    if not assigned(m) then
                      m := tmatch.create(self);
                    if m.active then
                    begin
                      button3d2d.caption := caption_nki3d2d;
                      m.stop;
                      exit;
                    end;
                    button3d2d.caption := caption_nkistop;
                    str1 := caption;
                    quirtviewerupdcoronal.interpolate.value := 0;
                    quirtviewerupdsagittal.interpolate.value := 0;
                    quirtviewerupdtransversal.interpolate.value := 0;
                    if online[1].data.ndim=2 then
                    begin
                      m.fixscan2 := true;
                      m.postprocess := true;
                      m.scan1 := reference[1].data;
                      m.transform1 := reference[1].tomachine;
                      online[1].clipbox[1].make;
                      field_cropwithbox(online[1].data, online[1].clipbox[1], m.scan2);
                      m.transform2 := online[1].tomachine;
                      online[2].clipbox[1].make;
                      field_cropwithbox(online[2].data, online[2].clipbox[1], m.scan3);
                      m.transform3 := online[2].tomachine;
                    end
                    else
                    begin
                      m.fixscan2 := false;
                      m.postprocess := false;
                      reference[1].clipbox[1].make;
                      field_cropwithbox(reference[1].data, reference[1].clipbox[1], m.scan1);
                      m.transform1 := reference[1].tomachine;
                      m.scan2      := online[1].data;
                      m.transform2 := online[1].tomachine;
                    end;
                    m.adjust2 := machine_to_machineadjust;
                    m.onlowerfuncval := matchlowerfuncval;
                    if (radiogroupmatchoptions.itemindex = 0) then m.transformtype := shift_rot
                    else if (radiogroupmatchoptions.itemindex = 2) then m.transformtype := shift_xz
                    else m.transformtype := shift;
                    m.start;
                    if not (m.state = finished_ok) then
                      showmessage(m.information);
                    progressbar3.position := 0;
                    caption := str1;
                    button3d2d.caption := caption_nki3d2d;
                    m.free;
                    m := nil;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_315()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.matchlowerfuncval(sender: tobject);
                  begin
                    if assigned(m) then
                    begin
                      progressbar3.position := round (progressoffset + progressscale * progressbar3.max*(m.progress/100));
                        caption := m.information;
                      countmakes := 0;
                      quirtviewerupdsagittal.make;
                      quirtviewerupdcoronal.make;
                      quirtviewerupdtransversal.make;
                      timer1timer(timer1);
                      timer1.enabled := false;
                      timer1.enabled := true;
                      application.processmessages;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_316()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.visboneseg(online : boolean);
                  var n: integer;
                  begin
                    if ((pos(match_substring_seed, comboboxmaskmatch.text)\>0) and editmask.checked) then
                      n := 3
                    else
                      n := 1;
                    if online then
                    begin
                      chamferdotslutonline.setvalue([0, 0], 255);
                      chamferdotslutonline.setvalue([0, 1], 0);
                      chamferdotslutonline.setvalue([0, 2], 255);
                      chamferdotslutonline.setvalue([0, 3], 0);
                      chamferdotslutonline.setvalue([0, 4], 15);
                      quirtviewerupdcoronal.polydots[5] := chamferdotsonline;
                      quirtviewerupdsagittal.polydots[5] := chamferdotsonline;
                      quirtviewerupdtransversal.polydots[5] := chamferdotsonline;
                      quirtviewerupdcoronal.polylut[5] := chamferdotslutonline;
                      quirtviewerupdsagittal.polylut[5] := chamferdotslutonline;
                      quirtviewerupdtransversal.polylut[5] := chamferdotslutonline;
                    end
                    else
                    begin
                      chamferdotslutreference.setvalue([0, 0], 255);
                      chamferdotslutreference.setvalue([0, 1], 255 div n);
                      chamferdotslutreference.setvalue([0, 2],   0);
                      chamferdotslutreference.setvalue([0, 3], 255 div n);
                      chamferdotslutreference.setvalue([0, 4], 15);
                      quirtviewerupdcoronal.polydots[9] := chamferdotsreference;
                      quirtviewerupdsagittal.polydots[9] := chamferdotsreference;
                      quirtviewerupdtransversal.polydots[9] := chamferdotsreference;
                      quirtviewerupdcoronal.polylut[9] := chamferdotslutreference;
                      quirtviewerupdsagittal.polylut[9] := chamferdotslutreference;
                      quirtviewerupdtransversal.polylut[9] := chamferdotslutreference;
                    end;
                    if online then
                    begin
                      quirtviewerupdcoronal.polytransform[5] := online_to_machine;
                      quirtviewerupdsagittal.polytransform[5] := online_to_machine;
                      quirtviewerupdtransversal.polytransform[5] := online_to_machine;
                      quirtviewerupdcoronal.polyadjust[5] := machine_to_machineadjust;
                      quirtviewerupdsagittal.polyadjust[5] := machine_to_machineadjust;
                      quirtviewerupdtransversal.polyadjust[5] := machine_to_machineadjust;
                    end
                    else
                    begin
                      quirtviewerupdcoronal.polytransform[9] := reference_to_machine;
                      quirtviewerupdsagittal.polytransform[9] := reference_to_machine;
                      quirtviewerupdtransversal.polytransform[9] := reference_to_machine;
                      quirtviewerupdcoronal.polyadjust[9] := nil;
                      quirtviewerupdsagittal.polyadjust[9] := nil;
                      quirtviewerupdtransversal.polyadjust[9] := nil;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_317()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.matchclassbuttonclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_318()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.acceptsingleframematch(sender: tobject);
                  var dummy  : tavsfield;
                      r, f      : integer;
                  begin
                    r := quirtviewerupdcoronal.activeclipbox.value-1;
                    f := quirtviewerupdcoronal.frame.value;
                    if r\<0 then r := 0;
                    if r\>=transform4d.dimensions[2] then exit;
                    if f\<0 then f := 0;
                    if f\>=transform4d.dimensions[3] then exit;
                    dummy := tavsfield.create;
                    field_inc_ndim(machine_to_machineadjust, dummy);
                    field_inc_ndim(dummy, dummy);
                    field_insert2(transform4d, dummy, transform4d, 0, 0, r, f);
                    dummy.free;
                    showmessage(format(message_nkimatchupdroi, [r+1, f]));
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_319()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.externalmatch(region: integer; frame: integer; matchmode: tmatchmode; style: integer);
                  var
                    v2, eq, i, j:  integer;
                    f, g, rp, dum1, dum2 : tavsfield;
                    s, str1 : string;
                    save_cursor: tcursor;
                    tprerot,toldadjust, tbestadjust, t1 : ttransform;
                    k, dumval : integer;
                    endcfvalue         : double;
                    segmenterror : boolean;
                    fl: textfile;
                    clipboxmask: tavsfield;
                    clipboxxfm: tavsfield;
                  begin
                    if not assigned(m) then
                      m := tmatch.create(self);
                    if (avlstate=1003) and enabletestmode then
                    begin
                      m.optimizer := plotcf;
                      if fileexists(getfullinifilename(\'plotcf.dat\')) then
                      begin
                        field_create(m.plotpoints, \'field 1d 6-vector double\', 10000);
                        assignfile(fl, getfullinifilename(\'plotcf.dat\'));
                        reset(fl);
                        i := 0;
                        while not eof(fl) do
                        begin
                          readln(fl, s);
                          for j:=0 to m.plotpoints.veclen-1 do
                            m.plotpoints.setvalue([i, j], valuefromstr(s, j+1, -1));
                          inc(i);
                        end;
                        field_crop(m.plotpoints, m.plotpoints, 0, i-1);
                        closefile(fl);
                      end
                      else
                      begin
                        field_create(m.plotpoints, \'field 1d 6-vector double\', 600);
                        for i:=0 to 99 do
                        begin
                          m.plotpoints.setvalue([i,     0], (i-50)/25);
                          m.plotpoints.setvalue([i+100, 1], (i-50)/25);
                          m.plotpoints.setvalue([i+200, 2], (i-50)/25);
                          m.plotpoints.setvalue([i+300, 3], (i-50)/2.5);
                          m.plotpoints.setvalue([i+400, 4], (i-50)/2.5);
                          m.plotpoints.setvalue([i+500, 5], (i-50)/2.5);
                        end;
                      end;
                    end;
                    segmenterror := false;
                    if m.active then
                    begin
                      matchclassbutton.caption := caption_nkimatchclass;
                      buttonmatch.caption := startmatch_caption;
                      m.stop;
                      matchinprogress := false;
                      exit;
                    end;
                    if ( (region\>=nclipbox) and maskedreference.empty ) then
                    begin
                      showmessage(mask_error);
                      exit;
                    end;
                    if region\<nclipbox then
                      if clipbox[region+1].empty then
                    begin
                      showmessage(clipbox_error);
                      exit;
                    end;
                    save_cursor := screen.cursor;
                    screen.cursor := crhourglass;
                    matchclassbutton.caption := caption_nkistop;
                    buttonmatch.caption := stopmatch_caption;
                    str1 :=   caption;
                    matchinprogress := true;
                    f := tavsfield.create;
                    g := tavsfield.create;
                    rp := tavsfield.createas(\'field 1d irregular 3-space\', [1]);
                    m.transform1 := reference[1].tomachine;
                    m.transform2 := online[1].tomachine;
                    m.adjust2    := machine_to_machineadjust;
                    m.onlowerfuncval := matchlowerfuncval;
                    m.excludezeros          := true;
                    m.forcefastinterpolator := true;
                    m.fixscan2              := false;
                    if style in [0] then
                    begin
                      m.transformtype := shift;
                      m.param1 := 0.001;
                    end
                    else if style in [1,2] then
                      m.transformtype := shift_rot
                    else if style in [3] then
                    begin
                      m.transformtype := rotate;
                      m.param1 := 0.001;
                      if not quirtviewerupdcoronal.markerdots[1].empty then
                      begin
                        rp.coordinate[0,0] := quirtviewerupdcoronal.markerdots[1].coordinate[0,0];
                        rp.coordinate[1,0] := quirtviewerupdcoronal.markerdots[1].coordinate[1,0];
                        rp.coordinate[2,0] := quirtviewerupdcoronal.markerdots[1].coordinate[2,0];
                      end
                      else
                      begin
                        rp.coordinate[0,0] := correctionreferencepoint.coordinate[0,0];
                        rp.coordinate[1,0] := correctionreferencepoint.coordinate[1,0];
                        rp.coordinate[2,0] := correctionreferencepoint.coordinate[2,0];
                      end;
                      m.rotationpoint1 := rp;
                    end
                    else
                    begin
                      f.free;
                      g.free;
                      exit;
                    end;
                    if online[1].data.ndim=4 then
                    begin
                      if frame\>=0 then
                        field_slice(online[1].data, g, -1, -1, -1, frame)
                      else
                      begin
                        if not phasehist.empty then
                          field_ortho_wghtsum(online[1].data, phasehist, g, field_ortho_wghtsum_udirection)
                        else
                          field_ortho_average(online[1].data, g, field_ortho_average_udirection);
                        field_to_short(g, g);
                      end;
                    end
                    else
                      field_copy(online[1].data, g);
                    if region\<nclipbox then s := comboboxclipboxmatch.text
                    else s := comboboxmaskmatch.text;
                    if region\<nclipbox then
                    begin
                      reference[1].clipbox[region+1].make;
                      field_cropwithbox(reference[1].data, reference[1].clipbox[region+1], f, 0);
                      online[1].clipbox[region+1].make;
                      field_cropwithbox(g, online[1].clipbox[region+1], g, 1);
                    end
                    else if region = nclipbox then
                    begin
                      maskedreference.make;
                      field_copy(maskedreference, f);
                      clipboxmask := tavsfield.create;
                      clipboxxfm := tavsfield.create;
                      field_findcropbox(maskedreference, clipboxmask);
                      cropbox_to_coords(clipboxmask, maskedreference, clipboxmask);
                      transform_math(maskedreferencetransform, machine_to_machineadjust, clipboxxfm, false, true);
                      transform_math(clipboxxfm, online[1].tomachine, clipboxxfm, false, true);
                      cropbox_transform(clipboxmask, clipboxxfm, clipboxmask);
                      field_cropwithbox(g, clipboxmask, g, 1);
                      clipboxmask.free;
                      clipboxxfm.free;
                    end;
                    if f.ndim=4 then
                    begin
                      field_ortho_average(f, f, field_ortho_average_udirection);
                      field_to_short(f, f);
                    end;
                    if matchmode=mmchamfer then
                    begin
                      if region\<nclipbox then s := comboboxclipboxmatch.text
                      else s := comboboxmaskmatch.text;
                      if (pos(match_substring_seed, s)\>0) then
                      begin
                        dum1 := tavsfield.create;
                        dum2 := tavsfield.create;
                        field_mrthreshold(f, dum1, dumval, v2, dum2, -1, 11, 1, 0.2, 100, 100, false, false);
                        dum1.free;
                        dum2.free;
                        v2 := v2 + (round(f.maximum) - v2) div 8;
                        createdotlist    (f, m.scan1, v2, false, 1);
                        if (m.scan1.dimensions[0]\<1) or (v2\<600) then segmenterror := true;
                        m.chamferrms := true;
                      end
                      else
                      begin
                        dum1 := tavsfield.create;
                        dum2 := tavsfield.create;
                        field_mrthreshold(f, dum1, dumval, v2, dum2, -1, 11, 1, 0.2, 100, 115, false, false);
                        dum1.free;
                        dum2.free;
                        createdotlist    (f, m.scan1, v2, false);
                        if (m.scan1.dimensions[0]\<1) or (v2\<600) then segmenterror := true;
                      end;
                      githreshold1 := v2;
                      if visualizebonesegmentation1.checked then
                      begin
                        chamferdotsreference.assign(m.scan1);
                        visboneseg(false);
                      end;
                      dum1 := tavsfield.create;
                      dum2 := tavsfield.create;
                      if (pos(match_substring_seed, s)\>0) then
                      begin
                        field_mrthreshold(g, dum1, dumval, v2, dum2, -1, 11, 1, 0.2, 100, 100, false, false);
                        v2 := v2 + (round(g.maximum) - v2) div 8;
                      end
                      else
                      begin
                        field_mrthreshold(g, dum1, dumval, v2, dum2, -1, 11, 1, 0.2, 100, 115, false, false);
                      end;
                      githreshold2 := v2;
                      dum1.free;
                      dum2.free;
                      if (v2 \>= g.maximum) or (v2\<600) then segmenterror := true;
                      createdistancemap(g, m.scan2, v2, false);
                      if visualizebonesegmentation1.checked then
                      begin
                        field_gtec(g, chamferdotsonline, v2);
                        fieldtrace(chamferdotsonline, chamferdotsonline, 1);
                        visboneseg(true);
                      end;
                      m.fixscan2 := true;
                    end
                    else
                    begin
                      field_resize(f, f, f.dimensions[0] div 70, f.dimensions[1] div 70, f.dimensions[2] div 70);
                      preprocessscan(f, m.scan1);
                      preprocessscan(g, m.scan2);
                    end;
                    if transform4d.empty then
                    begin
                      field_create(transform4d, \'field 4d float\', 4, 4, nclipbox*3, max(onlinecube.dimensions[3], 1));
                      field_setc(transform4d, transform4d, -1);
                      field_copy(transform4d, backuptransform4d);
                    end;
                    toldadjust  := ttransform.create;
                    toldadjust.assign(machine_to_machineadjust);
                    if not segmenterror then
                    begin
                      if style in [0,1,3] then
                        m.start
                      else
                      begin
                        tprerot     := ttransform.create;
                        tbestadjust := ttransform.create;
                        t1 := ttransform.create;
                        field_copy(machine_to_machineadjust, toldadjust);
                        endcfvalue := 0;
                        for k := -1 to 1 do
                        begin
                          if strcomp(pchar(matchclassbutton.caption), \'matchclass\')=0 then
                            break;
                          tprerot.makerotation(k*5, 0, 0);
                          if matchrotmark then
                          begin
                            t1.maketranslation(quirtviewerupdcoronal.markerdots[1].coordinate[0,0], quirtviewerupdcoronal.markerdots[1].coordinate[1,0], quirtviewerupdcoronal.markerdots[1].coordinate[2,0]);
                            tprerot.premultiply(t1);
                            t1.invert;
                            tprerot.postmultiply(t1);
                          end;
                          machine_to_machineadjust.assign(toldadjust);
                          machine_to_machineadjust.premultiply(tprerot);
                          m.start;
                          if m.endcfvalue \< endcfvalue then
                          begin
                            endcfvalue := m.endcfvalue;
                            tbestadjust.assign(machine_to_machineadjust);
                          end;
                        end;
                        machine_to_machineadjust.assign(tbestadjust);
                        tprerot.free;
                        tbestadjust.free;
                        t1.free;
                      end;
                    end;
                    if (matchmode=mmchamfer) and not segmenterror then
                    begin
                      if ((pos(match_substring_seed, s)\>0)  and (m.endcfvalue \> seedmatchdoubtthreshold)) or
                         ((pos(match_substring_seed, s)\<=0) and (m.endcfvalue \> bonematchdoubtthreshold)) then
                      begin
                        if showmatchresultsdetailsbone then
                        begin
                          if messagedlg(match_doubt1 + #13 + #13 + m.information + #13 + #13 + match_accept,
                            mtwarning, [mbyes, mbno], 0) \<\> mryes then
                          begin
                            machine_to_machineadjust.assign(toldadjust);
                            invalidatecorrection;
                          end
                        end
                        else
                          if messagedlg(match_doubt2 + #13 + match_accept, mtwarning, [mbyes, mbno], 0) \<\> mryes then
                          begin
                            machine_to_machineadjust.assign(toldadjust);
                            invalidatecorrection;
                            match2inprogress := false;
                          end;
                      end;
                    end;
                    field_compare_data(machine_to_machineadjust,toldadjust,eq);
                    if (eq\<\>1) then
                      externalmanualmatchto4d(frame, region);
                    if online[1].data.ndim\<\>4 then progressbar3.position := 0;
                    caption := str1;
                    matchclassbutton.caption := caption_nkimatchclass;
                    buttonmatch.caption := startmatch_caption;
                    if region\<nclipbox then
                      lastclipboxmatchresult := m.information
                    else
                      lastmaskmatchresult := m.information;
                    if (avlstate=1003) and enabletestmode then
                    begin
                      assignfile(fl, extractfilepath(application.exename)+scanuid+\'.res\');
                      if fileexists(extractfilepath(application.exename)+scanuid+\'.res\') then append(fl) else rewrite(fl);
                      writeln(fl, formatdatetime(\'yyyymmdd hh:mm:ss\', now), #9, region, #9, frame, #9, ord(matchmode), #9, style);
                      for i:=0 to m.plotpoints.dimensions[0]-1 do
                        writeln(fl, m.plotpoints.getvalue([i, 0]), #9,
                                    m.plotpoints.getvalue([i, 1]), #9,
                                    m.plotpoints.getvalue([i, 2]), #9,
                                    m.plotpoints.getvalue([i, 3]), #9,
                                    m.plotpoints.getvalue([i, 4]), #9,
                                    m.plotpoints.getvalue([i, 5]), #9,
                                    m.plotdata.getvalue([i]));
                      closefile(fl);
                    end;
                    m.free;
                    m := nil;
                    f.free;
                    g.free;
                    toldadjust.free;
                    rp.free;
                    matchinprogress := false;
                    screen.cursor  := save_cursor;
                    if segmenterror then
                    begin
                      if (pos(match_substring_seed, s)\>0) then str1 := segment_error_seed
                      else                                     str1 := segment_error_bone;
                      if region\>=nclipbox then str1 := format(str1, [segment_error_mask, segment_error_mask])
                      else                     str1 := format(str1, [segment_error_clipbox, segment_error_clipbox]);
                      showmessage(str1);
                      exit;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_320()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.tr2t(t: ttransform; crp: tavsfield);
                  var
                      p : tavsfield;
                      x, y, z : double;
                  begin
                      p := tavsfield.create;
                      t.invert;
                      dotxfm(crp, t, p);
                      x := p.coordinate[0,0] - crp.coordinate[0,0];
                      y := p.coordinate[1,0] - crp.coordinate[1,0];
                      z := p.coordinate[2,0] - crp.coordinate[2,0];
                      t.makeidentity;
                      t.maketranslation(x,y,z);
                      p.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_321()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.externalconverttocorrection;
                  var t: ttransform;
                      p, crp: tavsfield;
                      x, y, z, v, w: double;
                      i, j, i1, i2: integer;
                      s: string;
                      nexhale: integer;
                      multiclip : boolean;
                  begin
                    x := 0;
                    y := 0;
                    z := 0;
                    w := 0;
                    clipboxlist.make;
                    multiclip := false;
                    if not clipbox[2].empty then
                    begin
                      v := 0;
                      for i :=1 to nclipbox do
                        if (clipboxlist.getvalue([i-1, 6])\<\>0) then v := v +1;
                      if v \> 1 then
                        multiclip := true;
                    end;
                    if alignmentmode.value=2 then begin i1:=2*nclipbox+1; i2:=2*nclipbox+1 end
                    else if (comboboxcorrectionprotocol.text = correction_from_clipbox) then begin i1:=1; i2:=nclipbox end
                    else begin i1:=nclipbox+1; i2:=2*nclipbox end;
                    if not ((alignmentmode.value in [0..2])) then
                      exit;
                    t := ttransform.create;
                    p := tavsfield.create;
                    crp := tavsfield.create;
                    for i:=i1 to i2 do
                      for j:=0 to max(onlinecube.dimensions[3]-1, 0) do
                    begin
                      if transform4d.empty then
                        t.assign(machine_to_machineadjust)
                      else
                      begin
                        if i-1 \>= transform4d.dimensions[2] then continue;
                        if j   \>= transform4d.dimensions[3] then continue;
                        field_slice(transform4d, t, -1, -1, i-1, j);
                      end;
                      field_copy(correctionreferencepoint, crp);
                      if ( ((comboboxcorrectionprotocol.text = correction_from_clipbox) and multiclip) or
                            (comboboxcorrectionprotocol.text \<\> correction_from_clipbox))  and (i\<=nclipbox) then
                      begin
                        if (not clipbox[i].empty) then
                        begin
                          crp.coordinate[0,0] := (clipbox[i].getvalue([0]) + clipbox[i].getvalue([1]))/2;
                          crp.coordinate[1,0] := (clipbox[i].getvalue([2]) + clipbox[i].getvalue([3]))/2;
                          crp.coordinate[2,0] := (clipbox[i].getvalue([4]) + clipbox[i].getvalue([5]))/2;
                        end;
                      end
                      else if (comboboxcorrectionprotocol.text = correction_from_clipbox) and (i=(nclipbox+1)) then
                      begin
                        mask_cog[1].make;
                        if mask_cog[1].coordinate[0,0] \> -9998 then
                        begin
                          crp.coordinate[0,0] := mask_cog[1].coordinate[0,0];
                          crp.coordinate[1,0] := mask_cog[1].coordinate[1,0];
                          crp.coordinate[2,0] := mask_cog[1].coordinate[2,0];
                        end;
                      end;
                      if correctionbyhexapod then
                        field_setc(crp, crp, 0, true);
                      nexhale := onlinecube.dimensions[3] div 8;
                      if (comboboxcorrectionprotocol.text = correction_from_mask_exh) then
                        if (j\>nexhale) and (j\<onlinecube.dimensions[3]-nexhale) then continue;
                      if t.getvalue([3,3])\<0 then continue;
                      t.invert;
                      dotxfm(crp, t, p);
                      p.coordinate[0,0] := p.coordinate[0,0] - crp.coordinate[0,0];
                      p.coordinate[1,0] := p.coordinate[1,0] - crp.coordinate[1,0];
                      p.coordinate[2,0] := p.coordinate[2,0] - crp.coordinate[2,0];
                      if i\<=nclipbox then v := clipboxlist.getvalue([i-1, 6])
                      else                v := 1;
                      if not phasehist.empty then v := v * phasehist.getvalue([j]);
                      x := x + v * p.coordinate[0,0];
                      y := y + v * p.coordinate[1,0];
                      z := z + v * p.coordinate[2,0];
                      w := w + v;
                      if transform4d.empty then break;
                    end;
                    if w\<\>0 then
                    begin
                      x := x/w;
                      y := y/w;
                      z := z/w;
                    end;
                    edittranslationlr.text := floattostrf(x, fffixed, 5, 2);
                    edittranslationcc.text := floattostrf(y, fffixed, 5, 2);
                    edittranslationap.text := floattostrf(z, fffixed, 5, 2);
                    if not correctionbyhexapod then
                    begin
                      editrotationlr.text := \'0.0\';
                      editrotationcc.text := \'0.0\';
                      editrotationap.text := \'0.0\';
                    end;
                    labelcomputedlat2.caption   := floattostrf(-x, fffixed, 5, complabprec);
                    labelcomputedlong2.caption  := floattostrf(-y, fffixed, 5, complabprec);
                    if iec_linear_convention in [0, 1, 3] then
                      labelcomputedheight2.caption:= floattostrf( z, fffixed, 5, complabprec)
                    else
                      labelcomputedheight2.caption:= floattostrf(-z, fffixed, 5, complabprec);
                    labelcomputedlat2.enabled := true;
                    labelcomputedlong2.enabled := true;
                    labelcomputedheight2.enabled := true;
                    if safestrtofloat(labelcomputedlat2.caption)\>0    then labelcomputedlat2.hint    := hint_right else labelcomputedlat2.hint    := hint_left;
                    if safestrtofloat(labelcomputedlong2.caption)\>0   then labelcomputedlong2.hint   := hint_in    else labelcomputedlong2.hint   := hint_out;
                    if iec_linear_convention in [0, 1, 3] then
                      if safestrtofloat(labelcomputedheight2.caption)\<0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down
                    else
                      if safestrtofloat(labelcomputedheight2.caption)\>0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down;
                    t.assign(online_to_machine);
                    t.premultiply(machine_to_machineadjust);
                    transform_math(t, reference_to_machine, t, false, true, false);
                    s := t.asstring;
                    for j:=1 to length(s) do
                    begin
                      if s[j]=#10 then s[j] := \' \';
                      if s[j]=#13 then s[j] := \' \';
                    end;
                    onlinetoreftransformmatched := s;
                    t.free;
                    p.free;
                    crp.free;
                    externalmanualmatchto4d(-1, nclipbox*2);
                    if ( (unpackregistration(-4, -1, s, s, s, s, s, s, s, false, true, false)\>0) and (comboboxregistrationprotocol.itemindex in [0,2,3,5]) ) or
                       ( (unpackregistration(nclipbox, -5, s, s, s, s, s, s, s, false, true, false)\>0) and (comboboxregistrationprotocol.itemindex in [1,2,3,5]) ) then
                    begin
                      alignmentmode.value := 2;
                      correctionapprovalby := \'\';
                    end
                    else
                    begin
                        alignmentmode.value := 3;
                      correctionapprovalby := \'*\';
                    end;
                    appliedcorrectionprotocol := comboboxregistrationprotocol.mappedtext;
                    appliedcorrectionfrom     := comboboxcorrectionprotocol.mappedtext;
                    appliedcorrectionby       := comboboxcorrectionby.mappedtext;
                    manualmatchactive := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_322()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.weightedconverttocorrection(weight: single);
                  var t: ttransform;
                      p, crp: tavsfield;
                      x, y, z, v, w: double;
                      rx, ry, rz: double;
                      rrx, rry, rrz: single;
                      i, j, i1, i2: integer;
                      s: string;
                      nexhale: integer;
                      multiclip : boolean;
                  begin
                    x := 0;
                    y := 0;
                    z := 0;
                    w := 0;
                    rx:= 0;
                    ry:= 0;
                    rz:= 0;
                    clipboxlist.make;
                    i1:=1; i2:=nclipbox+1;
                    multiclip := false;
                    if not clipbox[2].empty then
                    begin
                      v := 0;
                      for i :=1 to nclipbox do
                        if (clipboxlist.getvalue([i-1, 6])\<\>0) then v := v +1;
                      if v \> 1 then
                        multiclip := true;
                    end;
                    t := ttransform.create;
                    p := tavsfield.create;
                    crp := tavsfield.create;
                    for i:=i1 to i2 do
                      for j:=0 to max(onlinecube.dimensions[3]-1, 0) do
                    begin
                      if transform4d.empty then
                        t.assign(machine_to_machineadjust)
                      else
                      begin
                        if i-1 \>= transform4d.dimensions[2] then continue;
                        if j   \>= transform4d.dimensions[3] then continue;
                        field_slice(transform4d, t, -1, -1, i-1, j);
                      end;
                      field_copy(correctionreferencepoint, crp);
                      if ((comboboxcorrectionprotocol.text \<\> correction_from_clipbox) or multiclip) and (i\<=nclipbox) then
                      begin
                        if (not clipbox[i].empty) then
                        begin
                          crp.coordinate[0,0] := (clipbox[i].getvalue([0]) + clipbox[i].getvalue([1]))/2;
                          crp.coordinate[1,0] := (clipbox[i].getvalue([2]) + clipbox[i].getvalue([3]))/2;
                          crp.coordinate[2,0] := (clipbox[i].getvalue([4]) + clipbox[i].getvalue([5]))/2;
                        end;
                      end
                      else if (comboboxcorrectionprotocol.text = correction_from_clipbox) and (i=(nclipbox+1)) then
                      begin
                        mask_cog[1].make;
                        if mask_cog[1].coordinate[0,0] \> -9998 then
                        begin
                          crp.coordinate[0,0] := mask_cog[1].coordinate[0,0];
                          crp.coordinate[1,0] := mask_cog[1].coordinate[1,0];
                          crp.coordinate[2,0] := mask_cog[1].coordinate[2,0];
                        end;
                      end;
                      if correctionbyhexapod then
                        field_setc(crp, crp, 0, true);
                      nexhale := onlinecube.dimensions[3] div 8;
                      if (comboboxcorrectionprotocol.text = correction_from_mask_exh) then
                        if (j\>nexhale) and (j\<onlinecube.dimensions[3]-nexhale) then continue;
                      if t.getvalue([3,3])\<0 then continue;
                      t.invert;
                      dotxfm(crp, t, p);
                      t.getrotationafterscaling(rrx, rry, rrz);
                      rrx := -rrx;
                      rry := -rry;
                      rrz := -rrz;
                      p.coordinate[0,0] := p.coordinate[0,0] - crp.coordinate[0,0];
                      p.coordinate[1,0] := p.coordinate[1,0] - crp.coordinate[1,0];
                      p.coordinate[2,0] := p.coordinate[2,0] - crp.coordinate[2,0];
                      if i\<=nclipbox then v := clipboxlist.getvalue([i-1, 6]) * (1-weight)
                      else                v := 1                              * weight;
                      if not phasehist.empty then v := v * phasehist.getvalue([j]);
                      x := x + v * p.coordinate[0,0];
                      y := y + v * p.coordinate[1,0];
                      z := z + v * p.coordinate[2,0];
                      rx := rx + v * rrx;
                      ry := ry + v * rry;
                      rz := rz + v * rrz;
                      w := w + v;
                      if transform4d.empty then break;
                    end;
                    if w\<\>0 then
                    begin
                      x := x/w;
                      y := y/w;
                      z := z/w;
                      rx := rx/w;
                      ry := ry/w;
                      rz := rz/w;
                    end;
                    if colorstringgrid1.cellprops[3,1].box.checked then edittranslationlr.text := floattostrf(x, fffixed, 5, 2);
                    if colorstringgrid1.cellprops[3,2].box.checked then edittranslationcc.text := floattostrf(y, fffixed, 5, 2);
                    if colorstringgrid1.cellprops[3,3].box.checked then edittranslationap.text := floattostrf(z, fffixed, 5, 2);
                    if correctionbyhexapod then
                    begin
                      editrotationlr.text := \'0.0\';
                      editrotationcc.text := \'0.0\';
                      editrotationap.text := \'0.0\';
                    end
                    else
                    begin
                      if not iec_angle_convention then
                      begin
                        if colorstringgrid1.cellprops[3,4].box.checked then editrotationlr.text := floattostrf( rx, fffixed, 5, 1);
                        if colorstringgrid1.cellprops[3,5].box.checked then editrotationcc.text := floattostrf(-ry, fffixed, 5, 1);
                        if colorstringgrid1.cellprops[3,6].box.checked then editrotationap.text := floattostrf( rz, fffixed, 5, 1);
                      end
                      else
                      begin
                        if colorstringgrid1.cellprops[3,4].box.checked then
                        begin
                          if rx\>-0.05 then
                            editrotationlr.text := floattostrf( rx, fffixed, 5, 1)
                          else
                            editrotationlr.text := floattostrf( rx + 360, fffixed, 5, 1);
                        end;
                        if colorstringgrid1.cellprops[3,5].box.checked then
                        begin
                          if ry\<0.05 then
                            editrotationcc.text := floattostrf(-ry, fffixed, 5, 1)
                          else
                            editrotationcc.text := floattostrf(-ry + 360, fffixed, 5, 1);
                        end;
                        if colorstringgrid1.cellprops[3,6].box.checked then
                        begin
                          if rz\>-0.05 then
                            editrotationap.text := floattostrf( rz, fffixed, 5, 1)
                          else
                            editrotationap.text := floattostrf( rz + 360, fffixed, 5, 1);
                        end;
                      end;
                    end;
                    machine_to_machineadjust.make;
                    if colorstringgrid1.cellprops[3,1].box.checked then
                      labelcomputedlat2.caption   := floattostrf(-x, fffixed, 5, complabprec);
                    if colorstringgrid1.cellprops[3,2].box.checked then
                      labelcomputedlong2.caption  := floattostrf(-y, fffixed, 5, complabprec);
                    if colorstringgrid1.cellprops[3,3].box.checked then
                    begin
                      if iec_linear_convention in [0, 1, 3] then
                        labelcomputedheight2.caption:= floattostrf( z, fffixed, 5, complabprec)
                      else
                        labelcomputedheight2.caption:= floattostrf(-z, fffixed, 5, complabprec);
                    end;
                    if safestrtofloat(labelcomputedlat2.caption)\>0    then labelcomputedlat2.hint    := hint_right else labelcomputedlat2.hint    := hint_left;
                    if safestrtofloat(labelcomputedlong2.caption)\>0   then labelcomputedlong2.hint   := hint_in    else labelcomputedlong2.hint   := hint_out;
                    if iec_linear_convention in [0, 1, 3] then
                      if safestrtofloat(labelcomputedheight2.caption)\<0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down
                    else
                      if safestrtofloat(labelcomputedheight2.caption)\>0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down;
                    t.assign(online_to_machine);
                    t.premultiply(machine_to_machineadjust);
                    transform_math(t, reference_to_machine, t, false, true, false);
                    s := t.asstring;
                    for j:=1 to length(s) do
                    begin
                      if s[j]=#10 then s[j] := \' \';
                      if s[j]=#13 then s[j] := \' \';
                    end;
                    onlinetoreftransformmatched := s;
                    t.free;
                    p.free;
                    crp.free;
                    externalmanualmatchto4d(-1, nclipbox*2);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_323()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.externalmanualmatchto4d(frame, region: integer);
                  var f: tavsfield;
                      f1, f2, i: integer;
                  begin
                    if transform4d.empty then
                    begin
                      field_create(transform4d, \'field 4d float\', 4, 4, 3*nclipbox, max(onlinecube.dimensions[3], 1));
                      field_setc(transform4d, transform4d, -1);
                      field_copy(transform4d, backuptransform4d);
                    end;
                    f1 := frame;
                    f2 := f1;
                    if f1\<0 then begin f1 := 0; f2:=max(transform4d.dimensions[3]-1, 0); end;
                    f := tavsfield.create;
                    field_inc_ndim(machine_to_machineadjust, f);
                    field_inc_ndim(f, f);
                    for i := f1 to f2 do field_insert2(transform4d, f, transform4d, 0, 0, region, i);
                    f.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_324()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.compareregistrationbackup(low, high: integer): boolean;
                  var f, g: tavsfield;
                      eq: integer;
                  begin
                    result := false;
                    if backuptransform4d.empty and transform4d.empty then result := true;
                    if backuptransform4d.empty then exit;
                    if transform4d.empty then exit;
                    f := tavsfield.create;
                    g := tavsfield.create;
                    field_crop(transform4d,       f, 0, 9999, 0, 9999, low, high, 0, 9999);
                    field_crop(backuptransform4d, g, 0, 9999, 0, 9999, low, high, 0, 9999);
                    field_compare_data(f, g, eq);
                    result := eq\<\>0;
                    f.free;
                    g.free;
                    exit;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_325()
{
    return parse(#DelphiGrammar::MethodImplementation, "function tform1.compareregistrationbackuppartial(low, high: integer): integer;
                  var f, g: tavsfield;
                      eq, i, r, neq: integer;
                  begin
                     result := 0;
                     if backuptransform4d.empty and transform4d.empty then result := 100;
                     if backuptransform4d.empty then exit;
                     if transform4d.empty then exit;
                     f := tavsfield.create;
                     g := tavsfield.create;
                     neq := 0;
                     for i:=low to high do
                       for r:=0 to transform4d.dimensions[3]-1 do
                     begin
                       field_crop(transform4d,       f, 0, 9999, 0, 9999, i, i, r, r);
                       field_crop(backuptransform4d, g, 0, 9999, 0, 9999, i, i, r, r);
                       field_compare_data(f, g, eq);
                       neq := neq + eq;
                     end;
                     result := neq;
                     f.free;
                     g.free;
                     exit;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_326()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.makeregistrationbackup(low, high, phaselow, phasehigh: integer);
                  var f: tavsfield;
                  begin
                    if transform4d.empty then
                    begin
                      backuptransform4d.clear;
                      exit;
                    end;
                    if backuptransform4d.empty then
                    begin
                      field_copy(transform4d, backuptransform4d);
                      field_setc(backuptransform4d, backuptransform4d, -1);
                    end;
                    f := tavsfield.create;
                    field_crop(transform4d,       f, 0, 9999, 0, 9999, low, high, phaselow, phasehigh);
                    field_insert2(backuptransform4d, f, backuptransform4d, 0, 0, low, phaselow, 0);
                    f.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_327()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.invalidateregistrationbackup(low, high: integer);
                  var f: tavsfield;
                  begin
                    if transform4d.empty then
                    begin
                      backuptransform4d.clear;
                      exit;
                    end;
                    if backuptransform4d.empty then
                    begin
                      field_copy(transform4d, backuptransform4d);
                      field_setc(backuptransform4d, backuptransform4d, -1);
                    end;
                    f := tavsfield.create;
                    field_crop(transform4d,       f, 0, 9999, 0, 9999, low, high, 0, 9999);
                    field_setc(f, f, -9999);
                    field_insert2(backuptransform4d, f, backuptransform4d, 0, 0, low, 0, 0);
                    f.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_328()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.readini;
                  var i, j: integer;
                      s: string;
                      h: tqinifile;
                  begin
                    inifile := tinifiles.create([paramstr2]);
                    if avlstate\<\>inifile.readinteger(\'xvi\', \'avlstate\', -1) then
                    begin
                      if avlstate=6 then reconterminate(false, error_inifile)
                      else
                      begin
                        showmessage(error_inifile);
                        application.terminate;
                      end;
                    end;
                    if inifile.readbool(\'xvi\', \'profile\', false) then
                    begin
                      appstarttime := now;
                      quirtavstrace(\'\');
                    end;
                    readonly := inifile.readbool(\'xvi\', \'readonly\', false);
                    buttonelektaaccept.enabled := not readonly;
                    exitaccept1.enabled := buttonelektaaccept.enabled;
                    avlflexmapmode := (inifile.readbool(\'xvi\', \'avlflexmapmode\',false));
                    projectionscalibrated := inifile.readinteger(\'reconstruction\', \'projectionscalibrated\', 0);
                    offsetfilename     := inifile.readstring(\'reconstruction\', \'offsetfile\',    \'\');
                    gainfilename       := inifile.readstring(\'reconstruction\', \'gainfile\',      \'\');
                    gainfilename       := inifile.readstring(\'reconstruction\', \'gainfileopen\', gainfilename);
                    gainbowtiefilename := inifile.readstring(\'reconstruction\', \'gainfilebowtie\',\'\');
                    badmapfilename     := inifile.readstring(\'reconstruction\', \'badmapfile\',    \'\');
                    readcorrectionimages(gain, offset, bad, bowtie);
                    checkboxmultithread.checked := inifile.readbool(\'xvi\', \'multithreaded\', true) and checkboxmultithread.enabled;
                    checkboxmedian.checked      := inifile.readbool(\'xvi\', \'medianfilter\', false);
                    skipcolumnsleft             := inifile.readinteger(\'xvi\', \'skipcolumnsleft\',  0);
                    skipcolumnsright            := inifile.readinteger(\'xvi\', \'skipcolumnsright\', 0);
                    skiprowstop                 := inifile.readinteger(\'xvi\', \'skiprowstop\',  0);
                    skiprowsbottom              := inifile.readinteger(\'xvi\', \'skiprowsbottum\', 0);
                    skiprowsbottom              := inifile.readinteger(\'xvi\', \'skiprowsbottom\', skiprowsbottom);
                    fastcorrectimage            := inifile.readbool   (\'xvi\', \'fastcorrectimage\', false);
                    fastcorrectimagescale       := inifile.readinteger(\'xvi\', \'fastcorrectimagescale\', 4);
                    correctfor0xffffpixelbug    := inifile.readbool   (\'xvi\', \'correctfor0xffffpixelbug\', false);
                    editfp0.text      := format(\'%.2f\', [inifile.readfloat(\'xvi\', \'fp0\', 0.7)]);
                    editfp1.text      := format(\'%.2f\', [inifile.readfloat(\'xvi\', \'fp1\', 90)]);
                    inplanerotationcorrectionangle :=
                      inifile.readfloat(\'xvi\', \'inplanerotationcorrectionangle\', 0);
                    iec_angle_convention := inifile.readbool(\'xvi\', \'iecangleconvention\', false);
                    iec_linear_convention := inifile.readinteger(\'xvi\', \'ieclinearconvention\', 1);
                    application.hinthidepause := inifile.readinteger(\'xvi\', \'hinthidepauselength\', 2500);
                    pagecontrol1.activepageindex := 2;
                    statusbar1.panels[0].text := inifile.readstring(\'xvi\', \'statuslinetext\', \'\');
                    showmatchresultsdetailsgreyvalue := inifile.readbool(\'xvi\', \'showmatchresultsdetailsgreyvalue\', true);
                    showmatchresultsdetailsbone := inifile.readbool(\'xvi\', \'showmatchresultsdetailsbone\', true);
                    if (avlstate\<=0) and not pagecontrol1.pages[1].tabvisible then
                    begin
                      pagecontrol1.tabheight := 1;
                      pagecontrol1.tabwidth  := 1;
                    end;
                    if avlstate\>0 then
                    begin
                      patientid          := inifile.readstring(\'identification\', \'patientid\', \'\');
                      patientname        := inifile.readstring(\'identification\', \'lastname\', \'\') + \', \' +
                                            inifile.readstring(\'identification\', \'firstname\', \'\');
                      treatmentid        := inifile.readstring(\'identification\', \'treatmentid\', \'\');
                      plansopuid         := inifile.readstring(\'identification\', \'referenceuid\', \'\');
                      treatmentuid       := inifile.readstring(\'identification\', \'referenceuid\', \'\');
                      scanuid            := inifile.readstring(\'identification\', \'scanuid\', \'\');
                      titlebarstring         := inifile.readstring(\'identification\', \'titlebarstring\', \'\');
                      referenceoverlaystring := inifile.readstring(\'identification\', \'referenceoverlaystring\', \'\');
                      onlineoverlaystring    := inifile.readstring(\'identification\', \'onlineoverlaystring\', \'\');
                      dob                    := inifile.readstring(\'identification\', \'dob\', \'\');
                      reconfilebase      := inifile.readstring(\'xvi\', \'reconstructedscansdirectory\', \'\');
                      adminfilebase      := inifile.readstring(\'xvi\', \'administrativefilesdirectory\', \'\');
                      substituteparms(adminfilebase);
                    end;
                    if not readonly then
                      sysutils.forcedirectories(extractfilepath(adminfilebase));
                    cachefilebase      := inifile.readstring(\'xvi\', \'referencecachedirectory\', \'\');
                    if avlstate in [2, 6] then
                      cachefilebase := cachefilebase + plansopuid + \'\\\';
                    projectionfilebase := inifile.readstring(\'xvi\', \'projectiondirectory\', \'\');
                    anglefilebase      := inifile.readstring(\'xvi\', \'administrativefilesdirectory\', \'\') +
                                          inifile.readstring(\'reconstruction\', \'projectionanglefile\', \'\');
                    if avlstate in [2, 4, 6] then
                    begin
                      if useonlinereconstruction then
                        numframes:=9000
                      else
                      begin
                        for i:=0 to 9000 do
                        begin
                          s := format(anglefilebase, [i]);
                          for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                          if fileexists(s) then numframes := i+1 else break;
                        end;
                      end;
                      frameid   := 0;
                      if useonlinereconstruction then
                        projdim := inifile.readinteger(\'reconstruction\', \'camerawidth\', 512)
                      else
                      begin
                        s := format(anglefilebase, [frameid]);
                        for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                        h :=tqinifile.create(s);
                        s := format(\'%.4d\', [frameid]);
                        s := projectionfilebase + h.readstring(s, \'projectiondatafile\', \'\');
                        read_heimann_his(f, s);
                        projdim := f.dimensions[0];
                        h.free;
                      end;
                      prepad := 0;
                      case projdim of
                        960, 480, 240, 120, 60:
                          begin
                            detectorsize := 43.0;
                            fdd          := 153.2;
                          end;
                        780, 390, 195:
                          begin
                            detectorsize := 28.7;
                            fdd          := 153.6;
                          end;
                        1024, 512, 256, 128, 64:
                          begin
                            detectorsize := 40.96;
                            fdd          := 153.6;
                          end;
                        else
                          begin
                            showmessage(\'unsupported detector\');
                            detectorsize := 10.0;
                            fdd          := 153.6;
                          end;
                      end;
                      detectorsize := inifile.readfloat(\'xvi\', \'detectorsize\', detectorsize);
                      fdd := inifile.readfloat(\'xvi\', \'focusdetectordistance\', fdd);
                      fid := inifile.readfloat(\'xvi\', \'focusisocdistance\', 100.00);
                    end;
                    matchresultlogfile := inifile.readstring(\'xvi\', \'matchresultlogfile\', \'\');
                    flexmapfilename := inifile.readstring(\'reconstruction\', \'flexmap\', \'\');
                    useonlinereconstruction := inifile.readbool(\'reconstruction\', \'useonlinereconstruction\', false);
                    projectiontimeout := inifile.readinteger(\'reconstruction\', \'projectiontimeout\', 10);
                    zoomfix := inifile.readfloat(\'xvi\', \'zoomfix\', 1);
                    quirtviewerupdtransversal.interpolatedzoom.value := ord(inifile.readbool(\'xvi\', \'interpolatedzoom\', true));
                    reversemotion.value := inifile.readinteger(\'xvi\', \'planningstationary\', 0);
                    i := inifile.readinteger(\'xvi\', \'guirefreshinterval\', 20);
                    if i=0 then
                      timer1.enabled := false
                    else
                      timer1.interval:= i;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_329()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.formresize(sender: tobject);
                  begin
                    if not xviischildwindow then exit;
                    progressbar3.height := height;
                    progressbar3.left := width - 15;
                    if screenlayoutmode=0 then
                    begin
                      quirtviewerupdcoronal.top := 0;
                      quirtviewerupdcoronal.left := 0;
                      quirtviewerupdcoronal.height := round(height * screenlayoutratio2);
                      quirtviewerupdcoronal.width  := round(width  * screenlayoutratio1);
                      quirtviewerupdsagittal.top := 0;
                      quirtviewerupdsagittal.height := quirtviewerupdcoronal.height;
                      quirtviewerupdsagittal.left   := quirtviewerupdcoronal.left + quirtviewerupdcoronal.width + 3;
                      quirtviewerupdsagittal.width  := width - quirtviewerupdcoronal.width - 15 - 6;
                      quirtviewerupdtransversal.left := quirtviewerupdcoronal.left;
                      quirtviewerupdtransversal.top    := quirtviewerupdcoronal.top + quirtviewerupdcoronal.height + 3;
                      quirtviewerupdtransversal.height := height - quirtviewerupdcoronal.height - 3;
                      quirtviewerupdtransversal.width  := quirtviewerupdcoronal.width;
                    end
                    else if screenlayoutmode=1 then
                    begin
                      quirtviewerupdtransversal.top := 0;
                      quirtviewerupdtransversal.left := 0;
                      quirtviewerupdtransversal.height := height;
                      quirtviewerupdtransversal.width  := round((width - 15 - 6) * screenlayoutratio1);
                      quirtviewerupdcoronal.top := 0;
                      quirtviewerupdcoronal.height := height;
                      quirtviewerupdcoronal.width  := round((width - 15 - 6) * screenlayoutratio2);
                      quirtviewerupdcoronal.left   := quirtviewerupdtransversal.left + quirtviewerupdtransversal.width + 3;
                      if quirtviewerupdcoronal.left=3 then quirtviewerupdcoronal.left := 0;
                      quirtviewerupdsagittal.top    := 0;
                      quirtviewerupdsagittal.height := height;
                      if screenlayoutratio1+screenlayoutratio2 = 0 then
                        quirtviewerupdsagittal.width  := width - quirtviewerupdtransversal.width - quirtviewerupdcoronal.width - 15 - 3
                      else
                        quirtviewerupdsagittal.width  := width - quirtviewerupdtransversal.width - quirtviewerupdcoronal.width - 15 - 9;
                      quirtviewerupdsagittal.left := quirtviewerupdcoronal.left + quirtviewerupdcoronal.width + 3;
                      if quirtviewerupdsagittal.left=3 then quirtviewerupdsagittal.left := 0;
                      if quirtviewerupdtransversal.width\<10 then  quirtviewerupdtransversal.width := 10;
                      if quirtviewerupdcoronal.width\<10 then      quirtviewerupdcoronal.width := 10;
                      if quirtviewerupdsagittal.width\<10 then     quirtviewerupdsagittal.width := 10;
                    end
                    else if screenlayoutmode=2 then
                    begin
                      quirtviewerupdtransversal.left := 0;
                      quirtviewerupdtransversal.top    := 0;
                      quirtviewerupdtransversal.height := round(height * screenlayoutratio2);
                      quirtviewerupdtransversal.width  := round(width  * screenlayoutratio1);
                      quirtviewerupdcoronal.top := quirtviewerupdtransversal.top + quirtviewerupdtransversal.height + 3;
                      quirtviewerupdcoronal.left := quirtviewerupdtransversal.left;
                      quirtviewerupdcoronal.height := height - quirtviewerupdtransversal.height - 3;
                      quirtviewerupdcoronal.width  := quirtviewerupdtransversal.width;
                      quirtviewerupdsagittal.top := quirtviewerupdcoronal.top;
                      quirtviewerupdsagittal.height := quirtviewerupdcoronal.height;
                      quirtviewerupdsagittal.left   := quirtviewerupdcoronal.left + quirtviewerupdcoronal.width + 3;
                      quirtviewerupdsagittal.width  := width - quirtviewerupdcoronal.width - 15 - 6;
                    end
                    else if screenlayoutmode=3 then
                    begin
                      quirtviewerupdtransversal.left := 0;
                      quirtviewerupdtransversal.top    := 0;
                      quirtviewerupdtransversal.height := height;
                      quirtviewerupdtransversal.width  := round(width  * screenlayoutratio1);
                      quirtviewerupdcoronal.top := 0;
                      quirtviewerupdcoronal.left := quirtviewerupdtransversal.left + quirtviewerupdtransversal.width + 3;
                      quirtviewerupdcoronal.height := round(height * screenlayoutratio2);
                      quirtviewerupdcoronal.width  := width - quirtviewerupdtransversal.width - 15 - 6;
                      quirtviewerupdsagittal.top := quirtviewerupdcoronal.top + quirtviewerupdcoronal.height + 3;
                      quirtviewerupdsagittal.height := height - quirtviewerupdcoronal.height - 3;
                      quirtviewerupdsagittal.left   := quirtviewerupdtransversal.left + quirtviewerupdtransversal.width + 3;
                      quirtviewerupdsagittal.width  := width - quirtviewerupdtransversal.width - 15 - 6;
                    end
                    else if screenlayoutmode=4 then
                    begin
                      quirtviewerupdcoronal.left := 0;
                      quirtviewerupdcoronal.top    := 0;
                      quirtviewerupdcoronal.height := height;
                      quirtviewerupdcoronal.width  := round(width  * screenlayoutratio1);
                      quirtviewerupdtransversal.top := 0;
                      quirtviewerupdtransversal.left := quirtviewerupdcoronal.left + quirtviewerupdcoronal.width + 3;
                      quirtviewerupdtransversal.height := round(height * screenlayoutratio2);
                      quirtviewerupdtransversal.width  := width - quirtviewerupdcoronal.width - 15 - 6;
                      quirtviewerupdsagittal.top := quirtviewerupdtransversal.top + quirtviewerupdtransversal.height + 3;
                      quirtviewerupdsagittal.height := height - quirtviewerupdtransversal.height - 3;
                      quirtviewerupdsagittal.left   := quirtviewerupdcoronal.left + quirtviewerupdcoronal.width + 3;
                      quirtviewerupdsagittal.width  := width - quirtviewerupdcoronal.width - 15 - 6;
                    end
                    else if screenlayoutmode=5 then
                    begin
                      quirtviewerupdsagittal.left := 0;
                      quirtviewerupdsagittal.top    := 0;
                      quirtviewerupdsagittal.height := height;
                      quirtviewerupdsagittal.width  := round(width  * screenlayoutratio1);
                      quirtviewerupdtransversal.top := 0;
                      quirtviewerupdtransversal.left := quirtviewerupdsagittal.left + quirtviewerupdsagittal.width + 3;
                      quirtviewerupdtransversal.height := round(height * screenlayoutratio2);
                      quirtviewerupdtransversal.width  := width - quirtviewerupdsagittal.width - 15 - 6;
                      quirtviewerupdcoronal.top := quirtviewerupdtransversal.top + quirtviewerupdtransversal.height + 3;
                      quirtviewerupdcoronal.height := height - quirtviewerupdtransversal.height - 3;
                      quirtviewerupdcoronal.left   := quirtviewerupdsagittal.left + quirtviewerupdsagittal.width + 3;
                      quirtviewerupdcoronal.width  := width - quirtviewerupdsagittal.width - 15 - 6;
                    end;
                    quirtviewerupdcoronal.visible     := (quirtviewerupdcoronal.width\>10) and (quirtviewerupdcoronal.height\>10);
                    quirtviewerupdsagittal.visible    := (quirtviewerupdsagittal.width\>10) and (quirtviewerupdsagittal.height\>10);
                    quirtviewerupdtransversal.visible := (quirtviewerupdtransversal.width\>10) and (quirtviewerupdtransversal.height\>10);
                    quirtviewerupdcoronalpanchanged(self, 0, 0);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_330()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.formshow(sender: tobject);
                  var
                    i: integer;
                    activepageindex: integer;
                  begin
                    activepageindex := pagecontrol1.activepageindex;
                    for i := pagecontrol1.pagecount-1 downto 0 do
                      pagecontrol1.activepage := pagecontrol1.pages[i];
                    pagecontrol1.activepageindex := activepageindex;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_331()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonsummarizeclipclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_332()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttontestclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_333()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.freeall;
                  var i:integer;
                  begin
                    timer1.enabled := false;
                    if assigned(gquerylist) then
                    begin
                      for i:=0 to gquerylist.count-1 do
                        gquerylist.objects[i].free;
                      gquerylist.free;
                    end;
                    inifile.free;
                    caldirlist.free;
                    machine_to_machineadjust.free;
                    prevmachine_to_machineadjust.free;
                    machine_to_siddon.free;
                    cbctonline.free;
                    dtsonline.free;
                    cbctreference.free;
                    dtsreference.free;
                    for i:=1 to high(online)    do online[i].free;
                    for i:=1 to high(reference) do reference[i].free;
                    for i:=1 to high(dose)      do dose[i].free;
                    filteredrecords.free;
                    scanlist.free;
                    queryscanswhere.free;
                    vistransform4d2.free;
                    bonetumormatchlist.free;
                    convertcorexcllist.free;
                    for i := 1 to nclipbox do
                    begin
                      quirtviewerupdcoronal.clipboxtext[i].free;
                      quirtviewerupdcoronal.clipbox[i].free;
                    end;
                    cbnames.free;
                    m.free;
                    bad.free;
                    freeandnil(tabledbid);
                    freeandnil(tablepatients);
                    freeandnil(tableports);
                    freeandnil(tableprocedure);
                    freeandnil(tabletreatments);
                    freeandnil(queryscans);
                    freeandnil(queryframes);
                    freeandnil(queryoffsets);
                    freeandnil(queryscandetails);
                    freeandnil(queryframedetails);
                    freeandnil(queryoffsetframes);
                    freeandnil(queryimages);
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_334()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.copytoclipboard1click(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_335()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonmeasureinsertsclick(sender: tobject);
                  const
                    densarr: array[0..15] of integer = (-4, -3, -2, -1, 1, 2, 800, 900, 965, 1096, 1097, 1098, 1099, 1120, 1340, 1990);
                  var
                    tmpf: tavsfield;
                    tmpf2: tavsfield;
                    tmpf3: tavsfield;
                    cbct: tavsfield;
                    _mean, _mean2: single;
                    sres: string;
                    t, tcbct: ttransform;
                    i: integer;
                    fres: tavsfield;
                  begin
                    t := ttransform.create;
                    tcbct := ttransform.create;
                    tmpf := tavsfield.create;
                    tmpf2 := tavsfield.create;
                    tmpf3 := tavsfield.create;
                    cbct := tavsfield.create;
                    fres := tavsfield.create;
                    eulerxfm(t);
                    transform_math(t, reference_to_machine, t);
                    field_to_short(quirtviewerupdtransversal.field[2], tmpf);
                    field_to_short(quirtviewerupdtransversal.field[1], cbct);
                    t.invert;
                    eulerxfm(tcbct);
                    transform_math(tcbct, online_to_machine, tcbct);
                    transform_math(tcbct, machine_to_machineadjust, tcbct);
                    transform_math(tcbct, t, t);
                    fieldxfm(cbct, t, quirtviewerupdtransversal.field[2], cbct, 0, 0, fieldxfm_3dfield);
                    if queryscans.active then
                      sres := queryscans.fieldbyname(\'dbid\').asstring + #9 + memo1.lines[1] + #13#10;
                    field_create(fres, \'field 1d rectilinear double\', high(densarr)+1);
                    for i:=0 to high(densarr) do
                    begin
                      field_threshold(tmpf, tmpf3, densarr[i], densarr[i]);
                      field_autocrop(tmpf3, tmpf3);
                      field_ops(tmpf3, tmpf3, 3, field_ops_localmin);
                      _mean2 := tmpf3.mean;
                      field_croptogrid(cbct, tmpf3, tmpf2);
                      field_mask(tmpf2, tmpf3, tmpf2);
                      _mean := tmpf2.mean * 255.0 / _mean2;
                      sres := sres+ inttostr(i) + #9 + inttostr(densarr[i]) + #9 + floattostr(_mean) + #13#10;
                      fres.coordinate[0, i] := densarr[i];
                      fres.setvalue([i], _mean);
                    end;
                    nstats(fres, tmpf, nstats_regression, 0, 1);
                    sres := sres+ \'regression\' + #9 + floattostr(tmpf.getvalue([0,0])) + #9 + floattostr(tmpf.getvalue([0,1])) + #9 + floattostr(tmpf.getvalue([0,2])) + #13#10;
                    t.free;
                    tcbct.free;
                    tmpf.free;
                    tmpf2.free;
                    tmpf3.free;
                    cbct.free;
                    fres.free;
                    sres :=
                      format(\'%d ma, %d ms, %d kv\',
                      [
                        form1.scanma,
                        form1.scanms,
                        form1.scankv
                      ]) +  #13#10 + sres;
                    clipboard.astext := sres;
                    showmessage(message_copiedtexttoclpbrd + #13#10 + sres);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_336()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonidealcatphanasrefclick(sender: tobject);
                  var
                    i: integer;
                    ellipse: tavsfield;
                  begin
                    buttonclearreferenceclick(self);
                    referencedatachanged := true;
                    checkboxroi.checked := true;
                    menuclipboxlocked.checked := false;
                    referencecube.assign(onlinecube);
                    ellipse := tavsfield.create;
                    for i:=0 to referencecube.dimensions[0]-1 do
                    begin
                      field_slice(referencecube, ellipse, 0, -1, -1);
                      field_setc(ellipse, ellipse, 0);
                      if inrange(referencecube.coordinate[0, i], -9, 9) then
                        paint_elipse(ellipse, nil, ellipse, 0, 0, 0, 7.5, 7.5, 1, 1000);
                      if inrange(referencecube.coordinate[0, i], -3-1.25+0.05, -3+1.25-0.05) then
                      begin
                        paint_elipse(ellipse, nil, ellipse, 0,  5.8, 0, 0.6, 0.6, 1, 1);
                        paint_elipse(ellipse, nil, ellipse, 0, -5.8, 0, 0.6, 0.6, 1, 2);
                        paint_elipse(ellipse, nil, ellipse, -8,  8, 0, 0.6, 0.6, 1, -1);
                        paint_elipse(ellipse, nil, ellipse, -8, -8, 0, 0.6, 0.6, 1, -2);
                        paint_elipse(ellipse, nil, ellipse,  8, -8, 0, 0.6, 0.6, 1, -3);
                        paint_elipse(ellipse, nil, ellipse,  8,  8, 0, 0.6, 0.6, 1, -4);
                        paint_elipse(ellipse, nil, ellipse, -5.02294734,  2.9, 0, 0.6, 0.6, 1, 1096);
                        paint_elipse(ellipse, nil, ellipse, -5.02294734, -2.9, 0, 0.6, 0.6, 1, 1097);
                        paint_elipse(ellipse, nil, ellipse,  5.02294734,  2.9, 0, 0.6, 0.6, 1, 1098);
                        paint_elipse(ellipse, nil, ellipse,  5.02294734, -2.9, 0, 0.6, 0.6, 1, 1099);
                        paint_elipse(ellipse, nil, ellipse, -5.8, 0, 0, 0.6, 0.6, 1, 1340);
                        paint_elipse(ellipse, nil, ellipse,  5.8, 0, 0, 0.6, 0.6, 1, 900);
                        paint_elipse(ellipse, nil, ellipse,  2.9 , -5.02294734 , 0, 0.6, 0.6, 1, 965);
                        paint_elipse(ellipse, nil, ellipse,  2.9,  5.02294734, 0, 0.6, 0.6, 1, 800);
                        paint_elipse(ellipse, nil, ellipse, -2.9, -5.02294734, 0, 0.6, 0.6, 1, 1120);
                        paint_elipse(ellipse, nil, ellipse, -2.9,  5.02294734, 0, 0.6, 0.6, 1, 1990);
                      end;
                      field_inc_ndim(ellipse, ellipse);
                      field_transpose(ellipse, ellipse, 2);
                      field_insert(referencecube, ellipse, referencecube, i, 0, 0);
                    end;
                    reference_to_siddon.assign(online_to_machine);
                    reference_to_patient.assign(online_to_machine);
                    dosecube.clear;
                    doseaccu.clear;
                    dose_to_siddon.clear;
                    dose_to_machine.clear;
                    quirtviewerupdsagittal.level[2].value := quirtviewerupdsagittal.level[1].value-100;
                    quirtviewerupdsagittal.window[2].value := quirtviewerupdsagittal.window[1].value;
                    field_create(beamdots, \'field 1d 3-space irregular\', 1);
                    if synergymode then plansopuid := \'fake_\' + scanuid else treatmentuid := \'fake_\' + scanuid;
                    beamindex.clear;
                    buttonresetmatchclick(self);
                    if exportedscan = \'\' then
                      scanurl := \'xdr:\' + reconfilebase + scanuid + \'.scan\'
                    else
                      scanurl := exportedscan;
                    planurl := \'fake\';
                    beamurl := \'\';
                    doseurl := \'\';
                    clipbox[1].setvalue([0],-7.5);
                    clipbox[1].setvalue([1], 7.5);
                    clipbox[1].setvalue([2], 1.5);
                    clipbox[1].setvalue([3], 4.5);
                    clipbox[1].setvalue([4],-7.5);
                    clipbox[1].setvalue([5], 7.5);
                    if referenceoverlaystring\<\>\'\' then
                      quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + referenceoverlaystring
                    else
                      quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + ref_overlay + scandate;
                    eulerxfm(ellipse, 0, 0, 0, 0, -4, 0);
                    eulerxfm(machine_to_machineadjust, -180, 0, -180);
                    transform_math(ellipse, machine_to_machineadjust, machine_to_machineadjust);
                    ellipse.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_337()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.button2click(sender: tobject);
                  var i:integer;
                  begin
                    i := 1;
                    if quirtviewerupdcoronal.toolbar[i].empty then
                    begin
                      field_create(quirtviewerupdcoronal.toolbar[i], \'field 2d 3-vector byte\', quirtviewerupdcoronal.width-2, 40);
                      field_setc(quirtviewerupdcoronal.toolbar[i], quirtviewerupdcoronal.toolbar[i], 128);
                      field_text(quirtviewerupdcoronal.toolbar[i], nil, quirtviewerupdcoronal.toolbar[i], \'hallo\');
                      field_setc(quirtviewerupdcoronal.toolbarsel[i], quirtviewerupdcoronal.toolbarsel[i], -4);
                      quirtviewerupdcoronal.toolbarsel[i].locked := true;
                          quirtviewerupdcoronal.interpolatedzoom.value := 0;
                    end
                    else
                    begin
                      quirtviewerupdcoronal.toolbar[i].clear;
                      quirtviewerupdcoronal.toolbarsel[i].clear;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_338()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtngreenpurplecutclick(sender: tobject);
                  begin
                    if comboboxdisplaymode.itemindex=0 then comboboxdisplaymode.itemindex := 1
                    else comboboxdisplaymode.itemindex := 0;
                    checkboxscan.checked := true;
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_339()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnreflocclick(sender: tobject);
                  begin
                    if comboboxdisplaymode.itemindex=2 then comboboxdisplaymode.itemindex := 3
                    else comboboxdisplaymode.itemindex := 2;
                    checkboxscan.checked := true;
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_340()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnpresetlevelwindowsclick(sender: tobject);
                  begin
                    popupmenu2.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_341()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.changelevelorwindow(sender: tobject);
                  var i: integer;
                  begin
                    for i:=0 to popupmenu2.items.count-1 do
                      popupmenu2.items[i].checked := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_342()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.restore1click(sender: tobject);
                  var l, h:integer;
                      brecall: boolean;
                  begin
                    l := 0;
                    h := 0;
                    brecall := false;
                    quirtviewerupdcoronal.level[1].onchanged := changelevelorwindow;
                    quirtviewerupdcoronal.window[1].onchanged := changelevelorwindow;
                    quirtviewerupdcoronal.level[2].onchanged := changelevelorwindow;
                    quirtviewerupdcoronal.window[2].onchanged := changelevelorwindow;
                    case (sender as tmenuitem).menuindex of
                      0:  begin l:=0;   h:=0;   end;
                      1:  begin l:=30;  h:=170; end;
                      2:  begin l:=60;  h:=140; end;
                      3:  begin l:=80;  h:=120; end;
                      4:  begin l:=0;   h:=140; end;
                      6:  begin
                            online[1].window.maximum := 2000;
                            online[1].window.minimum := 0;
                            reference[1].window.maximum := 2000;
                            reference[1].window.minimum := 0;
                            online[1].level.maximum := 2000;
                            online[1].level.minimum := -2000;
                            reference[1].level.maximum := 2000;
                            reference[1].level.minimum := -2000;
                            online[1].level.value := levels[0];
                            online[1].window.value := levels[1];
                            reference[1].level.value := levels[2];
                            reference[1].window.value := levels[3];
                            brecall := true;
                           end;
                    end;
                    if not brecall then
                    begin
                      quirtviewerupdcoronal.blw(1, l, h);
                      quirtviewerupdcoronal.blw(2, l, h);
                      timer1timer(self);
                    end;
                    (sender as tmenuitem).checked := true;
                    popupmenu2.popup(
                      thackpopupmenu(popupmenu2).popuppoint.x,
                      thackpopupmenu(popupmenu2).popuppoint.y);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_343()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.copyclipbox1;
                  var t: tavsfield;
                  begin
                    t := tavsfield.create;
                    if transform4d.empty then
                      externalmanualmatchto4d(-1, 0);
                    field_slice(transform4d, t, -1, -1, 0, 0);
                    if t.getvalue([3,3])\>0.99 then
                    begin
                      field_copy(t, machine_to_machineadjust);
                      externalmanualmatchto4d(-1, nclipbox);
                    end;
                    t.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_344()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.tabcontrol1change(sender: tobject);
                  begin
                    if assigned(activecontrol) and assigned(activecontrol.parent) and
                      ((activecontrol.parent=paneltranslation) or
                       (activecontrol.parent=panelrotation)) then
                    begin
                      activecontrol := nil;
                      timer1timer(nil);
                    end;
                    reversemotion.value := 0;
                      case 10 * comboboxregistrationprotocol.itemindex + tabcontrol1.tabindex of
                         0: alignmentmode.value := 0;
                                1:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                         2: alignmentmode.value := 4;
                        10: alignmentmode.value := 1;
                        11:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                        12: alignmentmode.value := 4;
                        20: alignmentmode.value := 0;
                        21: alignmentmode.value := 1;
                        22:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                        23: alignmentmode.value := 4;
                        30: alignmentmode.value := 0;
                        31: alignmentmode.value := 1;
                        32:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                        33: alignmentmode.value := 4;
                        40: alignmentmode.value := 0;
                        41:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                        42: alignmentmode.value := 4;
                        50: alignmentmode.value := 1;
                        51:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                        52: alignmentmode.value := 4;
                      end;
                    if (alignmentmode.value=4) and assigned(colorstringgridsummaryupd) then
                      colorstringgridsummaryupd.forceupdate;
                    memomaskclipboxdifference.lines.text := memo_nkidoubleclick;
                    manualmatchactive := false;
                    if not quirtviewerupdcoronal.toolbar[1].empty then
                    begin
                      buttonlimitinformationclick(self);
                      buttonlimitinformationclick(self);
                    end;
                    comboboxsummarytype.items.clear;
                    comboboxsummarytype.items.add(summary_current);
                    if online[1].data.ndim\>3 then comboboxsummarytype.items.add(summary_details);
                    comboboxsummarytype.items.add(summary_residuals);
                    if comboboxregistrationprotocol.itemindex\>1 then comboboxsummarytype.items.add(summary_limits);
                    comboboxsummarytype.itemindex := 0;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_345()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.tabcontrol1changing(sender: tobject;
                    var allowchange: boolean);
                  begin
                    allowchange := true;
                    if matchinprogress then allowchange := false;
                    if match2inprogress then allowchange := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_346()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonnextstepclick(sender: tobject);
                  var tx1, ty1, tz1, tx2, ty2, tz2, rx1, ry1, rz1, rx2, ry2, rz2, dum: string;
                  var limits1, limits2: integer;
                  var i: integer;
                  begin
                    manualmatchactive := false;
                    reversemotion.value := 0;
                    if (alignmentmode.value=0) and
                       ((comboboxregistrationprotocol.itemindex=2) or (comboboxregistrationprotocol.itemindex=3)) then
                      centerofmask1click(self)
                    else if (alignmentmode.value=2) then
                    begin
                      if inputquery(signature_dlg, initials_dlg, dum) then
                      begin
                        if (dum=\'\') or (dum[1]=\'\'\'\') or (dum[1]=\'\"\')then
                        begin
                          repeat
                            if not inputquery(signature_dlg, initials_dlg, dum) then
                            begin
                              reversemotion.value := 0;
                              exit;
                            end;
                          until (dum\<\>\'\') and (dum[1]\<\>\'\'\'\') and (dum[1]\<\>\'\"\');
                        end;
                        if not compareregistrationbackup(2*nclipbox, 3*nclipbox-1) or transform4d.empty then
                          externalconverttocorrection;
                        alignmentmode.value := 3;
                        if (correctionapprovalby = \'\') or (correctionapprovalby = \'*\') then
                          correctionapprovalby := dum
                        else
                          correctionapprovalby := correctionapprovalby + \' + \' + dum;
                        makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999);
                      reversemotion.value := 0;
                      end;
                      for i:=1 to 6 do
                        colorstringgrid1.cellprops[3,i].box.checked := false;
                      exit;
                    end;
                    case 10 * comboboxregistrationprotocol.itemindex + tabcontrol1.tabindex of
                         0: begin tabcontrol1.tabindex := 1; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                        10: begin tabcontrol1.tabindex := 1; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                        20: begin tabcontrol1.tabindex := 1; alignmentmode.value := 1; copyclipbox1; makeregistrationbackup(nclipbox, 2*nclipbox-1, 0, 9999); invalidatecorrection; end;
                        21: begin tabcontrol1.tabindex := 2; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                    30: begin tabcontrol1.tabindex := 2; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                    40: begin tabcontrol1.tabindex := 1; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                        50: begin tabcontrol1.tabindex := 1; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                      end;
                    if alignmentmode.value=2 then
                    begin
                      showmessage(warning_reviewcorrection);
                      if (comboboxcorrectionprotocol.text = correction_from_clipbox) then trackbarweight.position := 0
                      else trackbarweight.position := 10;
                      limits1 := unpackregistration(-4,        -1, tx1, ty1, tz1, rx1, ry1, rz1, dum, false, true, false);
                      limits2 := unpackregistration(nclipbox, -5, tx2, ty2, tz2, rx2, ry2, rz2, dum, false, true, false);
                      colorstringgrid1.cellprops[3,1].box.checked :=
                             ((limits1 and $003) or (limits2 and $003))\<\>0;
                      colorstringgrid1.cellprops[3,2].box.checked :=
                             ((limits1 and $00c) or (limits2 and $00c))\<\>0;
                      colorstringgrid1.cellprops[3,3].box.checked :=
                             ((limits1 and $030) or (limits2 and $030))\<\>0;
                      if correctionbyhexapod then
                      begin
                        colorstringgrid1.cellprops[3,4].box.checked :=
                             ((limits1 and $0c0) or (limits2 and $0c0))\<\>0;
                        colorstringgrid1.cellprops[3,5].box.checked :=
                             ((limits1 and $300) or (limits2 and $300))\<\>0;
                        colorstringgrid1.cellprops[3,6].box.checked :=
                             ((limits1 and $c00) or (limits2 and $c00))\<\>0;
                      end
                      else
                      begin
                        colorstringgrid1.cellprops[3,4].box.checked := false;
                        colorstringgrid1.cellprops[3,5].box.checked := false;
                        colorstringgrid1.cellprops[3,6].box.checked := false;
                      end;
                    end;
                    reversemotion.value := 0;
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_347()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtndismisscorrectionclick(sender: tobject);
                  begin
                    alignmentmode.value := 2;
                    correctionapprovalby := \'\';
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_348()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.comboboxregistrationprotocolchange(sender: tobject);
                  var x: tavsfield;
                      i: integer;
                  begin
                         if (comboboxregistrationprotocol.itemindex=0) and (alignmentmode.value=1) then alignmentmode.value:=0
                    else if (comboboxregistrationprotocol.itemindex=1) and (alignmentmode.value=0) then alignmentmode.value:=1
                    else if (comboboxregistrationprotocol.itemindex=2) and (alignmentmode.value=1) then alignmentmode.value:=0
                    else if (comboboxregistrationprotocol.itemindex=3) and (alignmentmode.value=1) then alignmentmode.value:=0
                    else if (comboboxregistrationprotocol.itemindex=4) and (alignmentmode.value=1) then alignmentmode.value:=0
                    else if (comboboxregistrationprotocol.itemindex=5) and (alignmentmode.value=0) then alignmentmode.value:=1;
                    preparetabs(sender) ;
                    i := comboboxcorrectionprotocol.itemindex;
                    comboboxcorrectionprotocol.clear;
                    if (comboboxregistrationprotocol.itemindex in [0,3,4]) then
                      comboboxcorrectionprotocol.add(correction_from_clipbox, [\'clipbox\', \'clipbox registration\']);
                    if (comboboxregistrationprotocol.itemindex in [1,2,5]) then
                    begin
                      comboboxcorrectionprotocol.add(correction_from_mask_mean, [\'mask (mean if 4d)\']);
                      if not reference[1].data.empty then
                      begin
                        x := tavsfield.create;
                        transform_math(reference[1].topatient, reference[1].tosiddon, x, true);
                        if x.getvalue([1,1])\>0 then
                        begin
                          comboboxcorrectionprotocol.add(correction_from_mask_exh, [\'mask (exhale if 4d)\']);
                          comboboxcorrectionprotocol.hint :=
                            combobox_comboboxcorrectionprotocol_hint;
                        end
                        else
                          comboboxcorrectionprotocol.hint :=
                            combobox_comboboxcorrectionprotocol_hint + #10 +
                            combobox_comboboxcorrectionprotocol_hint2;
                        x.free;
                      end
                      else
                        comboboxcorrectionprotocol.add(correction_from_mask_exh, [\'mask (exhale if 4d)\']);
                    end;
                    if (i\>=0) and (i\<comboboxcorrectionprotocol.items.count) then
                      comboboxcorrectionprotocol.itemindex := i
                    else
                      comboboxcorrectionprotocol.itemindex := 0;
                    tabcontrol1change(self);
                    buttonresetmatchclick(self);
                    referencedatachanged := true;
                    if assigned(sender) then
                    begin
                      if comboboxregistrationprotocol.itemindex \<\> 1 then
                        checkboxroi.checked := true;
                      if comboboxregistrationprotocol.itemindex \<\> 0 then
                        checkboxreferencemask.checked := true;
                      if comboboxregistrationprotocol.itemindex = 1 then
                        checkboxroi.checked := false;
                      if comboboxregistrationprotocol.itemindex = 0 then
                        checkboxreferencemask.checked := false;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_349()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.comboboxcorrectionprotocolchange(sender: tobject);
                  begin
                    invalidatecorrection;
                   if assigned(colorstringgridsummaryupd) then colorstringgridsummaryupd.forceupdate;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_350()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.comboboxcorrectionbychange(sender: tobject);
                  begin
                    invalidatecorrection;
                    correctionbyhexapod := comboboxcorrectionby.itemindex =
                      comboboxcorrectionby.indexofmapped(nameof6dsystemmappedtext);
                    preparetabs(sender);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_351()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.preparetabs(sender: tobject) ;
                  begin
                      if onlinecube.empty or (onlinecube.veclen=0) then
                      begin
                        case comboboxregistrationprotocol.itemindex of
                          0: tabcontrol1.tabs.commatext := tab_regclip;
                          1: tabcontrol1.tabs.commatext := tab_regmask;
                          2: tabcontrol1.tabs.commatext := tab_regclip+\',\'+tab_regmask;
                          3: tabcontrol1.tabs.commatext := tab_regclip+\',\'+tab_regmask;
                          4: tabcontrol1.tabs.commatext := tab_regclip;
                          5: tabcontrol1.tabs.commatext := tab_regmask;
                        end;
                      end
                      else
                      begin
                        tabcontrol1.tabwidth := 120 ;
                        case comboboxregistrationprotocol.itemindex of
                          0: tabcontrol1.tabs.commatext := tab_regclip+\',\'+tab_correction+\',\'+tab_overview;
                          1: tabcontrol1.tabs.commatext := tab_regmask+\',\'+tab_correction+\',\'+tab_overview;
                          2, 3: tabcontrol1.tabs.commatext := tab_regclip+\',\'+tab_regmask+\',\'+tab_correction+\',\'+tab_overview;
                          4: tabcontrol1.tabs.commatext := tab_regclip+\',\'+tab_correction+\',\'+tab_overview;
                          5: tabcontrol1.tabs.commatext := tab_regmask+\',\'+tab_correction+\',\'+tab_overview;
                        end;
                      end;
                      tabcontrol1change(sender);
                        end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_352()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updownroismouseup(sender: tobject; button: tmousebutton;
                    shift: tshiftstate; x, y: integer);
                  begin
                    updownroisupdate;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_353()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.updownroisupdate;
                  var
                    save : boolean;
                  begin
                    save := quirtviewerupdcoronal.activeclipbox.locked;
                    quirtviewerupdcoronal.activeclipbox.locked := save;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_354()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonmatch2click(sender: tobject);
                  var style, r, r1, r2, f, f1, f2: integer;
                      s: string;
                      save: tavsfield;
                      id : ttransform;
                      matchmode: tmatchmode;
                  begin
                    timer4d.enabled := false;
                    reversemotion.value := 0;
                    if match2inprogress then
                    begin
                      if assigned(m) then m.stop;
                      match2inprogress := false;
                      exit;
                    end;
                    save := tavsfield.create;
                    field_copy(machine_to_machineadjust, save);
                    if alignmentmode.value=0 then
                    begin
                      if radiobuttonallrois.checked then
                      begin
                        r1 := 0;
                        r2 := nclipbox-1;
                        activeregion.value := 0;
                      end
                      else
                      begin
                        r1 := activeregion.value;
                        r2 := activeregion.value;
                        activeregion.value := 0;
                      end;
                      s := comboboxclipboxmatch.mappedtext;
                      end
                    else
                    begin
                          if maskedreference.empty then
                      begin
                        showmessage(mask_error);
                        save.free;
                        exit;
                      end;
                      s := comboboxmaskmatch.mappedtext;
                      r1 := nclipbox;
                      r2 := nclipbox;
                      if editmask.checked then editmaskclick(self);
                      id := ttransform.create;
                      id.makeidentity;
                      if machine_to_machineadjust.equals(id) then
                      begin
                        centerofmask1click(self);
                        timer1timer(self);
                      end;
                      id.free;
                    end;
                    if (pos(match_substring_4d, s)\>0) and (onlinecube.ndim=3) then
                    begin
                      showmessage(warning_4dtoolon3ddata);
                    end;
                    buttonmatch2.caption := stopmatch_caption;
                    match2inprogress := true;
                    invalidatecorrection;
                    panelcontrol4d.enabled := false;
                    page1.enabled := false;
                    screen.cursor := crhourglass;
                    id := ttransform.create;
                    id.makeidentity;
                    for r:=r1 to r2 do
                    begin
                      if r\<nclipbox then
                      begin
                        if clipbox[r+1].empty then continue;
                        quirtviewerupdcoronal.activeclipbox.value := r+1;
                        updownrois.position := r;
                        activeregion.value := r;
                        labelrois.caption := \'\';
                        field_copy(save, machine_to_machineadjust);
                        if machine_to_machineadjust.equals(id) then
                          centerofclipbox1click(self);
                      end;
                      if alignmentmode.value=0 then
                        s := comboboxclipboxmatch.mappedtext
                      else
                        s := comboboxmaskmatch.mappedtext;
                        if radiobuttonallframes.checked and (pos(match_substring_4d, s)\>0) then
                      begin
                        f1 := 0;
                        f2 := max(online[1].data.dimensions[3]-1, 0);
                      end
                      else if pos(match_substring_4d, s)\>0 then
                      begin
                        f1 := quirtviewerupdcoronal.frame.value;
                        f2 := quirtviewerupdcoronal.frame.value;
                      end
                      else
                      begin
                        f1 := -1;
                        f2 := -1;
                      end;
                      if pos(match_substring_t , s)\>0 then
                        style := 0
                      else if pos(match_substring_prerot, s)\>0 then
                        style := 2
                      else if pos(match_substring_r , s)\>0 then
                        style := 3
                      else
                       style := 1;
                      if (pos(match_substring_bone, s)\>0) or
                         (pos(match_substring_seed, s)\>0) then
                        matchmode := mmchamfer
                      else
                        matchmode := mmgreyvalue;
                      progressbar3.position := 0;
                      for f:=f1 to f2 do
                      begin
                        progressoffset := (f-f1) * progressbar3.max / (1+f2-f1);
                        progressscale := 1 / (1+f2-f1);
                        quirtviewerupdcoronal.frame.value := f;
                        externalmatch(r, f, matchmode, style);
                        if not match2inprogress then break;
                      end;
                      if not match2inprogress then break;
                    end;
                    id.free;
                    screen.cursor := crdefault;
                    progressoffset := 0;
                    progressscale := 1;
                    progressbar3.position := 0;
                    buttonmatch2.caption := startmatch_caption;
                    match2inprogress := false;
                    panelcontrol4d.enabled := true;
                    page1.enabled := true;
                    if alignmentmode.value=0 then
                      appliedclipboxmatchmethod := s
                    else if alignmentmode.value=1 then
                      appliedmaskmatchmethod := s;
                    if radiobuttonallrois.checked then
                    begin
                      activeregion.value := 0;
                      updownrois.position := 0;
                    end;
                    if pos(match_substring_4d, s)\>0 then
                    begin
                      if alignmentmode.value=0 then
                        centerofclipbox1click(nil)
                      else
                        visitcenterofmask;
                      buttonplay4dclick(bitbtnplaygreen);
                    end;
                    save.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_355()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonmarkersclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenumarkers.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_356()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.showmarkertoolclick(sender: tobject);
                  begin
                    showmarkertool.checked := not showmarkertool.checked;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_357()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.savereferencemarkerlistclick(sender: tobject);
                  var
                    dir               : string;
                  begin
                    if quirtviewerupdcoronal.polydots[6].empty then exit;
                    if quirtviewerupdcoronal.polydots[6].dimensions[0]=0 then exit;
                    dir := cachefilebase;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_358()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.loadreferencemarkersclick(sender: tobject);
                  var
                   dir, filename, uid : string;
                  begin
                    dir := cachefilebase;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    filename := dir + \'\\\' +uid + \'.xvi\';
                    if not fileexists(filename) then
                    begin
                      showmessage(\'cannot find xvi inifile...\');
                      exit;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_359()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.saveonlinemarkersclick(sender: tobject);
                  var
                   dir             : string;
                  begin
                    if quirtviewerupdcoronal.polydots[7].empty then exit;
                    if quirtviewerupdcoronal.polydots[7].dimensions[0]=0 then exit;
                    dir := cachefilebase;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_360()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.loadonlinemarkersclick(sender: tobject);
                  var
                   dir, filename, uid : string;
                  begin
                   dir := cachefilebase;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    filename := dir + \'\\\' +uid + \'.xvi\';
                    if not fileexists(filename) then
                    begin
                      showmessage(\'cannot find xvi inifile...\');
                      exit;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_361()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.formdestroy(sender: tobject);
                  begin
                    destroyhintlist;
                    freeall;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_362()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.memomaskclipboxdifferencedblclick(sender: tobject);
                  begin
                    if memomaskclipboxdifference.lines[0]=memodiff_double then
                      memomaskclipboxdifference.lines.text := \'\'
                    else
                      memomaskclipboxdifference.lines.text := memodiff_info;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_363()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.trackbarweightchange(sender: tobject);
                  begin
                    weightedconverttocorrection(trackbarweight.position / trackbarweight.max);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_364()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnunlockprotocolclick(sender: tobject);
                  begin
                    if bitbtnunlockprotocol.tag=0 then
                    begin
                      bitbtnunlockprotocol.glyph := bitbtnunlock.glyph;
                      bitbtnunlockprotocol.tag := 1;
                    end
                    else
                    begin
                      bitbtnunlockprotocol.glyph := bitbtnlock.glyph;
                      bitbtnunlockprotocol.tag := 0;
                      referencedatachanged := false;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_365()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.importdose1click(sender: tobject);
                  begin
                    buttonsetdoseclick(buttonsetdose);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_366()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.exportraw3d1click(sender: tobject);
                  begin
                    quirtviewerupdcoronal.frame.value := -1;
                    buttonexportclick(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_367()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.exportraw4d1click(sender: tobject);
                  begin
                    quirtviewerupdcoronal.frame.value := 0;
                    buttonexportclick(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_368()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.shiftscan1click(sender: tobject);
                  var s: string;
                      x: single;
                  begin
                    s := inputbox(\'enter longitudonal shift\', \'shift (cm)\', \'0\');
                    x := safestrtofloat(s);
                    if x\<\>0 then
                    begin
                      field_shift(onlinecube, x, 0, 0);
                      onlinecube.hasnewvalue;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_369()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.copy1click(sender: tobject);
                  begin
                    write_xdr(onlinecube, cachefilebase + treatmentuid + \'.clipboard\', \'\', \'\', 2);
                    showmessage(message_copiedscantoclipbrd);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_370()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.pasteasreference1click(sender: tobject);
                  begin
                    if not fileexists(cachefilebase + treatmentuid + \'.clipboard\') then
                    begin
                      showmessage(warning_nothingtopaste);
                      exit;
                    end;
                    buttonclearreferenceclick(self);
                    referencedatachanged := true;
                    checkboxroi.checked := true;
                    menuclipboxlocked.checked := false;
                    read_xdr(referencecube, cachefilebase + treatmentuid + \'.clipboard\');
                    reference_to_siddon.assign(online_to_machine);
                    reference_to_patient.assign(online_to_machine);
                    dosecube.clear;
                    doseaccu.clear;
                    dose_to_siddon.clear;
                    dose_to_machine.clear;
                    quirtviewerupdsagittal.level[2].value := quirtviewerupdsagittal.level[1].value-100;
                    quirtviewerupdsagittal.window[2].value := quirtviewerupdsagittal.window[1].value;
                    field_create(beamdots, \'field 1d 3-space irregular\', 1);
                    if synergymode then plansopuid := \'fake_\' + scanuid else treatmentuid := \'fake_\' + scanuid;
                    beamindex.clear;
                    buttonresetmatchclick(self);
                    showmessage(toref_warn2);
                    scanurl := research_clipurl;
                    planurl := \'fake\';
                    beamurl := \'\';
                    doseurl := \'\';
                    referenceoverlaystring := research_clipurl;
                    quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + referenceoverlaystring;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_371()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.pastetostitch1click(sender: tobject);
                  var s, t: tavsfield;
                  begin
                    if not fileexists(cachefilebase + treatmentuid + \'.clipboard\') then
                    begin
                      showmessage(warning_nothingtopaste);
                      exit;
                    end;
                    s := tavsfield.create;
                    t := tavsfield.create;
                    read_xdr(s, cachefilebase + treatmentuid + \'.clipboard\');
                    if (s.ndim=4) or (onlinecube.ndim=4) then
                    begin
                      showmessage(error_no4dstitch);
                    end
                    else
                    begin
                      extents_grid2(onlinecube, s, nil, nil, t, onlinecube.coordinate[0, 1]-onlinecube.coordinate[0, 0]);
                      fieldxfm(s, nil, t, s, 0, 0, fieldxfm_3dfield);
                      fieldxfm(onlinecube, nil, t, onlinecube, 0, 0, fieldxfm_3dfield);
                      field_max(s, onlinecube, onlinecube);
                    end;
                    s.free;
                    t.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_372()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.exit1click(sender: tobject);
                  begin
                    buttonelektadismissclick(buttonelektadismiss);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_373()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.imageguidance1click(sender: tobject);
                  begin
                    pagecontrol1.activepageindex := 2;
                    pagecontrol1change(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_374()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.dbase1click(sender: tobject);
                  begin
                    pagecontrol1.activepageindex := 0;
                    pagecontrol1change(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_375()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.imageselection1click(sender: tobject);
                  begin
                    pagecontrol1.activepageindex := 1;
                    pagecontrol1change(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_376()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.clipbox1click(sender: tobject);
                  begin
                    tabcontrol1.tabindex := 0;
                    tabcontrol1change(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_377()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.clipbox2refmark1click(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_378()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.reg2onlinemark1click(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_379()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.mask1click(sender: tobject);
                  begin
                    if comboboxregistrationprotocol.itemindex=2 then
                      tabcontrol1.tabindex := 1
                    else
                      tabcontrol1.tabindex := 0;
                    tabcontrol1change(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_380()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.correction1click(sender: tobject);
                  begin
                    if comboboxregistrationprotocol.itemindex in [2,3] then
                      tabcontrol1.tabindex := 2
                    else
                      tabcontrol1.tabindex := 1;
                    tabcontrol1change(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_381()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.overview1click(sender: tobject);
                  begin
                    if comboboxregistrationprotocol.itemindex in [2,3] then
                      tabcontrol1.tabindex := 3
                    else
                      tabcontrol1.tabindex := 2;
                    tabcontrol1change(self);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_382()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure writescan(f: tavsfield; dir, name, patid: string);
                  var xfm: tavsfield;
                  begin
                    xfm := tavsfield.create;
                    eulerxfm(xfm);
                    if form1.datatype=\'dicom\' then
                    else if form1.datatype=\'pinnacle\' then
                      write_pin_scan(f, dir, patid + \' \' + name, \'hfs\', strtointdef(name, 9999));
                    xfm.free;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_383()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.exportmatched3d1click(sender: tobject);
                  begin
                    quirtviewerupdcoronal.frame.value := -1;
                    exportmatched4d1click(nil);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_384()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.exportmatched4d1click(sender: tobject);
                  var url, t, filename, f, name, patid: string;
                      i, j, k: integer;
                      machinetosiddon, x, tmp: tavsfield;
                      ini: tinifile;
                  begin
                    if assigned(sender) then
                      quirtviewerupdcoronal.frame.value := 0;
                    if datatype\<\>\'dicom\' then
                    begin
                      if doseurl=\'\' then
                      begin
                        buttonclinicalpatientclick(nil);
                        url := patienturl;
                        url := treeselector(url, \'beam\');
                        if url=\'\' then exit;
                      end
                      else
                        url := doseurl;
                      patienturl := copy(url, 1, pos(\'.patient\', url)+8);
                      j := 0;
                      for i:=1 to length(patienturl) do
                        if patienturl[i]=\':\' then j:=i;
                      patienturl := copy(patienturl,1,j-1);
                      if (pos(\'.scan\', url)\>=1) and not reference[1].properties.empty then
                        t := copy(url, 1, pos(\'.scan\', url)+4)
                      else
                        t := treeselector(patienturl, \'scan\');
                      if t=\'\' then exit;
                    end;
                    filename := datapath + copy(patienturl, 7, 250);
                    if datatype\<\>\'dicom\' then
                    begin
                      if not sysutils.directoryexists(filename) then
                      begin
                        showmessage(clinical_warning);
                        exit;
                      end;
                      f    := filename;
                      name := \'\';
                      if not inputquery(pinname_query, scan_prompt, name) then exit;
                      if length(name)=0 then exit;
                    end
                    else
                    begin
                      name := tempdir+\'test%04d\';
                      if not inputquery(\'dicom file name base\', \'scan: \', name) then exit;
                      if length(name)=0 then exit;
                    end;
                    ini := tqinifile.create(getfullinifilename(\'datasources.ini\'));
                    datasource := ini.readstring(\'xvi\', \'device\', \'\');
                    ini.free;
                    i := pos(\':\', datasource);
                    if i\>0 then
                    begin
                      datatype := uppercase(copy(datasource, 1, i-1));
                      datapath := copy(datasource, i+1, 250);
                      if datapath[length(datapath)]\<\>\'\\\' then datapath := datapath + \'\\\';
                    end;
                    if datatype\<\>\'dicom\' then
                    begin
                      treereader(online[4].data, t, \'\');
                      treereader(online[4].tosiddon,  t, \'worldxfm\');
                      treereader(online[4].properties, t, \'all\');
                      if pos(\'.dose\', url)\>0 then
                      begin
                        j := 0;
                        for i:=1 to length(url) do
                          if url[i]=\'\\\' then j:=i;
                        url := copy(url,1,j)+\'1.beam\';
                      end;
                    machinetosiddon := tavsfield.create;
                      treereader(machinetosiddon, url, \'worldxfm\');
                      for i:=0 to 2 do
                        for j:=0 to 2 do
                          if i=j then machinetosiddon.setvalue([i,j], 1)
                          else        machinetosiddon.setvalue([i,j], 0);
                      transform_math(online[4].tosiddon, machinetosiddon, online[4].tomachine, false, true);
                      transform_math(online[4].tomachine, machine_to_siddon, online[4].tosiddon, false, false);
                      machinetosiddon.free;
                    end;
                    x := tavsfield.create;
                    tmp := tavsfield.create;
                    if transform4d.empty then
                      field_copy(machine_to_machineadjust, x)
                    else
                      field_slice(transform4d, x, -1, -1, nclipbox*2, 0);
                    if x.getvalue([3,3])\<0.95 then eulerxfm(x);
                    transform_math(online_to_machine, x, x);
                    if datatype\<\>\'dicom\' then
                      transform_math(x, online[4].tomachine, x, false, true)
                    else
                      transform_math(x, reference[1].tomachine, x, false, true);
                    if (onlinecube.ndim=4) and (sender\<\>nil) then
                    begin
                      for k:=0 to onlinecube.dimensions[3]-1 do
                      begin
                        field_slice(onlinecube, tmp, -1, -1, -1, k);
                        if datatype\<\>\'dicom\' then
                        begin
                          fieldxfm(tmp, x, online[4].data, tmp, 0, 0, fieldxfm_3dfield);
                          yzx_to_xyz(tmp, tmp);
                        end
                        else
                        begin
                          fieldxfm(tmp, x, reference[1].data, tmp, 0, 0, fieldxfm_3dfield);
                          field_resize(tmp, tmp, 2, 2);
                          if tmp.coordinate[0,0]\<tmp.coordinate[0,1] then modify_extents(tmp, tmp, -1);
                          if tmp.coordinate[1,0]\>tmp.coordinate[1,1] then modify_extents(tmp, tmp, 1, -1);
                        end;
                        if tmp.datasize\<\>2 then field_to_short(tmp, tmp);
                        field_maxc(tmp, tmp, 0);
                        j := pos(\':\', patienturl);
                        patid := copy(patienturl, j+1, 250);
                        writescan(tmp, f, name + \'.\' + inttostr(k), patid);
                        if datatype\<\>\'dicom\' then
                          name := inttostr(strtointdef(name, 9999)+1);
                      end
                    end
                    else
                    begin
                      if (onlinecube.ndim=4) and (sender=nil) then
                      begin
                        field_ortho_average(onlinecube, tmp, field_ortho_average_udirection);
                        showmessage(scan_saved_avg);
                      end;
                      if datatype\<\>\'dicom\' then
                      begin
                        fieldxfm(tmp, x, online[4].data, tmp, 0, 0, fieldxfm_3dfield);
                        yzx_to_xyz(tmp, tmp);
                      end
                      else
                      begin
                        fieldxfm(tmp, x, reference[1].data, tmp, 0, 0, fieldxfm_3dfield);
                        if tmp.coordinate[0,0]\<tmp.coordinate[0,1] then modify_extents(tmp, tmp, -1);
                        if tmp.coordinate[1,0]\>tmp.coordinate[1,1] then modify_extents(tmp, tmp, 1, -1);
                      end;
                      if tmp.datasize\<\>2 then field_to_short(tmp, tmp);
                      field_maxc(tmp, tmp, 0);
                      j := pos(\':\', patienturl);
                      patid := copy(patienturl, j+1, 250);
                      writescan(tmp, f, name, patid);
                      showmessage(scan_saved_pin + name);
                    end;
                    x.free;
                    tmp.free;
                    online[4].clear;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_385()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.colorstringgrid3setedittext(sender: tobject; acol,
                    arow: integer; const value: string);
                  var g: tcolorstringgrid;
                  begin
                    g := sender as tcolorstringgrid;
                    boxclick(g.cellprops[1,0].box);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_386()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.colorstringgrid3exit(sender: tobject);
                  var g: tcolorstringgrid;
                      arow : integer;
                  begin
                    g := sender as tcolorstringgrid;
                    for arow := 1 to 3 do
                    begin
                      g.cells[1,arow] := format(\'%.1f\', [-abs(0.001+safestrtofloat(g.cells[1,arow]))]);
                      g.cells[2,arow] := format(\'%.1f\', [abs(0.001+safestrtofloat(g.cells[2,arow]))]);
                    end;
                    for arow := 5 to 7 do
                    begin
                      g.cells[1,arow] := format(\'%.1f\', [-min(abs(0.001+safestrtofloat(g.cells[1,arow])),180)]);
                      g.cells[2,arow] := format(\'%.1f\', [min(abs(0.001+safestrtofloat(g.cells[2,arow])),180)]);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_387()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.colorstringgrid3enter(sender: tobject);
                  var g: tcolorstringgrid;
                  begin
                    g := sender as tcolorstringgrid;
                    g.onselectcell := nil;
                    g.row := 1;
                    if g.cellprops[1,0].box.checked then g.col := 2 else g.col := 1;
                    g.onselectcell := colorstringgrid3selectcell;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_388()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.colorstringgrid3selectcell(sender: tobject; acol,
                    arow: integer; var canselect: boolean);
                  var g: tcolorstringgrid;
                  begin
                     g := sender as tcolorstringgrid;
                     if arow in [0, 4] then g.options := g.options - [goediting];
                     if (arow in [1, 5]) and (acol in [2]) then
                       g.options := g.options + [goediting]
                     else
                     begin
                       g.options := g.options - [goediting];
                       if not g.cellprops[1,0].box.checked then
                         if (arow in [1,2,3]) and (acol in [1,2]) then g.options := g.options + [goediting];
                       if not g.cellprops[1,4].box.checked then
                         if (arow in [5,6,7]) and (acol in [1,2]) then g.options := g.options + [goediting];
                    end;
                    if not (goediting in g.options) then
                      canselect := false;
                    if (arow=2) and (acol=1) and not (goediting in g.options) then
                    begin
                      g.row := 5;
                      g.col := 1 + ord(g.cellprops[1,4].box.checked);
                    end;
                    if (arow=6) and (acol=1) and not (goediting in g.options) then
                    begin
                      if g.cellprops[1,4].box.checked then
                      begin
                        g.row := 1;
                        g.col := 1 + ord(g.cellprops[1,0].box.checked);
                      end;
                    end;
                    if (arow=4) and (acol=1) and not (goediting in g.options) then
                    begin
                      g.row := 5;
                      g.col := 1 + ord(g.cellprops[1,4].box.checked);
                    end;
                    if (arow=0) and (acol=1) and not (goediting in g.options) then
                    begin
                      g.row := 1;
                      g.col := 1 + ord(g.cellprops[1,4].box.checked);
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_389()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.boxclick(sender: tobject);
                  var g: tcolorstringgrid;
                      i: integer;
                  begin
                    g := ((sender as tcheckbox).parent) as tcolorstringgrid;
                    if g.cellprops[1,0].box.checked then
                    begin
                      g.cells[1,1] := format(\'%.1f\', [-abs(0.001+safestrtofloat(g.cells[2,1]))]);
                      for i:=2 to 3 do g.cells[1,i] := g.cells[1,1];
                      g.cells[2,2] := format(\'%.1f\', [abs(0.001+safestrtofloat(g.cells[2,1]))]);
                      g.cells[2,3] := g.cells[2,2];
                      for i:=1 to 3 do g.cellprops[1,i].color := clgray;
                      for i:=2 to 3 do g.cellprops[2,i].color := clgray;
                      for i:=1 to 3 do g.cellprops[1,i].style := [];
                      for i:=2 to 3 do g.cellprops[2,i].style := [];
                      for i:=1 to 1 do g.cellprops[2,i].color := clblack;
                      for i:=1 to 1 do g.cellprops[2,i].style := [fsbold];
                    end
                    else
                    begin
                      for i:=1 to 3 do g.cellprops[1,i].color := clblack;
                      for i:=2 to 3 do g.cellprops[2,i].color := clblack;
                      for i:=1 to 3 do g.cellprops[1,i].style := [fsbold];
                      for i:=2 to 3 do g.cellprops[2,i].style := [fsbold];
                    end;
                    if g.cellprops[1,4].box.checked then
                    begin
                      g.cells[1,5] := format(\'%.1f\', [-abs(0.001+safestrtofloat(g.cells[2,5]))]);
                      for i:=6 to 7 do g.cells[1,i] := g.cells[1,5];
                      g.cells[2,6] := format(\'%.1f\', [abs(0.001+safestrtofloat(g.cells[2,5]))]);
                      g.cells[2,7] := g.cells[2,6];
                      for i:=5 to 7 do g.cellprops[1,i].color := clgray;
                      for i:=6 to 7 do g.cellprops[2,i].color := clgray;
                      for i:=5 to 7 do g.cellprops[1,i].style := [];
                      for i:=6 to 7 do g.cellprops[2,i].style := [];
                      for i:=5 to 5 do g.cellprops[2,i].color := clblack;
                      for i:=5 to 5 do g.cellprops[2,i].style := [fsbold];
                    end
                    else
                    begin
                      for i:=5 to 7 do g.cellprops[1,i].color := clblack;
                      for i:=5 to 7 do g.cellprops[2,i].color := clblack;
                      for i:=5 to 7 do g.cellprops[1,i].style := [fsbold];
                      for i:=5 to 7 do g.cellprops[2,i].style := [fsbold];
                    end;
                    g.invalidate;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_390()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.btnlockplanselectclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_391()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonstatclick(sender: tobject);
                  var
                    ix, iy, t: single;
                    g: tavsfield;
                    mean, sdev, min, fmax: single;
                    npoints: integer;
                    text: string;
                  begin
                    if not assigned(quirtviewer1.clipbox[1]) or (quirtviewer1.clipbox[1].empty) then
                    begin
                      field_create(quirtviewer1.clipbox[1], \'field 1d float\', 4);
                    ix := 0;
                      iy := 0;
                      t := 2;
                      quirtviewer1.clipbox[1].setvalue([0],ix-t);
                      quirtviewer1.clipbox[1].setvalue([1],ix+t);
                      quirtviewer1.clipbox[1].setvalue([2],iy-t);
                      quirtviewer1.clipbox[1].setvalue([3],iy+t);
                    end;
                    g := tavsfield.create;
                    field_cropwithbox(quirtviewer1.field[1], quirtviewer1.clipbox[1] , g);
                    field_stat(g, mean, sdev, min, fmax, npoints, 0, 0, text);
                    memo1.lines.add(floattostr(mean));
                    g.free;
                    end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_392()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.trackbar1change(sender: tobject);
                  var
                    icomplpos: integer;
                  begin
                    if not queryframes.active then
                      exit;
                    icomplpos := trackbar1.max+1-trackbar1.position;
                    if icomplpos\<\>strtointdef(queryframes.fieldbyname(\'seq_num\').asstring, 1) then
                    begin
                      queryframes.locate(\'seq_num\',inttostr(icomplpos), [locaseinsensitive]);
                      setgantry();
                      movieloop(self);
                    end
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_393()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.makematchinactiveclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_394()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.clinicalmodeclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_395()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttoncopytohexapodclick(sender: tobject);
                  begin
                    if runprogramblocking(runtableshift, extractfilepath(runtableshift),
                                  [edittranslationlr.text,edittranslationcc.text,edittranslationap.text,
                                   editrotationlr.text,editrotationcc.text,editrotationap.text,
                                   floattostr(correctionreferencepoint.coordinate[0, 0]),
                                   floattostr(correctionreferencepoint.coordinate[1, 0]),
                                   floattostr(correctionreferencepoint.coordinate[2, 0])])=-1 then
                      showmessage(format(\'copy this data to hexapod: %s %s %s %s %s %s %s %s %s\',
                                  [edittranslationlr.text,edittranslationcc.text,edittranslationap.text,
                                   editrotationlr.text,editrotationcc.text,editrotationap.text,
                                   floattostr(correctionreferencepoint.coordinate[0, 0]),
                                   floattostr(correctionreferencepoint.coordinate[1, 0]),
                                   floattostr(correctionreferencepoint.coordinate[2, 0])]));
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_396()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.warpformcreate(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_397()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.checkboxdoseclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_398()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.checkboxdoseaccuclick(sender: tobject);
                  begin
                    if checkboxdoseaccu.checked then
                      checkboxdose.checked := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_399()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonlimitinformationclick(sender: tobject);
                  begin
                    if quirtviewerupdcoronal.toolbar[1].empty and (alignmentmode.value=0) then
                    begin
                      read_xdr(quirtviewerupdcoronal.toolbar[1], getfullinifilename(\'limits_coronal_clipbox.xdr\'));
                      read_xdr(quirtviewerupdsagittal.toolbar[1], getfullinifilename(\'limits_sagittal_clipbox.xdr\'));
                      read_xdr(quirtviewerupdtransversal.toolbar[1], getfullinifilename(\'limits_transverse_clipbox.xdr\'));
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_clipbox, 10, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_limits,  10, 4, 255, 255, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_clipbox, 10, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_limits,  10, 4, 255, 255, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_clipbox, 10, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_limits,  10, 4, 255, 255, 0, 0);
                    end
                    else if quirtviewerupdcoronal.toolbar[1].empty and (alignmentmode.value=1) then
                    begin
                      read_xdr(quirtviewerupdcoronal.toolbar[1], getfullinifilename(\'limits_coronal_mask.xdr\'));
                      read_xdr(quirtviewerupdsagittal.toolbar[1], getfullinifilename(\'limits_sagittal_mask.xdr\'));
                      read_xdr(quirtviewerupdtransversal.toolbar[1], getfullinifilename(\'limits_transverse_mask.xdr\'));
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_mask, 25, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_limits,  25, 4, 255, 255, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_mask, 25, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_limits,  25, 4, 255, 255, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_mask, 25, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_limits,  25, 4, 255, 255, 0, 0);
                    end
                    else
                    begin
                      quirtviewerupdcoronal.toolbar[1].clear;
                      quirtviewerupdsagittal.toolbar[1].clear;
                      quirtviewerupdtransversal.toolbar[1].clear;
                    end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_400()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.exitaccept1click(sender: tobject);
                  begin
                    buttonelektadismissclick(buttonelektaaccept);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_401()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.recordvideo1click(sender: tobject);
                  begin
                    recordvideo1.checked := not recordvideo1.checked;
                    checkboxrecordform.checked := recordvideo1.checked;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_402()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnaverage4dtransformclick(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_403()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnaverage4dtransformmousedown(sender: tobject;
                    button: tmousebutton; shift: tshiftstate; x, y: integer);
                  begin
                    radiobuttonaverageframes.checked := true;
                    radiobuttoneachframe.checked := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_404()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnaverage4dtransformmouseup(sender: tobject;
                    button: tmousebutton; shift: tshiftstate; x, y: integer);
                  begin
                    radiobuttonaverageframes.checked := false;
                    radiobuttoneachframe.checked := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_405()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.label74click(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_406()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.linac1newpatient(const apatientid: string;
                    aworkset: tmercworkset; aevent: tmercevent; aicompacket: tmercicompacket);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_407()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.linac1newtreatment(const atreatname: string;
                    aworkset: tmercworkset; aevent: tmercevent; aicompacket: tmercicompacket);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_408()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.linkmark2clip1click(sender: tobject);
                  begin
                    linkmark2clip1.checked := not linkmark2clip1.checked;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_409()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.bitbtnwarpclick(sender: tobject);
                  begin
                    if radiobuttonwarpallrois.checked then radiobuttoneachroi.checked := true
                    else radiobuttonwarpallrois.checked := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_410()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.creategeometryclick(sender: tobject);
                  var
                   dir, ifname : string;
                  begin
                    dir := reconfilebase;
                    ifname := dir + treatmentuid  +\'.reference.markers\';
                    if fileexists(ifname) = false then
                       ifname := dir + scanuid + \'.\' + scandate + \'.\' + scantime + \'.online.markers\';
                    if fileexists(ifname) then
                    begin
                    end
                    else
                      showmessage(error_nkinoonlinemarkerfile + #10 + ifname);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_411()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.createmultianglegainfile1click(sender: tobject);
                  begin
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_412()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.visualizebonesegmentation1click(sender: tobject);
                  begin
                     visualizebonesegmentation1.checked := not visualizebonesegmentation1.checked;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_413()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.buttonloadtestdataclick(sender: tobject);
                  var f: textfile;
                      s, t: string;
                      i: integer;
                  begin
                    if not opendialog1.execute then exit;
                    assignfile(f, opendialog1.filename);
                    reset(f);
                    readln(f, s);
                    readln(f, s);
                    for i:=0 to max(onlinecube.dimensions[3]-1, 0) do
                    begin
                      readln(f, s);
                      if onlinecube.dimensions[3]\>0 then
                        phasehist.setvalue([i], valuefromstr(s, 2, -1));
                      if comboboxregistrationprotocol.itemindex \<\> comboboxregistrationprotocol.indexofmapped(\'mask\') then
                      begin
                        t := format(\'%g,%g,%g,%g,%g,%g\',
                          [valuefromstr(s, 3, -1), valuefromstr(s, 4, -1),
                           valuefromstr(s, 5, -1), valuefromstr(s, 6, -1),
                           valuefromstr(s, 7, -1), valuefromstr(s, 8, -1)]);
                        packregistration(nil, t, i, 0);
                      end;
                      if comboboxregistrationprotocol.itemindex \<\> comboboxregistrationprotocol.indexofmapped(\'clipbox\') then
                      begin
                        t := format(\'%g,%g,%g,%g,%g,%g\',
                          [valuefromstr(s, 9, -1), valuefromstr(s, 10, -1),
                           valuefromstr(s, 11, -1), valuefromstr(s, 12, -1),
                           valuefromstr(s, 13, -1), valuefromstr(s, 14, -1)]);
                        packregistration(nil, t, i, nclipbox);
                      end;
                      t := format(\'%g,%g,%g,%g,%g,%g\',
                        [valuefromstr(s, 15, -1), valuefromstr(s, 16, -1),
                         valuefromstr(s, 17, -1), valuefromstr(s, 18, -1),
                         valuefromstr(s, 19, -1), valuefromstr(s, 20, -1)]);
                      packregistration(nil, t, i, 2*nclipbox);
                    end;
                    closefile(f);
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_414()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.checkboxshowsegmentationclick(sender: tobject);
                  begin
                    visualizebonesegmentation1.checked := checkboxshowsegmentation.checked;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_415()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.colorstringgrid3keydown(sender: tobject; var key: word;
                    shift: tshiftstate);
                  begin
                    timeracceptlimits.enabled := false;
                    timeracceptlimits.enabled := true;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_416()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.timeracceptlimitstimer(sender: tobject);
                  begin
                    colorstringgrid2.onexit(colorstringgrid2);
                    colorstringgrid3.onexit(colorstringgrid3);
                    timeracceptlimits.enabled := false;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_417()
{
    return parse(#DelphiGrammar::MethodImplementation, "function getbuilddate(const afilename: string): string;
                  var
                    filename: string;
                    infosize, wnd: dword;
                    verbuf: pointer;
                    fi: pchar;
                    versize: dword;
                  begin
                    result := \'\';
                    try
                      filename := afilename;
                      uniquestring(filename);
                      infosize := getfileversioninfosize(pchar(filename), wnd);
                      if infosize \<\> 0 then
                      begin
                        getmem(verbuf, infosize);
                        try
                          if getfileversioninfo(pchar(filename), wnd, infosize, verbuf) then
                            if verqueryvalue(verbuf, \'\\stringfileinfo\\040904e4\\build date\',
                              pointer(fi), versize) then
                              result := fi;
                        finally
                          freemem(verbuf);
                        end;
                      end;
                    except
                      end;
                  end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation_418()
{
    return parse(#DelphiGrammar::MethodImplementation, "procedure tform1.loaddvf1click(sender: tobject);
                  begin
                  end;");
}

test bool Test_TestCases_1_MethodImplementation()
{
    print("Running 419 tests for construction \'MethodImplementation\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "function fixscanurl (orgurl: string) : string;
                  var
                    newurl : string;
                  begin
                    newurl := orgurl;
                    result := newurl;
                  end;",
// Sentence 001
                  "function rightdelimitedstr (s: string; delimitors: string): string;
                  begin
                    result := rightstr(s, length(s)-lastdelimiter(delimitors, s));
                  end;",
// Sentence 002
                  "function safestrtofloat(s: string; fdef: single): single;
                  begin
                    if (s = \'\') or (s = \'-\') then
                      result := fdef
                    else
                      try
                        result := strtofloat(s);
                      except
                        result := fdef;
                      end;
                  end;",
// Sentence 003
                  "procedure transformtostring(t : ttransform; var s: string);
                  var i,j : integer;
                  begin
                    s := \'\';
                    for i:=0 to t.dimensions[0]-1 do
                    begin
                      for j:=0 to t.dimensions[1]-1 do
                      begin
                        s := s + format(\'%9.4f\', [t.getvalue([i,j])]);
                        if (i\<\> t.dimensions[0]-1) or (j \<\> t.dimensions[1]-1) then s := s + \',\';
                      end;
                    end;
                  end;",
// Sentence 004
                  "function stringtotransform(s : string; var t : ttransform): boolean;
                  var i,j : integer;
                  begin
                    for i:=0 to t.dimensions[0]-1 do
                    begin
                      for j:=0 to t.dimensions[1]-1 do
                      begin
                        t.setvalue([i,j], valuefromstr(s,i*4+j+1));
                      end;
                    end;
                    result := true;
                  end;",
// Sentence 005
                  "function writematrix(t: tavsfield; points: boolean): string;
                  var i, j: integer;
                  begin
                    result := \'\';
                    if points then
                    begin
                      for i:=0 to t.dimensions[0]-1 do
                      begin
                        for j:=0 to t.nspace-1 do
                        begin
                          result := result + format(\'%9.4f\', [t.coordinate[j, i]]);
                          if j \<\> t.nspace-1 then result := result + \'  \'
                          else                    result := result + #13 + #10;
                        end;
                      end;
                      exit;
                    end;
                    if t.ndim=2 then
                    begin
                      for i:=0 to t.dimensions[1]-1 do
                      begin
                        for j:=0 to t.dimensions[0]-1 do
                        begin
                          if (t.datatype=3) or (t.datatype=4) then
                            result := result + format(\'%9.4f\', [t.getvalue([i,j])])
                          else
                            result := result + format(\'%9d\', [round(t.getvalue([i,j]))]);
                          if j \<\> t.dimensions[0]-1 then result := result + \'  \'
                          else                           result := result + #13 + #10;
                        end;
                      end;
                    end
                    else if t.ndim=1 then
                    begin
                      for i:=0 to t.dimensions[0]-1 do
                      begin
                        if (t.datatype=3) or (t.datatype=4) then
                          result := result + format(\'%9.4f\', [t.getvalue([i])])
                        else
                          result := result + format(\'%9d\', [round(t.getvalue([i]))]);
                        if i \<\> t.dimensions[0]-1 then result := result + \'  \'
                        else                           result := result + #13 + #10;
                      end;
                    end;
                  end;",
// Sentence 006
                  "function valuefromstr(str: string; n: integer; fdef: single=0.0) : single;
                  var
                    i,j,k : integer;
                  begin
                    j := 1;
                    while (j \<= length(str)) and (not (ansichar(str[j]) in [\'0\'..\'9\',\'+\',\'-\',\'.\'])) do j := j+1;
                    result := fdef;
                    for i:=1 to n do
                      begin
                        k := j;
                        while (k \<= length(str)) and ((ansichar(str[k]) in [\'0\'..\'9\',\'+\',\'-\',\'.\',\'e\',\'e\'])) do k := k+1;
                        result := safestrtofloat(copy(str, j, k-j), fdef);
                        j := k+1;
                        while (j \<= length(str)) and (not (ansichar(str[j]) in [\'0\'..\'9\',\'+\',\'-\',\'.\'])) do j := j+1;
                      end;
                  end;",
// Sentence 007
                  "procedure setstrictdelimitedtext(const value: string; delimiter: char;
                    quotechar: char; strings: tstrings);
                  var
                    p, p1: pchar;
                    s: string;
                  begin
                    try
                      strings.clear;
                      p := pchar(value);
                      while p^ \<\> #0 do
                      begin
                        if p^ = quotechar then
                          s := ansiextractquotedstr(p, quotechar)
                        else
                        begin
                          p1 := p;
                          while (p^ \<\> #0) and (p^ \<\> delimiter) do
                            p := charnext(p);
                          setstring(s, p1, p - p1);
                        end;
                        strings.add(s);
                        if p^ = delimiter then
                        begin
                          p1 := p;
                          if charnext(p1)^ = #0 then
                            strings.add(\'\');
                          p := charnext(p);
                        end;
                      end;
                    finally
                      strings.endupdate;
                    end;
                  end;",
// Sentence 008
                  "procedure applyfilter(dataset: tabstractdataset; tablename: string;
                    fieldnames: string; fieldvalues: string);
                  var
                    table: tabstracttable;
                    query: tabstractquery;
                    slnames: tstringlist;
                    slvalues: tstringlist;
                    i: integer;
                    whereclause: string;
                    newquery: string;
                  begin
                    if pos(\';\', fieldnames)\>0 then
                    begin
                      slnames := tstringlist.create;
                      slvalues := tstringlist.create;
                      try
                        slnames.delimiter := \';\';
                        slnames.strictdelimiter := true;
                        slvalues.delimiter := chr(256);
                        slvalues.strictdelimiter := true;
                        slnames.delimitedtext := fieldnames;
                        slvalues.delimitedtext := fieldvalues;
                        if slnames.count\<\>slvalues.count then
                          raise exception.create(\'mismatch between field names and values\');
                      whereclause := \'\';
                        for i := 0 to slnames.count-1 do
                        begin
                          if length(trim(slvalues[i]))=0 then
                            exit;
                          whereclause := whereclause + slnames[i] + \'=\' + slvalues[i];
                          if i\<slnames.count-1 then
                            whereclause := whereclause + \' and \'
                        end;
                      finally
                        slnames.free;
                        slvalues.free;
                      end;
                    end
                    else
                    begin
                      if length(trim(fieldvalues))=0 then
                        exit;
                      whereclause := fieldnames + \' = \' + fieldvalues;
                    end;
                     if dataset is tabstractquery then
                    begin
                      query := (dataset as tabstractquery);
                      end
                    else
                      query := nil;
                    if assigned(query) then
                    begin
                      newquery := \'select * from \' + tablename + \' where \' + whereclause;
                      if uppercase(trim(newquery))\<\>uppercase(trim(query.sql.text)) then
                      begin
                        query.active := false;
                        query.sql.text := newquery;
                      end;
                    end
                    else
                    begin
                      table := (dataset as tabstracttable);
                      if pos(tablename, table.tablename)=0 then
                      begin
                        table.active := false;
                        table.tablename := changefileext(tablename, \'.dbf\');
                      end;
                      table.filtered := true;
                      table.filter := whereclause;
                    end;
                    if not dataset.active then
                      dataset.active := true;
                  end;",
// Sentence 009
                  "procedure cleanupsectionsstring(var s: string);
                  begin
                    while pos(\',,\', s)\>0 do
                      s := stringreplace(s, \',,\', \',\', [rfreplaceall]);
                    if isdelimiter(\',\', s, 1) then
                      delete(s, 1, 1);
                    if isdelimiter(\',\', s, length(s)) then
                      delete(s, length(s), 1);
                  end;",
// Sentence 010
                  "function nstrings (s : string) : integer;
                  var
                    i : integer;
                  begin
                    result := 1;
                    for i := 1 to length(s) do
                      if s[i]=\',\' then inc(result);
                  end;",
// Sentence 011
                  "function stringn (s : string; n : integer): string;
                  var
                    i, k, start, stop : integer;
                  begin
                    if (n \< 1) or (n \> nstrings(s)) then
                    begin
                      result := \'\';
                    end
                    else
                    begin
                      k := 0;
                      start := 1;
                      stop := length(s);
                      for i := 1 to length(s) do
                      begin
                        if s[i]=\',\' then
                        begin
                          inc(k);
                          if k=n then
                            break
                          else
                            start := i+1;
                        end;
                        stop := i+1;
                      end;
                      result := copy(s,start,stop-start);
                    end;
                  end;",
// Sentence 012
                  "procedure tinifiles.addinifile(const sfilename: string; insertlocation: tinsertlocation=ilbegin);
                  var
                    i: integer;
                    ifound: integer;
                    icount: integer;
                    bfound: boolean;
                    inis: tstringlist;
                  begin
                    if not fileexists(sfilename) then
                      exit;
                    inis := tstringlist.create;
                    inis.sorted := false;
                    bfound := false;
                    ifound := -1;
                    icount := 0;
                    for i:=0 to nini do
                    begin
                      if assigned(inifile[i]) then
                      begin
                        inc(icount);
                        inis.addobject(inifile[i].filename, inifile[i]);
                        if sametext(inifile[i].filename, sfilename) then
                        begin
                          ifound := i;
                          bfound := true;
                        end;
                      end
                    end;
                    if icount+1\>=nini then
                    begin
                      showmessage(error_inifile);
                      inis.free;
                      exit;
                    end;
                    if bfound then
                    begin
                      if (insertlocation=ilbegin) and (ifound\<\>0) then
                      begin
                        inis.insertobject(0, sfilename, inifile[ifound]);
                        inis.delete(ifound+1);
                      end
                      else if (insertlocation=ilend) and (ifound\<\>icount-1) then
                      begin
                        inis.addobject(sfilename, inifile[ifound]);
                        inis.delete(ifound);
                      end
                    end
                    else
                    begin
                      if insertlocation=ilbegin then
                        inis.insertobject(0, sfilename, tqinifile.create(sfilename))
                      else
                        inis.addobject(sfilename, tqinifile.create(sfilename));
                    end;
                    for i:=0 to inis.count-1 do
                      inifile[i] := tqinifile(inis.objects[i]);
                    inis.free;
                  end;",
// Sentence 013
                  "constructor tinifiles.create(files: array of string);
                  var i: integer;
                  begin
                    for i:=0 to high(files) do
                      if fileexists(files[i]) then
                        inifile[i] := tqinifile.create(expandfilename(files[i]));
                    fqueries := tstringlist.create;
                    fqueries.sorted := true;
                    fqueries.duplicates := dupaccept;
                  end;",
// Sentence 014
                  "destructor tinifiles.destroy;
                  var
                    i: integer;
                  begin
                    for i:=0 to fqueries.count-1 do
                      fqueries.objects[i].free;
                    fqueries.free;
                    for i:=0 to nini do
                      inifile[i].free;
                  end;",
// Sentence 015
                  "function tinifiles.readstring(const sections, ident, default: string): string;
                  var i, j       : integer;
                      s          : string;
                      sc         : tinidetails;
                      sec, val,
                      src        : string;
                      str        : string;
                      files      : string;
                  begin
                    s := default;
                    sec := ident;
                    if length(default)=0 then
                      val := \'\<empty\> (default)\'
                    else
                      val := default + \' (default)\';
                    src := \'-\';
                    files := \'\';
                    for i:=0 to nini do
                      if assigned(inifile[i]) then
                      begin
                        files := files + \',\' + inifile[i].filename;
                        for j:= 1 to nstrings(sections) do
                        begin
                          str := inifile[i].readstring(stringn(sections,j), ident, #$0a);
                          if str\<\>#$0a then
                          begin
                            s := str;
                            sec := stringn(sections, j) + \',\' + ident;
                            val := str;
                            src := inifile[i].filename;
                          end
                        end;
                      end;
                    if enabletestmode then
                    begin
                      i := fqueries.indexof(sec);
                      if i\<0 then
                        sc := tinidetails.create
                      else
                        sc := tinidetails(fqueries.objects[i]);
                      sc.value := val;
                      sc.source := src;
                      sc.datatype := \'string\';
                      sc.candidates := sections;
                      sc.files := copy(files, 2, maxint);
                      if i\<0 then
                        fqueries.addobject(sec, sc);
                    end;
                    result := s;
                  end;",
// Sentence 016
                  "function tinifiles.readbool(const sections, ident: string; default: boolean): boolean;
                  var i, j    : integer;
                      s       : boolean;
                      sc      : tinidetails;
                      sec, val,
                      src     : string;
                      str     : string;
                      files   : string;
                  begin
                    s := default;
                    sec := ident;
                    val := booltostr(default, true) + \' (default)\';
                    src := \'-\';
                    files := \'\';
                    for i:=0 to nini do
                      if assigned(inifile[i]) then
                      begin
                        files := files + \',\' + inifile[i].filename;
                        for j:= 1 to nstrings(sections) do
                        begin
                          str := inifile[i].readstring(stringn(sections,j), ident, #$0a);
                          if str\<\>#$0a then
                          begin
                            if (length(str) \> 2) and (str[1] = \'0\') and
                               ((str[2] = \'x\') or (str[2] = \'x\')) then
                              str := \'$\' + copy(str, 3, maxint);
                            s := strtointdef(str, ord(default))\<\>0;
                            sec := stringn(sections, j) + \',\' + ident;
                            if strtointdef(str, 0)=strtointdef(str, 1) then
                              val := booltostr(s, true)
                            else
                              val := str + \' (using default: \' + booltostr(default, true) + \')\';
                            src := inifile[i].filename;
                          end
                        end;
                      end;
                    if enabletestmode then
                    begin
                      i := fqueries.indexof(sec);
                      if i\<0 then
                        sc := tinidetails.create
                      else
                        sc := tinidetails(fqueries.objects[i]);
                      sc.value := val;
                      sc.source := src;
                      sc.datatype := \'boolean\';
                      sc.candidates := sections;
                      sc.files := copy(files, 2, maxint);
                      if i\<0 then
                        fqueries.addobject(sec, sc);
                    end;
                    result := s;
                  end;",
// Sentence 017
                  "function tinifiles.readfloat(const sections, ident: string;  default: double): double;
                  var i, j    : integer;
                      s       : double;
                      sc      : tinidetails;
                      sec, val,
                      src     : string;
                      str     : string;
                      files   : string;
                  begin
                    s := default;
                    sec := ident;
                    val := floattostr(default) + \' (default)\';
                    src := \'-\';
                    files := \'\';
                    for i:=0 to nini do
                      if assigned(inifile[i]) then
                      begin
                        files := files + \',\' + inifile[i].filename;
                        for j:= 1 to nstrings(sections) do
                        begin
                          str := inifile[i].readstring(stringn(sections,j), ident, #$0a);
                          if str\<\>#$0a then
                          begin
                            s := strtofloatdef(str, default);
                            sec := stringn(sections, j) + \',\' + ident;
                            if (strtofloatdef(str, 1.1)-strtofloatdef(str, 0.0))\<1.0 then
                              val := str
                            else
                              val := str + \' (using default: \' + floattostr(default) + \')\';
                            src := inifile[i].filename;
                          end
                        end;
                      end;
                    if enabletestmode then
                    begin
                      i := fqueries.indexof(sec);
                      if i\<0 then
                        sc := tinidetails.create
                      else
                        sc := tinidetails(fqueries.objects[i]);
                      sc.value := val;
                      sc.source := src;
                      sc.datatype := \'float\';
                      sc.candidates := sections;
                      sc.files := copy(files, 2, maxint);
                      if i\<0 then
                        fqueries.addobject(sec, sc);
                    end;
                    result := s;
                  end;",
// Sentence 018
                  "function tinifiles.readinteger(const sections, ident: string; default: integer): longint;
                  var i, j    : integer;
                      s       : longint;
                      sc      : tinidetails;
                      sec, val,
                      src     : string;
                      str     : string;
                      files   : string;
                  begin
                    s := default;
                    sec := ident;
                    val := inttostr(default) + \' (default)\';
                    src := \'-\';
                    files := \'\';
                    for i:=0 to nini do
                      if assigned(inifile[i]) then
                      begin
                        files := files + \',\' + inifile[i].filename;
                        for j:= 1 to nstrings(sections) do
                        begin
                          str := inifile[i].readstring(stringn(sections,j), ident, #$0a);
                          if str\<\>#$0a then
                          begin
                            if (length(str) \> 2) and (str[1] = \'0\') and
                               ((str[2] = \'x\') or (str[2] = \'x\')) then
                              str := \'$\' + copy(str, 3, maxint);
                            s := strtointdef(str, default);
                            sec := stringn(sections, j) + \',\' + ident;
                            if strtointdef(str, 0)=strtointdef(str, 1) then
                              val := str
                            else
                              val := str + \' (using default: \' + inttostr(default) + \')\';
                            src := inifile[i].filename;
                          end
                        end;
                      end;
                    if enabletestmode then
                    begin
                      i := fqueries.indexof(sec);
                      if i\<0 then
                        sc := tinidetails.create
                      else
                        sc := tinidetails(fqueries.objects[i]);
                      sc.value := val;
                      sc.source := src;
                      sc.datatype := \'integer\';
                      sc.candidates := sections;
                      sc.files := copy(files, 2, maxint);
                      if i\<0 then
                        fqueries.addobject(sec, sc);
                    end;
                    result := s;
                  end;",
// Sentence 019
                  "procedure tinifiles.readsections(strings: tstrings; allinifiles: boolean = false);
                  var
                    tmpstrings : tstringlist;
                    i, j       : integer;
                  begin
                    if allinifiles then
                    begin
                      tmpstrings := tstringlist.create;
                      for i:=0 to nini do
                      begin
                        if assigned(inifile[i]) then
                        begin
                          inifile[i].readsections(tmpstrings);
                          for j:= 0 to tmpstrings.count - 1 do
                            if (strings.indexof(tmpstrings[j]) \< 0) then strings.add(tmpstrings[j])
                        end;
                      end;
                      tmpstrings.free;
                    end
                    else
                    begin
                    if assigned(inifile[0]) then
                      inifile[0].readsections(strings);
                    end;
                  end;",
// Sentence 020
                  "function tinifiles.sectionexists(const section: string): boolean;
                  var i:integer;
                  begin
                    result := false;
                    for i:=0 to nini do
                      if assigned(inifile[i]) then
                      begin
                        result := inifile[i].sectionexists(section);
                        if result then exit;
                      end;
                  end;",
// Sentence 021
                  "procedure tqinifile.readsections(strings: tstrings);
                  const
                    initialbufsize = 16*16384;
                    maxiterations = 10;
                  var
                    gppsres: integer;
                    bufsize: integer;
                    buffer, p: pchar;
                    i: integer;
                  begin
                    bufsize := initialbufsize;
                    getmem(buffer, bufsize*sizeof(char));
                    try
                      for i:=0 to maxiterations-1 do
                      begin
                        gppsres :=  getprivateprofilestring(nil, nil, nil, buffer, bufsize, pchar(filename));
                        if gppsres = 0 then
                          break
                        else if gppsres \<\> bufsize-2 then
                        begin
                          p := buffer;
                          while p^ \<\> #0 do
                          begin
                            strings.add(p);
                            inc(p, strlen(p) + 1);
                          end;
                          break;
                        end
                        else
                        begin
                          bufsize := 2* bufsize;
                          freemem(buffer);
                          getmem(buffer, bufsize*sizeof(char));
                        end;
                      end;
                    finally
                      freemem(buffer);
                    end;
                  end;",
// Sentence 022
                  "function tqinifile.sectionexists(const sectionsubstring: string): boolean;
                  const
                    initialbufsize = 16*16384;
                    maxiterations = 10;
                  var
                    gppsres: integer;
                    bufsize: integer;
                    buffer, p: pchar;
                    i: integer;
                  begin
                    bufsize := initialbufsize;
                    getmem(buffer, bufsize*sizeof(char));
                    result := false;
                    try
                      for i:=0 to maxiterations-1 do
                      begin
                        gppsres :=  getprivateprofilestring(nil, nil, nil, buffer, bufsize, pchar(filename));
                        if gppsres = 0 then
                          break
                        else if gppsres \<\> bufsize-2 then
                        begin
                          p := buffer;
                          while p^ \<\> #0 do
                          begin
                            if matchesmask(p, sectionsubstring) then
                            begin
                              result := true;
                              break;
                            end;
                            inc(p, strlen(p) + 1);
                          end;
                          break;
                        end
                        else
                        begin
                          bufsize := 2* bufsize;
                          freemem(buffer);
                          getmem(buffer, bufsize*sizeof(char));
                        end;
                      end;
                    finally
                      freemem(buffer);
                    end;
                  end;",
// Sentence 023
                  "constructor tscan.create(owner: tform);
                  var
                    i : integer;
                  begin
                    inherited create;
                    fowner      := owner;
                    data        := tavsfield.create(self, \'data\');
                    lut         := tavsfield.create(self, \'lut\');
                    externallut := tavsfield.create(self, \'externallut\');
                    properties  := tavsfield.create(self, \'properties\');
                    tosiddon    := ttransform.create(self, \'tosiddon\'); tosiddon.clear;
                    topatient   := ttransform.create(self, \'topatient\'); topatient.clear;
                    tomachine   := ttransform.create(self, \'tomachine\'); tomachine.clear;
                    for i := 1 to nclipbox do
                      clipbox[i]  := tavsfield.create(self, \'clipbox_\'+inttostr(i));
                    compressionlevel := 2;
                    headerstring     := \'\';
                    filename         := \'\';
                    level      := tupdatabledouble.create(self, \'level\');
                    window     := tupdatabledouble.create(self, \'window\');
                    processing := tupdatableinteger.create(self, \'processing\');
                    tomachine.adddependency((fowner as tform1).machine_to_siddon);
                    tomachine.adddependency(tosiddon);
                    tomachine.onupdate := updatetomachine;
                    lut.adddependency(externallut);
                    lut.adddependency(processing);
                    lut.onupdate := updatelut;
                    for i := 1 to nclipbox do
                    begin
                      clipbox[i].adddependency((fowner as tform1).clipbox[i]);
                      clipbox[i].adddependency((fowner as tform1).machine_to_machineadjust);
                      clipbox[i].adddependency(tomachine);
                      clipbox[i].adddependency((fowner as tform1).reversemotion);
                      clipbox[i].onupdate  := updateclipbox;
                    end;
                  end;",
// Sentence 024
                  "destructor tscan.destroy;
                  var
                    i   : integer;
                  begin
                    inherited;
                  end;",
// Sentence 025
                  "procedure tscan.connectviewer(viewer: tlightquirtviewerupd; channel: integer);
                  var i:integer;
                  begin
                    if channel=1 then
                      viewer.grid.removedependency(viewer.transform[1]);
                    viewer.field     [channel] := data;
                    viewer.lut       [channel] := lut;
                    viewer.transform [channel] := tomachine;
                    viewer.level     [channel] := level;
                    viewer.window    [channel] := window;
                    viewer.processing[channel] := processing;
                    viewer.fieldname [channel].value := fieldname;
                    if channel=1 then
                    begin
                      for i:=1 to high((fowner as tform1).online   ) do viewer.viewtransform.removedependency((fowner as tform1).online   [i].tomachine);
                      for i:=1 to high((fowner as tform1).reference) do viewer.viewtransform.removedependency((fowner as tform1).reference[i].tomachine);
                      for i:=1 to high((fowner as tform1).dose     ) do viewer.viewtransform.removedependency((fowner as tform1).dose     [i].tomachine);
                      viewer.viewtransform.adddependency(tomachine);
                      for i:=1 to high((fowner as tform1).online   ) do viewer.grid.removedependency((fowner as tform1).online   [i].data);
                      for i:=1 to high((fowner as tform1).reference) do viewer.grid.removedependency((fowner as tform1).reference[i].data);
                      for i:=1 to high((fowner as tform1).dose     ) do viewer.grid.removedependency((fowner as tform1).dose     [i].data);
                      viewer.grid.adddependency(data);
                      viewer.grid.adddependency(viewer.transform[1]);
                    end;
                  end;",
// Sentence 026
                  "procedure tscan.clear;
                  var
                    i : integer;
                  begin
                    data.clear;
                    tomachine.clear;
                    topatient.clear;
                    tosiddon.clear;
                    externallut.clear;
                    for i := 1 to nclipbox do clipbox[i].clear;
                    level.value := 0;
                    window.value := 0;
                    processing.value := 0;
                    filename := \'\';
                  end;",
// Sentence 027
                  "procedure tscan.updatetomachine(sender: tobject; var unchanged: boolean);
                  begin
                    if not tosiddon.empty then
                      transform_math(tosiddon, (fowner as tform1).machine_to_siddon, tomachine, false, true);
                    end;",
// Sentence 028
                  "procedure tscan.updatelut(sender: tobject; var unchanged: boolean);
                  begin
                    if processing.value=411 then
                    begin
                      field_overlay_lut(lut, \'monochrome\', 0, 256);
                      level.locked := true;
                      window.locked := true;
                    end
                    else
                    begin
                      lut.assign(externallut);
                      level.locked := false;
                      window.locked := false;
                    end;
                  end;",
// Sentence 029
                  "procedure tscan.updateclipbox(sender: tobject; var unchanged: boolean);
                  var t1: ttransform;
                      i, j : integer;
                      bclpadj  : boolean;
                  begin
                    if data.empty then exit;
                    t1 := ttransform.create;
                    t1.assign(tomachine);
                    t1.invert;
                    bclpadj := false;
                    for i:=1 to high((fowner as tform1).online   ) do
                      for j:=1 to nclipbox do
                        if (tavsfield(sender)=(fowner as tform1).online[i].clipbox[j]) then
                          bclpadj := true;
                    for i := 1 to nclipbox do
                    begin
                      clipbox[i].enabled := false;
                      if (fowner as tform1).clipbox[i].empty then clipbox[i].clear
                      else
                      begin
                        if bclpadj then
                        begin
                          t1.assign(tomachine);
                          t1.premultiply((fowner as tform1).machine_to_machineadjust);
                          t1.invert;
                        end;
                        cropbox_transform((fowner as tform1).clipbox[i],t1,clipbox[i]);
                      end;
                      clipbox[i].owner   := (fowner as tform1).clipbox[i].owner;
                      clipbox[i].locked  := (fowner as tform1).clipbox[i].locked  or (data.ndim=2);
                      clipbox[i].blanking:= (fowner as tform1).clipbox[i].blanking;
                      clipbox[i].enabled := true;
                    end;
                    t1.free;
                  end;",
// Sentence 030
                  "procedure tscan.loadinternal(fld: tavsfield; base, name: string);
                  var i: integer;
                  begin
                    if fileexists(base+name) then
                    begin
                        read_xdr(fld, base+name);
                      lastfile := base+name;
                    end
                    else
                    begin
                      for i:=low(aliases) to high(aliases) do
                        if aliases[i].name=name then
                          if fileexists(base+aliases[i].alias) then
                          begin
                            read_xdr(fld, base+aliases[i].alias);
                            lastfile := base+aliases[i].alias;
                            exit;
                          end;
                    end;
                  end;",
// Sentence 031
                  "function tscan.existsinternal(base, name: string): boolean;
                  var i: integer;
                  begin
                    result := false;
                    if fileexists(base+name) then result := true
                    else
                    begin
                      for i:=low(aliases) to high(aliases) do
                        if aliases[i].name=name then
                          if fileexists(base+aliases[i].alias) then
                          begin
                            result := true;
                            exit;
                          end;
                    end;
                  end;",
// Sentence 032
                  "function tscan.deleteinternal(base, name: string): boolean;
                  var i: integer;
                  begin
                    result := false;
                    if fileexists(base+name) then
                    begin
                      deletefile(base+name);
                      result := true;
                    end
                    else
                    begin
                      for i:=low(aliases) to high(aliases) do
                        if aliases[i].name=name then
                          if fileexists(base+aliases[i].alias) then
                          begin
                            deletefile(base+aliases[i].alias);
                            result := true;
                            exit;
                          end;
                    end;
                  end;",
// Sentence 033
                  "function tscan.load(dir, uid, name: string): boolean;
                  var base: string;
                  begin
                    result := false;
                    if uid\<\>\'\' then base := dir + uid + \'.\'
                    else            base := dir;
                    data.clear;
                    tomachine.clear;
                    topatient.clear;
                    tosiddon.clear;
                    externallut.clear;
                    if not existsinternal(base, name) then exit;
                    result := true;
                    try
                      loadinternal(data, base, name);
                      filename := lastfile;
                      loadinternal(tosiddon,    base, name + \'.orientation\');
                      loadinternal(topatient,   base, name + \'.patientorientation\');
                      loadinternal(tomachine,   base, name + \'.machineorientation\');
                      loadinternal(externallut, base, name + \'.lut\');
                      loadinternal(properties,  base, name + \'.properties\');
                    except
                      result := false;
                    end;
                    tomachine.make;
                    lut.make;
                  end;",
// Sentence 034
                  "function tscan.exists(dir, uid, name: string): boolean;
                  begin
                    result := existsinternal(dir + uid + \'.\', name);
                  end;",
// Sentence 035
                  "function tscan.save(dir, uid, name: string): boolean;
                  var f: string;
                  begin
                    result := true;
                    f := dir + uid + \'.\' + name;
                    try
                      if      not data.empty      then
                      begin
                        write_xdr(data,      f + \'\', headerstring, \'\', compressionlevel);
                        filename := f;
                      end;
                      if      not topatient.empty   then write_xdr(topatient,   f + \'.patientorientation\');
                      if      not externallut.empty then write_xdr(externallut, f + \'.lut\');
                      if      not properties.empty  then write_xdr(properties,  f + \'.properties\');
                      if      not tosiddon.empty    then write_xdr(tosiddon,    f + \'.orientation\')
                      else if not tomachine.empty   then write_xdr(tomachine,   f + \'.machineorientation\');
                    except
                      result := false;
                    end;
                  end;",
// Sentence 036
                  "function tscan.delete(dir, uid, name: string): boolean;
                  var base: string;
                  begin
                    result := true;
                    base := dir + uid + \'.\';
                    try
                      deleteinternal(base, name);
                      deleteinternal(base, name + \'.patientorientation\');
                      deleteinternal(base, name + \'.lut\');
                      deleteinternal(base, name + \'.properties\');
                      deleteinternal(base, name + \'.orientation\');
                      deleteinternal(base, name + \'.machineorientation\');
                    except
                      result := false;
                    end;
                  end;",
// Sentence 037
                  "function tscan.readheader(entry: string): string;
                  begin
                    result := \'\';
                    if fileexists(filename) then read_xdr_header(result, filename, entry)
                  end;",
// Sentence 038
                  "procedure avsmessagehandler(const smessage: pansichar; const stitle: pansichar) cdecl;
                  var
                    tf: textfile;
                  begin
                    inc(form1timer1enabled);
                    if form1.avlstate=6 then
                    begin
                      sysutils.forcedirectories(extractfilepath(application.exename) + \'logs\');
                      assignfile(tf, extractfilepath(application.exename) + \'logs\\ntpars_error.log\');
                      if fileexists(extractfilepath(application.exename) + \'logs\\ntpars_error.log\') then append(tf) else rewrite(tf);
                      write(tf, formatdatetime(\'yyyymmdd hh:nn:ss \', now));
                      write(tf, smessage);
                      write(tf, \' \');
                      writeln(tf, stitle);
                      closefile(tf);
                      form1.reconterminate(false, avs_error_msg);
                      exit;
                    end;
                    if smessage = \'match stopped close to search limits - possibly incorrect answer\' then
                    begin
                      if not disableshowmessage then showmessage(avs_matc_warning)
                    end
                    else if smessage = \'invalid histogram; check input image or histogram max value\' then
                    begin
                      if not disableshowmessage then showmessage(avs_mrtr_warning)
                    end
                    else if pos(ansistring(\'avs_rpinnacle: could not find\'), smessage)=1 then
                    begin
                      if not disableshowmessage then showmessage(pinnacle_warning + #10 + string(smessage));
                      sysutils.forcedirectories(extractfilepath(application.exename) + \'logs\');
                      assignfile(tf, extractfilepath(application.exename) + \'logs\\ntpars_error.log\');
                      if fileexists(extractfilepath(application.exename) + \'logs\\ntpars_error.log\') then append(tf) else rewrite(tf);
                      write(tf, formatdatetime(\'yyyymmdd hh:nn:ss \', now));
                      write(tf, smessage);
                      write(tf, \' \');
                      writeln(tf, stitle);
                      closefile(tf);
                    end
                    else
                    begin
                      if not disableshowmessage then showmessage(avs_error_msg);
                      sysutils.forcedirectories(extractfilepath(application.exename) + \'logs\');
                      assignfile(tf, extractfilepath(application.exename) + \'logs\\ntpars_error.log\');
                      if fileexists(extractfilepath(application.exename) + \'logs\\ntpars_error.log\') then append(tf) else rewrite(tf);
                      write(tf, formatdatetime(\'yyyymmdd hh:nn:ss \', now));
                      write(tf, smessage);
                      write(tf, \' \');
                      writeln(tf, stitle);
                      closefile(tf);
                      application.terminate;
                      exit;
                    end;
                    dec(form1timer1enabled);
                  end;",
// Sentence 039
                  "procedure tform1.fixdirectory(var f: string);
                  var
                    i1, j1, i2, j2: integer;
                  begin
                    i1 := 0;
                    repeat
                      j1 := i1;
                      i1 := posex(\'\\patient_\', lowercase(paramstr2), i1+1);
                    until i1=0;
                    i2 := 0;
                    repeat
                      j2 := i2;
                      i2 := posex(\'\\patient_\', lowercase(f), i2+1);
                    until i2=0;
                    if (j1=0) or (j2=0) then exit;
                    f := copy(paramstr2, 1, j1-1) + copy(f, j2, 1000);
                  end;",
// Sentence 040
                  "procedure tform1.activesettingsdblclick(sender: tobject);
                  var r: integer;
                      s: string;
                  begin
                    s := \'\';
                    for r:=0 to (sender as tlistview).items.count-1 do
                    begin
                      s := s + (sender as tlistview).items[r].caption + #9;
                      s := s + (sender as tlistview).items[r].subitems.strings[0] + #9;
                      s := s + (sender as tlistview).items[r].subitems.strings[1] + #9;
                      s := s + (sender as tlistview).items[r].subitems.strings[2] + #9;
                      s := s + (sender as tlistview).items[r].subitems.strings[3];
                      s := s + #13#10;
                    end;
                    clipboard.astext := s;
                    showmessage(message_copiedtexttoclpbrd);
                  end;",
// Sentence 041
                  "procedure tform1.handlelvcolor(sender: tcustomlistview; item: tlistitem;
                      state: tcustomdrawstate; var defaultdraw: boolean);
                  var
                    lv: tlistview;
                    c: tcolor;
                  begin
                    c := clblack;
                    if pos(\' (default)\', item.subitems[1])\>0 then c := clblue;
                    if pos(\'.xvi\', item.subitems[2])\>0 then c := clred;
                    lv := tlistview(item.listview);
                    if lv.canvas.font.color \<\> c then
                      lv.canvas.font.color := c;
                  end;",
// Sentence 042
                  "procedure tform1.populatelistview(lv: tlistview);
                  var
                    i: integer;
                    li: tlistitem;
                    id: tinidetails;
                  begin
                    lv.items.clear;
                    for i := 0 to gquerylist.count - 1 do
                    begin
                      li := lv.items.add;
                      li.caption := gquerylist[i];
                      id := tinidetails(gquerylist.objects[i]);
                      li.subitems.add(id.datatype);
                      li.subitems.add(id.value);
                      li.subitems.add(id.source);
                      li.subitems.add(id.candidates);
                      li.subitems.add(id.files);
                    end;
                  end;",
// Sentence 043
                  "procedure tform1.popupmenumarkerspopup(sender: tobject);
                  begin
                    popupmenumarkers.items[1].enabled := not readonly;
                    popupmenumarkers.items[3].enabled := not readonly;
                  end;",
// Sentence 044
                  "procedure tform1.updatequerylist(inifile: tinifiles);
                  var
                    sc: tinidetails;
                    j: integer;
                    i: integer;
                  begin
                    for i := 0 to inifile.querylist.count - 1 do
                    begin
                      j := gquerylist.indexof(inifile.querylist[i]);
                      if j \< 0 then
                        sc := tinidetails.create
                      else
                        sc := tinidetails(gquerylist.objects[j]);
                      sc.value := tinidetails(inifile.querylist.objects[i]).value;
                      sc.source := tinidetails(inifile.querylist.objects[i]).source;
                      sc.datatype := tinidetails(inifile.querylist.objects[i]).datatype;
                      sc.candidates := tinidetails(inifile.querylist.objects[i]).candidates;
                      sc.files := tinidetails(inifile.querylist.objects[i]).files;
                      if j \< 0 then
                      begin
                        if (pos(\',\', sc.candidates) = 0) and (pos(\',\', inifile.querylist[i]) = 0) then
                          gquerylist.addobject(sc.candidates + \',\' + inifile.querylist[i], sc)
                        else
                          gquerylist.addobject(inifile.querylist[i], sc);
                      end;
                    end;
                  end;",
// Sentence 045
                  "procedure tform1.preparesettingsform(var lv: tlistview);
                  begin
                    if not assigned(gactivesettingsform) then
                    begin
                      gquerylist := tstringlist.create;
                      gquerylist.sorted := true;
                      gquerylist.duplicates := dupignore;
                      gactivesettingsform := tform.create(application);
                      gactivesettingsform.caption := \'settings\';
                      gactivesettingsform.position := poscreencenter;
                      gactivesettingsform.width := screen.width - 200;
                      gactivesettingsform.height := screen.height - 200;
                      lv := tlistview.create(gactivesettingsform);
                      lv.align := alclient;
                      lv.parent := gactivesettingsform;
                      lv.viewstyle := vsreport;
                      lv.rowselect := true;
                      lv.columns.add;
                      lv.columns.add;
                      lv.columns.add;
                      lv.columns.add;
                      lv.columns.add;
                      lv.columns.add;
                      lv.columns[0].caption := \'name\';
                      lv.columns[1].caption := \'type\';
                      lv.columns[2].caption := \'value\';
                      lv.columns[3].caption := \'source\';
                      lv.columns[4].caption := \'candidates\';
                      lv.columns[5].caption := \'files\';
                      lv.ondblclick := activesettingsdblclick;
                    end
                    else
                      lv := gactivesettingsform.controls[0] as tlistview;
                  end;",
// Sentence 046
                  "procedure tform1.activesettingstolistview(inifile: tinifiles; bupdatelistview: boolean);
                  var
                    lv: tlistview;
                  begin
                    preparesettingsform(lv);
                    updatequerylist(inifile);
                    if bupdatelistview then
                    begin
                      lv.columns[0].width :=  50;
                      lv.columns[1].width :=  50;
                      lv.columns[2].width := 250;
                      lv.columns[3].width :=  50;
                      lv.columns[4].width :=  50;
                      lv.columns[5].width :=  50;
                      populatelistview(lv);
                      lv.columns[0].width :=  -1;
                      lv.columns[1].width :=  -1;
                      lv.columns[2].width := 250;
                      lv.columns[3].width :=  -1;
                      lv.columns[4].width :=  -1;
                      lv.columns[5].width :=  -1;
                      lv.oncustomdrawitem := handlelvcolor;
                    end;
                  end;",
// Sentence 047
                  "procedure tform1.showactivesettings(sender: tobject);
                  begin
                    activesettingstolistview(inifile, true);
                    gactivesettingsform.showmodal;
                  end;",
// Sentence 048
                  "procedure removealltempdbfiles(const path: string);
                  var
                    searchrec: tsearchrec;
                    spath: string;
                    ires: integer;
                  begin
                    spath := includetrailingpathdelimiter(path);
                    ires := findfirst(spath + \'_qsql*.dbf\', not fadirectory, searchrec);
                    while ires = 0 do
                    begin
                      deletefile(spath + searchrec.name);
                      ires := findnext(searchrec);
                    end;
                    findclose(searchrec);
                  end;",
// Sentence 049
                  "function sqlformatted(const wherelist: tstringlist): string;
                  var
                    i: integer;
                  begin
                    result := \'\';
                    for i:=0 to wherelist.count-1 do
                    begin
                      if length(trim(wherelist[i]))\>0 then
                        result := result + trim(wherelist[i]) + \' and \'
                    end;
                    if length(result)\>0 then
                    begin
                      delete(result, length(result)-4, 5);
                      if length(result)\>0 then
                        result := \'where \' + result;
                    end;
                  end;",
// Sentence 050
                  "procedure tform1.createtablesandqueries(sqldatasource: string);
                  begin
                    freeandnil(tabledbid);
                    freeandnil(tablepatients);
                    freeandnil(tableports);
                    freeandnil(tableprocedure);
                    freeandnil(tabletreatments);
                    freeandnil(queryscans);
                    freeandnil(queryframes);
                    freeandnil(queryoffsets);
                    freeandnil(queryscandetails);
                    freeandnil(queryframedetails);
                    freeandnil(queryoffsetframes);
                    freeandnil(queryimages);
                  end;",
// Sentence 051
                  "procedure tform1.formcreate(sender: tobject);
                  var
                    i, j           : integer;
                    reg            : tregistry;
                    tmpstr         : array [0..255] of char;
                    s, stationname : string;
                    h              : tqinifile;
                    guirefreshinterval: integer;
                    query: tabstractquery;
                    rtdatasourceinifile: trtdatasourceinifile;
                  begin
                    timer1.enabled := false;
                    form1 := self;
                    screenlayoutmode  := 0;
                    screenlayoutratio1:= 0.48;
                    screenlayoutratio2:= 0.52;
                    activated         := false;
                    levels[0] := 0;
                    levels[1] := 0;
                    levels[2] := 0;
                    levels[3] := 0;
                    restore1.enabled := false;
                    if not xviischildwindow then
                    begin
                      paramstr1 := paramstr(1);
                      paramstr2 := paramstr(2);
                      paramcnt  := paramcount;
                    end;
                    setavsmessagehandler(avsmessagehandler);
                    decimalseparator := \'.\';
                    try
                      if loadnewresourcemodule(english) \<\> 0 then
                        reinitializeforms;
                    finally
                    end;
                    if not xviischildwindow then
                    begin
                      top       := 0;
                      left      := 0;
                      if abs(font.height)\<\>11 then
                      begin
                        width     := round(1007*abs(form1.font.height)/11);
                        height    := round(815*abs(form1.font.height)/11);
                      end
                      else
                      begin
                        width     := round(1047*abs(form1.font.height)/11);
                        height    := round(856*abs(form1.font.height)/11);
                        windowstate := wsnormal;
                      end;
                      if width\<screen.width then
                        constraints.minwidth  := width;
                      if height\<screen.height then
                        constraints.minheight := height;
                    end
                    else
                    begin
                      constraints.minwidth  := 100;
                      constraints.minheight := 100;
                    end;
                    gettemppath(255, @tmpstr);
                    tempdir := tmpstr;
                    reg := tregistry.create;
                    reg.rootkey := hkey_local_machine;
                    if reg.openkey(\'hardware\\description\\system\\centralprocessor\\1\', false) then
                    begin
                      checkboxmultithread.checked := true;
                      reg.closekey;
                    end
                    else
                    begin
                      checkboxmultithread.checked := false;
                      checkboxmultithread.enabled := false;
                    end;
                    reg.free;
                    h := tqinifile.create(getfullinifilename(\'datasources.ini\'));
                    datasource := h.readstring(\'xvi\', \'device\', \'\');
                    h.free;
                    i := pos(\':\', datasource);
                    if i\>0 then
                    begin
                      datatype := uppercase(copy(datasource, 1, i-1));
                      datapath := copy(datasource, i+1, 250);
                      if datapath[length(datapath)]\<\>\'\\\' then datapath := datapath + \'\\\';
                    end;
                    avlstate := 0;
                    if (paramcnt = 2) then
                    begin
                      if (strtointdef(paramstr1, -1) in [1..6]) and
                         (uppercase(extractfileext(paramstr2))=\'.ini\') then
                        avlstate := strtointdef(paramstr1, -1);
                    end
                    else if (uppercase(extractfileext(paramstr1))=\'.ini\') then
                      avlstate := 0;
                    if avlstate\<0 then
                    begin
                      h := tqinifile.create(getfullinifilename(\'xvi.ini\'));
                      s := h.readstring(\'xvi\', \'localinifilename\', \'\');
                      h.free;
                      inifile := tinifiles.create([getfullinifilename(\'xvi.ini\'), s]);
                    end
                    else
                      inifile := tinifiles.create([paramstr2 + \'.xvi\', paramstr2]);
                    if paramstr2=paramstr1 then avlstate := inifile.readinteger(\'xvi\', \'avlstate\', 0);
                    if avlstate\<\>inifile.readinteger(\'xvi\', \'avlstate\', -1) then
                    begin
                      if avlstate=6 then reconterminate(false, error_inifile)
                      else
                      begin
                        showmessage(error_inifile);
                        application.terminate;
                      end;
                    end;
                    admincount := inifile.readinteger(\'xvi\', \'admincount\', 0);
                    if inifile.readbool(\'xvi\', \'profile\', false) then
                    begin
                      appstarttime := now;
                      quirtavstrace(\'\');
                    end;
                    reconstructlatestscan:=inifile.readbool(\'xvi\', \'reconstructlatestscan\', false);
                    loadlatestalignment  :=inifile.readbool(\'xvi\', \'loadlatestalignment\', false);
                    readonly := inifile.readbool(\'xvi\', \'readonly\', false);
                    buttonelektaaccept.enabled := not readonly;
                    exitaccept1.enabled := buttonelektaaccept.enabled;
                    complabprec := 2;
                    if avlstate\<0 then
                    begin
                      lastdb              := inifile.readstring(\'xvi\', \'lastdb\', \'\');
                      lastdb              := inifile.readstring(\'xvi\', \'maindb\', lastdb);
                      if (paramcnt \> 1) then cmddb := paramstr2 else cmddb := \'\\\';
                      for i:=1 to 10 do
                        backupdb[i] := inifile.readstring(\'xvi\', \'backupdb\'+inttostr(i), \'\');
                      setlength(jukeboxbase,10);
                      for i:=0 to 9 do
                      begin
                        jukeboxbase[i] := inifile.readstring(\'xvi\', \'jukeboxdirectory\'+inttostr(i+1), \'\');
                        if jukeboxbase[i] = \'\' then
                        begin
                          jukeboxbase := copy(jukeboxbase,0,max(1,i));
                          break;
                        end
                      end;
                      if (jukeboxbase[0] = \'\') then
                        jukeboxbase[0]        := inifile.readstring(\'xvi\', \'jukeboxdirectory\', \'\');
                      jukeboxreadproj    := inifile.readbool(\'xvi\', \'jukeboxreadproj\', false);
                      if (cmddb[length(cmddb)] = \'\\\') then delete(cmddb, length(cmddb), 1);
                      lastdb := excludetrailingpathdelimiter(lastdb);
                      if fileexists(cmddb+\'\\dbid.dbf\') then
                        edit1.text := cmddb
                      else
                        edit1.text := lastdb;
                      nframedb := inifile.readinteger(\'xvi\', \'nframedb\', 1);
                      sqldatasource  := inifile.readstring(\'xvi\', \'sqldatasource\', \'\');
                      sqllogin       := inifile.readstring(\'xvi\', \'sqllogin\',      \'\');
                      sqlpassword    := inifile.readstring(\'xvi\', \'sqlpassword\',   \'\');
                      queryscanswhere := tstringlist.create;
                      fakeimporturl := inifile.readstring(\'xvi\', \'fakeimporturl\', \'[xvi]:\');
                      if fakeimporturl \<\> \'[xvi]:\' then
                      begin
                        s:=fakeimporturl;
                        i:= pos(\'[\', s);
                        s:= copy(s, i+1, 250);
                        i:= pos(\']\', s);
                        s:= copy(s, 1, i-1);
                        rtdatasourceinifile := trtdatasourceinifile.create();
                        importdatatype := rtdatasourceinifile.device(s);
                        importdatapath := rtdatasourceinifile.datapath(s);
                        rtdatasourceinifile.free;
                        if length(importdatapath)\>0 then
                        begin
                          if importdatapath[length(importdatapath)]\<\>\'\\\' then importdatapath := importdatapath + \'\\\';
                        end
                        else
                        begin
                          importdatatype := datatype;
                          importdatapath := datapath;
                        end;
                      end;
                    end;
                    runtableshift       := inifile.readstring(\'xvi\', \'runtableshift\', \'\');
                    bad                       := tavsfield.create;
                    offset                    := tavsfield.create(bad);
                    gain                      := tavsfield.create(bad);
                    bowtie                    := tavsfield.create(bad);
                    offset2                   := tavsfield.create(bad);
                    gain2                     := tavsfield.create(bad);
                    bowtie2                   := tavsfield.create(bad);
                    gfmultianglegain          := tavsfield.create(bad);
                   caldirlist   := tstringlist.create;
                    avlflexmapmode := false;
                    bonematchdoubtthreshold := inifile.readfloat(\'xvi\', \'bonematchdoubtthreshold\', 2.0);
                    seedmatchdoubtthreshold := inifile.readfloat(\'xvi\', \'seedmatchdoubtthreshold\', 2.0);
                    projectionsinverted := inifile.readbool(\'xvi\', \'projectionsinverted\', true);
                    begin
                      projectionscalibrated := inifile.readinteger(\'reconstruction\', \'projectionscalibrated\', 0);
                      offsetfilename     := inifile.readstring(\'reconstruction\', \'offsetfile\',    \'\');
                      gainfilename       := inifile.readstring(\'reconstruction\', \'gainfile\',      \'\');
                      gainfilename       := inifile.readstring(\'reconstruction\', \'gainfileopen\', gainfilename);
                      gainbowtiefilename := inifile.readstring(\'reconstruction\', \'gainfilebowtie\',\'\');
                      badmapfilename     := inifile.readstring(\'reconstruction\', \'badmapfile\',    \'\');
                      readcorrectionimages(gain, offset, bad, bowtie);
                    end;
                    checkboxmultithread.checked := inifile.readbool(\'xvi\', \'multithreaded\', true) and checkboxmultithread.enabled;
                    checkboxmedian.checked      := inifile.readbool(\'xvi\', \'medianfilter\', false);
                    skipcolumnsleft             := inifile.readinteger(\'xvi\', \'skipcolumnsleft\',  0);
                    skipcolumnsright            := inifile.readinteger(\'xvi\', \'skipcolumnsright\', 0);
                    skiprowstop                 := inifile.readinteger(\'xvi\', \'skiprowstop\',  0);
                    skiprowsbottom              := inifile.readinteger(\'xvi\', \'skiprowsbottum\', 0);
                    skiprowsbottom              := inifile.readinteger(\'xvi\', \'skiprowsbottom\', skiprowsbottom);
                    fastcorrectimage            := inifile.readbool   (\'xvi\', \'fastcorrectimage\', false);
                    fastcorrectimagescale       := inifile.readinteger(\'xvi\', \'fastcorrectimagescale\', 4);
                    correctfor0xffffpixelbug    := inifile.readbool   (\'xvi\', \'correctfor0xffffpixelbug\', false);
                    editprojectionimageresolution.text    := \'256\';
                    editreconstructedimageresolution.text := \'256\';
                    editreconstructionsize.text           := format(\'%.1f\', [25.6]);
                    editgainimage.text                    := gainfilename;
                    editoffsetimage.text                  := offsetfilename;
                    edituseints.text                      := inttostr(2);
                    editinterpolate.text                  := inttostr(2);
                    editscale.text                        := floattostr(420);
                    useonlinereconstruction := false;
                    editfp0.text      := format(\'%.2f\', [inifile.readfloat(\'xvi\', \'fp0\', 0.7)]);
                    editfp1.text      := format(\'%.2f\', [inifile.readfloat(\'xvi\', \'fp1\', 90)]);
                    editspr.text      := \'0.33\';
                    editghost.text    := \'0.989\'; editghost.visible := false; label19.visible := false;
                    editghostampl.text:= \'0\'; ;   editghostampl.visible := false;
                    editgainimage.readonly   := true;
                    editoffsetimage.readonly := true;
                    inplanerotationcorrectionangle :=
                      inifile.readfloat(\'xvi\', \'inplanerotationcorrectionangle\', 0);
                    iec_angle_convention := inifile.readbool(\'xvi\', \'iecangleconvention\', false);
                    iec_linear_convention := inifile.readinteger(\'xvi\', \'ieclinearconvention\', 1);
                    nameof6dofsystem     := inifile.readstring(\'xvi\', \'nameof6dofsystem\', \'\');
                    nameof3dofsystem     := inifile.readstring(\'xvi\', \'nameof3dofsystem\', \'precision couch\');
                    b6dofsystemhascrp    := inifile.readbool(\'xvi\', \'6dofsystemhascrp\', false);
                    matchrotmark := false;
                    matchprerotate := false;
                    match4dsingleframe := false;
                    appliedcorrectionprotocol := \'\';
                    appliedcorrectionfrom     := \'\';
                    appliedcorrectionby       := \'\';
                    appliedclipboxmatchmethod := \'\';
                    appliedmaskmatchmethod    := \'\';
                    correctionapprovalby := \'\';
                    correctionapproved := -1;
                    f                         := tavsfield.create(bad);
                    phase                     := tavsfield.create(bad);
                    phasehist                 := tavsfield.create(bad);
                    carm                      := tavsfield.create(bad);
                    doseaccu                  := tavsfield.create(bad);
                    doseacculut               := tavsfield.create(bad);
                    clipboxlist := tavsfield.create(bad);
                    clipboxlist.debugname := \'clipboxlist\';
                    cbnames := tstringlist.create ;
                    for i := 1 to nclipbox do
                    begin
                      clipbox[i]             := tavsfield.create;
                      clipbox[i].debugname := \'clipbox[\' + inttostr(i) + \']\';
                      cbnames.add(clipbox[i].debugname);
                      cbweights[i] := 1.0 ;
                      quirtviewerupdcoronal.clipboxtext[i] := tupdatablestring.create;
                      quirtviewerupdsagittal.clipboxtext[i]    := quirtviewerupdcoronal.clipboxtext[i];
                      quirtviewerupdtransversal.clipboxtext[i] := quirtviewerupdcoronal.clipboxtext[i];
                      quirtviewerupdcoronal.clipboxtext[i].owner := self;
                      quirtviewerupdcoronal.clipboxtext[i].locked := true ;
                      clipboxlist.adddependency(clipbox[i]);
                      clipboxlist.adddependency(quirtviewerupdcoronal.clipboxtext[i]);
                    end;
                    clipboxlist.onupdate := updateclipboxlist;
                    transform4d               := tavsfield.create(bad);
                    backuptransform4d         := tavsfield.create(bad);
                    vistransform4d            := tavsfield.create(bad);
                    vistransform4d2           := ttransform.create;
                    vistransform4d2.clear;
                    delineationdots           := tavsfield.create(bad);
                    delineationindex          := tavsfield.create(bad);
                    delineationdotslut        := tavsfield.create(bad);
                    delineationtransform      := tavsfield.create(bad);
                    warpvectors               := tavsfield.create(bad);
                    beamdots                  := tavsfield.create(bad);
                    beamindex                 := tavsfield.create(bad);
                    beamlut                   := tavsfield.create(bad);
                    beamtransform             := tavsfield.create(bad);
                    maskedreference           := tavsfield.create(bad);
                    referencemask             := tavsfield.create(bad);
                    maskedreferencelut        := tavsfield.create(bad);
                    maskedreferencetransform  := tavsfield.create(bad);
                    for i := 1 to nclipbox do
                    begin
                      mask_cog[i]             := tavsfield.create(bad);
                      field_create(mask_cog[i], \'field 1d 3-space 0-vector irregular float\', 3);
                      mask_cog[i].coordinate[0,0] := -9999;
                      mask_cog[i].coordinate[1,0] := -9999;
                      mask_cog[i].coordinate[2,0] := -9999;
                      if i=1 then
                      begin
                        mask_cog[i].adddependency(maskedreference);
                        mask_cog[i].onupdate := update_mask_cog;
                      end;
                    end;
                    machine_to_machineadjust    := ttransform.create;
                    machine_to_machineadjust.debugname := \'machine_to_machineadjust\';
                    prevmachine_to_machineadjust:= ttransform.create;
                    oldmachine_to_machineadjust := tavsfield.create(bad);
                    machine_to_machineadjustwarpi:= tavsfield.create(bad);
                    externalwarp :=                 tavsfield.create(bad);
                    viewwarp:= tavsfield.create(bad);
                    machine_to_siddon           := ttransform.create;
                    f_cbctmarkers             := tavsfield.create(bad);
                    chamferdots               := tavsfield.create(bad);
                    chamferdotslut            := tavsfield.create(bad);
                    field_create(chamferdotslut, \'field 1d 4-vector byte\', 1);
                    chamferdotsonline               := tavsfield.create(bad);
                    chamferdotslutonline            := tavsfield.create(bad);
                    field_create(chamferdotslutonline, \'field 1d 5-vector byte\', 1);
                    chamferdotslutreference            := tavsfield.create(bad);
                    field_create(chamferdotslutreference, \'field 1d 5-vector byte\', 1);
                    chamferdotsreference               := tavsfield.create(bad);
                    chamferdotsreference.adddependency(referencemask);
                    chamferdotsreference.onupdate      := updatechamferdotsreference;
                    visboneseg(false);
                    reversemotion := tupdatableinteger.create(bad);
                    transformdisplaymode := tupdatableinteger.create(bad);
                    alignmentmode := tupdatableinteger.create(bad);
                    activeregion := tupdatableinteger.create(bad);
                    maskactiveregion := tupdatableinteger.create(bad);
                    comboboxregistrationprotocol.itemindex := 0;
                    btncorrectionby.visible := false;
                    btncorrectionby.enabled := false;
                    comboboxcorrectionby.itemindex := 0;
                    comboboxcorrectionby.visible := (nameof6dofsystem\<\>\'\');
                    label21.visible := (nameof6dofsystem\<\>\'\');
                    comboboxcorrectionby.clear;
                    comboboxcorrectionby.add(nameof3dofsystem, [nameof3dsystemmappedtext]);
                    if nameof6dofsystem\<\>\'\' then
                      comboboxcorrectionby.add(nameof6dofsystem, [nameof6dsystemmappedtext]);
                    compressionmode := inifile.readinteger(\'xvi\', \'compressionmode\',  2);
                    avicodec := inifile.readstring(\'xvi\', \'avicodec\',  \'vidc\');
                    cbctonline := tscan.create(self);
                    dtsonline := tscan.create(self);
                    cbctreference := tscan.create(self);
                    dtsreference := tscan.create(self);
                    for i:=1 to high(online)    do online[i]    := tscan.create(self);
                    for i:=1 to high(reference) do reference[i] := tscan.create(self);
                    for i:=1 to high(dose)      do dose[i]      := tscan.create(self);
                    online[1].link := cbctonline;
                    reference[1].link := cbctreference;
                    for i:=1 to high(online)    do online[i].compressionlevel := compressionmode;
                    for i:=1 to high(reference) do reference[i].compressionlevel := compressionmode;
                    for i:=1 to high(dose)      do dose[i].compressionlevel := compressionmode;
                    online[1].fieldname    := viewer_cbct;
                    reference[1].fieldname := viewer_ref;
                    dose[1].fieldname      := viewer_dose;
                    for i:=2 to high(online)    do online[i].fieldname    := viewer_cbct + inttostr(i);
                    for i:=2 to high(reference) do reference[i].fieldname := viewer_ref  + inttostr(i);
                    for i:=2 to high(dose)      do dose[i].fieldname      := viewer_dose + inttostr(i);
                    onlinecube           := online[1].data;
                    online_to_machine    := online[1].tomachine;
                    referencecube        := reference[1].data;
                    reference_to_machine := reference[1].tomachine;
                    reference_to_patient := reference[1].topatient;
                    reference_to_siddon  := reference[1].tosiddon;
                    dosecube             := dose[1].data;
                    dose_to_machine      := dose[1].tomachine;
                    dose_to_siddon       := dose[1].tosiddon;
                    doselut              := dose[1].lut;
                    readcorrectionimages(gain, offset, bad, bowtie);
                    online_to_machine.makerotation(270, 0, 270);
                    savetoquirt     := false;
                    needloadmatch := false ;
                    panelplanselectprepare.visible := false;
                    comboboxfiltertype.items.clear;
                    comboboxfiltertype.items.add(\'none\');
                    comboboxfiltertype.items.add(\'enhance\');
                    comboboxfiltertype.items.add(\'extract\');
                    comboboxfiltertype.items.add(\'unsharp mask\');
                    comboboxfiltertype.items.add(\'umask + hismod\');
                    comboboxfiltertype.itemindex:=0;
                    if avlstate\<0 then
                    begin
                      createtablesandqueries(sqldatasource);
                      if assigned(queryscans) then
                      begin
                        if queryscans is tabstractquery then
                          (queryscans as tabstractquery).datasource := datasourceports
                        else
                          (queryscans as tabstracttable).mastersource := datasourceports;
                        queryscansselect := \'select img_date,img_time,kv,ma,kvlength,fov,patimg.dbid,patimg.dicom_uid from patimg,patimg_k\';
                        queryscanswhere.clear;
                        queryscanswhere.add(\'patimg.dbid=patimg_k.pimg_dbid\');
                        queryscanswhere.add(\'patimg_k.type!=68\');
                        queryscanswhere.add(\'patimg.port_dbid = :dbid\');
                        queryscansorder := \'order by img_date, img_time\';
                    if queryscans is tabstractquery then
                        begin
                          query := queryscans as tabstractquery;
                          query.sql.clear;
                          query.sql.add(queryscansselect);
                          query.sql.add(sqlformatted(queryscanswhere));
                          query.sql.add(queryscansorder);
                        end;
                      end;
                      if queryoffsets is tabstractquery then
                        (queryoffsets as tabstractquery).datasource := datasourceports
                      else
                        (queryoffsets as tabstracttable).mastersource := datasourceports;
                      if queryoffsets is tabstractquery then
                      begin
                        query := queryoffsets as tabstractquery;
                        query.sql.clear;
                        query.sql.add(\'select img_date,img_time,patimg.dbid,patimg.dicom_uid from patimg,patimg_k where\');
                        query.sql.add(\'patimg.dbid=patimg_k.pimg_dbid and patimg_k.type=68 and patimg.port_dbid = :dbid\');
                        query.sql.add(\'order by img_time\');
                      end;
                      if queryscandetails is tabstractquery then
                        (queryscandetails as tabstractquery).datasource := datasourcescansquery
                      else
                        (queryscandetails as tabstracttable).mastersource := datasourcescansquery;
                      if queryscandetails is tabstractquery then
                      begin
                        query := queryscandetails as tabstractquery;
                        query.sql.clear;
                        query.sql.add(\'select * from patimg_k where\');
                        query.sql.add(\'patimg_k.pimg_dbid=:dbid\');
                      end;
                      if assigned(queryframes) then
                      begin
                        if queryframes is tabstractquery then
                          (queryframes as tabstractquery).datasource := datasourcescansquery
                        else
                          (queryframes as tabstracttable).mastersource := datasourcescansquery;
                        if queryframes is tabstractquery then
                        begin
                          query := queryframes as tabstractquery;
                          query.sql.clear;
                          query.sql.add(\'select * from frame where\');
                          query.sql.add(\'frame.pimg_dbid=:dbid\');
                          query.sql.add(\'order by seq_num\');
                        end;
                      end;
                      if queryframedetails is tabstractquery then
                        (queryframedetails as tabstractquery).datasource := datasourceframes
                      else
                        (queryframedetails as tabstracttable).mastersource := datasourceframes;
                      if queryframedetails is tabstractquery then
                      begin
                        query := queryframedetails as tabstractquery;
                        query.sql.clear;
                        query.sql.add(\'select * from frame_k where\');
                        query.sql.add(\'frame_k.frm_dbid=:dbid\');
                      end;
                      if queryoffsetframes is tabstractquery then
                        (queryoffsetframes as tabstractquery).datasource := datasourceoffsetsquery
                      else
                        (queryoffsetframes as tabstracttable).mastersource := datasourceoffsetsquery;
                      if queryoffsetframes is tabstractquery then
                      begin
                        query := queryoffsetframes as tabstractquery;
                        query.sql.clear;
                        query.sql.add(\'select * from frame where\');
                        query.sql.add(\'frame.pimg_dbid=:dbid\');
                      end;
                      if queryimages is tabstractquery then
                      begin
                        query := queryimages as tabstractquery;
                        query.sql.clear;
                        query.sql.add(\'select * from patimg\');
                        query.sql.add(\'order by dicom_uid\');
                      end;
                    end;
                    application.hinthidepause := inifile.readinteger(\'xvi\', \'hinthidepauselength\', 2500);
                    if inifile.readbool(\'xvi\', \'runmaximized\', false) then
                      windowstate := wsmaximized;
                   if (inifile.readinteger(\'xvi\', \'starttab\', 1) \>= 0) and
                       (inifile.readinteger(\'xvi\', \'starttab\', 1) \< pagecontrol1.pagecount)
                    then pagecontrol1.activepageindex := inifile.readinteger(\'xvi\', \'starttab\', 1)
                    else pagecontrol1.activepageindex := 1;
                    tabsheet1.tabvisible := inifile.readbool(\'xvi\', \'elektadatabasesheetvisible\', true);
                    tabsheet2.tabvisible := inifile.readbool(\'xvi\', \'imageselectionsheetvisible\', true);
                    tabsheet1.tabvisible := false;
                    tabsheet2.tabvisible := false;
                    groupbox1.visible := inifile.readbool(\'xvi\', \'reconstructiongroupvisible\', true);
                    groupbox5.visible := inifile.readbool(\'xvi\', \'displaygroupvisible\', true);
                    groupbox6.visible := inifile.readbool(\'xvi\', \'calibrationgroupvisible\', true);
                    statusbar1.panels[0].text := inifile.readstring(\'xvi\', \'statuslinetext\', \'\');
                    statusbar1.visible := statusbar1.panels[0].text\<\>\'\';
                    showmatchresultsdetailsgreyvalue := inifile.readbool(\'xvi\', \'showmatchresultsdetailsgreyvalue\', true);
                    showmatchresultsdetailsbone := inifile.readbool(\'xvi\', \'showmatchresultsdetailsbone\', true);
                    showmatchresultsdetails     := inifile.readbool(\'xvi\', \'showmatchresultsdetails\', false);
                    if (avlstate\<=0) and not pagecontrol1.pages[1].tabvisible then
                    begin
                      pagecontrol1.tabheight := 1;
                      pagecontrol1.tabwidth  := 1;
                    end;
                    if true then
                    begin
                      popupmenueditmask.items[0].clear;
                      trackbartranslationlr.visible:= false;
                      trackbartranslationap.visible:= false;
                      trackbartranslationcc.visible:= false;
                      trackbarrotationlr.visible:= false;
                      trackbarrotationap.visible:= false;
                      trackbarrotationcc.visible:= false;
                      edittranslationlr.left := edittranslationlr.left - trackbartranslationlr.width + 20 - 5;
                      edittranslationcc.left := edittranslationcc.left - trackbartranslationlr.width + 20 - 5;
                      edittranslationap.left := edittranslationap.left - trackbartranslationlr.width + 20 - 5;
                      edittranslationlr.width := edittranslationlr.width + 10;
                      edittranslationcc.width := edittranslationcc.width + 10;
                      edittranslationap.width := edittranslationap.width + 10;
                      updowntranslationlr.left := updowntranslationlr.left - trackbartranslationlr.width + 30 - 5;
                      updowntranslationcc.left := updowntranslationcc.left - trackbartranslationlr.width + 30 - 5;
                      updowntranslationap.left := updowntranslationap.left - trackbartranslationlr.width + 30 - 5;
                      editrotationlr.left := editrotationlr.left - trackbarrotationlr.width + 20 - 5;
                      editrotationap.left := editrotationap.left - trackbarrotationlr.width + 20 - 5;
                      editrotationcc.left := editrotationcc.left - trackbarrotationlr.width + 20 - 5;
                      updownrotationlr.left := updownrotationlr.left - trackbarrotationlr.width + 20 - 5;
                      updownrotationap.left := updownrotationap.left - trackbarrotationlr.width + 20 - 5;
                      updownrotationcc.left := updownrotationcc.left - trackbarrotationlr.width + 20 - 5;
                      updownrotationlr.visible := true;
                      updownrotationap.visible := true;
                      updownrotationcc.visible := true;
                      panelelektacouchshift.visible := true;
                      panelnkicouchshift.visible := false;
                      comboboxmaskmatch.left := comboboxclipboxmatch.left;
                      comboboxmaskmatch.top := comboboxclipboxmatch.top;
                      comboboxsummarytype.top := comboboxclipboxmatch.top;
                      comboboxsummarytype.itemindex := 0;
                      panelelektamode.visible := true;
                    end;
                    if avlstate\>0 then
                    begin
                      buttonreconstruct.visible := false;
                      comboboxprotocol.visible := false;
                      buttonclinicalpatient.visible := false;
                      checkboxenablerotation.visible := false;
                      buttontoreference.visible := false;
                      buttonexport.visible := false;
                      buttonloadscan.visible := false;
                      buttonsavescan.visible := false;
                      updown1.visible := false;
                      menushowunlockpresentclipbox.visible := false;
                    end;
                    memo1.scrollbars := ssvertical;
                      about1.caption := menu_about1_caption;
                      bitbtnaverage4d.caption := button_bitbtnaverage4d_caption;
                      bitbtnaverage4d.hint := button_bitbtnaverage4d_hint;
                      bitbtnaverage4dtransform.caption := button_bitbtnaverage4dtransform_caption;
                      bitbtnaverage4dtransform.hint := button_bitbtnaverage4dtransform_hint;
                      bitbtnback4d.caption := button_bitbtnback4d_caption;
                      bitbtnback4d.hint := button_bitbtnback4d_hint;
                      bitbtndismisscorrection.caption := button_bitbtndismisscorrection_caption;
                      bitbtndismisscorrection.hint := button_bitbtndismisscorrection_hint;
                      bitbtnfwd4d.caption := button_bitbtnfwd4d_caption;
                      bitbtnfwd4d.hint := button_bitbtnfwd4d_hint;
                      bitbtngreenpurplecut.caption := button_bitbtngreenpurplecut_caption;
                      bitbtngreenpurplecut.hint := button_bitbtngreenpurplecut_hint;
                      bitbtnlock.caption := button_bitbtnlock_caption;
                      bitbtnlock.hint := button_bitbtnlock_hint;
                      bitbtnplaygreen.caption := button_bitbtnplaygreen_caption;
                      bitbtnplaygreen.hint := button_bitbtnplaygreen_hint;
                      bitbtnplaypurple.caption := button_bitbtnplaypurple_caption;
                      bitbtnplaypurple.hint := button_bitbtnplaypurple_hint;
                      bitbtnpresetlevelwindows.caption := button_bitbtnpresetlevelwindows_caption;
                      bitbtnpresetlevelwindows.hint := button_bitbtnpresetlevelwindows_hint;
                      bitbtnrefloc.caption := button_bitbtnrefloc_caption;
                      bitbtnrefloc.hint := button_bitbtnrefloc_hint;
                      bitbtnstop4d.caption := button_bitbtnstop4d_caption;
                      bitbtnstop4d.hint := button_bitbtnstop4d_hint;
                      bitbtnunlock.caption := button_bitbtnunlock_caption;
                      bitbtnunlock.hint := button_bitbtnunlock_hint;
                      bitbtnunlockprotocol.caption := button_bitbtnunlockprotocol_caption;
                      bitbtnunlockprotocol.hint := button_bitbtnunlockprotocol_hint;
                      bitbtnwarp.caption := button_bitbtnwarp_caption;
                      bitbtnwarp.hint := button_bitbtnwarp_hint;
                      button1.caption := button_button1_caption;
                      button26.caption := button_button26_caption;
                      button3d2d.caption := button_button3d2d_caption;
                      buttonacceptmatch.caption := button_buttonacceptmatch_caption;
                      buttonacceptmatch.hint := button_buttonacceptmatch_hint;
                      buttonbatchmatch.caption := button_buttonbatchmatch_caption;
                      buttonchangecalibration.caption := button_buttonchangecalibration_caption;
                      buttonclearonline.caption := button_buttonclearonline_caption;
                      buttonclearreference.caption := button_buttonclearreference_caption;
                      buttonclearreference.hint := button_buttonclearreference_hint;
                      buttonclinicalpatient.caption := button_buttonclinicalpatient_caption;
                      buttonclinicalpatient.hint := button_buttonclinicalpatient_hint;
                      buttonclipbox.caption := button_buttonclipbox_caption;
                      buttonclipbox.hint := button_buttonclipbox_hint;
                      buttonclipstats.caption := button_buttonclipstats_caption;
                      buttonconverttocorrection.caption := button_buttonconverttocorrection_caption;
                      buttonconverttocorrection.hint := button_buttonconverttocorrection_hint;
                      buttoncopytohexapod1.caption := format(button_buttoncopytohexapod1_caption, [nameof6dofsystem]);
                      buttondoseaccumulate.caption := button_buttondoseaccumulate_caption;
                      buttondoseaccumulate.hint := button_buttondoseaccumulate_hint;
                      buttonelektaaccept.caption := button_buttonelektaaccept_caption;
                      buttonelektadismiss.caption := button_buttonelektadismiss_caption;
                      buttonexport.caption := button_buttonexport_caption;
                      buttonexport.hint := button_buttonexport_hint;
                      buttonfirst.caption := button_buttonfirst_caption;
                      buttonfirst.hint := button_buttonfirst_hint;
                      buttonflexmapbb.caption := button_buttonflexmapbb_caption;
                      buttongenerateanglefiles.caption := button_buttongenerateanglefiles_caption;
                      buttongotoisoc.caption := button_buttongotoisoc_caption;
                      buttongotoisoc.hint := button_buttongotoisoc_hint;
                      buttongraphicalhelp.caption := button_buttongraphicalhelp_caption;
                      buttongraphicalhelp.hint := button_buttongraphicalhelp_hint;
                      buttonidealcatphanasref.caption := button_buttonidealcatphanasref_caption;
                      buttonidealcatphanasref.hint := button_buttonidealcatphanasref_hint;
                      buttonlast.caption := button_buttonlast_caption;
                      buttonlast.hint := button_buttonlast_hint;
                      buttonlimitinformation.caption := button_buttonlimitinformation_caption;
                      buttonlimitinformation.hint := button_buttonlimitinformation_hint;
                      buttonloadmatch.caption := button_buttonloadmatch_caption;
                      buttonloadmatch.hint := button_buttonloadmatch_hint;
                      buttonloadreference.caption := button_buttonloadreference_caption;
                      buttonloadreference.hint := button_buttonloadreference_hint;
                      buttonloadscan.caption := button_buttonloadscan_caption;
                      buttonloadscan.hint := button_buttonloadscan_hint;
                      buttonmarkers.caption := button_buttonmarkers_caption;
                      buttonmarkers.hint := button_buttonmarkers_hint;
                      buttonmask.caption := button_buttonmask_caption;
                      buttonmask.hint := button_buttonmask_hint;
                      buttonmatch.caption := button_buttonmatch_caption;
                      buttonmatch.hint := button_buttonmatch_hint;
                      buttonmatch2.caption := button_buttonmatch2_caption;
                      buttonmatch2.hint := button_buttonmatch2_hint;
                      buttonmeasureinserts.caption := button_buttonmeasureinserts_caption;
                      buttonmeasureinserts.hint := button_buttonmeasureinserts_hint;
                      buttonmovecouch.hint := button_buttonmovecouch_hint;
                      buttonnext.hint := button_buttonnext_hint;
                      buttonnextstep.caption := button_buttonnextstep_caption;
                      buttonnextstep.hint := button_buttonnextstep_hint;
                      buttonpause.caption := button_buttonpause_caption;
                      buttonpause.hint := button_buttonpause_hint;
                      buttonplay4d.caption := button_buttonplay4d_caption;
                      buttonplay4d.hint := button_buttonplay4d_hint;
                      buttonprevious.caption := button_buttonprevious_caption;
                      buttonprevious.hint := button_buttonprevious_hint;
                      buttonread4dtransform.caption := button_buttonread4dtransform_caption;
                      buttonreadmatch.caption := button_buttonreadmatch_caption;
                      buttonreconstruct.caption := button_buttonreconstruct_caption;
                      buttonreconstruct.hint := button_buttonreconstruct_hint;
                      buttonreconstructorview.caption := button_buttonreconstructorview_caption;
                      buttonreconstructorview.hint := button_buttonreconstructorview_hint;
                      buttonresetmatch.hint := button_buttonresetmatch_hint;
                      buttonroistats.caption := button_buttonroistats_caption;
                      buttonrun.caption := button_buttonrun_caption;
                      buttonrun.hint := button_buttonrun_hint;
                      buttonsavegainoffset.caption := button_buttonsavegainoffset_caption;
                      buttonsavereference.caption := button_buttonsavereference_caption;
                      buttonsavereference.hint := button_buttonsavereference_hint;
                      buttonsavescan.caption := button_buttonsavescan_caption;
                      buttonsavescan.hint := button_buttonsavescan_hint;
                      buttonscan.caption := button_buttonscan_caption;
                      buttonscan.hint := button_buttonscan_hint;
                      buttonselectlatest.caption := button_buttonselectlatest_caption;
                      buttonselectlatest.hint := button_buttonselectlatest_hint;
                      buttonsetcorrectionreferencepoint.caption := button_buttonsetcorrectionreferencepoint_caption;
                      buttonsetcorrectionreferencepoint.hint := button_buttonsetcorrectionreferencepoint_hint;
                      buttonsetdelineation.caption := button_buttonsetdelineation_caption;
                      buttonsetdelineation.hint := button_buttonsetdelineation_hint;
                      buttonsetdose.caption := button_buttonsetdose_caption;
                      buttonsetdose.hint := button_buttonsetdose_hint;
                      buttonsetplan.caption := button_buttonsetplan_caption;
                      buttonsetplan.hint := button_buttonsetplan_hint;
                      buttonsetreferencemask.caption := button_buttonsetreferencemask_caption;
                      buttonsetreferencemask.hint := button_buttonsetreferencemask_hint;
                      buttonsetroi.caption := button_buttonsetroi_caption;
                      buttonsetroi.hint := button_buttonsetroi_hint;
                      buttonsetscan.caption := button_buttonsetscan_caption;
                      buttonsetscan.hint := button_buttonsetscan_hint;
                      buttonstat.caption := button_buttonstat_caption;
                      buttonstopstep4d.caption := button_buttonstopstep4d_caption;
                      buttonstopstep4d.hint := button_buttonstopstep4d_hint;
                      buttonstructures.caption := button_buttonstructures_caption;
                      buttonstructures.hint := button_buttonstructures_hint;
                      buttonsummarizeclip.caption := button_buttonsummarizeclip_caption;
                      buttontoreference.caption := button_buttontoreference_caption;
                      buttontoreference.hint := button_buttontoreference_hint;
                      buttonwritematch.caption := button_buttonwritematch_caption;
                      buttonwritematch.hint := button_buttonwritematch_hint;
                      buttonzoom.caption := button_buttonzoom_caption;
                      buttonzoom.hint := button_buttonzoom_hint;
                      buttonzoomout.caption := button_buttonzoomout_caption;
                      buttonzoomout.hint := button_buttonzoomout_hint;
                      calibration1.caption := menu_calibration1_caption;
                      centerofclipbox1.caption := menu_centerofclipbox1_caption;
                      centerofmask1.caption := menu_centerofmask1_caption;
                      checkbox4dcorrected.caption := checkbox_checkbox4dcorrected_caption;
                      checkboxadvancedoptions.caption := checkbox_checkboxadvancedoptions_caption;
                      checkboxadvancedoptions.hint := checkbox_checkboxadvancedoptions_hint;
                      checkboxallframes.caption := checkbox_checkboxallframes_caption;
                      checkboxallrois.caption := checkbox_checkboxallrois_caption;
                      radiobuttoncurrentframe.caption := radiobuttoncurrentframes_caption;
                      radiobuttonallframes.caption := radiobuttonallframes_caption;
                      checkboxcorrectionreference.caption := checkbox_checkboxcorrectionreference_caption;
                      checkboxcorrectionreference.hint := checkbox_checkboxcorrectionreference_hint;
                      checkboxdelineation.caption := checkbox_checkboxdelineation_caption;
                      checkboxdelineation.hint := checkbox_checkboxdelineation_hint;
                      checkboxdose.caption := checkbox_checkboxdose_caption;
                      checkboxdose.hint := checkbox_checkboxdose_hint;
                      checkboxdoseaccu.caption := checkbox_checkboxdoseaccu_caption;
                      checkboxdoseaccu.hint := checkbox_checkboxdoseaccu_hint;
                      checkboxenablerotation.caption := checkbox_checkboxenablerotation_caption;
                      checkboxenablerotation.hint := checkbox_checkboxenablerotation_hint;
                      checkboxghostcorrection.caption := checkbox_checkboxghostcorrection_caption;
                      checkboxghostcorrection.enabled := false;
                      checkboxghostcorrection.checked := false;
                      checkboxlockrap.caption := checkbox_checkboxlockrap_caption;
                      checkboxlockrap.hint := checkbox_checkboxlockrap_hint;
                      checkboxlockrcc.caption := checkbox_checkboxlockrcc_caption;
                      checkboxlockrcc.hint := checkbox_checkboxlockrcc_hint;
                      checkboxlockrlr.caption := checkbox_checkboxlockrlr_caption;
                      checkboxlockrlr.hint := checkbox_checkboxlockrlr_hint;
                      checkboxmarkers.caption := checkbox_checkboxmarkers_caption;
                      checkboxmarkers.hint := checkbox_checkboxmarkers_hint;
                      checkboxmean.caption := checkbox_checkboxmean_caption;
                      checkboxmedian.caption := checkbox_checkboxmedian_caption;
                      checkboxmedian.hint := checkbox_checkboxmedian_hint;
                      checkboxmultithread.caption := checkbox_checkboxmultithread_caption;
                      checkboxmultithread.hint := checkbox_checkboxmultithread_hint;
                      checkboxplan.caption := checkbox_checkboxplan_caption;
                      checkboxplan.hint := checkbox_checkboxplan_hint;
                      checkboxrecordform.caption := checkbox_checkboxrecordform_caption;
                      checkboxreferencemask.caption := checkbox_checkboxreferencemask_caption;
                      checkboxreferencemask.hint := checkbox_checkboxreferencemask_hint;
                      checkboxreversemotion.caption := checkbox_checkboxreversemotion_caption;
                      checkboxroi.caption := checkbox_checkboxroi_caption;
                      checkboxroi.hint := checkbox_checkboxroi_hint;
                      checkboxscan.caption := checkbox_checkboxscan_caption;
                      checkboxscan.hint := checkbox_checkboxscan_hint;
                      checkboxusecalibrationimages.caption := checkbox_checkboxusecalibrationimages_caption;
                      checkboxusecalibrationimages.hint := checkbox_checkboxusecalibrationimages_hint;
                      checkboxwarp.caption := checkbox_checkboxwarp_caption;
                      clearmask.caption := menu_clearmask_caption;
                      clinicalmode.caption := menu_clinicalmode_caption;
                      clipbox1.caption := menu_clipbox1_caption;
                      colorstringgrid1.hint := stringgrid_colorstringgrid1_hint;
                      colorstringgrid2.hint := stringgrid_colorstringgrid2_hint;
                      colorstringgrid3.hint := stringgrid_colorstringgrid3_hint;
                      colorstringgridsummary.hint := stringgrid_colorstringgridsummary_hint;
                      comboboxclipboxmatch.hint := combobox_comboboxclipboxmatch_hint;
                      comboboxcorrectionby.hint := combobox_comboboxcorrectionby_hint;
                      comboboxcorrectionprotocol.hint := combobox_comboboxcorrectionprotocol_hint;
                      comboboxdisplaymode.hint := combobox_comboboxdisplaymode_hint;
                      comboboxfiltertype.hint := combobox_comboboxfiltertype_hint;
                      comboboxmaskmatch.hint := combobox_comboboxmaskmatch_hint;
                      comboboxmatch.hint := combobox_comboboxmatch_hint;
                      comboboxprotocol.hint := combobox_comboboxprotocol_hint;
                      comboboxregistrationprotocol.hint := combobox_comboboxregistrationprotocol_hint;
                      comboboxsliceaveraging.hint := combobox_comboboxsliceaveraging_hint;
                      comboboxtransformmode.hint := combobox_comboboxtransformmode_hint;
                      convertmatch.caption := button_convertmatch_caption;
                      copy1.caption := menu_copy1_caption;
                      copyallrecons.caption := menu_copyallrecons_caption;
                      copyallscans.caption := menu_copyallscans_caption;
                      copyalltolocal.caption := menu_copyalltolocal_caption;
                      copyeconstructions.caption := menu_copyeconstructions_caption;
                      copyprojections.caption := menu_copyprojections_caption;
                      copyreferencedata.caption := menu_copyreferencedata_caption;
                      copyreferencesettings.caption := menu_copyreferencesettings_caption;
                      copythisreconstruction.caption := menu_copythisreconstruction_caption;
                      copythisscan.caption := menu_copythisscan_caption;
                      copytoclipboard1.caption := menu_copytoclipboard1_caption;
                      copyxvifile.caption := button_copyxvifile_caption;
                      correction1.caption := menu_correction1_caption;
                      createcatphanreference1.caption := menu_createcatphanreference1_caption;
                      creategeometry.caption := menu_creategeometry_caption;
                      createmask1.caption := menu_createmask1_caption;
                      detectmarkers2.caption := menu_detectmarkers2_caption;
                      editbeamhardening.hint := edit_editbeamhardening_hint;
                      editfp0.hint := edit_editfp0_hint;
                      editfp1.hint := edit_editfp1_hint;
                      editinterpolate.hint := edit_editinterpolate_hint;
                      editmask.caption := menu_editmask_caption;
                      masklocked.caption := menu_masklocked_caption;
                      editprojectionimageresolution.hint := edit_editprojectionimageresolution_hint;
                      editreconstructedimageresolution.hint := edit_editreconstructedimageresolution_hint;
                      editreconstructionsize.hint := edit_editreconstructionsize_hint;
                      editrotationap.hint := edit_editrotationap_hint;
                      editrotationcc.hint := edit_editrotationcc_hint;
                      editrotationlr.hint := edit_editrotationlr_hint;
                      editscale.hint := edit_editscale_hint;
                      editskip.hint := edit_editskip_hint;
                      editspr.hint := edit_editspr_hint;
                      edittranslationap.hint := edit_edittranslationap_hint;
                      edittranslationcc.hint := edit_edittranslationcc_hint;
                      edittranslationlr.hint := edit_edittranslationlr_hint;
                      edituseints.hint := edit_edituseints_hint;
                      exit1.caption := menu_exit1_caption;
                      exitaccept1.caption := menu_exitaccept1_caption;
                      exportmatched3d1.caption := menu_exportmatched3d1_caption;
                      exportmatched4d1.caption := menu_exportmatched4d1_caption;
                      exportraw3d1.caption := menu_exportraw3d1_caption;
                      exportraw4d1.caption := menu_exportraw4d1_caption;
                      file1.caption := menu_file1_caption;
                      gotocorrectionreferencepoint.caption := menu_gotocorrectionreferencepoint_caption;
                      gotoisocenter.caption := menu_gotoisocenter_caption;
                      gotomarker.caption := menu_gotomarker_caption;
                      hard1.caption := menu_hard1_caption;
                      help1.caption := menu_help1_caption;
                      importdose1.caption := menu_importdose1_caption;
                      label1.caption := label_label1_caption;
                      label10.caption := label_label10_caption;
                      label11.caption := label_label11_caption;
                      label12.caption := label_label12_caption;
                      label13.caption := label_label13_caption;
                      label14.caption := label_label14_caption;
                      label15.caption := label_label15_caption;
                      label16.caption := label_label16_caption;
                      label17.caption := label_label17_caption;
                      label18.caption := label_label18_caption;
                      label19.caption := label_label19_caption;
                      label2.caption := label_label2_caption;
                      label20.caption := label_label20_caption;
                      label21.caption := label_label21_caption;
                      label22.caption := label_label22_caption;
                      label23.caption := label_label23_caption;
                      label24.caption := label_label24_caption;
                      label25.caption := label_label25_caption;
                      label26.caption := label_label26_caption;
                      label27.caption := label_label27_caption;
                      label28.caption := label_label28_caption;
                      label29.caption := label_label29_caption;
                      label3.caption := label_label3_caption;
                      label31.caption := label_label31_caption;
                      label32.caption := label_label32_caption;
                      label33.caption := label_label33_caption;
                      label34.caption := label_label34_caption;
                      label36.caption := label_label36_caption;
                      label37.caption := label_label37_caption;
                      label38.caption := label_label38_caption;
                      label39.caption := label_label39_caption;
                      label4.caption := label_label4_caption;
                      label40.caption := label_label40_caption;
                      label41.caption := label_label41_caption;
                      label42.caption := label_label42_caption;
                      label43.caption := label_label43_caption;
                      label44.caption := label_label44_caption;
                      label45.caption := label_label45_caption;
                      label46.caption := label_label46_caption;
                      label47.caption := label_label47_caption;
                      label48.caption := label_label48_caption;
                      label49.caption := label_label49_caption;
                      label4d.caption := label_label4d_caption;
                      label4d.hint := label_label4d_hint;
                      label5.caption := label_label5_caption;
                      label50.caption := label_label50_caption;
                      label54.caption := label_label54_caption;
                      label55.caption := label_label55_caption;
                      label56.caption := label_label56_caption;
                      label57.caption := label_label57_caption;
                      label6.caption := label_label6_caption;
                      label61.caption := label_label61_caption;
                      label62.caption := label_label62_caption;
                      label65.caption := label_label65_caption;
                      label66.caption := label_label66_caption;
                      label67.caption := label_label67_caption;
                      label68.caption := label_label68_caption;
                      label69.caption := label_label69_caption;
                      label7.caption := label_label7_caption;
                      label70.caption := label_label70_caption;
                      label71.caption := label_label71_caption;
                      label72.caption := label_label72_caption;
                      label73.caption := label_label73_caption;
                      label74.caption := label_label74_caption;
                      label75.caption := label_label75_caption;
                      label79.caption := label_label79_caption;
                      label8.caption := label_label8_caption;
                      label80.caption := label_label80_caption;
                      label81.caption := label_label81_caption;
                      label9.caption := label_label9_caption;
                      labelactualheight.caption := label_labelactualheight_caption;
                      labelactuallat.caption := label_labelactuallat_caption;
                      labelactuallong.caption := label_labelactuallong_caption;
                      labelcomputedheight.caption := label_labelcomputedheight_caption;
                      labelcomputedheight2.caption := label_labelcomputedheight2_caption;
                      labelcomputedlat.caption := label_labelcomputedlat_caption;
                      labelcomputedlat2.caption := label_labelcomputedlat2_caption;
                      labelcomputedlong.caption := label_labelcomputedlong_caption;
                      labelcomputedlong2.caption := label_labelcomputedlong2_caption;
                      labelcomputedpitch2.caption := label_labelcomputedpitch2_caption;
                      labelcomputedroll2.caption := label_labelcomputedroll2_caption;
                      labelcomputedyaw2.caption := label_labelcomputedyaw2_caption;
                      labelelektamode.caption := label_labelelektamode_caption;
                      labelheight.caption := label_labelheight_caption;
                      labelheight2.caption := label_labelheight2_caption;
                      labellat.caption := label_labellat_caption;
                      labellat2.caption := label_labellat2_caption;
                      labellimitshelp.caption := label_labellimitshelp_caption;
                      labellong.caption := label_labellong_caption;
                      labellong2.caption := label_labellong2_caption;
                      labelpitch2.caption := label_labelpitch2_caption;
                      labelrois.caption := label_labelrois_caption;
                      labelroll2.caption := label_labelroll2_caption;
                      labeltabpage.caption := label_labeltabpage_caption;
                      labelyaw2.caption := label_labelyaw2_caption;
                      loadacceptedmatch.caption := menu_loadacceptedmatch_caption;
                      loadbonematch.caption := menu_loadbonematch_caption;
                      loadonlinemarkers.caption := menu_loadonlinemarkers_caption;
                      loadreferencemarkers.caption := menu_loadreferencemarkers_caption;
                      loadtumormatch.caption := menu_loadtumormatch_caption;
                      lung1.caption := menu_lung1_caption;
                      makematchinactive.caption := menu_makematchinactive_caption;
                      mask1.caption := menu_mask1_caption;
                      matchclassbutton.caption := button_matchclassbutton_caption;
                      measurecatphaninserts1.caption := menu_measurecatphaninserts1_caption;
                      createmultianglegainfile1.caption := menu_createmultianglegainfile1_caption;
                      medium1.caption := menu_medium1_caption;
                      memoclipboxcorrectiondifference.hint := memo_memoclipboxcorrectiondifference_hint;
                      memomaskclipboxdifference.hint := memo_memomaskclipboxdifference_hint;
                      menuclipboxlocked.caption := menu_menuclipboxlocked_caption;
                      menushowunlockpresentclipbox.caption := menu_menushowunlockpresentclipbox_caption;
                      n1.caption := menu_n1_caption;
                      n10mm1.caption := menu_n10mm1_caption;
                      n15mm1.caption := menu_n15mm1_caption;
                      n2.caption := menu_n2_caption;
                      n20mm1.caption := menu_n20mm1_caption;
                      n2mm1.caption := menu_n2mm1_caption;
                      n3.caption := menu_n3_caption;
                      n4.caption := menu_n4_caption;
                      n4mm1.caption := menu_n4mm1_caption;
                      n5.caption := menu_n5_caption;
                      n6.caption := menu_n6_caption;
                      overview1.caption := menu_overview1_caption;
                      page1.caption := menu_page1_caption;
                      paintbrushsize.caption := menu_paintbrushsize_caption;
                      pasteasreference1.caption := menu_pasteasreference1_caption;
                      pastetostitch1.caption := menu_pastetostitch1_caption;
                      plannedisoc1.caption := menu_plannedisoc1_caption;
                      print1.caption := menu_print1_caption;
                      readmask.caption := menu_readmask_caption;
                      recordvideo1.caption := menu_recordvideo1_caption;
                      refpointatcenterofclipbox1.caption := menu_refpointatcenterofclipbox1_caption;
                      refpointatcenterofdelineation.caption := menu_refpointatcenterofdelineation_caption;
                      refpointatisocenter1.caption := menu_refpointatisocenter1_caption;
                      refpointatmarker.caption := menu_refpointatmarker_caption;
                      research.caption := menu_research_caption;
                      restore1.caption := menu_restore1_caption;
                      saveas1.caption := menu_saveas1_caption;
                      saveonlinemarkers.caption := menu_saveonlinemarkers_caption;
                      savereferencemarkerlist.caption := menu_savereferencemarkerlist_caption;
                      shiftscan1.caption := menu_shiftscan1_caption;
                      showall1.caption := menu_showall1_caption;
                      showmarkertool.caption := menu_showmarkertool_caption;
                      soft1.caption := menu_soft1_caption;
                      tools.caption := menu_tools_caption;
                      trackbarfilterkernel.hint := trackbar_trackbarfilterkernel_hint;
                      trackbarrotationap.hint := trackbar_trackbarrotationap_hint;
                      trackbarrotationcc.hint := trackbar_trackbarrotationcc_hint;
                      trackbarrotationlr.hint := trackbar_trackbarrotationlr_hint;
                      trackbartranslationap.hint := trackbar_trackbartranslationap_hint;
                      trackbartranslationcc.hint := trackbar_trackbartranslationcc_hint;
                      trackbartranslationlr.hint := trackbar_trackbartranslationlr_hint;
                      trackbarweight.hint := trackbar_trackbarweight_hint;
                      updown1.hint := updown_updown1_hint;
                      updownrois.hint := updown_updownrois_hint;
                      verysoft1.caption := menu_verysoft1_caption;
                      viewerhelp1.caption := menu_viewerhelp1_caption;
                      viewpoint1.caption := menu_viewpoint1_caption;
                      visualizebonesegmentation1.caption := menu_visualizebonesegmentation1_caption;
                      warpform1.caption := menu_warpform1_caption;
                      writemask.caption := menu_writemask_caption;
                    if avlstate\>0 then
                    begin
                      buttonsetscan.visible := false;
                      buttonsetplan.visible := false;
                      checkboxplan.visible := false;
                      buttonsetdelineation.visible := false;
                      buttonmarkers.visible := false;
                      checkboxmarkers.visible := false;
                      buttonclearreference.visible := false;
                      buttonsetreferencemask.visible := false;
                      buttonsetroi.visible := false;
                      buttonloadreference.visible := false;
                      buttonsavereference.visible := false;
                      pagecontrol1.pages[0].tabvisible := false;
                      if not pagecontrol1.pages[1].tabvisible then
                      begin
                        pagecontrol1.tabheight := 1;
                        pagecontrol1.tabwidth  := 1;
                      end;
                      panelelektamode.visible := true;
                      case avlstate of
                        1: labelelektamode.caption := mode1_caption;
                        2: labelelektamode.caption := mode2_caption;
                        3: labelelektamode.caption := mode3_caption;
                        4: labelelektamode.caption := mode4_caption;
                        5: labelelektamode.caption := mode5_caption;
                        6: labelelektamode.caption := mode2_caption;
                        else labelelektamode.caption := mode_unknown;
                      end;
                      if readonly then labelelektamode.caption := labelelektamode.caption + mode_readonly;
                      buttonloadreference.caption := caption_reload;
                      buttonloadmatch.caption := caption_reload;
                      buttonacceptmatch.visible := false;
                      buttonloadmatch.visible     := false;
                    end;
                    if xviischildwindow then
                    begin
                      panelnkicouchshift.visible := false;
                      panelimage.visible := false;
                      panelrotation.visible := false;
                      paneltranslation.visible := false;
                      panelelektacouchshift.visible := false;
                      panelreferencepreset.visible := false;
                      panelalignment.visible := false;
                      panelelektamode.visible := false;
                      tabcontrol1.visible := false;
                      progressbar3.left := 907;
                      progressbar3.height := 762;
                      statusbar1.visible := false;
                      borderstyle := bsnone;
                      quirtviewerupdcoronal.parent := self;
                      quirtviewerupdsagittal.parent := self;
                      quirtviewerupdtransversal.parent := self;
                      progressbar3.parent := self;
                      pagecontrol1.visible := false;
                    end;
                    colorstringgrid1.cells[1,0] := grid_clipbox;
                    colorstringgrid1.cells[2,0] := grid_mask;
                    colorstringgrid1.cellprops[1,0].alignment := tacenter;
                    colorstringgrid1.cellprops[2,0].alignment := tacenter;
                    colorstringgrid1.cellprops[3,0].alignment := tacenter;
                    colorstringgrid1.cellprops[1,0].bgcolor := clbtnface;
                    colorstringgrid1.cellprops[2,0].bgcolor := clbtnface;
                    colorstringgrid1.cellprops[3,0].bgcolor := clbtnface;
                    colorstringgrid1.cells[0,1] := grid_tx;
                    colorstringgrid1.cells[0,2] := grid_ty;
                    colorstringgrid1.cells[0,3] := grid_tz;
                    colorstringgrid1.cells[0,4] := grid_rx;
                    colorstringgrid1.cells[0,5] := grid_ry;
                    colorstringgrid1.cells[0,6] := grid_rz;
                    for i:=1 to 6 do
                    begin
                      colorstringgrid1.cellprops[0,i].alignment := tacenter;
                      colorstringgrid1.cellprops[0,i].bgcolor := clbtnface;
                    end;
                    for i:=1 to 6 do
                    begin
                      colorstringgrid1.cellprops[1,i].alignment := tacenter;
                      colorstringgrid1.cellprops[2,i].alignment := tacenter;
                    end;
                    colorstringgrid1.cells[3,0] := grid_adjust;
                    for i:=1 to 6 do
                    begin
                      colorstringgrid1.cells[3,i] := \'\';
                      colorstringgrid1.cellprops[3,i].box.checked := false;
                    end;
                    if screen.pixelsperinch = 120 then
                    begin
                      colorstringgrid1.defaultcolwidth := (colorstringgrid1.defaultcolwidth * 120) div 96;
                      colorstringgrid2.defaultcolwidth := (colorstringgrid2.defaultcolwidth * 120) div 96;
                      colorstringgrid3.defaultcolwidth := (colorstringgrid3.defaultcolwidth * 120) div 96;
                      colorstringgrid1.defaultrowheight := (colorstringgrid1.defaultrowheight * 120) div 96;
                      colorstringgrid2.defaultrowheight := (colorstringgrid2.defaultrowheight * 120) div 96;
                      colorstringgrid3.defaultrowheight := (colorstringgrid3.defaultrowheight * 120) div 96;
                    end;
                    colorstringgrid1.scrollbars := ssnone;
                    colorstringgrid2.scrollbars := ssnone;
                    colorstringgrid3.scrollbars := ssnone;
                    colorstringgrid3.options := colorstringgrid3.options - [goediting];
                    colorstringgrid2.options := colorstringgrid2.options - [goediting];
                    colorstringgrid2.cells[1,0] := grid_allthesame;
                    colorstringgrid2.cellprops[1,0].box.checked := true;
                    colorstringgrid2.cellprops[1,0].box.enabled := true;
                    colorstringgrid2.cellprops[1,0].span := 2;
                    colorstringgrid2.cellprops[1,0].alignment := tacenter;
                    colorstringgrid2.cells[0,0] := grid_limits;
                    colorstringgrid2.cells[0,1] := grid_tx;
                    colorstringgrid2.cells[0,2] := grid_ty;
                    colorstringgrid2.cells[0,3] := grid_tz;
                    colorstringgrid2.cells[1,4] := grid_allthesame;
                    colorstringgrid2.cellprops[1,4].box.checked := true;
                    colorstringgrid2.cellprops[1,4].box.enabled := true;
                    colorstringgrid2.cellprops[1,4].span := 2;
                    colorstringgrid2.cellprops[1,4].alignment := tacenter;
                    colorstringgrid2.cells[0,4] := grid_limits2;
                    colorstringgrid2.cells[0,5] := grid_rx;
                    colorstringgrid2.cells[0,6] := grid_ry;
                    colorstringgrid2.cells[0,7] := grid_rz;
                    for i:=0 to 7 do
                    begin
                      colorstringgrid2.cellprops[0,i].alignment := tacenter;
                      colorstringgrid2.cellprops[0,i].bgcolor := clbtnface;
                    end;
                    colorstringgrid2.cellprops[1,0].box.onclick := boxclick;
                    colorstringgrid2.cellprops[1,4].box.onclick := boxclick;
                    boxclick(colorstringgrid2.cellprops[1,0].box);
                    colorstringgrid3.cells[1,0] := grid_allthesame;
                    colorstringgrid3.cellprops[1,0].box.checked := true;
                    colorstringgrid3.cellprops[1,0].box.enabled := true;
                    colorstringgrid3.cellprops[1,0].span := 2;
                    colorstringgrid3.cellprops[1,0].alignment := tacenter;
                    colorstringgrid3.cells[0,0] := grid_limits;
                    colorstringgrid3.cells[0,1] := grid_tx;
                    colorstringgrid3.cells[0,2] := grid_ty;
                    colorstringgrid3.cells[0,3] := grid_tz;
                    colorstringgrid3.cells[1,4] := grid_allthesame;
                    colorstringgrid3.cellprops[1,4].box.checked := true;
                    colorstringgrid3.cellprops[1,4].box.enabled := true;
                    colorstringgrid3.cellprops[1,4].span := 2;
                    colorstringgrid3.cellprops[1,4].alignment := tacenter;
                    colorstringgrid3.cells[0,4] := grid_limits2;
                    colorstringgrid3.cells[0,5] := grid_rx;
                    colorstringgrid3.cells[0,6] := grid_ry;
                    colorstringgrid3.cells[0,7] := grid_rz;
                    for i:=0 to 7 do
                    begin
                      colorstringgrid3.cellprops[0,i].alignment := tacenter;
                      colorstringgrid3.cellprops[0,i].bgcolor := clbtnface;
                    end;
                    colorstringgrid3.cellprops[1,0].box.onclick := boxclick;
                    colorstringgrid3.cellprops[1,4].box.onclick := boxclick;
                    boxclick(colorstringgrid3.cellprops[1,0].box);
                    quirtviewer1.transpose.value := 0;
                    quirtviewer1.interpolatedzoom.value := 0;
                    quirtviewer1.slicedir.value := 3;
                    quirtviewer1.onprocessing := quirtviewerprocessing;
                    if avlstate\>0 then
                    begin
                      patientid          := inifile.readstring(\'identification\', \'patientid\', \'\');
                      patientname        := inifile.readstring(\'identification\', \'lastname\', \'\') + \', \' +
                                            inifile.readstring(\'identification\', \'firstname\', \'\');
                      treatmentid        := inifile.readstring(\'identification\', \'treatmentid\', \'\');
                      plansopuid         := inifile.readstring(\'identification\', \'referenceuid\', \'\');
                      treatmentuid       := inifile.readstring(\'identification\', \'referenceuid\', \'\');
                      elektatreatmentuid := inifile.readstring(\'identification\', \'treatmentuid\', \'\');
                      scanuid            := inifile.readstring(\'identification\', \'scanuid\', \'\');
                      titlebarstring         := inifile.readstring(\'identification\', \'titlebarstring\', \'\');
                      referenceoverlaystring := inifile.readstring(\'identification\', \'referenceoverlaystring\', \'\');
                      onlineoverlaystring    := inifile.readstring(\'identification\', \'onlineoverlaystring\', \'\');
                      dob                    := inifile.readstring(\'identification\', \'dob\', \'\');
                      reconfilebase      := inifile.readstring(\'xvi\', \'reconstructedscansdirectory\', \'\');
                      fixdirectory(reconfilebase);
                      adminfilebase      := inifile.readstring(\'xvi\', \'administrativefilesdirectory\', \'\');
                      fixdirectory(adminfilebase);
                      substituteparms(adminfilebase);
                        sysutils.forcedirectories(extractfilepath(adminfilebase));
                      cachefilebase      := inifile.readstring(\'xvi\', \'referencecachedirectory\', \'\');
                      fixdirectory(cachefilebase);
                      if avlstate in [2, 6] then
                        cachefilebase := cachefilebase + plansopuid + \'\\\';
                      projectionfilebase := inifile.readstring(\'xvi\', \'projectiondirectory\', \'\');
                      fixdirectory(projectionfilebase);
                      h := tqinifile.create(paramstr2);
                      anglefilebase      := h.readstring(\'xvi\', \'administrativefilesdirectory\', \'\') +
                                            h.readstring(\'reconstruction\', \'projectionanglefile\', \'\');
                      h.free;
                      fixdirectory(anglefilebase);
                      matchresultlogfile := inifile.readstring(\'xvi\', \'matchresultlogfile\', \'\');
                      flexmapfilename := inifile.readstring(\'reconstruction\', \'flexmap\', \'\');
                      useonlinereconstruction := inifile.readbool(\'reconstruction\', \'useonlinereconstruction\', false);
                      projectiontimeout := inifile.readinteger(\'reconstruction\', \'projectiontimeout\', 10);
                      fakeimporturl := inifile.readstring(\'xvi\', \'fakeimporturl\', \'[xvi]:\');
                      patienturl := fakeimporturl + patientid;
                      if assigned(uexportscan.okbottomdlg) then
                      begin
                        uexportscan.okbottomdlg.edit1.text := patientid;
                        uexportscan.okbottomdlg.edit2.text := patientname;
                        uexportscan.okbottomdlg.edit3.text := \'\';
                      end;
                      if titlebarstring\<\>\'\' then
                        caption:=titlebarstring
                      else
                        caption:=format(nki_caption, [patientid, patientname]);
                      if avlstate in [2, 4, 6] then
                      begin
                        if useonlinereconstruction then
                          numframes:=9000
                        else
                        begin
                          for i:=0 to 9000 do
                          begin
                            s := format(anglefilebase, [i]);
                            for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                            if fileexists(s) then numframes := i+1 else break;
                          end;
                        end;
                        frameid   := 0;
                        if useonlinereconstruction then
                          projdim := inifile.readinteger(\'reconstruction\', \'camerawidth\', 512)
                        else
                        begin
                          s := format(anglefilebase, [frameid]);
                          for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                          h :=tqinifile.create(s);
                          s := format(\'%.4d\', [frameid]);
                          s := projectionfilebase + h.readstring(s, \'projectiondatafile\', \'\');
                          read_heimann_his(f, s);
                          projdim := f.dimensions[0];
                          h.free;
                        end;
                        prepad  := 0;
                        case projdim of
                          960, 480, 240, 120, 60:
                            begin
                              detectorsize := 43.0;
                              fdd          := 153.2;
                            end;
                          780, 390, 195:
                            begin
                              detectorsize := 28.7;
                              fdd          := 153.6;
                            end;
                          1024, 512, 256, 128, 64:
                            begin
                              detectorsize := 40.96;
                              fdd          := 153.6;
                            end;
                          else
                            begin
                              showmessage(\'unsupported detector\');
                              detectorsize := 10.0;
                              fdd          := 153.6;
                            end;
                        end;
                        detectorsize := inifile.readfloat(\'xvi\', \'detectorsize\', detectorsize);
                        fdd := inifile.readfloat(\'xvi\', \'focusdetectordistance\', fdd);
                        fid := inifile.readfloat(\'xvi\', \'focusisocdistance\', 100.00);
                      end;
                    end;
                    filteredrecords := tstringlist.create;
                    filteredrecords.sorted := true;
                    filteredrecords.duplicates := dupignore;
                    scanlist := tstringlist.create;
                    zoomfix := inifile.readfloat(\'xvi\', \'zoomfix\', 1);
                    gridvoxelsize := inifile.readfloat(\'xvi\', \'gridvoxelsize\', 0.1);
                    enabletestmode := inifile.readbool(\'xvi\', \'testmode\', false);
                    progressoffset := 0;
                    progressscale := 1;
                    if avlstate\>0 then
                    begin
                      comboboxprotocol.items.clear;
                      comboboxprotocol.items.add(reconprotocolprog);
                    end
                    else
                    begin
                      comboboxprotocol.items.clear;
                      inifile.readsections(comboboxprotocol.items);
                      i := comboboxprotocol.items.indexof(\'planselection\');
                      if i\>=0 then
                        comboboxprotocol.items.delete(i);
                      comboboxprotocol.items[0] := reconprotocolgui;
                    end;
                    comboboxprotocol.dropdowncount := min(comboboxprotocol.items.count, 50);
                    quirtviewerupdcoronal.fieldname[5].value := \'\';
                    quirtviewerupdsagittal.fieldname[5].value := \'\';
                    quirtviewerupdtransversal.fieldname[5].value := \'\';
                    quirtviewerupdcoronal.fieldname[7].value := viewer_accu;
                    quirtviewerupdsagittal.fieldname[7].value := viewer_accu;
                    quirtviewerupdtransversal.fieldname[7].value := viewer_accu;
                    quirtviewerupdcoronal.interpolatedzoom := quirtviewerupdtransversal.interpolatedzoom;
                    quirtviewerupdsagittal.interpolatedzoom := quirtviewerupdtransversal.interpolatedzoom;
                    quirtviewerupdtransversal.interpolatedzoom.value := ord(inifile.readbool(\'xvi\', \'interpolatedzoom\', true));
                    quirtviewerupdcoronal.frame := quirtviewerupdtransversal.frame;
                    quirtviewerupdsagittal.frame := quirtviewerupdtransversal.frame;
                    quirtviewerupdcoronal.activeclipbox :=  quirtviewerupdsagittal.activeclipbox;
                    quirtviewerupdtransversal.activeclipbox :=  quirtviewerupdsagittal.activeclipbox;
                    quirtviewerupdcoronal.activeclipbox.value := 1;
                    quirtviewerupdcoronal.activeclipbox.locked := true;
                    quirtviewerupdcoronal.sliceblur := quirtviewerupdtransversal.sliceblur;
                    quirtviewerupdsagittal.sliceblur := quirtviewerupdtransversal.sliceblur;
                    quirtviewerupdtransversal.showhelp := quirtviewerupdsagittal.showhelp;
                    quirtviewerupdcoronal.showhelp     := quirtviewerupdsagittal.showhelp;
                    quirtviewer1.showhelp              := quirtviewerupdsagittal.showhelp;
                    quirtviewerupdcoronal.zoom  := quirtviewerupdtransversal.zoom;
                    quirtviewerupdsagittal.zoom := quirtviewerupdtransversal.zoom;
                    quirtviewerupdcoronal.cutmode := quirtviewerupdsagittal.cutmode;
                    quirtviewerupdtransversal.cutmode := quirtviewerupdsagittal.cutmode;
                    quirtviewerupdcoronal.markerdots[1] := quirtviewerupdsagittal.markerdots[1];
                    quirtviewerupdtransversal.markerdots[1] := quirtviewerupdsagittal.markerdots[1];
                    quirtviewerupdcoronal.markerdots[nmarkers+1] := quirtviewerupdsagittal.markerdots[nmarkers+1];
                    quirtviewerupdtransversal.markerdots[nmarkers+1] := quirtviewerupdsagittal.markerdots[nmarkers+1];
                    correctionreferencepoint  := tavsfield.create(bad);
                    field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                    correctionreferencepoint.debugname := \'0\';
                    quirtviewerupdcoronal.markerdots[2] := correctionreferencepoint;
                    quirtviewerupdsagittal.markerdots[2] := correctionreferencepoint;
                    quirtviewerupdtransversal.markerdots[2] := correctionreferencepoint;
                    quirtviewerupdcoronal.markerdots[3] := quirtviewerupdsagittal.markerdots[3];
                    quirtviewerupdtransversal.markerdots[3] := quirtviewerupdsagittal.markerdots[3];
                    quirtviewerupdsagittal.markerdots[4] := tavsfield.create(bad);
                    field_create(quirtviewerupdsagittal.markerdots[4], \'field 1d 3-space irregular 10-vector byte\', 1);
                    quirtviewerupdsagittal.markerdots[4].empty := false;
                    quirtviewerupdsagittal.markerdots[4].ischangedby := nil;
                    quirtviewerupdcoronal.markerdots[4] := quirtviewerupdsagittal.markerdots[4];
                    quirtviewerupdtransversal.markerdots[4] := quirtviewerupdsagittal.markerdots[4];
                    quirtviewerupdtransversal.transpose.value := 1;
                    quirtviewerupdcoronal.transpose.value := 1;
                    quirtviewerupdsagittal.transpose.value := 1;
                    quirtviewerupdcoronal.slice.value := 128;
                    quirtviewerupdtransversal.slice.value := 128;
                    quirtviewerupdsagittal.slice.value := 128;
                    quirtviewerupdcoronal.sliceborder[1] := quirtviewerupdsagittal.slice;
                    quirtviewerupdcoronal.sliceborder[2] := quirtviewerupdtransversal.slice;
                    quirtviewerupdsagittal.sliceborder[1] := quirtviewerupdcoronal.slice;
                    quirtviewerupdsagittal.sliceborder[2] := quirtviewerupdtransversal.slice;
                    quirtviewerupdtransversal.sliceborder[1] := quirtviewerupdsagittal.slice;
                    quirtviewerupdtransversal.sliceborder[2] := quirtviewerupdcoronal.slice;
                    eulerxfm(machine_to_machineadjust);
                    transformdisplaymode.value := 0;
                    alignmentmode.value := 0;
                    activeregion.value := 0;
                    maskactiveregion.value := 0;
                    machine_to_machineadjustwarpi.clear;
                    viewwarp.clear;
                    externalwarp.clear;
                    online[1].connectviewer(quirtviewerupdcoronal, 1);
                    online[1].connectviewer(quirtviewerupdsagittal, 1);
                    online[1].connectviewer(quirtviewerupdtransversal, 1);
                    quirtviewerupdcoronal.onprocessing := quirtviewerprocessing;
                    quirtviewerupdtransversal.onprocessing := quirtviewerprocessing;
                    quirtviewerupdsagittal.onprocessing := quirtviewerprocessing;
                    quirtviewerupdcoronal.adjust[1] := machine_to_machineadjust;
                    quirtviewerupdsagittal.adjust[1] := machine_to_machineadjust;
                    quirtviewerupdtransversal.adjust[1] := machine_to_machineadjust;
                    quirtviewerupdcoronal.inversewarp[1] := machine_to_machineadjustwarpi;
                    quirtviewerupdsagittal.inversewarp[1] := machine_to_machineadjustwarpi;
                    quirtviewerupdtransversal.inversewarp[1] := machine_to_machineadjustwarpi;
                    quirtviewerupdcoronal.viewwarp := viewwarp;
                    quirtviewerupdsagittal.viewwarp := viewwarp;
                    quirtviewerupdtransversal.viewwarp := viewwarp;
                    quirtviewerupdcoronal.extoutsidewarpfflag.value := true;
                    quirtviewerupdsagittal.extoutsidewarpfflag := quirtviewerupdcoronal.extoutsidewarpfflag;
                    quirtviewerupdtransversal.extoutsidewarpfflag := quirtviewerupdcoronal.extoutsidewarpfflag;
                    quirtviewerupdcoronal.grid := tavsfield.create(bad);
                    quirtviewerupdcoronal.grid.debugname := \'quirtviewerupdcoronal.grid\';
                    quirtviewerupdcoronal.grid.adddependency(onlinecube);
                    quirtviewerupdcoronal.grid.onupdate := updategrid;
                    quirtviewerupdsagittal.grid := tavsfield.create(bad);
                    quirtviewerupdsagittal.grid.debugname := \'quirtviewerupdsagittal.grid\';
                    quirtviewerupdsagittal.grid.adddependency(onlinecube);
                    quirtviewerupdsagittal.grid.onupdate := updategrid;
                    quirtviewerupdtransversal.grid := tavsfield.create(bad);
                    quirtviewerupdtransversal.grid.debugname := \'quirtviewerupdtransversal.grid\';
                    quirtviewerupdtransversal.grid.adddependency(onlinecube);
                    quirtviewerupdtransversal.grid.onupdate := updategrid;
                    quirtviewerupdcoronal.viewtransform := tavsfield.create(bad);
                    quirtviewerupdcoronal.viewtransform.debugname := \'quirtviewerupdcoronal.viewtransform\';
                    quirtviewerupdcoronal.viewtransform.adddependency(online_to_machine);
                    quirtviewerupdcoronal.viewtransform.adddependency(machine_to_machineadjust);
                    quirtviewerupdcoronal.viewtransform.adddependency(reversemotion);
                    quirtviewerupdcoronal.viewtransform.onupdate := updateviewtransform;
                    quirtviewerupdsagittal.viewtransform := tavsfield.create(bad);
                    quirtviewerupdsagittal.viewtransform.debugname := \'quirtviewerupdsagittal.viewtransform\';
                    quirtviewerupdsagittal.viewtransform.adddependency(online_to_machine);
                    quirtviewerupdsagittal.viewtransform.adddependency(machine_to_machineadjust);
                    quirtviewerupdsagittal.viewtransform.adddependency(reversemotion);
                    quirtviewerupdsagittal.viewtransform.onupdate := updateviewtransform;
                    quirtviewerupdtransversal.viewtransform := tavsfield.create(bad);
                    quirtviewerupdtransversal.viewtransform.debugname := \'quirtviewerupdtransversal.viewtransform\';
                    quirtviewerupdtransversal.viewtransform.adddependency(online_to_machine);
                    quirtviewerupdtransversal.viewtransform.adddependency(machine_to_machineadjust);
                    quirtviewerupdtransversal.viewtransform.adddependency(reversemotion);
                    quirtviewerupdtransversal.viewtransform.onupdate := updateviewtransform;
                    reversemotion.value := inifile.readinteger(\'xvi\', \'planningstationary\', 0);
                    checkboxreversemotion.checked := reversemotion.value\<\>0;
                    reference[1].connectviewer(quirtviewerupdcoronal,     2);
                    reference[1].connectviewer(quirtviewerupdsagittal,    2);
                    reference[1].connectviewer(quirtviewerupdtransversal, 2);
                    reference[2].connectviewer(quirtviewerupdcoronal,     4);
                    reference[2].connectviewer(quirtviewerupdsagittal,    4);
                    reference[2].connectviewer(quirtviewerupdtransversal, 4);
                    quirtviewerupdcoronal.trackertransform := machine_to_machineadjust;
                    quirtviewerupdsagittal.trackertransform := machine_to_machineadjust;
                    quirtviewerupdtransversal.trackertransform := machine_to_machineadjust;
                    quirtviewerupdcoronal.trackerviewtransform := quirtviewerupdcoronal.viewtransform;
                    quirtviewerupdsagittal.trackerviewtransform := quirtviewerupdsagittal.viewtransform;
                    quirtviewerupdtransversal.trackerviewtransform := quirtviewerupdtransversal.viewtransform;
                    quirtviewerupdcoronal.trackershapetransform := tavsfield.create(bad);
                    quirtviewerupdsagittal.trackershapetransform := quirtviewerupdcoronal.trackershapetransform;
                    quirtviewerupdtransversal.trackershapetransform := quirtviewerupdcoronal.trackershapetransform;
                    quirtviewerupdcoronal.trackershapetransform.adddependency(reference_to_patient);
                    quirtviewerupdcoronal.trackershapetransform.adddependency(reference_to_siddon);
                    quirtviewerupdcoronal.trackershapetransform.onupdate := updatetrackershapetransform;
                    quirtviewerupdcoronal.trackershape := quirtviewerupdtransversal.trackershape;
                    quirtviewerupdsagittal.trackershape := quirtviewerupdtransversal.trackershape;
                    quirtviewerupdcoronal.trackerdots := quirtviewerupdtransversal.trackerdots;
                    quirtviewerupdsagittal.trackerdots := quirtviewerupdtransversal.trackerdots;
                    quirtviewerupdcoronal.trackerindex := quirtviewerupdtransversal.trackerindex;
                    quirtviewerupdsagittal.trackerindex := quirtviewerupdtransversal.trackerindex;
                    quirtviewerupdcoronal.trackerlut := quirtviewerupdtransversal.trackerlut;
                    quirtviewerupdsagittal.trackerlut := quirtviewerupdtransversal.trackerlut;
                    if getfullinifilename(\'_potatorl_vr.wrl\') \<\> \'\' then
                      vrml_read(quirtviewerupdcoronal.trackerdots, quirtviewerupdcoronal.trackerindex, quirtviewerupdcoronal.trackerlut, getfullinifilename(\'_potatorl_vr.wrl\'));
                    machine_to_machineadjust.onchanged := changemachine_to_machineadjust;
                    transform4d.debugname := \'transform4d\';
                    quirtviewerupdcoronal.frame.debugname := \'quirtviewerupdcoronal.frame\';
                    activeregion.debugname := \'activeregion\';
                    maskactiveregion.debugname := \'maskactiveregion\';
                    alignmentmode.debugname := \'alignmentmode\';
                    transformdisplaymode.debugname := \'transformdisplaymode\';
                    machine_to_machineadjust.adddependency(transform4d);
                    machine_to_machineadjust.adddependency(quirtviewerupdcoronal.frame);
                    machine_to_machineadjust.adddependency(activeregion);
                    machine_to_machineadjust.adddependency(maskactiveregion);
                    machine_to_machineadjust.adddependency(alignmentmode);
                    machine_to_machineadjust.adddependency(transformdisplaymode);
                    machine_to_machineadjust.onupdate := updatemachine_to_machineadjust;
                    quirtviewerupdsagittal.text[2].adddependency(transform4d);
                    quirtviewerupdsagittal.text[2].adddependency(quirtviewerupdcoronal.frame);
                    quirtviewerupdsagittal.text[2].adddependency(activeregion);
                    quirtviewerupdsagittal.text[2].adddependency(maskactiveregion);
                    quirtviewerupdsagittal.text[2].adddependency(alignmentmode);
                    quirtviewerupdsagittal.text[2].adddependency(transformdisplaymode);
                    quirtviewerupdsagittal.text[2].onupdate := updatesagitaltext2;
                    machine_to_machineadjustwarpi.adddependency(transform4d);
                    machine_to_machineadjustwarpi.adddependency(quirtviewerupdcoronal.frame);
                    machine_to_machineadjustwarpi.adddependency(transformdisplaymode);
                    machine_to_machineadjustwarpi.adddependency(externalwarp);
                    machine_to_machineadjustwarpi.onupdate := updatemachine_to_machineadjustwarpi;
                    viewwarp.adddependency(machine_to_machineadjustwarpi);
                    viewwarp.adddependency(transformdisplaymode);
                    viewwarp.adddependency(reversemotion);
                    viewwarp.onupdate := updateviewwarp;
                    quirtviewerupdcoronal.polydots[1] := delineationdots;
                    quirtviewerupdsagittal.polydots[1] := delineationdots;
                    quirtviewerupdtransversal.polydots[1] := delineationdots;
                    quirtviewerupdcoronal.polyindex[1] := delineationindex;
                    quirtviewerupdsagittal.polyindex[1] := delineationindex;
                    quirtviewerupdtransversal.polyindex[1] := delineationindex;
                    quirtviewerupdcoronal.polytransform[1] := delineationtransform;
                    quirtviewerupdsagittal.polytransform[1] := delineationtransform;
                    quirtviewerupdtransversal.polytransform[1] := delineationtransform;
                    quirtviewerupdcoronal.polylut[1] := delineationdotslut;
                    quirtviewerupdsagittal.polylut[1] := delineationdotslut;
                    quirtviewerupdtransversal.polylut[1] := delineationdotslut;
                    quirtviewerupdcoronal.polydots[8] := warpvectors;
                    quirtviewerupdsagittal.polydots[8] := warpvectors;
                    quirtviewerupdtransversal.polydots[8] := warpvectors;
                    quirtviewerupdcoronal.polydots[3] := beamdots;
                    quirtviewerupdsagittal.polydots[3] := beamdots;
                    quirtviewerupdtransversal.polydots[3] := beamdots;
                    quirtviewerupdcoronal.polyindex[3] := beamindex;
                    quirtviewerupdsagittal.polyindex[3] := beamindex;
                    quirtviewerupdtransversal.polyindex[3] := beamindex;
                    quirtviewerupdcoronal.polytransform[3] := beamtransform;
                    quirtviewerupdsagittal.polytransform[3] := beamtransform;
                    quirtviewerupdtransversal.polytransform[3] := beamtransform;
                    quirtviewerupdcoronal.polylut[3] := beamlut;
                    quirtviewerupdsagittal.polylut[3] := beamlut;
                    quirtviewerupdtransversal.polylut[3] := beamlut;
                    field_create(beamlut, \'field 1d 256-vector byte\', 256);
                    for i:=0 to 255 do
                    begin
                      beamlut.setvalue([i,0], 255);
                      beamlut.setvalue([i,1],   0);
                      beamlut.setvalue([i,2],   0);
                      beamlut.setvalue([i,3], 255);
                    end;
                    isocdots := tavsfield.create(bad);
                    field_create(isocdots, \'field 1d 0-vector byte 3-space irregular\', 600);
                    for i:=0   to 199 do isocdots.coordinate[0, i]:= (i - 100)/10;
                    for i:=200 to 399 do isocdots.coordinate[1, i]:= (i - 300)/10;
                    for i:=400 to 599 do isocdots.coordinate[2, i]:= (i - 500)/10;
                    isoclut  := tavsfield.create(bad);
                    field_create(isoclut, \'field 1d 4-vector byte\', 1);
                    isoclut.setvalue([0, 0], 255);
                    isoclut.setvalue([0, 1], 255);
                    isoclut.setvalue([0, 2], 255);
                    isoclut.setvalue([0, 3],   0);
                    quirtviewerupdcoronal.polydots[4]        := isocdots;
                    quirtviewerupdsagittal.polydots[4]       := isocdots;
                    quirtviewerupdtransversal.polydots[4]    := isocdots;
                    quirtviewerupdcoronal.polylut[4]         := isoclut;
                    quirtviewerupdsagittal.polylut[4]        := isoclut;
                    quirtviewerupdtransversal.polylut[4]     := isoclut;
                    clipbox[1].owner := self;
                    for i:=1 to nclipbox do
                    begin
                      quirtviewerupdcoronal.clipbox[i]     := clipbox[i];
                      quirtviewerupdsagittal.clipbox[i]    := quirtviewerupdcoronal.clipbox[i];
                      quirtviewerupdtransversal.clipbox[i] := quirtviewerupdcoronal.clipbox[i];
                      quirtviewerupdcoronal.clipbox[i].onchanged := changeclipbox;
                      quirtviewerupdcoronal.activeclipbox.onchanged := quirtviewerupdcoronalactiveclipboxchanged;
                      quirtviewerupdcoronal.clipboxtext[i].onchanged := changeclipboxtext;
                      if i\>1 then clipbox[i].owner := self;
                    end;
                    quirtviewerupdcoronal.field[5]         := maskedreference;
                    quirtviewerupdsagittal.field[5]        := maskedreference;
                    quirtviewerupdtransversal.field[5]     := maskedreference;
                    quirtviewerupdcoronal.transform[5]     := maskedreferencetransform;
                    quirtviewerupdsagittal.transform[5]    := maskedreferencetransform;
                    quirtviewerupdtransversal.transform[5] := maskedreferencetransform;
                    quirtviewerupdcoronal.lut[5]           := maskedreferencelut;
                    quirtviewerupdsagittal.lut[5]          := maskedreferencelut;
                    quirtviewerupdtransversal.lut[5]       := maskedreferencelut;
                    dose[1].connectviewer(quirtviewerupdcoronal, 6);
                    dose[1].connectviewer(quirtviewerupdsagittal, 6);
                    dose[1].connectviewer(quirtviewerupdtransversal, 6);
                    quirtviewerupdcoronal.field[7] := doseaccu;
                    quirtviewerupdsagittal.field[7] := doseaccu;
                    quirtviewerupdtransversal.field[7] := doseaccu;
                    quirtviewerupdcoronal.lut[7] := doseacculut;
                    quirtviewerupdsagittal.lut[7] := doseacculut;
                    quirtviewerupdtransversal.lut[7] := doseacculut;
                    buttonzerocouch.enabled := false;
                    comboboxmatch.items.clear;
                    comboboxmatch.items.add(match_bone);
                    comboboxmatch.items.add(match_greyvalue);
                    comboboxmatch.items.add(match_manual);
                    comboboxmatch.items.add(match_mask);
                    comboboxmatch.itemindex          := 0;
                    comboboxregistrationprotocol.clear;
                    comboboxregistrationprotocol.add(protocol_clipbox, [\'clipbox\']);
                    if (admincount and admincount_roi3d)\<\>0 then
                      comboboxregistrationprotocol.add(protocol_mask, [\'mask\']);
                    if (admincount and admincount_dualregistration)\<\>0 then
                      comboboxregistrationprotocol.add(protocol_clipbox_mask, [\'clipbox --\> mask\']);
                    comboboxsummarytype.items.clear;
                    comboboxsummarytype.items.add(summary_current);
                    comboboxsummarytype.items.add(summary_details);
                    comboboxsummarytype.items.add(summary_residuals);
                    comboboxsummarytype.items.add(summary_limits);
                    comboboxsummarytype.itemindex := 0;
                    comboboxcorrectionprotocol.clear;
                    comboboxcorrectionprotocol.add(correction_from_clipbox, [\'clipbox\', \'clipbox registration\']);
                    comboboxcorrectionprotocol.add(correction_from_mask_mean, [\'mask (mean if 4d)\']);
                    comboboxcorrectionprotocol.add(correction_from_mask_exh, [\'mask (exhale if 4d)\']);
                    comboboxclipboxmatch.clear;
                    comboboxclipboxmatch.add(match_manual, [\'manual\']);
                    comboboxclipboxmatch.add(match_bone_tr, [\'bone (t + r)\']);
                    if (admincount and admincount_seedmatch)\<\>0 then
                      comboboxclipboxmatch.add(match_seed_tr, [\'seed (t + r)\']);
                    comboboxclipboxmatch.add(match_greyvalue_tr, [\'grey value (t + r)\']);
                    comboboxclipboxmatch.add(match_greyvalue_t, [\'grey value (t)\']);
                    comboboxclipboxmatch.itemindex := 1;
                    comboboxclipboxmatch.dropdowncount := comboboxclipboxmatch.items.count;
                    comboboxmaskmatch.clear;
                    comboboxmaskmatch.add(match_manual, [\'manual\']);
                    comboboxmaskmatch.add(match_bone_tr, [\'bone (t + r)\']);
                    if (admincount and admincount_seedmatch)\<\>0 then
                      comboboxmaskmatch.add(match_seed_tr, [\'seed (t + r)\']);
                    comboboxmaskmatch.add(match_greyvalue_tr, [\'grey value (t + r)\']);
                    comboboxmaskmatch.add(match_greyvalue_t, [\'grey value (t)\']);
                    if (admincount and admincount_reconstructionandviewing4d)\<\>0 then
                      comboboxmaskmatch.add(match_greyvalue_4dt, [\'grey value 4d (t)\']);
                    comboboxmaskmatch.itemindex := 3;
                    comboboxmaskmatch.dropdowncount := comboboxmaskmatch.items.count;
                    bonetumormatchlist := tstringlist.create;
                    convertcorexcllist := tstringlist.create;
                    bonetumormatchlist.add(match_bone_manualcc);
                    bonetumormatchlist.add(match_greyvalue_manualcc);
                    bonetumormatchlist.add(match_bone_4dmask);
                    bonetumormatchlist.add(match_greyvalue_4dmask);
                    bonetumormatchlist.sort;
                    convertcorexcllist.add(match_mask_art);
                    convertcorexcllist.sort;
                    buttonsetreferencemask.visible := false;
                    checkboxreferencemask.visible := false;
                    buttonmask.visible := false;
                    if (admincount and admincount_roi3d)=0 then
                    begin
                      buttonmask.visible := false;
                      checkboxreferencemask.visible := false;
                      checkboxreferencemask.checked := false;
                    end;
                    checkboxusecalibrationimages.enabled := false;
                    buttonchangecalibration.visible := false;
                    buttonsavegainoffset.visible := false;
                    buttonflexmapbb.visible := false;
                    detectmarkers2.visible := false;
                    calibration1.visible := false;
                    clinicalmode.visible := false;
                    hidetracker1.visible := false;
                    warpform1.visible    := false;
                    research.visible := false;
                    tools.visible := false;
                    page1.visible := screen.monitors[0].height\<=800;
                    loaddvf1.visible := false;
                    buttonexport.visible := false;
                    checkbox4dcorrected.visible := false;
                    checkboxenablerotation.visible := false;
                    buttonmovecouch.visible := false;
                    buttonstopcouch.visible := false;
                    buttonzerocouch.visible := false;
                    comboboxsliceaveraging.items.clear;
                    comboboxsliceaveraging.items.add(sliceavg_none);
                    comboboxsliceaveraging.items.add(\'3\'+sliceavg_slices);
                    comboboxsliceaveraging.items.add(\'5\'+sliceavg_slices);
                    comboboxsliceaveraging.items.add(\'7\'+sliceavg_slices);
                    comboboxsliceaveraging.items.add(\'9\'+sliceavg_slices);
                    comboboxsliceaveraging.itemindex := 0;
                    comboboxdisplaymode.items.clear;
                    comboboxdisplaymode.items.add(displaymode_grpu);
                    comboboxdisplaymode.items.add(displaymode_cut);
                    comboboxdisplaymode.items.add(displaymode_online);
                    comboboxdisplaymode.items.add(displaymode_ref);
                    comboboxdisplaymode.itemindex    := 0;
                    comboboxtransformmode.items.clear;
                    comboboxtransformmode.items.add(transformmode_asis);
                    comboboxtransformmode.items.add(transformmode_selected);
                    comboboxtransformmode.items.add(transformmode_warp);
                    comboboxtransformmode.items.add(transformmode_correction);
                    comboboxtransformmode.items.add(transformmode_average);
                    comboboxtransformmode.itemindex    := 0;
                    comboboxprotocol.itemindex       := 0;
                    guirefreshinterval := inifile.readinteger(\'xvi\', \'guirefreshinterval\', 20);
                    if guirefreshinterval=0 then
                      timer1.enabled := false
                    else
                      timer1.interval:= guirefreshinterval;
                    if avlstate = 5 then
                    begin
                      buttonelektaaccept.enabled:=false;
                      exitaccept1.enabled := buttonelektaaccept.enabled;
                    end;
                    sf := tform.create(self);
                    sf.position := podesigned;
                    sf.top := 500;
                    sf.left := 500;
                    sf.width := 300;
                    sf.height := 70;
                    sf.caption := wait_viewerloading;
                    sf.formstyle := fsstayontop;
                    sf.bordericons := [];
                    sl := tlabel.create(sf);
                    sl.parent := sf;
                    sl.align := alclient;
                    sl.font.style := [fsbold];
                    sl.alignment := tacenter;
                    sl.layout := tlcenter;
                    sl.caption := wait_preparation;
                    sl.update;
                    if not useonlinereconstruction then sf.show;
                    sf.update;
                    if avlstate in [1..6] then
                    begin
                      buttonelektaaccept.enabled := false;
                      exitaccept1.enabled := buttonelektaaccept.enabled;
                    end;
                    if enabletestmode then
                    begin
                      help1.insert(help1.count, tmenuitem.create(help1));
                      help1.items[help1.count-1].caption := \'show active settings\';
                      help1.items[help1.count-1].onclick := showactivesettings;
                    end;
                    hintwindowclass := thackhintwindow;
                    timer1.enabled := guirefreshinterval\<\>0;
                    gbmultianglecorrection := inifile.readbool(\'xvi\', \'multianglecorrection\', false);
                  end;",
// Sentence 052
                  "function controlisvisible(control: tcontrol): boolean;
                  begin
                    result := true;
                    while assigned(control.parent) do
                    begin
                      if not control.visible then
                      begin
                        result := false;
                        exit;
                      end;
                      control := control.parent;
                    end;
                  end;",
// Sentence 053
                  "function compareitems(item1, item2: pointer): integer;
                  var
                    r1, r2: trect;
                    icent1, icent2: integer;
                  begin
                    r1 := thintandrect(item1).rect;
                    r2 := thintandrect(item2).rect;
                    icent1 := (r1.left + r1.right) div 2;
                    icent2 := (r2.left + r2.right) div 2;
                    if r1.top\<r2.top then
                      result := -1
                    else if r1.top=r2.top then
                    begin
                      if icent1\<icent2 then
                        result := -1
                      else if icent1=icent2 then
                          result := 0
                      else
                        result := 1
                    end
                    else
                      result := 1
                  end;",
// Sentence 054
                  "procedure tform1.buildhintlist;
                  var
                    tw: thackhintwindow;
                    i : integer;
                    ha: thintandrect;
                    r1: trect;
                    ioffshor, ioffsvert: integer;
                  begin
                    destroyhintlist;
                    twl := tlist.create;
                    for i := 0 to self.componentcount - 1 do
                    begin
                      if self.components[i] is twincontrol then
                      begin
                        if (twincontrol(self.components[i]).showhint) and
                           (twincontrol(self.components[i]).hint \<\> \'\') and
                           (twincontrol(self.components[i]).hint[1] \<\> avlonly) and
                           controlisvisible(twincontrol(self.components[i])) then
                        begin
                          tw := thackhintwindow.create(self.components[i]);
                          tw.hint := twincontrol(self.components[i]).hint;
                          tw.parent := twincontrol(self.components[i]);
                          tw.color := application.hintcolor;
                          ha := thintandrect.create;
                          ha.hintwindow := tw;
                          twl.add(ha);
                        end;
                      end;
                    end;
                    twl.sort(compareitems);
                    for i := 0 to twl.count - 1 do
                    begin
                      r1 := thintandrect(twl[i]).hintwindow.calchintrect(1000, thintandrect(twl[i]).hintwindow.hint,nil);
                      r1.topleft := thintandrect(twl[i]).hintwindow.parent.clientorigin;
                      r1.bottom := r1.bottom + r1.top;
                      r1.right := r1.right + r1.left;
                      ioffshor := thintandrect(twl[i]).hintwindow.parent.width div 2;
                      ioffsvert := thintandrect(twl[i]).hintwindow.parent.height div 2;
                      r1.top    := r1.top    + ioffsvert;
                      r1.left   := r1.left   + ioffshor;
                      r1.bottom := r1.bottom + ioffsvert;
                      r1.right  := r1.right  + ioffshor;
                      thintandrect(twl[i]).rect := r1;
                    end
                  end;",
// Sentence 055
                  "procedure tform1.destroyhintlist;
                  var
                    i : integer;
                    ha: thintandrect;
                  begin
                    if assigned(twl) then
                    begin
                      for i := 0 to twl.count - 1 do
                      begin
                        thintandrect(twl[i]).hintwindow.releasehandle;
                        ha := thintandrect(twl[i]);
                        if assigned(ha) then
                        begin
                          freeandnil(ha.hintwindow);
                          freeandnil(ha);
                        end
                      end;
                      twl.free;
                      twl := nil;
                    end;
                  end;",
// Sentence 056
                  "function conflictinghint(i: integer): boolean;
                  var
                    j: integer;
                    r1, r2: trect;
                  begin
                    result := false;
                    r1 := thintandrect(twl[i]).rect;
                    for j:=0 to twl.count-1 do
                    begin
                      if i=j then
                        continue;
                      r2 := thintandrect(twl[j]).rect;
                      if ((abs(r1.top-r2.top)\<15) or
                          (abs(r1.bottom-r2.bottom)\<15))
                        and
                        (inrange(r1.left, r2.left, r2.right) or inrange(r1.right, r2.left, r2.right) or
                         inrange(r2.left, r1.left, r1.right) or inrange(r2.right, r1.left, r1.right)) then
                      begin
                        result := true;
                        exit;
                      end;
                    end
                  end;",
// Sentence 057
                  "procedure tform1.showallhints;
                  var
                    i : integer;
                    irnd: integer;
                  begin
                    for i := 0 to twl.count - 1 do
                    begin
                      while conflictinghint(i) do
                      begin
                        irnd := random(30)-15;
                        inc(thintandrect(twl[i]).rect.top, irnd);
                        inc(thintandrect(twl[i]).rect.bottom, irnd);
                      end;
                      thintandrect(twl[i]).hintwindow.activatehint(thintandrect(twl[i]).rect, thintandrect(twl[i]).hintwindow.hint);
                    end;
                  end;",
// Sentence 058
                  "procedure tform1.hideallhints;
                  var i : integer;
                  begin
                    if assigned(twl) then
                    for i := 0 to twl.count - 1 do
                      thintandrect(twl[i]).hintwindow.releasehandle;
                  end;",
// Sentence 059
                  "procedure tform1.hideisoccorrefpoint1click(sender: tobject);
                  begin
                     hideisoccorrefpoint1.checked := not hideisoccorrefpoint1.checked;
                  end;",
// Sentence 060
                  "procedure tform1.hidetracker1click(sender: tobject);
                  begin
                     hidetracker1.checked := not hidetracker1.checked;
                  end;",
// Sentence 061
                  "function tform1.findpopupcontrol(control: twincontrol; const apopup: tpopupmenu): twincontrol;
                  var
                    i: integer;
                    c: tcontrol;
                  begin
                    result := nil;
                    for i:=0 to control.controlcount-1 do
                    begin
                      c := control.controls[i];
                      if assigned(c) then
                      begin
                        if thackcontrol(c).popupmenu=apopup then
                        begin
                          result := c as twincontrol;
                          break;
                        end
                        else if c is twincontrol then
                        begin
                          result := findpopupcontrol((c as twincontrol), apopup);
                          if assigned(result) then
                            break
                        end;
                      end
                    end;
                  end;",
// Sentence 062
                  "function clienttoparent(const c: tcontrol; const point: tpoint; aparent: twincontrol): tpoint;
                  var
                    lparent: twincontrol;
                  begin
                    if aparent = nil then
                      aparent := c.parent;
                    if aparent = nil then
                      raise einvalidoperation.createfmt(sparentrequired, [c.name]);
                    result := point;
                    inc(result.x, c.left);
                    inc(result.y, c.top);
                    lparent := c.parent;
                    while lparent \<\> nil do
                    begin
                      if lparent.parent \<\> nil then
                      begin
                        inc(result.x, lparent.left);
                        inc(result.y, lparent.top);
                      end;
                      if lparent = aparent then
                        break
                      else
                        lparent := lparent.parent;
                    end;
                    if lparent = nil then
                      raise einvalidoperation.createfmt(sinvalidname, [c.name]);
                  end;",
// Sentence 063
                  "procedure tform1.showallpopupmenus;
                  var
                    i: integer;
                    p: tpoint;
                    c: twincontrol;
                  begin
                    timerpopup1.enabled := true;
                    for i:=0 to popuplist.count-1 do
                    begin
                      if tpopupmenu(popuplist[i]).items.count=0 then continue;
                      if tpopupmenu(popuplist[i]).items[0].caption=\'\' then continue;
                      if tpopupmenu(popuplist[i]).items[0].caption[1]=\'*\' then continue;
                      gipopup := i;
                      c := findpopupcontrol(form1, tpopupmenu(popuplist[i]));
                      if not assigned(c) then
                      begin
                        p := point(longrec(tpopupmenu(popuplist[i]).designinfo).lo, longrec(tpopupmenu(popuplist[i]).designinfo).hi);
                        p := clienttoscreen(p);
                      end
                      else if controlisvisible(c) then
                      begin
                        p := point(c.width div 2, c.height div 2);
                        if assigned(c) then
                          p :=  main3.clienttoparent(c, p, c.parent);
                        p := clienttoscreen(p);
                      end
                      else
                      begin
                        p := point(0,0);
                        p := clienttoscreen(p);
                      end;
                      gipopuppointx := p.x;
                      gipopuppointy := p.y;
                      tpopupmenu(popuplist[i]).popup(p.x, p.y);
                    end;
                    form1.sendtoback;
                    timerpopup1.enabled := false;
                  end;",
// Sentence 064
                  "procedure tform1.showallpopupmenusasforms;
                  var
                    i: integer;
                  begin
                    timerpopup1.enabled := false;
                    if not timerpopup1.enabled then
                    begin
                      for i:=0 to high(gformarray) do
                        if assigned(gformarray[i]) then
                          gformarray[i].show;
                    end
                  end;",
// Sentence 065
                  "procedure tform1.popupmenuscanpopup(sender: tobject);
                  begin
                  end;",
// Sentence 066
                  "procedure tform1.showdvf1click(sender: tobject);
                  begin
                  end;",
// Sentence 067
                  "procedure tform1.applydvfclick(sender: tobject);
                  begin
                  end;",
// Sentence 068
                  "procedure tform1.btncorrectionbyclick(sender: tobject);
                  begin
                    popupmenucorrectionby.popup(btncorrectionby.clientorigin.x + btncorrectionby.width div 2, btncorrectionby.clientorigin.y + btncorrectionby.height div 2);
                  end;",
// Sentence 069
                  "procedure tform1.showuniformity;
                  const
                    box_size=7;
                  var
                    meas00, meas04: double;
                    i0, i1, i2: integer;
                    fmax: double;
                    measregion: tavsfield;
                  begin
                    if assigned(onlinecube) and (not onlinecube.empty) then
                    begin
                      i0 := onlinecube.nearestpixel[0,0];
                      i1 := onlinecube.nearestpixel[1,0];
                      i2 := onlinecube.nearestpixel[2,0];
                      measregion := tavsfield.create;
                      field_crop(onlinecube, measregion, i0, i0, i1-box_size, i1+box_size, i2-box_size, i2+box_size);
                      meas00 := measregion.mean;
                      i0 := onlinecube.nearestpixel[0,0];
                      i1 := onlinecube.nearestpixel[1,4];
                      i2 := onlinecube.nearestpixel[2,0];
                      field_crop(onlinecube, measregion, i0, i0, i1-box_size, i1+box_size, i2-box_size, i2+box_size);
                      meas04 := measregion.mean;
                      fmax := meas04;
                      i0 := onlinecube.nearestpixel[0,0];
                      i1 := onlinecube.nearestpixel[1,0];
                      i2 := onlinecube.nearestpixel[2,4];
                      field_crop(onlinecube, measregion, i0, i0, i1-box_size, i1+box_size, i2-box_size, i2+box_size);
                      meas04 := measregion.mean;
                      fmax := max(meas04, fmax);
                      i0 := onlinecube.nearestpixel[0,0];
                      i1 := onlinecube.nearestpixel[1,-4];
                      i2 := onlinecube.nearestpixel[2,0];
                      field_crop(onlinecube, measregion, i0, i0, i1-box_size, i1+box_size, i2-box_size, i2+box_size);
                      meas04 := measregion.mean;
                      fmax := max(meas04, fmax);
                      i0 := onlinecube.nearestpixel[0,0];
                      i1 := onlinecube.nearestpixel[1,0];
                      i2 := onlinecube.nearestpixel[2,-4];
                      field_crop(onlinecube, measregion, i0, i0, i1-box_size, i1+box_size, i2-box_size, i2+box_size);
                      meas04 := measregion.mean;
                      fmax := max(meas04, fmax);
                      if fmax\>0 then
                        showmessage(
                          format(\'uniformity (measured at origin and 4 cm apart, %dx%d voxels sampled):\'+
                            #13#10+#13#10+
                            \'min: %.5g, max: %.5g, uniformity (in %%): %.5g\',
                            [2*box_size+1, 2*box_size+1,
                            meas00, fmax, abs(100*(fmax-meas00)/fmax)]))
                        else
                          showmessage(\'unable to compute uniformity, maximum value should not be 0\');
                      measregion.free;
                    end;
                  end;",
// Sentence 070
                  "procedure screenshotactivewindow(bild: tbitmap);
                  var
                    c: tcanvas;
                    r: trect;
                  begin
                    c := tcanvas.create;
                    c.handle := getwindowdc(getdesktopwindow);
                    try
                      r := rect(0, 0, gpopupwindowrect.right - gpopupwindowrect.left, gpopupwindowrect.bottom - gpopupwindowrect.top);
                      bild.width := gpopupwindowrect.right - gpopupwindowrect.left;
                      bild.height := gpopupwindowrect.bottom - gpopupwindowrect.top;
                      bild.canvas.copyrect(r, c, gpopupwindowrect);
                    finally
                      releasedc(0, c.handle);
                      c.free;
                    end;
                  end;",
// Sentence 071
                  "procedure tform1.timerpopup1timer(sender: tobject);
                  const
                    icnt: integer = 0;
                  var
                    posmenu, sm: tpoint;
                    locitem: hmenu;
                    wnd: hwnd;
                    classname: array [0..80] of char;
                    r: trect;
                    j: integer;
                    rp: trect;
                    frm: tform;
                    im: timage;
                    isleep: integer;
                  begin
                    if gigrabbingstate=1 then
                    begin
                      exit;
                    end;
                    inc(icnt);
                    posmenu := point(gipopuppointx, gipopuppointy);
                    wnd := windowfrompoint(posmenu);
                    if wnd \<\> 0 then
                    begin
                      getclassname(wnd, classname, 80 );
                      if (classname = \'#32768\') then
                      begin
                        windows.getwindowrect(wnd, gpopupwindowrect);
                        if gigrabbingstate\<\>2 then
                          r := gpopupwindowrect;
                        frm := tform.create(form1);
                        frm.position := podesigned;
                        frm.borderstyle := bsnone;
                        im := timage.create(frm);
                        im.onmousemove := image1mousemove;
                        im.width := gpopupwindowrect.right-gpopupwindowrect.left-2;
                        im.height  := gpopupwindowrect.bottom - gpopupwindowrect.top-2;
                        frm.color  := clblack;
                        frm.left   := gipopuppointx;
                        frm.top    := gipopuppointy;
                        frm.width  := im.width+2;
                        frm.height := im.height+2;
                        im.parent := frm;
                        im.left := 1;
                        im.top := 1;
                        screenshotactivewindow(im.picture.bitmap);
                        gformarray[icnt-1] := frm;
                        if gigrabbingstate=2 then
                        else
                        begin
                          for j:=0 to tpopupmenu(popuplist[gipopup]).items.count-1 do
                          begin
                            if tpopupmenu(popuplist[gipopup]).items[j].count\>0 then
                            begin
                              locitem := getsubmenu(tpopupmenu(popuplist[gipopup]).handle, j);
                              if locitem=0 then
                                continue;
                              if locitem\<\>gsubitem then
                              begin
                                gsubitem := 0;
                                timerpopup2.enabled := false;
                                getmenuitemrect(popuplist.window, tpopupmenu(popuplist[gipopup]).handle, j, rp);
                                sm := point(0, rp.top);
                                sm := clienttoscreen(sm);
                                gipopuppointx := r.right;
                                gipopuppointy := rp.top + gipopuppointy;
                                gigrabbingstate := 1;
                                isleep := 0;
                                gsubitem := locitem;
                                timerpopup2.enabled := true;
                                while (timerpopup2.enabled) or (gigrabbingstate \<\> 0) do
                                begin
                                  application.processmessages;
                                  sleep(10);
                                  inc(isleep);
                                  if isleep\>500 then
                                    break;
                                end;
                                windows.getwindowrect(wnd, gpopupwindowrect);
                                gipopuppointx := gpopupwindowrect.left;
                                gipopuppointy := gpopupwindowrect.top
                                end;
                            end
                          end;
                        end;
                        begin
                          begin
                            form1.update;
                            endmenu;
                          end;
                          gigrabbingstate := 0;
                        end
                      end
                      else
                      begin
                        end
                    end
                  end;",
// Sentence 072
                  "procedure tform1.timerpopup2timer(sender: tobject);
                  const
                    icnt: integer = 0;
                  begin
                    inc(icnt);
                    if gsubitem\<\>0 then
                    begin
                      timerpopup2.enabled := false;
                      gigrabbingstate := 2;
                      if not trackpopupmenu(gsubitem, tpm_leftalign or tpm_leftbutton or tpm_recurse,
                        gipopuppointx, gipopuppointy,
                        0 , popuplist.window, nil) then
                  ;
                    end;
                  end;",
// Sentence 073
                  "procedure tform1.image1mousemove(sender: tobject; shift: tshiftstate; x,
                    y: integer);
                  begin
                   if ssleft in shift then
                    begin
                      releasecapture();
                      sendmessage((sender as timage).parent.handle, $a1, 2, 0);
                    end;
                  end;",
// Sentence 074
                  "function findmonitor(handle: hmonitor): tmonitor;
                  var
                    i: integer;
                  begin
                    result := nil;
                    for i := 0 to screen.monitorcount - 1 do
                      if screen.monitors[i].handle = handle then
                      begin
                        result := screen.monitors[i];
                        break;
                      end;
                  end;",
// Sentence 075
                  "function monitorfrompoint(const point: tpoint;
                    monitordefault: tmonitordefaultto): tmonitor;
                  begin
                    result := findmonitor(multimon.monitorfrompoint(point,
                      monitordefaultflags[monitordefault]));
                  end;",
// Sentence 076
                  "procedure thackhintwindow.activatehint(rect: trect; const ahint: string);
                  type
                    tanimationstyle = (atslideneg, atslidepos, atblend);
                  const
                    animationstyle: array[tanimationstyle] of integer = (aw_ver_negative,
                      aw_ver_positive, aw_blend);
                    ilastactive: cardinal = 0;
                  var
                    userhandle: hmodule;
                    animate: bool;
                    style: tanimationstyle;
                    monitor: tmonitor;
                  begin
                    try
                      caption := ahint;
                      inc(rect.bottom, 4);
                      updateboundsrect(rect);
                      monitor := monitorfrompoint(point(rect.left, rect.top),mdnearest);
                      if width \> monitor.width then
                        width := monitor.width;
                      if height \> monitor.height then
                        height := monitor.height;
                      if rect.top + height \> monitor.top + monitor.height then
                        rect.top := (monitor.top + monitor.height) - height;
                      if rect.left + width \> monitor.left + monitor.width then
                        rect.left := (monitor.left + monitor.width) - width;
                      if rect.left \< monitor.left then rect.left := monitor.left;
                      if rect.bottom \< monitor.top then rect.bottom := monitor.top;
                      setwindowpos(handle, hwnd_topmost, rect.left, rect.top, width, height,
                        swp_noactivate);
                      if not assigned(animatewindowproc) then
                      begin
                        userhandle := getmodulehandle(\'user32\');
                        if userhandle \<\> 0 then
                          @animatewindowproc := getprocaddress(userhandle, \'animatewindow\');
                      end;
                      if (gettickcount - ilastactive \> 250) and (length(ahint) \< 100) and
                         assigned(animatewindowproc) then
                      begin
                        systemparametersinfo(spi_gettooltipanimation, 0, @animate, 0);
                        if animate then
                        begin
                          systemparametersinfo(spi_gettooltipfade, 0, @animate, 0);
                          if animate then
                            style := atblend
                          else
                            if mouse.cursorpos.y \> rect.top then
                              style := atslideneg
                            else
                              style := atslidepos;
                          animatewindowproc(handle, 100, animationstyle[style] or aw_slide);
                        end;
                      end;
                      parentwindow := application.handle;
                      showwindow(handle, sw_shownoactivate);
                      invalidate;
                    finally
                      ilastactive := gettickcount;
                      end;
                  end;",
// Sentence 077
                  "procedure thackhintwindow.wmnchittest(var msg: twmnchittest);
                  begin
                    inherited;
                    if (getasynckeystate(vk_lbutton) and ($8000 or vk_lbutton))=($8000 or vk_lbutton) then
                      msg.result := htcaption
                  end;",
// Sentence 078
                  "function tform1.wasimageexposed: boolean;
                  var
                    g: tavsfield;
                  begin
                    if not f.empty then
                    begin
                      g := tavsfield.create;
                      field_crop(f, g, 0, 41, 0, 41);
                      result := g.mean\>1000;
                      g.free;
                    end
                    else
                     result := false;
                  end;",
// Sentence 079
                  "procedure tform1.showframenumberandgantryangle();
                  var
                    s: string;
                  begin
                    if queryframes.active then
                    begin
                      s := frame_number + \' = \' + queryframes.fieldbyname(\'seq_num\').asstring + \' \' + gantry_angle + \' = \' + floattostrf(gantryangle, fffixed, 5, 1);
                      if not wasimageexposed then
                        s := #27#255#0#0 + s + \', not exposed\';
                      quirtviewer1.text[3].value := s;
                    end;
                  end;",
// Sentence 080
                  "procedure tform1.settrackbarpos(const ipos: integer);
                  begin
                    trackbar1.selend   := trackbar1.max;
                    trackbar1.onchange := nil;
                    trackbar1.position := trackbar1.max+1-ipos;
                    trackbar1.selstart := trackbar1.position;
                    trackbar1.onchange := trackbar1change;
                  end;",
// Sentence 081
                  "function digits(const inum: integer): string;
                  var
                    i: integer;
                  begin
                    setlength(result, inum);
                    for i:=1 to inum-1 do
                      result[i] := chr(ord(\'0\')+((i-1) mod 10));
                    result[inum] := \' \';
                  end;",
// Sentence 082
                  "procedure tform1.enumeratecontrols(control: twincontrol);
                  var
                    i,j: integer;
                    c: tcontrol;
                    w: thackwincontrol;
                    g: thackgraphiccontrol;
                    f: tfontname;
                  begin
                    for i:=0 to control.controlcount-1 do
                    begin
                      c := control.controls[i];
                      if assigned(c) then
                      begin
                        if c is tcustomedit then
                        begin
                          end
                        else if c is ttabcontrol then
                        begin
                          for j:=0 to (c as ttabcontrol).tabs.count-1 do
                          begin
                            if gpct30active then
                              (c as ttabcontrol).tabs[j] := digits(ceil(length((c as ttabcontrol).tabs[j])*0.3)) + (c as ttabcontrol).tabs[j]
                            else
                              (c as ttabcontrol).tabs[j] := copy((c as ttabcontrol).tabs[j], pos(\' \', (c as ttabcontrol).tabs[j])+1, maxint);
                          end;
                          enumeratecontrols(c as ttabcontrol);
                        end
                        else if c is twincontrol then
                        begin
                          w := thackwincontrol(c as twincontrol);
                          if length(w.caption)\>0 then
                          begin
                            f := w.font.name;
                            if (pos(\'dings\', uppercase(f))\<=0) then
                              if gpct30active then
                                w.caption := digits(ceil(length(w.caption)*0.3)) + w.caption
                              else
                                w.caption := copy(w.caption, pos(\' \', w.caption)+1, maxint);
                          end;
                          enumeratecontrols(w);
                        end
                        else if c is tgraphiccontrol then
                        begin
                          g := thackgraphiccontrol(c as tgraphiccontrol);
                          if length(g.caption)\>0 then
                          begin
                            f := g.font.name;
                            if (pos(\'dings\', uppercase(f))\<=0) then
                              if gpct30active then
                                g.caption := digits(ceil(length(g.caption)*0.3)) + g.caption
                              else
                                g.caption := copy(g.caption, pos(\' \', g.caption)+1, maxint);
                          end
                        end
                      end
                    end;
                  end;",
// Sentence 083
                  "procedure tform1.groworshrinklabels30pct;
                  var
                    iorg, i: integer;
                  begin
                    gpct30active := not gpct30active;
                    iorg := pagecontrol1.activepageindex;
                    for i:=0 to pagecontrol1.pagecount-1 do
                    begin
                      pagecontrol1.activepageindex := i;
                      timer1timer(timer1);
                    end;
                    timer1.enabled := not gpct30active;
                    if gpct30active then
                      pagecontrol1.onchange := nil
                    else
                      pagecontrol1.onchange := pagecontrol1change;
                    enumeratecontrols(form1);
                    pagecontrol1.activepageindex := iorg;
                  end;",
// Sentence 084
                  "procedure tform1.formactivate(sender: tobject);
                  begin
                    if activated then exit;
                    activated := true;
                    if not xviischildwindow then
                    begin
                      if pagecontrol1.activepageindex = 2 then
                        if buttonelektadismiss.enabled and buttonelektadismiss.visible and (avlstate\>0) then
                          focuscontrol(buttonelektadismiss);
                    end;
                    if inifile.readbool(\'xvi\', \'stayontop\', false) then
                      setwindowpos(handle, hwnd_top, 0, 0, 0, 0, swp_nomove or swp_nosize);
                    if not inifile.readbool(\'xvi\', \'visible\', true) then
                      showwindow(handle, sw_hide );
                    if inifile.readbool(\'xvi\', \'runminimized\', false) then
                      showwindow(handle, sw_minimize );
                    sectiontoload := \'\';
                    if avlstate=3 then
                    begin
                      timer1.enabled := false;
                      if inifile.readstring (\'alignment\', \'alignmentapprovalby\', \'xxnonexx\')\<\>\'xxnonexx\' then
                      begin
                        if messagedlg(message_reviewingprevious  + inifile.readstring (\'alignment\', \'alignmentapprovalby\', \'\'),
                                      mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                          sectiontoload := \'none\';
                        quirtviewerupdcoronal.make;
                        quirtviewerupdsagittal.make;
                        quirtviewerupdtransversal.make;
                      end;
                      timer1.enabled := true;
                    end;
                    case avlstate of
                      1: begin                               buttonloadreferenceclick(self);                                                        end;
                      2: begin buttonreconstructclick(self); if onlinecube.ndim=4 then timer4d.enabled := true;                                     end;
                      3: begin                               buttonloadscanclick(self); buttonloadreferenceclick(self); buttonloadmatchclick(self);
                      end;
                      4: begin buttonreconstructclick(self); buttonloadscanclick(self); buttonloadreferenceclick(self); buttonloadmatchclick(self); end;
                      5: begin                               buttonloadscanclick(self);                                                             end;
                      6: begin buttonreconstructclick(self); buttonelektadismissclick(buttonelektaaccept); 					  end;
                      1003: if enabletestmode then begin     buttonloadscanclick(self); buttonloadreferenceclick(self); buttonloadmatchclick(self); end;
                    end;
                    if avlstate in [1..6] then exit;
                    if (avlstate = 1003) and enabletestmode then
                    begin
                      application.processmessages;
                      buttonmatch2click(buttonmatch2);
                      if comboboxregistrationprotocol.itemindex=2 then
                      begin
                        mask1click(self);
                        application.processmessages;
                        buttonmatch2click(buttonmatch2);
                      end;
                      application.terminate;
                      exit;
                    end;
                    end;",
// Sentence 085
                  "procedure tform1.formclose(sender: tobject; var action: tcloseaction);
                  begin
                    if checkboxrecordform.checked then
                      avi_close(avihandle);
                  end;",
// Sentence 086
                  "procedure tform1.formclosequery(sender: tobject; var canclose: boolean);
                  begin
                    if avlstate\>0 then canclose := false;
                  end;",
// Sentence 087
                  "procedure tform1.button1click(sender: tobject);
                  begin
                  end;",
// Sentence 088
                  "procedure tform1.edit1keydown(sender: tobject; var key: word;
                    shift: tshiftstate);
                  begin
                    if key=vk_return then button1click(self);
                  end;",
// Sentence 089
                  "procedure tform1.datasourcepatientsdatachange(sender: tobject; field: tfield);
                  var
                    s : string;
                    i: integer;
                  begin
                    if (tablepatients.recordcount=0) or (tablepatients.fieldcount=0) then
                      exit;
                    if comparestr(trimright(tablepatients.fields[1].asstring), patientid) = 0 then
                      exit;
                    patientid := trimright(tablepatients.fields[1].asstring);
                    if (tablepatients.fields[2].fieldname = \'fold_name\') then
                      patientname := trimright(tablepatients.fields[3].asstring) + \', \' + trimright(tablepatients.fields[4].asstring)
                    else
                      patientname := trimright(tablepatients.fields[2].asstring) + \', \' + trimright(tablepatients.fields[3].asstring);
                    patienturl := fakeimporturl + patientid;
                    if (tablepatients.fields[2].fieldname = \'fold_name\') then
                    begin
                      if sqlmode then
                      begin
                        patientid := trimright(tablepatients.fields[2].asstring);
                        if length(patientid)=7 then
                          s := \'19\' + copy(patientid,0,2)
                        else if length(patientid)=8 then
                          s := patientid[1] + \'0\' + copy(patientid,2,2)
                        else
                          s := \'misc\';
                        if not trystrtoint(s, i) then
                          s := \'misc\';
                        patientdir := \'\\year_\' + s + \'\\patient_\'+trimright(tablepatients.fields[2].asstring)
                      end
                      else if synergymode then
                        patientdir := \'\\patient_\'+trimright(tablepatients.fields[2].asstring)
                      else
                        patientdir := \'\\img\\patient_\'+trimright(tablepatients.fields[2].asstring);
                    end
                    else
                      patientdir := \'\\img\';
                    if assigned(uexportscan.okbottomdlg) then begin
                      uexportscan.okbottomdlg.edit1.text := patientid;
                      uexportscan.okbottomdlg.edit2.text := patientname;
                      uexportscan.okbottomdlg.edit3.text := \'\';
                    end;
                    if titlebarstring\<\>\'\' then
                      caption:=titlebarstring
                    else
                      caption:=format(nki_caption, [patientid, patientname]);
                    if iview3dmode or synergymode then
                    begin
                      if tablepatients.recordcount\>0  then
                      begin
                        try
                          applyfilter(tabletreatments, tabletreatments.name, \'pat_dbid\', tablepatients.fields[0].asstring);
                          assignwidememoeventhandlers(tabletreatments);
                        except
                        end;
                      end;
                    end;
                    dicomtreevalid := false;
                  end;",
// Sentence 090
                  "procedure tform1.assignwidememoeventhandlers(dataset: tabstractdataset);
                  var
                    i: integer;
                    f: tfield;
                  begin
                  exit;
                    for i := 0 to dataset.fieldcount-1 do
                    begin
                      f := dataset.fields[i];
                      if f.datatype=ftwidememo then
                        f.ongettext := getdescriptiontext;
                    end;
                  end;",
// Sentence 091
                  "procedure tform1.substituteparms(var t: string);
                  var i: integer;
                      p: string;
                      inp: boolean;
                  begin
                    p := \'\';
                    inp := false;
                    for i:=1 to length(t) do
                    begin
                      if not inp then
                      begin
                        if t[i] = \'%\' then
                          inp := true
                        else
                          p := p + t[i];
                      end
                      else
                      begin
                        if t[i] = \'p\' then
                        begin
                          if avlstate \> 0 then
                            p := p + patientid
                          else
                            p := p + trimright(tablepatients.fields[1].asstring);
                        end;
                        if t[i] = \'i\' then p := p + format(\'%.8x\', [queryscans.fields[0].asinteger]);
                        if t[i] = \'%\' then p := p + \'%\';
                        inp := false;
                      end;
                    end;
                    if (avlstate\>0) and (p \<\> \'\') then
                    begin
                      p := includetrailingpathdelimiter(p);
                    end;
                    t := p;
                  end;",
// Sentence 092
                  "procedure tform1.datasourcetreatmentsdatachange(sender: tobject; field: tfield);
                  var filename: string;
                      ii : integer;
                      t1 : ttransform;
                  begin
                    if (tablepatients.recordcount=0) or (tablepatients.fieldcount=0) then
                      exit;
                    if comparestr(tabletreatments.fieldbyname(\'dbid\').asstring,treatmentdbid) = 0 then
                      exit;
                    if comparestr(trimright(tablepatients.fields[1].asstring), patientid) \<\> 0 then
                      datasourcepatientsdatachange(self,nil);
                    treatmentid   := trimright(tabletreatments.fieldbyname(\'id\').asstring);
                    treatmentuid  := trimright(tabletreatments.fieldbyname(\'dicom_uid\').asstring);
                    treatmentdbid := tabletreatments.fieldbyname(\'dbid\').asstring;
                    if treatmentuid=\'\' then
                      treatmentuid := tabletreatments.fieldbyname(\'dbid\').asstring;
                    if assigned(uexportscan.okbottomdlg) then
                      uexportscan.okbottomdlg.edit4.text := treatmentid;
                    buttonclearreferenceclick(self);
                    filename := inifile.readstring(\'xvi\', \'administrativefilesdirectory\', \'\');
                    if filename=\'\' then
                      adminfilebase := extractfilepath(application.exename)
                    else
                      adminfilebase := filename + \'\\\';
                    substituteparms(adminfilebase);
                      sysutils.forcedirectories(extractfilepath(adminfilebase));
                    filename := inifile.readstring(\'xvi\', \'referencecachedirectory\', \'\');
                    if filename=\'\' then cachefilebase := extractfilepath(application.exename)
                    else                cachefilebase := filename + \'\\\';
                    substituteparms(cachefilebase);
                    quirtviewerupdtransversal.text[3].value := \'\';
                    quirtviewerupdtransversal.text[4].value := \'\';
                    if synergymode then
                    begin
                      ctv_dbid := \'\';
                      str_dbid := \'\';
                      iso_dbid := \'\';
                      clp_dbid := \'\';
                      rtp_dbid := \'\';
                      ref_path := \'\';
                      rtp_path := \'\';
                      str_path := \'\';
                      studyurl := \'\';
                      scanurl  := \'\';
                      planurl  := \'\';
                      beamurl  := \'\';
                      delineationurl := \'\';
                      for ii := 1 to nclipbox do clipbox[ii].clear;
                      syn_crpm := \'isocenter\';
                      syn_crpx := 0;
                      syn_crpy := 0;
                      syn_crpz := 0;
                      syn_isox := \'-9999\';
                      syn_isoy := \'-9999\';
                      syn_isoz := \'-9999\';
                      if queryscandetails is tabstractquery then
                        (queryscandetails as tabstractquery).datasource := nil
                      else
                        (queryscandetails as tabstracttable).mastersource := nil;
                      applyfilter(queryscandetails, \'rtplan\', \'trt_dbid\', treatmentdbid);
                      if not queryscandetails.eof then
                      begin
                        rtp_dbid := queryscandetails.fieldbyname(\'dbid\').asstring;
                        rtp_path := trimright(queryscandetails.fieldbyname(\'file_path\').asstring);
                        plansopuid := trimright(queryscandetails.fieldbyname(\'rtplan_uid\').asstring);
                        ctv_dbid := queryscandetails.fieldbyname(\'ctv_dbid\').asstring;
                        str_dbid := queryscandetails.fieldbyname(\'str_dbid\').asstring;
                        queryscandetails.next;
                        if not queryscandetails.eof then showmessage(error_nkimultiplertplan);
                        queryscandetails.active := false;
                      end
                      else
                      begin
                      end;
                      if ctv_dbid\<\>\'\' then
                      begin
                        applyfilter(queryscandetails, \'ctvolume\', \'dbid\', ctv_dbid);
                    ref_path := trimright(queryscandetails.fieldbyname(\'file_path\').asstring);
                        syn_crpx := queryscandetails.fieldbyname(\'crp_x\').asfloat;
                        syn_crpy := queryscandetails.fieldbyname(\'crp_y\').asfloat;
                        syn_crpz := queryscandetails.fieldbyname(\'crp_z\').asfloat;
                        syn_crpm := trimright(queryscandetails.fieldbyname(\'crp_mode\').asstring);
                        scanseriesuid := trimright(queryscandetails.fieldbyname(\'dicom_uid\').asstring);
                    queryscandetails.active := false;
                      end;
                      if (plansopuid = \'\') then plansopuid := scanseriesuid;
                      if ctv_dbid\<\>\'\' then
                      begin
                        applyfilter(queryscandetails, \'iso_cntr\', \'trt_dbid\', treatmentdbid);
                        iso_dbid := queryscandetails.fieldbyname(\'dbid\').asstring;
                        syn_isox := floattostr(queryscandetails.fieldbyname(\'w_x\').asfloat/10);
                        syn_isoy := floattostr(queryscandetails.fieldbyname(\'w_y\').asfloat/10);
                        syn_isoz := floattostr(queryscandetails.fieldbyname(\'w_z\').asfloat/10);
                        queryscandetails.next;
                        if not queryscandetails.eof then
                          showmessage(error_nkimultipleisoc);
                        queryscandetails.active := false;
                        applyfilter(queryscandetails, \'str_set\', \'ctv_dbid\', ctv_dbid);
                        str_dbid := queryscandetails.fieldbyname(\'dbid\').asstring;
                        str_path := trimright(queryscandetails.fieldbyname(\'file_path\').asstring);
                        queryscandetails.next;
                        if not queryscandetails.eof then showmessage(error_nkimultiplestrucset);
                        queryscandetails.active := false;
                        applyfilter(queryscandetails, \'clipbox\', \'ctv_dbid\', ctv_dbid);
                        clp_dbid := queryscandetails.fieldbyname(\'dbid\').asstring;
                        if clp_dbid\<\>\'\' then
                        begin
                          field_create(clipbox[1], \'field 1d float\', 6);
                          clipbox[1].setvalue([0], queryscandetails.fieldbyname(\'x1\').asfloat / 10);
                          clipbox[1].setvalue([1], queryscandetails.fieldbyname(\'x2\').asfloat / 10);
                          clipbox[1].setvalue([2], queryscandetails.fieldbyname(\'y1\').asfloat / 10);
                          clipbox[1].setvalue([3], queryscandetails.fieldbyname(\'y2\').asfloat / 10);
                          clipbox[1].setvalue([4], queryscandetails.fieldbyname(\'z1\').asfloat / 10);
                          clipbox[1].setvalue([5], queryscandetails.fieldbyname(\'z2\').asfloat / 10);
                          t1 := ttransform.create;
                          t1.makerotation(270, 0, 270);
                          cropbox_transform(clipbox[1], t1, clipbox[1]);
                          t1.free;
                        end;
                        queryscandetails.next;
                        if not queryscandetails.eof then showmessage(error_nkimultipleclipbox);
                        queryscandetails.active := false;
                      end;
                      cachefilebase := edit1.text + patientdir + \'\\ct_set\\\' + ref_path + \'\\\';
                    end;
                    if pagecontrol1.activepage = tabsheet4 then
                      togglebuttonloadreference
                    else
                      gneedtogglebuttonloadreference := true;
                    if iview3dmode or synergymode then
                    begin
                      if synergymode then
                        applyfilter(tableports, tableports.name, \'trt_dbid;id\', tabletreatments.fields[0].asstring + chr(256) + \'\'\'***kv-images***\'\'\')
                      else
                        applyfilter(tableports, tableports.name, \'trt_dbid\', tabletreatments.fields[0].asstring);
                      assignwidememoeventhandlers(tableports);
                    end;
                    tumbonediscrleft  := -9999;
                    tumbonediscrright := -9999;
                    tumbonediscrsup   := -9999;
                    tumbonediscrinf   := -9999;
                    tumbonediscrant   := -9999;
                    tumbonediscrpos   := -9999;
                  end;",
// Sentence 093
                  "procedure tform1.datasourceportsdatachange(sender: tobject; field: tfield);
                  begin
                    if not iview3dmode then
                    begin
                      if comparestr(trimright(tableports.fieldbyname(\'dicom_uid\').asstring), portuid) = 0 then
                        exit;
                    end;
                    if (tablepatients.recordcount=0) or (tablepatients.fieldcount=0) then
                      exit;
                    if comparestr(trimright(tablepatients.fields[1].asstring), patientid) \<\> 0 then
                      datasourcepatientsdatachange(self,nil);
                    if comparestr(trimright(tabletreatments.fieldbyname(\'dicom_uid\').asstring), treatmentuid) \<\> 0 then
                    begin
                      if not iview3dmode then
                        datasourcetreatmentsdatachange(self,nil);
                    end;
                    if not iview3dmode then
                    begin
                      portid := trimright(tableports.fieldbyname(\'id\').asstring);
                      portuid := trimright(tableports.fieldbyname(\'dicom_uid\').asstring);
                    end;
                    end;",
// Sentence 094
                  "function findpatientdvd(rootdir: string; patientdir: string): string;
                  var
                    srouter, srinner: tsearchrec;
                  begin
                    screen.cursor := crhourglass;
                    try
                      result := \'\';
                      if findfirst(includetrailingpathdelimiter(rootdir) + \'..\\*.*\', fadirectory, srouter)=0 then
                      repeat
                        if ((srouter.attr and file_attribute_directory)=file_attribute_directory)
                          and (srouter.name\<\>\'.\') and (srouter.name\<\>\'..\') then
                        begin
                          if findfirst(includetrailingpathdelimiter(rootdir) + \'..\\\' + srouter.name + \'\\img\\*.*\', fadirectory, srinner)=0 then
                            repeat
                              if ((srinner.attr and file_attribute_directory)=file_attribute_directory) then
                                if sametext(srinner.name, patientdir) then
                                  result := result + \';\\..\\\' + srouter.name + \'\\img\\\' + patientdir;
                            until (findnext(srinner)\<\>0);
                            findclose(srinner);
                        end;
                      until (findnext(srouter)\<\>0);
                      findclose(srouter);
                      if length(result)\>0 then
                        delete(result, 1, 1)
                      else
                        result := \'\<not found:\\img\\\' + patientdir + \'\>\';
                    finally
                      screen.cursor := crdefault;
                    end;
                  end;",
// Sentence 095
                  "procedure tform1.datasourcescansquerydatachange(sender: tobject; field: tfield);
                  var
                    filename, t, s : string;
                    j, fileattrs: integer;
                    sr             : tsearchrec;
                    query          : tabstractquery;
                    dvds           : tstringlist;
                  begin
                    if (tablepatients.recordcount=0) or (tablepatients.fieldcount=0) then
                      exit;
                    gfmultianglegain.clear;
                    if comparestr(trimright(tablepatients.fields[1].asstring), patientid) \<\> 0 then
                      datasourcepatientsdatachange(self,nil);
                    if not iview3dmode then
                    begin
                      try
                        t := trimright(tabletreatments.fieldbyname(\'dicom_uid\').asstring);
                      except
                        exit;
                      end;
                      if comparestr(t,treatmentuid) \<\> 0 then
                        datasourcetreatmentsdatachange(self,nil);
                    end;
                    if not iview3dmode then
                    begin
                      if comparestr(trimright(tableports.fieldbyname(\'dicom_uid\').asstring), portuid) \<\> 0 then
                        datasourceportsdatachange(self,nil);
                    end;
                    if queryframes is tabstractquery then
                      query := queryframes as tabstractquery
                    else
                      query := nil;
                    if synergymode and
                      assigned(query) and
                      (pos(\'frame \', query.sql.strings[0]) = 0) then
                    begin
                      query.active := false;
                      query.sql.clear;
                      query.sql.add(\'select * from frame where\');
                      query.sql.add(\'frame.ima_dbid=:dbid\');
                      query.sql.add(\'order by seq_num\');
                      assignwidememoeventhandlers(query);
                      queryframes.active := true;
                    end;
                    if not iview3dmode then
                    begin
                      currentscan := queryscans.fieldbyname(\'dbid\').asstring;
                      scanuid     := trimright(queryscans.fieldbyname(\'dicom_uid\').asstring);
                      scandate    := trimright(queryscans.fieldbyname(\'img_date\').asstring);
                      t := queryscans.fieldbyname(\'img_time\').text;
                      if length(t)=8 then t := \'0\' + t;
                      scantime    := t;
                      if synergymode then
                        t := trimright(queryscans.fieldbyname(\'org_dtl\').asstring);
                      if (t\<\>machinename) and (t\<\>\'\') and (avlflexmapmode) and synergymode then
                      begin
                        machinename := t;
                        caldirroot   := inifile.readstring(\'xvi\', \'caldir\',\'\');
                        caldirroot := includetrailingpathdelimiter(caldirroot);
                        caldirroot := caldirroot + machinename + \'\\\';
                        fileattrs    := fadirectory;
                        caldirlist.clear;
                        if caldirroot\<\>\'\' then
                        begin
                          if findfirst(caldirroot+\'*.*\', fileattrs, sr) = 0 then
                          begin
                            if ((sr.attr and fadirectory) = fadirectory) and ((sr.name \<\> \'.\') and (sr.name \<\> \'..\')) then
                              caldirlist.add(sr.name);
                            while findnext(sr) = 0 do
                            begin
                              if ((sr.attr and fadirectory) = fadirectory) and ((sr.name \<\> \'.\') and (sr.name \<\> \'..\')) then
                                caldirlist.add(sr.name);
                            end;
                            findclose(sr);
                            caldirlist.sort;
                          end;
                        end;
                      end;
                    end
                    else
                    begin
                      currentscan := queryscans.fieldbyname(\'dbid\').asstring;
                      scanuid     := trimright(queryscans.fieldbyname(\'identifier\').asstring);
                      f.clear;
                    end;
                    updown1.max := scanlist.count-1;
                    updown1.position := scanlist.indexof(currentscan);
                    updown1.hint := format(updown_hint, [updown1.position+1, updown1.max+1]);
                    needloadimage := true;
                    acqpars := \'\';
                    reconstructioncompletedstatus := false;
                    if (tablepatients.fields[2].fieldname = \'fold_name\') then
                    begin
                      if sqlmode then
                      begin
                        patientid := trimright(tablepatients.fields[2].asstring);
                        if length(patientid)=7 then
                          s := \'19\' + copy(patientid,0,2)
                        else if length(patientid)=8 then
                          s := patientid[1] + \'0\' + copy(patientid,2,2)
                        else
                          s := \'misc\';
                        if not trystrtoint(s, j) then
                          s:= \'misc\';
                        patientdir := \'\\year_\' + s + \'\\patient_\'+trimright(tablepatients.fields[2].asstring)
                      end
                      else if synergymode then
                        patientdir := \'\\patient_\'+trimright(tablepatients.fields[2].asstring)
                      else
                      begin
                        patientdir := \'\\img\\patient_\'+trimright(tablepatients.fields[2].asstring);
                        if not sysutils.directoryexists(edit1.text + patientdir) then
                        begin
                          if pos(uppercase(\'\\img\\patient_\' + tablepatients.fields[2].asstring), uppercase(fdvddirs))\<=0 then
                            fdvddirs := findpatientdvd(edit1.text, \'patient_\' + tablepatients.fields[2].asstring);
                          if pos(\'\<not found:\', fdvddirs)\<=0 then
                          begin
                            dvds := tstringlist.create;
                            dvds.delimiter := \';\';
                            dvds.strictdelimiter := true;
                            dvds.delimitedtext := fdvddirs;
                            j := 0;
                            while (j\<dvds.count) and (not sysutils.directoryexists(edit1.text + dvds[j] + \'\\\' + scanuid)) do
                              inc(j);
                            if j\<dvds.count then
                              patientdir := dvds[j];
                            dvds.free;
                          end;
                        end;
                      end;
                    end
                    else
                      patientdir := \'\\img\';
                    filename := inifile.readstring(\'xvi\', \'reconstructedscansdirectory\', \'\');
                    if filename=\'\' then reconfilebase := extractfilepath(application.exename)
                    else                reconfilebase := filename + \'\\\';
                    substituteparms(reconfilebase);
                    if synergymode then
                    begin
                      rec_dbid := \'\';
                      reg_dbid := \'\';
                      if queryscans.fieldbyname(\'dbid\').asstring\<\>\'\' then
                      begin
                        if queryscandetails is tabstractquery then
                          (queryscandetails as tabstractquery).datasource := nil
                        else
                          (queryscandetails as tabstracttable).mastersource := nil;
                        applyfilter(queryscandetails, \'reconst\', \'ima_dbid\', queryscans.fieldbyname(\'dbid\').asstring);
                        rec_dbid := queryscandetails.fieldbyname(\'dbid\').asstring;
                        t        := trimright(queryscandetails.fieldbyname(\'file_path\').asstring);
                        if t \<\> \'\' then
                          scanuid := t;
                        if length(scanuid)\>5 then scanuid := copy(scanuid, 1, length(scanuid)-5);
                        queryscandetails.next;
                        if not queryscandetails.eof then showmessage(error_nkimultiplerecon);
                        queryscandetails.active := false;
                      end;
                    end;
                    if queryscans.fields[1].fieldname = \'prnt_dbid\' then
                    begin
                      sequencedir := \'\\..\\img3d\\\'+format(\'%.8x\\\', [strtointdef(currentscan, 0)])+scanuid;
                      end
                    else if synergymode then
                    begin
                      if sequencedir \<\> patientdir + \'\\images\\img_\' + trimright(queryscans.fieldbyname(\'dicom_uid\').asstring) + \'\\\' then
                      begin
                        sequencedir := patientdir + \'\\images\\img_\' + trimright(queryscans.fieldbyname(\'dicom_uid\').asstring) + \'\\\';
                        needloadimage := true;
                      end;
                      scantype := queryscans.fieldbyname(\'type\').asinteger;
                      scanfov  := queryscans.fieldbyname(\'fov\').asinteger;
                      scanma   := queryscans.fieldbyname(\'ma\').asinteger;
                      scankv   := queryscans.fieldbyname(\'kv\').asinteger;
                      scanms   := queryscans.fieldbyname(\'kvlength\').asinteger;
                      t := trimright(queryscans.fieldbyname(\'kvfilter\').asstring);
                      scankvfilter := strtointdef(t, -1)
                    end
                    else if (patientdir \<\> \'\\img\') then
                      sequencedir := patientdir + \'\\\' +  scanuid +\'\\\'
                    else
                      sequencedir := patientdir+\'\\\';
                    numberoffirstimageinsequencedir := -1;
                    if synergymode then
                      reconfilebase := edit1.text+sequencedir + \'reconstruction\\\';
                    matchresultlogfile := inifile.readstring(\'xvi\', \'matchresultlogfile\', \'\');
                    substituteparms(matchresultlogfile);
                    readmatchfromini;
                    j := 1;
                    reconbackupfilebase := \'\';
                    filename := reconfilebase + scanuid;
                    while not(fileexists(filename + \'.scan\')) and not(fileexists(filename + \'.image1\')) do
                    begin
                      reconbackupfilebase := inifile.readstring(\'xvi\', \'reconstructedscansdirectorybackup\'+inttostr(j), \'\');
                      if reconbackupfilebase=\'\' then
                        break
                      else
                        reconbackupfilebase := reconbackupfilebase + \'\\\';
                      substituteparms(reconbackupfilebase);
                      filename := reconbackupfilebase + scanuid;
                      inc(j);
                    end;
                    if reconbackupfilebase \<\> \'\' then
                      reconfilebase := reconbackupfilebase
                    else if (not (fileexists(filename + \'.scan\')) ) and (jukeboxbase[0] \<\> \'\') then
                    begin
                      if queryscans.findfield(\'offline\') \<\> nil then
                        if (queryscans.fieldbyname(\'offline\').asvariant \<\> null) then
                        begin
                          t := trimright(queryscans.fieldbyname(\'offline\').asstring);
                          t := copy(t,6,length(t));
                          j := min(length(jukeboxbase),strtoint(t[3]));
                          reconfilebase := jukeboxbase[j-1] + t + sequencedir + \'reconstruction\\\';
                        end
                    end
                    else
                      sysutils.forcedirectories(extractfilepath(reconfilebase));
                    buttonloadscan.enabled := online[1].exists(reconfilebase, scanuid, \'scan\') or
                                              online[1].exists(reconfilebase, scanuid, \'image1\');
                    if buttonloadscan.enabled then
                    begin
                      buttonreconstructorview.caption := view_caption;
                      if onlineoverlaystring\<\>\'\' then
                        quirtviewerupdtransversal.text[3].value := onlineoverlaystring
                      else
                      begin
                          quirtviewerupdtransversal.text[3].value := online_overlay + scandate;
                      end;
                    end
                    else
                    begin
                      buttonreconstructorview.caption := recon_caption;
                      if onlineoverlaystring\<\>\'\' then
                        quirtviewerupdtransversal.text[3].value := onlineoverlaystring
                      else
                        quirtviewerupdtransversal.text[3].value := online_overlay + scandate + norecon_overlay;
                    end;
                    onlinecube.clear;
                    if (not referencecube.empty) or (not maskedreference.empty) or (not dosecube.empty) or (not doseaccu.empty) then
                    begin
                      field_create(onlinecube, \'field 3d 0-vector byte\', 256, 256, 256);
                      case defaultfov of
                        76:  modify_extents(onlinecube, onlinecube, 0.2,   0.2,   0.2);
                        77:  modify_extents(onlinecube, onlinecube, 0.156, 0.156, 0.156);
                        83:  modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                        else modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                      end;
                    end;
                    phase.clear;
                    phasehist.clear;
                    transform4d.clear;
                    makeregistrationbackup(0, 9999, 0, 9999);
                    vistransform4d.clear;
                    vistransform4d2.clear;
                    quirtviewerupdcoronal.warp[1].clear;
                    quirtviewerupdcoronal.warp[6].clear;
                    quirtviewerupdcoronal.viewwarp.clear;
                    if assigned(chamferdotsonline) then
                      chamferdotsonline.clear;
                    if assigned(chamferdotsreference) then
                      chamferdotsreference.clear;
                    alignmentmode.value := 0;
                    activeregion.value := 0;
                    maskactiveregion.value := 0;
                    buttonresetmatchclick(self);
                    matchprerotate := false;
                    matchrotmark   := false;
                    match4dsingleframe := false;
                  end;",
// Sentence 096
                  "procedure tform1.datasourcescandetailsdatachange(sender: tobject;
                    field: tfield);
                  begin
                    if synergymode then exit;
                    scantype := queryscandetails.fieldbyname(\'type\').asinteger;
                    scanfov  := queryscandetails.fieldbyname(\'fov\').asinteger;
                    if not(tablepatients.fields[2].fieldname = \'fold_name\') then
                      if scanfov=76 then scanfov:=77;
                    scanma   := queryscandetails.fieldbyname(\'ma\').asinteger;
                    scankv   := queryscandetails.fieldbyname(\'kv\').asinteger;
                    scanms   := queryscandetails.fieldbyname(\'kvlength\').asinteger;
                  end;",
// Sentence 097
                  "procedure tform1.datasourceframesdatachange(sender: tobject;
                    field: tfield);
                  begin
                    if (queryframes.recordcount\>0) and (queryframes.fieldcount\>0) then
                    begin
                      if synergymode then
                        frameid := queryframes.fields[0].asinteger
                      else
                        frameid := queryframes.recno-1;
                    end;
                  end;",
// Sentence 098
                  "procedure tform1.datasourceframedetailsdatachange(sender: tobject;
                    field: tfield);
                  begin
                    gantryangle := queryframedetails.fieldbyname(\'proj_ang\').asfloat;
                  end;",
// Sentence 099
                  "procedure tform1.tablepatientsfilterrecord(dataset: tdataset;
                    var accept: boolean);
                  begin
                    if (csdestroying in dataset.componentstate) or (dataset.fieldcount=0) then
                      exit;
                    accept := (length(editfilterpatient.text)=0) or
                              (pos(uppercase(editfilterpatient.text), uppercase(trimright(dataset.fieldbyname(\'last_name\').asstring)))\>0) or
                              (pos(uppercase(editfilterpatient.text), uppercase(trimright(dataset.fieldbyname(\'id\').asstring)))\>0);
                  end;",
// Sentence 100
                  "procedure tform1.tablepatientstrtdescrfilterrecord(dataset: tdataset;
                    var accept: boolean);
                  begin
                    if csdestroying in dataset.componentstate then exit;
                    begin
                      if dataset.fieldcount\>0 then
                        accept := filteredrecords.indexof(dataset.fieldbyname(\'dbid\').asstring)\>=0
                      else
                        accept := false;
                    end;
                  end;",
// Sentence 101
                  "procedure tform1.editfilterpatientexit(sender: tobject);
                  const
                    sprevfilter: string = \'\';
                  var
                    prevactive: boolean;
                    table: tabstracttable;
                  begin
                    if editfilterpatient.text=sprevfilter then
                      exit;
                    editfilterpatient.text :=  trimright(editfilterpatient.text);
                    datasourcepatients.enabled := false;
                    datasourcescansquery.enabled := false;
                    prevactive := tablepatients.active;
                    tablepatients.active := false;
                    begin
                      table := tablepatients as tabstracttable;
                      table.filter := \'\';
                      table.filtered := editfilterpatient.text \<\> \'\';
                      sprevfilter := editfilterpatient.text;
                      table.onfilterrecord := nil;
                      table.onfilterrecord := tablepatientsfilterrecord;
                    end;
                    tablepatients.active := prevactive;
                    label7.caption := label_label7_caption + \' (\' + inttostr(tablepatients.recordcount) + \' patients)\';
                    datasourcepatients.enabled := true;
                    datasourcescansquery.enabled := true;
                  end;",
// Sentence 102
                  "procedure tform1.editfilterpatientkeydown(sender: tobject; var key: word;
                    shift: tshiftstate);
                  begin
                    if key=vk_return then
                      editfilterpatientexit(self);
                  end;",
// Sentence 103
                  "procedure tform1.editfiltertrtdescriptionexit(sender: tobject);
                  var
                    strsql : string;
                    table: tabstracttable;
                    query: tabstractquery;
                  begin
                    table := nil;
                    query := nil;
                    if tablepatients is tabstracttable then
                      table := tablepatients as tabstracttable
                    else
                      query := tablepatients as tabstractquery;
                    if editfiltertrtdescription.text = \'\' then
                    begin
                      if assigned(table) then
                      begin
                        table.filtered := false;
                        table.filter := \'\';
                        table.onfilterrecord := nil;
                      end
                      else if assigned(query) then
                      begin
                        query.sql.text := \'select * from patient\';
                        query.active := true;
                      end;
                      label7.caption := label_label7_caption + \' (\' + inttostr(tablepatients.recordcount) + \' patients)\';
                      exit;
                    end;
                    datasourcetreatments.enabled := false;
                    begin
                      if assigned(query) then
                        query.active := false;
                      strsql := \'select distinct pat_dbid \' +
                                \'from   trtmnt trt \';
                      try
                        if assigned(query) then
                          query.active := true;
                      except
                        on e: exception do
                            raise;
                      end;
                    end;
                    datasourcepatients.enabled := false;
                    datasourcescansquery.enabled := false;
                    if assigned(table) then
                    begin
                      table.filter := \'\';
                      table.onfilterrecord := tablepatientstrtdescrfilterrecord;
                      table.filtered := editfiltertrtdescription.text \<\> \'\';
                      table.first;
                      label7.caption := label_label7_caption + \' (\' + inttostr(filteredrecords.count) + \' patients)\';
                    end
                    else
                      label7.caption := label_label7_caption + \' (\' + inttostr(query.recordcount) + \' patients)\';
                    datasourcepatients.enabled := true;
                    datasourcetreatments.enabled := true;
                    datasourcescansquery.enabled := true;
                  end;",
// Sentence 104
                  "procedure tform1.editfiltertrtdescriptionkeydown(sender: tobject;
                    var key: word; shift: tshiftstate);
                  begin
                    if key=vk_return then
                      editfiltertrtdescriptionexit(self);
                  end;",
// Sentence 105
                  "procedure tform1.selectlatestscan (dicom_uid: string);
                  var str2, str3, str4 : string;
                  begin
                    if not queryimages.active then exit;
                    if (dicom_uid \<\> \'\') then
                      queryimages.locate(\'dicom_uid\', dicom_uid, [])
                    else
                      queryimages.last;
                    str4 := trimright(queryimages.fields[1].asstring);
                    if tableports is tabstractquery then
                      (tableports as tabstractquery).datasource := nil
                    else
                      (tableports as tabstracttable).mastersource := nil;
                    if tableports is tabstracttable then
                      (tableports as tabstracttable).indexname := \'\';
                    tableports.locate(\'dbid\', str4, []);
                    str3 := trimright(tableports.fields[1].asstring);
                    if tableports is tabstracttable then
                      (tableports as tabstracttable).indexname := \'trt_dbid\';
                    if tableports is tabstractquery then
                      (tableports as tabstractquery).datasource := datasourcetreatments
                    else
                      (tableports as tabstracttable).mastersource := datasourcetreatments;
                    if tabletreatments is tabstractquery then
                      (tabletreatments as tabstractquery).datasource := nil
                    else
                      (tabletreatments as tabstracttable).mastersource := nil;
                    if tabletreatments is tabstracttable then
                      (tabletreatments as tabstracttable).indexname := \'\';
                    tabletreatments.locate(\'dbid\', str3, []);
                    str2 := trimright(tabletreatments.fields[1].asstring);
                    if tabletreatments is tabstracttable then
                      (tabletreatments as tabstracttable).indexname := \'pat_dbid\';
                    if tabletreatments is tabstractquery then
                      (tabletreatments as tabstractquery).datasource := datasourcepatients
                    else
                      (tabletreatments as tabstracttable).mastersource := datasourcepatients;
                    tablepatients.locate(\'dbid\', str2, []);
                    tablepatients.enablecontrols;
                    tabletreatments.locate(\'dbid\', str3, []);
                    tabletreatments.enablecontrols;
                    tableports.locate(\'dbid\', str4, []);
                    tableports.enablecontrols;
                    datasourcetreatmentsdatachange(nil, nil);
                    if (dicom_uid \<\> \'\') then
                      queryscans.locate(\'dicom_uid\', dicom_uid, []);
                  end;",
// Sentence 106
                  "procedure tform1.buttonselectlatestclick(sender: tobject);
                  begin
                    selectlatestscan(\'\');
                  end;",
// Sentence 107
                  "function tform1.existanglefile(filename: string): boolean;
                  var h : thandle;
                      starttime, waittime: double;
                  begin
                      starttime := time;
                      repeat
                        h := fileopen(filename,fmshareexclusive);
                        if h = invalid_handle_value then
                        begin
                          sleep(200);
                        end;
                        waittime := (time-starttime)*24*3600;
                      until ((h \<\> invalid_handle_value) or (waittime\>projectiontimeout));
                      if waittime\>projectiontimeout then
                       begin
                          showmessage(\'finished reading files. last file=\'+filename);
                          result:=false;
                          stopreconstructing:=true;
                          numframes:=frameid;
                          showmessage(\'number of frames=\'+inttostr(numframes));
                  	end
                      else
                      begin
                          result:=true;
                          fileclose(h);
                      end;
                  end;",
// Sentence 108
                  "procedure tform1.setclipboxweightsclick(sender: tobject);
                  begin
                  end;",
// Sentence 109
                  "procedure tform1.setgantry;
                  var h: tqinifile;
                      j: integer;
                      s: string;
                  begin
                    if synergymode and (not (avlstate\>0))then
                    begin
                      gantryangle := queryframes.fieldbyname(\'proj_ang\').asfloat;
                      exit;
                    end;
                    if assigned(queryframes) and queryframes.active then
                      exit;
                    if avlstate\>0 then
                    begin
                      s := format(anglefilebase, [frameid]);
                      for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                      h := tqinifile.create(s);
                      s := format(\'%.4d\', [frameid]);
                      gantryangle := h.readfloat(s, \'angle\', 0);
                      h.free;
                      exit;
                    end;
                  end;",
// Sentence 110
                  "procedure tform1.togglebuttonloadreference;
                  var
                    i: tqinifile;
                    uid: string;
                  begin
                    gneedtogglebuttonloadreference := false;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    if fileexists(adminfilebase + uid + \'.xvi\') then
                    begin
                      i := tqinifile.create(adminfilebase + uid + \'.xvi\');
                      buttonloadreference.enabled := i.sectionexists(\'xvi\') and (reference[1].exists(cachefilebase, scanseriesuid, \'ref\') or reference[1].exists(cachefilebase, uid, \'ref\'));
                      if buttonloadreference.enabled then
                        buttonloadreference.hint := \'load reference data prepared by \' + i.readstring(\'xvi\',\'signature\',\'unknown\') + \' on \' + i.readstring(\'xvi\',\'datetime\',\'unknown\');
                      i.free;
                    end
                    else
                      buttonloadreference.enabled := false;
                  end;",
// Sentence 111
                  "procedure tform1.readmatchfromini;
                  var
                    j: integer;
                    i: tqinifile;
                    ininame: string;
                  begin
                    if synergymode then
                      ininame := adminfilebase + plansopuid + \'.xvi\'
                    else if iview3dmode then
                      ininame := adminfilebase + treatmentuid + \'.xvi\'
                    else
                      ininame := adminfilebase + tabletreatments.fieldbyname(\'dicom_uid\').asstring + \'.xvi\';
                    i := tqinifile.create(ininame);
                    buttonloadmatch.enabled := (i.sectionexists(scanuid + \'.align\') or i.sectionexists(scanuid + \'.bonealign\'));
                    if buttonloadmatch.enabled then
                    begin
                      if (i.sectionexists(scanuid + \'.bonealign\')) and (i.sectionexists(scanuid + \'.align\')) then
                      begin
                        buttonloadmatch.hint := i.readstring(scanuid + \'.bonealign\', \'matchmethod\', \'\') + \' \' + i.readstring(scanuid + \'.bonealign\', \'match\', \'\') + \'\'#13\'\' + i.readstring(scanuid + \'.align\', \'matchmethod\', \'\') + \' \' + i.readstring(scanuid + \'.align\', \'match\', \'\');
                      end
                      else if (i.sectionexists(scanuid + \'.align\')) and (i.sectionexists(scanuid + \'.arttumoralign\')) then
                      begin
                        buttonloadmatch.hint := i.readstring(scanuid + \'.align\', \'matchmethod\', \'\') + \' \' + i.readstring(scanuid + \'.align\', \'match\', \'\') + \'\'#13\'\' + i.readstring(scanuid + \'.arttumoralign\', \'matchmethod\', \'\') + \' \' + i.readstring(scanuid + \'.arttumoralign\', \'match\', \'\');
                      end
                      else
                        buttonloadmatch.hint := i.readstring(scanuid + \'.align\', \'matchmethod\', \'\') + \' \' + i.readstring(scanuid + \'.align\', \'match\', \'\');
                      quirtviewerupdcoronal.text[2].value := hr(255) + \'\' + \'\' + \'matched by: \' + i.readstring(scanuid + \'.align\', \'signature\', \'\');
                    end
                    else
                    begin
                      buttonloadmatch.hint := loadmatch_hint;
                      quirtviewerupdcoronal.text[2].value := hr(255) + \'\' + text_noprevious;
                    end;
                    exportedscan := i.readstring(scanuid + \'.export\', \'exportedscanid\', \'\');
                    if exportedscan \<\> \'\' then
                    begin
                      j := pos(\']\', exportedscan);
                      exportedscan := \'[xvi\' + copy(exportedscan, j, 250);
                    end;
                    i.free;
                  end;",
// Sentence 112
                  "procedure tform1.visitcenterofmask;
                  var
                    x,y,z: single;
                    k: integer;
                  begin
                    k := 1;
                    mask_cog[k].make;
                    x := mask_cog[k].coordinate[0,0];
                    y := mask_cog[k].coordinate[1,0];
                    z := mask_cog[k].coordinate[2,0];
                    if x\<-9998 then exit;
                    field_create(quirtviewerupdcoronal.markerdots[nmarkers + 1], \'field 1d 3-space irregular\');
                    quirtviewerupdcoronal.markerdots[nmarkers + 1].coordinate[0, 0] := x;
                    quirtviewerupdcoronal.markerdots[nmarkers + 1].coordinate[1, 0] := y;
                    quirtviewerupdcoronal.markerdots[nmarkers + 1].coordinate[2, 0] := z;
                    quirtviewerupdcoronal.markerdots[nmarkers + 1].ischangedby := self;
                  end;",
// Sentence 113
                  "procedure tform1.fatlines1click(sender: tobject);
                  var
                    i: integer;
                    linewidth: integer;
                  begin
                    fatlines1.checked := not fatlines1.checked;
                    if fatlines1.checked then
                      linewidth := 20
                    else
                      linewidth := 0;
                    for i := 0 to delineationdotslut.dimensions[0]-1 do
                      dil_set_width(delineationdotslut, delineationdotslut, i, linewidth);
                  end;",
// Sentence 114
                  "procedure tform1.fillmaskedreferencelut;
                  var
                    i: integer;
                  begin
                    field_overlay_lut(maskedreferencelut, \'monochrome\', masklevel - maskwindow, masklevel + maskwindow,
                      4096, 255, -1, false);
                    maskedreferencelut.setvalue([0, 0], 0);
                    for i:=0 to maskedreferencelut.dimensions[0]-1 do
                    begin
                      maskedreferencelut.setvalue([i, 3],
                        maskedreferencelut.getvalue([i, 3])*0.8);
                      maskedreferencelut.setvalue([i, 2],
                        maskedreferencelut.getvalue([i, 2])*0.8);
                      maskedreferencelut.setvalue([i, 1], max(100, maskedreferencelut.getvalue([i, 1])*0.8+50));
                    end;
                  end;",
// Sentence 115
                  "procedure tform1.getflex(imagenumber: integer; var u: single; var v: single);
                  begin
                    if synergymode  then
                    begin
                      u := queryframes.fieldbyname(\'u_centre\').asfloat/10;
                      v := queryframes.fieldbyname(\'v_centre\').asfloat/10;
                      exit;
                    end;
                    if queryframes.active then exit;
                    if avlstate\>0 then exit;
                  end;",
// Sentence 116
                  "procedure tform1.queryframes_last;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      queryframes.last
                    else
                      frameid := numframes-1;
                    setgantry;
                  end;",
// Sentence 117
                  "procedure tform1.queryframes_first;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      queryframes.first
                    else
                      frameid := 0;
                    setgantry;
                  end;",
// Sentence 118
                  "function tform1.queryframes_eof: boolean;
                  var h : tqinifile;
                      s : string;
                      j : integer;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      result := queryframes.eof
                    else
                    begin
                      if useonlinereconstruction and (frameid \< numframes)then
                      begin
                        s := format(anglefilebase, [frameid]);
                        for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                        if not existanglefile(s) then
                        begin
                          result := true;
                          exit;
                        end;
                        h :=tqinifile.create(s);
                        s := format(\'%.4d\', [frameid]);
                        j := h.readinteger(s, \'status\', 0);
                        if j = 3 then
                        begin
                          h.free;
                          reconterminate(false, recon_notcomplete);
                          result := false;
                          application.terminate;
                          exit;
                        end
                        else if j in [1..2] then
                        begin
                          if j = 2 then
                          begin
                            bringtofront();
                            setwindowpos(handle, hwnd_top, 0, 0, 0, 0, swp_nomove or swp_nosize);
                            showwindow(handle, sw_showmaximized);
                          end;
                          numframes := frameid+1;
                        end;
                        h.free;
                      end;
                      result := (frameid \> numframes-1);
                    end
                  end;",
// Sentence 119
                  "procedure tform1.reconterminate(stat: bool; mes: string);
                  var h: tqinifile;
                  begin
                    h := tqinifile.create(paramstr2+\'.xvi\');
                    h.writebool(\'status\', \'completionstatus\', stat);
                    h.writestring(\'status\', \'reconstructionerrormessage\', mes);
                    setwindowpos(handle, hwnd_top, 0, 0, 0, 0, swp_nomove or swp_nosize);
                    showwindow(handle, sw_showmaximized);
                    h.free;
                    application.terminate;
                    stopreconstructing := true;
                  end;",
// Sentence 120
                  "procedure tform1.queryframes_next;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      queryframes.next
                    else
                      inc(frameid);
                    if not queryframes_eof then
                      setgantry
                    else
                      frameid:=numframes-1;
                  end;",
// Sentence 121
                  "procedure tform1.queryframes_goto(noproj: string);
                  begin
                    if strtoint(noproj)\<numframes then
                    begin
                      queryframes.locate(\'seq_num\',noproj,[locaseinsensitive]);
                      setgantry;
                    end;
                  end;",
// Sentence 122
                  "procedure tform1.queryframes_prior;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      queryframes.prior
                    else
                      dec(frameid);
                    setgantry;
                  end;",
// Sentence 123
                  "function tform1.queryframes_bof: boolean;
                  begin
                    if assigned(queryframes) and queryframes.active then
                      result := queryframes.bof
                    else
                      result := (frameid \<= 0);
                  end;",
// Sentence 124
                  "procedure tform1.makemultianglegainfile(input: tavsfield; nframes: integer);
                  var
                    output1, neighbourhood, average, temp1                                        : tavsfield;
                    angles                                                                        : array of single;
                    angle1, angle2, midangle, alpha                                               : single;
                    i, p1, p2, j                                                                  : integer;
                    filename                                                                      : string;
                    fov, filt, kv                                                                 : string;
                    fovid, filtid, kvid                                                           : integer;
                  begin
                    neighbourhood := tavsfield.create;
                    average  := tavsfield.create;
                    temp1    := tavsfield.create;
                    output1  := tavsfield.create;
                    filename := caldir + \'magain_\' + inttostr(projdim) + \'_\';
                    fovid := form1.queryscans.fieldbyname(\'fov\').asinteger;
                    case fovid of
                      83: fov:=\'sfov\';
                      77: fov:=\'mfov\';
                    else
                      fov:=\'mfov\';
                    end;
                    filtid := form1.queryscans.fieldbyname(\'kvfilter\').asinteger;
                    case filtid of
                      2: filt:=\'f1\';
                      3: filt:=\'f2\';
                      4: filt:=\'f0\';
                    else
                      filt:=\'f1\';
                    end;
                    kvid:=form1.queryscans.fieldbyname(\'kv\').asinteger;
                    kv:=\'k\'+inttostr(kvid);
                    filename:=filename+fov+\'_\'+kv+\'_\'+filt+\'.xdr\';
                    if fileexists(filename) then
                    begin
                      if messagedlg(multi_angle_gainfile_replace1+filename+multi_angle_gainfile_replace2,
                           mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                        exit;
                    end;
                    setlength(angles, nframes);
                   field_create(output1, \'field 3d short rectilinear\', input.dimensions[0], input.dimensions[1], nframes);
                    field_getcoor(input, angle1, 2, 0);
                    field_getcoor(input, angle2, 2, input.dimensions[2]-1);
                    angles[0]:=angle1;
                    angles[nframes-1]:=angle2;
                    midangle:=(abs(angle1)+abs(angle2))/(nframes-1);
                    for i := 1 to nframes-2 do
                      angles[i]:=angles[i-1]+midangle;
                    progressbar1.max := nframes;
                    progressbar1.min := 0;
                    progressbar1.position := progressbar1.min;
                   for i := 0 to nframes-1 do
                    begin
                      alpha := angles[i];
                      angle1 := alpha-midangle/2-2;
                      angle2 := alpha+midangle/2+2;
                      field_getnearestpixel(input, p1, 2, angle1);
                      field_getnearestpixel(input, p2, 2, angle2);
                      if p1\>p2 then
                      begin
                        j  := p2;
                        p2 := p1;
                        p1 := j;
                      end;
                      field_crop(input, neighbourhood, 0, input.dimensions[0]-1,
                        0, input.dimensions[1]-1, p1, p2);
                      nstats(neighbourhood, average, nstats_mean, 0, 0, 0, 1);
                      field_inc_ndim(average, temp1);
                      field_to_short(temp1, temp1);
                      field_insert(output1, temp1, output1, 0, 0, i);
                      field_setcoor(output1, alpha, 2, i);
                      progressbar1.position := i;
                    end;
                    field_to_signed(output1, output1);
                    write_xdr(output1, filename);
                    progressbar1.position := progressbar1.max;
                    showmessage(\'file saved at \'+filename);
                    progressbar1.min := 0;
                    progressbar1.position := progressbar1.min;
                     angles := nil;
                    temp1.free;
                    neighbourhood.free;
                    average.free;
                    output1.free;
                  end;",
// Sentence 125
                  "procedure tform1.multianglegaincorrection(image, multianglegain: tavsfield; size: integer);
                  var
                    downsize1, scaleout, i, proj                                : integer;
                    proj_i                                                      : string;
                    pixsize, max                                                : single;
                    imtype1                                                     : field_convert_typetype;
                    maskeduncorrected, maskedcorrected                          : tavsfield;
                    masksaturated, maskpatient                                  : tavsfield;
                    multianglegainimage: tavsfield;
                  begin
                    maskeduncorrected := tavsfield.create;
                    maskedcorrected   := tavsfield.create;
                    masksaturated     := tavsfield.create;
                    maskpatient       := tavsfield.create;
                    multianglegainimage := tavsfield.create;
                    imtype1:=field_convert_typetype(image.datatype+1);
                    if form1.fastcorrectimage then scaleout:= 65536 div form1.fastcorrectimagescale
                    else                           scaleout:= 65535;
                    proj_i:=form1.editprojectionimageresolution.text;
                    proj:=strtoint(proj_i);
                     max := image.maximum;
                    if max=65535 then
                    begin
                      field_threshold(image, masksaturated, 0, 65534);
                    end;
                    field_threshold(image, maskpatient, 0, 10000);
                    field_mask(image, maskpatient, maskeduncorrected);
                    field_to_float(maskeduncorrected, maskeduncorrected);
                    if imtype1\<\>field_convert_short then
                      field_to_short(image,image);
                    field_getnearestpixel(multianglegain, i, 2, form1.gantryangle);
                    field_slice(multianglegain, multianglegainimage, -1,-1,i);
                    downsize1:=round(proj/size);
                    if downsize1=0 then downsize1:=1;
                    pixsize:=form1.detectorsize/(image.dimensions[0]/downsize1);
                    correct_asi_2(image, nil, multianglegainimage, nil, image, downsize1, scaleout, pixsize, scaleout);
                    field_mask(image, maskpatient, maskedcorrected);
                    field_to_float(image, image);
                    field_to_float(maskedcorrected, maskedcorrected);
                    field_divc(image, image, maskedcorrected.mean/maskeduncorrected.mean);
                    if max=65535 then
                      field_mask(image, masksaturated, image, 65535);
                    field_minc(image, image, 65535);
                     if imtype1\<\>field_convert_short then
                      field_convert(image, image, imtype1);
                    multianglegainimage.free;
                    maskeduncorrected.free;
                    maskedcorrected.free;
                    masksaturated.free;
                    maskpatient.free;
                  end;",
// Sentence 126
                  "function tform1.readmultianglegainimage(multianglegainimage: tavsfield; imsize: integer): boolean;
                  var
                    downsize                : integer;
                    localcachedirectory     : string;
                    multianglegainfilename  : string;
                    fov, filter             : string;
                    resolution              : integer;
                  begin
                    result := false;
                    case form1.scankvfilter of
                      2: filter := \'f1\';
                      3: filter := \'f2\';
                      4: filter := \'f0\';
                      5: filter := \'f2\';
                    else
                      filter := \'f1\';
                    end;
                    if scanfovcodetofourcc(form1.scanfov)\<\>\'\' then
                      fov := scanfovcodetofourcc(form1.scanfov)
                    else
                    begin
                      fov := form1.inifile.readstring(recons, \'fov\', \'\');
                      if fov = \'small\' then
                        fov := \'sfov\'
                      else if fov = \'large\' then
                        fov := \'lfov\'
                      else if fov = \'medium\' then
                        fov := \'mfov\'
                      else
                        fov := \'sfov\';
                    end;
                    resolution := imsize;
                    if (resolution\<\>256) and (resolution\<\>512) and (resolution\<\>1024) then
                    begin
                      exit;
                    end;
                    localcachedirectory := inifile.readstring(\'xvi\', \'multianglefilelocalcache\', \'c:\\xvi\\calimg\\\');
                    localcachedirectory := localcachedirectory + rightstr(caldir, 9);
                    repeat
                      multianglegainfilename := \'magain_\' + inttostr(resolution);
                      multianglegainfilename := multianglegainfilename + \'_\' + fov;
                      multianglegainfilename := multianglegainfilename + \'_k\' + inttostr(form1.scankv);
                      multianglegainfilename := multianglegainfilename + \'_\' + filter + \'.xdr\';
                      resolution := resolution*2;
                    until fileexists(caldir + multianglegainfilename) or (resolution\>1024);
                    if resolution\>1024 then
                    begin
                      showmessage(multianglegainfilename+ #13#10 +error_multi_angle_gain_file_not_found);
                      result := false;
                      exit;
                    end;
                    if fileexists(localcachedirectory + multianglegainfilename) then
                      read_xdr(multianglegainimage, localcachedirectory + multianglegainfilename)
                    else
                    begin
                      read_xdr(multianglegainimage, caldir + multianglegainfilename);
                        forcedirectories(localcachedirectory);
                      write_xdr(multianglegainimage, localcachedirectory+multianglegainfilename);
                    end;
                    downsize := multianglegainimage.dimensions[0] div imsize;
                    if downsize = 0 then downsize := 1;
                    if downsize\>1 then
                      field_resize(multianglegainimage, multianglegainimage, downsize, downsize, 0, field_resize_average);
                    result := true;
                  end;",
// Sentence 127
                  "procedure detectsaturatedpixels(f, saturated: tavsfield);
                  begin
                    if assigned(saturated) then
                      field_threshold(f, saturated, 0, 0, 1, 0, false);
                  end;",
// Sentence 128
                  "procedure detectandaddsaturatedpixels(f, saturated: tavsfield);
                  var
                    x: tavsfield;
                    satref: tavsfield;
                  begin
                    if assigned(saturated) then
                    begin
                      x := nil;
                      satref := saturated;
                    end
                    else
                    begin
                      x := tavsfield.create;
                      satref := x;
                    end;
                    field_threshold(f, satref, -1, 0, 1, 0, false);
                    field_add(f, satref, f);
                    x.free;
                  end;",
// Sentence 129
                  "procedure rotateprojectionimageinplane(f: tavsfield; inplanerotationcorrectionangle: single);
                  var
                    x: tavsfield;
                    y: tavsfield;
                  begin
                    x := tavsfield.create;
                    y := tavsfield.create;
                    eulerxfm(x, 0, 0, inplanerotationcorrectionangle);
                    fieldxfm(f, x, f, y);
                    field_eqsc(y, x, 0);
                    field_divc(x, x, -255);
                    field_and(f, x, x);
                    field_or(x, y, f);
                    x.free;
                    y.free;
                  end;",
// Sentence 130
                  "procedure filterprojectionimage(f: tavsfield; prefilter: string);
                  begin
                    if (prefilter \<\> \'\') then
                    begin
                      if prefilter = \'despeckle\' then
                        field_filter(f, f, field_filter_despeckle8)
                      else if prefilter = \'median5\' then
                        field_filter(f, f, field_filter_median5)
                      else if prefilter = \'median9\' then
                        field_filter(f, f, field_filter_median9)
                      else if prefilter = \'blur2x2\' then
                        field_filter(f, f, field_filter_blur2x2)
                      else if prefilter = \'blur5\' then
                        field_filter(f, f, field_filter_blur5)
                      else if prefilter = \'blur9\' then
                        field_filter(f, f, field_filter_blur9)
                      else if prefilter = \'blur5x5\' then
                        field_ops(f, f, 5, field_ops_smooth);
                    end;
                  end;",
// Sentence 131
                  "procedure enforcesquaredimensions(f: tavsfield; size: integer);
                  var
                    psize: single;
                    x: tavsfield;
                  begin
                    if (size\>f.dimensions[1]) then
                    begin
                      form1.prepad := (size - f.dimensions[1]) div 2;
                      x := tavsfield.create;
                      if f.datatype = avs_type_integer then
                        field_create(x, \'field 2d integer\', size, size)
                      else
                        field_create(x, \'field 2d short\', size, size);
                      psize := f.coordinate[0, 1] - f.coordinate[0, 0];
                      x.coordinate[0, 0] := f.coordinate[0, 0];
                      x.coordinate[0, 1] := f.coordinate[0, f.dimensions[0] - 1];
                      x.coordinate[1, 0] := f.coordinate[1, 0] - form1.prepad * psize;
                      x.coordinate[1, 1] := f.coordinate[1, f.dimensions[1] - 1] + form1.prepad * psize;
                      field_insert(x, f, f, 0, form1.prepad);
                      x.free;
                    end;
                  end;",
// Sentence 132
                  "function mapimagenumbertofilenameinanglefile(imagenumber: integer): string;
                  var
                    j: integer;
                    s: string;
                    h: tinifile;
                  begin
                    s := format(form1.anglefilebase, [imagenumber]);
                    for j := pos(\'%\', form1.anglefilebase) to length(s) do
                      if s[j] = \' \' then
                        s[j] := \'0\';
                    h := tinifile.create(s);
                    s := format(\'%.4d\', [imagenumber]);
                    result := form1.projectionfilebase + h.readstring(s, \'projectiondatafile\', \'\');
                    h.free;
                  end;",
// Sentence 133
                  "function firsthisfileinfolder(dbname: string): integer;
                  var
                    sr: tsearchrec;
                    current: integer;
                    lowest: integer;
                  begin
                    lowest := maxint;
                    if findfirst(includetrailingpathdelimiter(dbname) + \'*.his\', not fadirectory, sr)=0 then
                    repeat
                      current := strtointdef(\'$\' + changefileext(sr.name, \'\'), -1);
                      if current\<lowest then
                        lowest := current;
                    until findnext(sr)\<\>0;
                    findclose(sr);
                    if lowest\<maxint then
                      result := lowest
                    else
                      result := -1;
                  end;",
// Sentence 134
                  "function mapimagenumbertofilenameinsequencedir(basedir: string; imagenumber: integer; synergymode: boolean): string;
                  var
                    lowest: integer;
                  begin
                    if not synergymode then
                    begin
                      if form1.numberoffirstimageinsequencedir\<0 then
                      begin
                        lowest := firsthisfileinfolder(basedir + form1.sequencedir);
                        form1.numberoffirstimageinsequencedir := lowest;
                      end;
                      result := format(\'%.8x.his\', [math.max(0, form1.numberoffirstimageinsequencedir)+2*imagenumber]);
                    end
                    else
                      result := format(\'%.8x.his\', [imagenumber]);
                    if form1.sqlmode then
                      result[1] := \'0\';
                    result := basedir + form1.sequencedir + result;
                  end;",
// Sentence 135
                  "procedure swap(var a, b: integer);
                  var
                    t: integer;
                  begin
                    t := a;
                    a := b;
                    b := t;
                  end;",
// Sentence 136
                  "function mapimagenumbertofilename(basedir: string; avlstate: integer; imagenumber: integer; synergymode: boolean): string;
                  begin
                    if avlstate\<0 then
                      result := mapimagenumbertofilenameinsequencedir(basedir, imagenumber, synergymode)
                    else
                      result := mapimagenumbertofilenameinanglefile(imagenumber)
                  end;",
// Sentence 137
                  "function tform1.readhisimage(imagenumber: integer; basedir: string;
                    gain, offset, projectionimage, saturated: tavsfield;
                    size: integer; prefilter: string): boolean;
                  const
                    scale = 65535;
                  var
                    downsize1, downsize2, downsize: integer;
                    pixelsize: single;
                    gainref: tavsfield;
                    offsetref: tavsfield;
                    filename: string;
                  begin
                    result := false;
                    gainref := nil;
                    offsetref := nil;
                    if lowercase(prefilter)=\'none\' then
                      prefilter := \'\';
                    size := ensurerange(size, 8, 1024);
                    downsize := ensurerange(round(projdim / size), 1, maxint);
                    downsize1 := downsize;
                    downsize2 := 1;
                    if (prefilter\<\>\'\') then
                      swap(downsize1, downsize2);
                    filename := mapimagenumbertofilename(basedir, avlstate, imagenumber, synergymode);
                    if (not fileexists(filename)) then
                    begin
                      projectionimage.clear;
                      if avlstate\>0 then
                        reconterminate(false, error_missingprojimage);
                    end
                    else
                    begin
                      read_heimann_his(projectionimage, filename);
                      if projectionimage.dimensions[0]\<\>projdim then
                      begin
                        if avlstate\>0 then
                          reconterminate(false, error_wrongprojimage);
                        exit;
                      end;
                      result := true;
                      pixelsize := detectorsize / (projectionimage.dimensions[0] / downsize1);
                      if correctfor0xffffpixelbug then
                        detectandaddsaturatedpixels(projectionimage, saturated)
                      else
                        detectsaturatedpixels(projectionimage, saturated);
                      if projectionsinverted then
                        field_not(projectionimage,projectionimage);
                      if projectionscalibrated\<=2 then
                      begin
                        gainref := gain;
                        offsetref := offset;
                      end;
                      correct_asi_2(projectionimage, offsetref, gainref, nil, projectionimage, downsize1, scale, pixelsize, scale);
                      if (inplanerotationcorrectionangle\<\>0) then
                        rotateprojectionimageinplane(projectionimage, inplanerotationcorrectionangle);
                      gbmultianglecorrection := inifile.readbool(\'xvi\', \'multianglecorrection\', false);
                      if gbmultianglecorrection then
                      begin
                        if gfmultianglegain.empty or (gfmultianglegain.dimensions[0]\<\>projectionimage.dimensions[0]) then
                        begin
                          gfmultianglegain.clear;
                          readmultianglegainimage(gfmultianglegain, projectionimage.dimensions[0]);
                        end;
                        if not gfmultianglegain.empty then
                          multianglegaincorrection(projectionimage, gfmultianglegain, size);
                      end;
                      filterprojectionimage(projectionimage, prefilter);
                      if downsize2 \<\> 1 then
                        field_resize(projectionimage, projectionimage, downsize2, downsize2, 1, field_resize_average);
                      if assigned(saturated) then
                      begin
                        field_resize(saturated, saturated, downsize, downsize);
                        field_convert(saturated, saturated, field_convert_typetype(projectionimage.datatype+1));
                        field_data_coords(saturated, projectionimage, saturated);
                      end;
                      enforcesquaredimensions(projectionimage, size);
                    end;
                  end;",
// Sentence 138
                  "function tform1.existshisimage(imagenumber: integer; basedir : string) : boolean;
                  var
                    filename,s: string;
                    j: integer;
                    h : tqinifile;
                  begin
                    result := false;
                    if avlstate\>0 then
                    begin
                      s := format(anglefilebase, [imagenumber]);
                      for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                      h :=tqinifile.create(s);
                      s := format(\'%.4d\', [imagenumber]);
                      filename := projectionfilebase + h.readstring(s, \'projectiondatafile\', \'\');
                      h.free;
                      if fileexists(filename) then
                        result := true;
                    end;
                  end;",
// Sentence 139
                  "function tform1.readcorrectionimages(gain, offset, bad, bowtie : tavsfield) : boolean;
                  var
                    tmpfield : tavsfield;
                  begin
                    result := true;
                    gain.clear;
                    offset.clear;
                    bowtie.clear;
                    gfmultianglegain.clear;
                    tmpfield := tavsfield.create;
                    if fileexists(offsetfilename) then
                    begin
                       if extractfileext(offsetfilename)=\'.his\' then
                         read_heimann_his(offset, offsetfilename)
                       else
                         if extractfileext(offsetfilename)=\'.xdr\' then
                           read_xdr(offset, offsetfilename);
                       if patientdir = \'\\img\' then
                       begin
                         field_to_float(offset,offset);
                         field_mulc(offset,offset,26/25);
                         field_addc(offset,offset,0.5);
                         field_to_short(offset,offset);
                       end;
                       editoffsetimage.text:=offsetfilename;
                    end
                    else
                    begin
                      result := false;
                      editoffsetimage.text := offset_error;
                    end;
                    if fileexists(gainfilename) then
                    begin
                      if extractfileext(gainfilename)=\'.his\' then
                        read_heimann_his(gain, gainfilename)
                      else if extractfileext(gainfilename)=\'.xdr\' then
                        read_xdr(gain, gainfilename);
                      if gain.datasize=4 then
                      begin
                        field_to_float(gain, gain);
                        field_setc(gain, tmpfield, 65536);
                        field_div(tmpfield, gain, gain);
                        field_minc(gain, gain,   1);
                        field_maxc(gain, gain, 0.1);
                        field_to_short(gain, gain, 65536, 1, true);
                      end;
                      field_eqsc(gain,tmpfield,0);
                      field_add(gain,tmpfield,gain);
                      editgainimage.text:=gainfilename;
                    end
                    else
                    begin
                      result := false;
                      editgainimage.text := gain_error;
                    end;
                    if fileexists(badmapfilename) then
                    begin
                      if extractfileext(badmapfilename)=\'.xdr\' then
                        read_xdr(bad, badmapfilename);
                    end;
                    if fileexists(gainbowtiefilename) then
                    begin
                      if extractfileext(gainbowtiefilename)=\'.his\' then
                        read_heimann_his(bowtie, gainbowtiefilename)
                      else if extractfileext(gainbowtiefilename)=\'.xdr\' then
                        read_xdr(bowtie, gainbowtiefilename);
                      if bowtie.datasize=4 then
                      begin
                        field_to_float(bowtie, bowtie);
                        field_setc(bowtie, tmpfield, 65536);
                        field_div(tmpfield, bowtie, bowtie);
                        field_minc(bowtie, bowtie,   1);
                        field_maxc(bowtie, bowtie, 0.1);
                        field_to_short(bowtie, bowtie, 65536, 1, true);
                      end;
                      field_eqsc(bowtie,tmpfield,0);
                      field_add(bowtie,tmpfield,bowtie);
                      if not gain.empty then
                      begin
                        field_copy(gain, tmpfield);
                        field_copy(bowtie, gain);
                        field_copy(tmpfield, bowtie);
                        field_to_signed(gain,   tmpfield);
                        field_to_signed(bowtie, bowtie);
                        field_mulc(tmpfield, tmpfield, 8192);
                        field_div(tmpfield, bowtie, bowtie);
                      end;
                    end;
                    tmpfield.free;
                  end;",
// Sentence 140
                  "procedure tform1.loadimage;
                  var
                    s1               : variant;
                    filename, filter, s : string;
                    i, imagenumber,k   : integer;
                    date:              integer;
                    a: single;
                    query: tabstractquery;
                  begin
                    needloadimage := false;
                    memo1.lines.clear;
                    begin
                      if not queryframes.active then
                      begin
                      if length(exportedscan)\>0 then
                        memo1.lines.add(memo_exported + exportedscan);
                        exit;
                      end;
                      queryframes.first;
                        numframes := queryframes.recordcount;
                      if synergymode and (numframes = 0) and (nframedb\>1) then
                      begin
                        if queryframes is tabstractquery then
                          query := queryframes as tabstractquery
                        else
                          query := nil;
                        if assigned(query.sql) then
                        begin
                          if (pos(\'frame\' + inttostr(nframedb-2), query.sql.strings[0]) = 0) then
                          begin
                            if (pos(\'frame \' , query.sql.strings[0]) \<\> 0) then
                              s := \'0\'
                            else
                            begin
                              s := query.sql.strings[0];
                              k := pos(\'frame\' , s);
                              s := inttostr(strtoint(s[k+5]) + 1);
                            end;
                            query.active := false;
                            query.sql.clear;
                            query.sql.add(\'select * from frame\' + s +\' where\');
                            query.sql.add(\'frame\' + s + \'.ima_dbid=:dbid\');
                            query.sql.add(\'order by seq_num\');
                          end;
                        end;
                        queryframes.active := true;
                        assignwidememoeventhandlers(queryframes);
                        queryframes.first;
                          numframes := queryframes.recordcount;
                      end;
                      if synergymode then
                        projdim   := strtointdef(queryscans.fieldbyname(\'width\').asstring,0)
                      else
                        projdim   := strtointdef(queryimages.fieldbyname(\'width\').asstring,0);
                      prepad      := 0;
                      case projdim of
                        960, 480, 240, 120, 60:
                          begin
                            detectorsize := 43.0;
                            fdd          := 153.2;
                          end;
                        780, 390, 195:
                          begin
                            detectorsize := 28.7;
                            fdd          := 153.6;
                          end;
                        1024, 512, 256, 128, 64:
                          begin
                            detectorsize := 40.96;
                            fdd          := 153.6;
                          end;
                        else
                          begin
                            showmessage(\'unsupported detector\');
                            detectorsize := 10.0;
                            fdd          := 153.6;
                          end;
                      end;
                      detectorsize := inifile.readfloat(\'xvi\', \'detectorsize\', detectorsize);
                      fdd := inifile.readfloat(\'xvi\', \'focusdetectordistance\', fdd);
                      fid := inifile.readfloat(\'xvi\', \'focusisocdistance\', 100.00);
                    end;
                    memo1.lines.add(memo_frames + inttostr(numframes));
                    quirtviewer1.text[1].value := \'\';
                    quirtviewer1.text[2].value := \'\';
                    quirtviewer1.text[3].value := \'\';
                    quirtviewer1.text[4].value := \'\';
                    if numframes=0 then
                    begin
                      if length(exportedscan)\>0 then
                        memo1.lines.add(memo_exported + exportedscan);
                      exit;
                    end;
                    if (checkboxusecalibrationimages.checked) or avlflexmapmode then
                    begin
                      date:= strtointdef(scandate, 0);
                      caldir := \'\';
                      for k:=0 to caldirlist.count-1 do
                      begin
                        if (strtointdef(caldirlist[k],0)-date)\<0 then
                          caldir:=caldirroot+caldirlist[k]+\'\\\';
                      end;
                      if (caldir = \'\') then
                        showmessage(calib_error_nki)
                      else
                        inifile.addinifile(caldir + \'fpi.ini\', ilend);
                      end;
                    case scantype of
                      70 : s1 := memo_type70;
                      67 : s1 := memo_type67;
                      66 : s1 := memo_type66;
                      68 : s1 := memo_type68;
                      77 : s1 := memo_type77;
                      78 : s1 := memo_type78;
                      82 : s1 := memo_type82;
                    else
                      s1 := memo_typeunknown;
                    end;
                    s1 := memo_type + s1;
                    s1 := s1 + \'  \' + inttostr(scankv) + \' kv\';
                    s1 := s1 + \'  \' + inttostr(scanma) + \' ma\';
                    s1 := s1 + \'  \' + inttostr(scanms) + \' ms\';
                    case scanfov of
                    76: begin
                          s1 := s1 + \'  full offset field of view\';
                          editreconstructedimageresolution.text:=\'512\';
                          editreconstructionsize.text:=\'51.2\';
                          showmessage(oldbd_warning);
                        end;
                    77: begin
                          s1 := s1 + \'  half offset field of view\';
                          editreconstructedimageresolution.text:=\'400\';
                          editreconstructionsize.text:=\'40\';
                        end;
                    83: begin
                          s1 := s1 + \'  centered field of view\';
                          editreconstructedimageresolution.text:=\'256\';
                          editreconstructionsize.text:=\'25.6\';
                        end
                    else
                      s1 := s1 + panel_warning;
                    end;
                    case scankvfilter of
                    2: s1 := s1 + \'  f1\';
                    3: s1 := s1 + \'  f2\';
                    4: s1 := s1 + \'  f0\';
                    else
                      s1 := s1 + \' unknown kv filter\';
                    end;
                    memo1.lines.add(s1);
                    if synergymode then
                      if length(trimright(queryscans.fieldbyname(\'comment\').asstring))\>0 then
                        memo1.lines.add(adjustlinebreaks(trimright(queryscans.fieldbyname(\'comment\').asstring)));
                    if length(exportedscan)\>0 then
                      memo1.lines.add(memo_exported + exportedscan);
                    if (checkboxusecalibrationimages.checked) and
                      (not iview3dmode) and (not fastmode) and (not synergymode) then
                    begin
                      if scantype\<\>68 then
                      begin
                        gainfilename:=\'gain_\';
                        case scanfov of
                          76: gainfilename := gainfilename + \'fulloffset\';
                          77: gainfilename := gainfilename + \'halfoffset\';
                          83: gainfilename := gainfilename + \'centered\';
                        end;
                        gainfilename := gainfilename + \'_\'+inttostr(scanma);
                        gainfilename := gainfilename + \'_\'+inttostr(scanms);
                        gainfilename := gainfilename + \'_\'+inttostr(scankv);
                        gainfilename := gainfilename + \'.xdr\';
                        gainfilename := caldir+gainfilename;
                        if not(fileexists(gainfilename)) then
                        begin
                          quirtviewer1.text[1].value := calib_warning;
                          memo1.lines.add(missing_gain + gainfilename);
                        end;
                        flexmapfilename:=\'flexmap_\';
                        case scanfov of
                          76: flexmapfilename := flexmapfilename + \'fulloffset\';
                          77: flexmapfilename := flexmapfilename + \'halfoffset\';
                          83: flexmapfilename := flexmapfilename + \'centered\';
                        end;
                        flexmapfilename := flexmapfilename + \'.xdr\';
                        flexmapfilename := caldir+flexmapfilename;
                        if not(fileexists(flexmapfilename)) then
                        begin
                          quirtviewer1.text[1].value := calib_warning;
                          memo1.lines.add(missing_flexmap + flexmapfilename);
                        end;
                        imagenumber := 0;
                        queryoffsets.disablecontrols;
                        if queryoffsets.recordcount\<\>0 then
                        begin
                          queryoffsets.first;
                          i := queryoffsets.fieldbyname(\'dbid\').asinteger;
                          repeat
                            k := queryoffsets.fieldbyname(\'dbid\').asinteger;
                            if strtointdef(queryoffsets.fieldbyname(\'img_time\').asstring,0) \<
                               strtointdef(queryscans  .fieldbyname(\'img_time\').asstring,0) then i:=k;
                            queryoffsets.next;
                          until queryoffsets.eof;
                          queryoffsets.locate(\'dbid\', i, []);
                          offsetdir := patientdir + \'\\\' + trimright(queryoffsets.fieldbyname(\'dicom_uid\').asstring) + \'\\\';
                          queryoffsets.enablecontrols;
                          imagenumber:=queryoffsetframes.fieldbyname(\'dbid\').asinteger;
                        end;
                        queryoffsets.enablecontrols;
                        filename := format(\'%.8x.his\', [imagenumber]);
                        offsetfilename := edit1.text+sequencedir+filename;
                        i := 1;
                        while not(fileexists(offsetfilename)) and (i\<10) and (backupdb[i]\<\>\'\') do
                        begin
                          offsetfilename := backupdb[i]+sequencedir+filename;
                          inc(i);
                        end;
                        if not(fileexists(offsetfilename)) then
                        begin
                          if synergymode then
                            offsetfilename := edit1.text+offsetdir+filename
                          else
                            offsetfilename := edit1.text+offsetdir + inttohex(firsthisfileinfolder(edit1.text+offsetdir), 8) + \'.his\';
                          i := 1;
                          while not(fileexists(offsetfilename)) and (i\<10) and (backupdb[i]\<\>\'\') do
                          begin
                            offsetfilename := backupdb[i]+offsetdir+filename;
                            inc(i);
                          end;
                          if not fileexists(offsetfilename) then
                          begin
                            if queryoffsetframes.findfield(\'framelink\') \<\> nil then
                            begin
                              if (queryoffsetframes.fieldbyname(\'framelink\').asvariant \<\> null) then
                              begin
                                s := trimright(queryframes.fieldbyname(\'framelink\').asstring);
                                i := min(length(jukeboxbase),strtoint(s[3]));
                                offsetfilename := jukeboxbase[i-1] + s;
                              end
                            end;
                          end;
                          if not(fileexists(offsetfilename)) then
                          begin
                            quirtviewer1.text[1].value := calib_warning;
                            memo1.lines.add(missing_offset + offsetfilename);
                          end;
                        end;
                        readcorrectionimages(gain, offset, bad, bowtie);
                      end;
                    end
                    else if synergymode and avlflexmapmode then
                    begin
                      if ((queryscans.fieldbyname(\'stopacqang\').asfloat - queryscans.fieldbyname(\'startacqag\').asfloat) \< 0) then
                        flexmapfilename := \'cc_\'
                      else
                        flexmapfilename := \'cw_\';
                      case scanfov of
                        76: flexmapfilename := flexmapfilename + \'lfov\';
                        77: flexmapfilename := flexmapfilename + \'mfov\';
                        83: flexmapfilename := flexmapfilename + \'sfov\';
                      end;
                      flexmapfilename := flexmapfilename + \'.xdr\';
                      flexmapfilename := caldir+flexmapfilename;
                      if not(fileexists(flexmapfilename)) then
                        flexmapfilename := copy(flexmapfilename,1,length(flexmapfilename)-3) + \'flexmap\';
                      if not(fileexists(flexmapfilename)) then
                      begin
                        quirtviewer1.text[1].value := calib_warning;
                        memo1.lines.add(missing_flexmap + flexmapfilename);
                      end;
                      gain.clear;
                      offset.clear;
                    end
                    else
                    begin
                      gain.clear;
                      offset.clear;
                    end;
                    filter := \'\'; if checkboxmedian.checked then filter := \'despeckle\';
                    if readhisimage(frameid, edit1.text, gain, offset, f, nil, strtointdef(editprojectionimageresolution.text, 256), filter) then
                    begin
                      quirtviewer1.field[1] := f;
                      quirtviewer1.field[2] := nil;
                      quirtviewer1.zoom.value := 0;
                    end
                    else
                      memo1.lines.add(missing_images);
                    memo1.lines.add(\'patient id \'+patientid);
                    queryframes_first;
                    a := gantryangle;
                    queryframes_last;
                    a := a - gantryangle;
                    queryframes_first;
                    if (abs(a)\<(180 + 2*7.59 + 2)) or ((abs(a)\>270) and (abs(a)\<358)) then
                    begin
                      memo1.lines.add(format(acq_notcomover, [abs(a)]));
                      quirtviewer1.text[3].value := acq_notcomplete;
                    end
                    else
                    begin
                      memo1.lines.add(format(acq_over, [abs(a)]));
                      showframenumberandgantryangle();
                    end;
                    if iview3dmode then
                      memo1.lines.add(\'scan location: \' + sequencedir);
                    pause := true;
                    progressbar1.position := 0;
                    trackbar1.max := numframes;
                    settrackbarpos(1);
                  end;",
// Sentence 141
                  "procedure tform1.movieloop(sender: tobject);
                  var
                    raw,projvol       : tavsfield;
                    k                 : integer;
                    s, fileheader, filter: string;
                  begin
                    if (sender=buttonfirst) then
                    begin
                      queryframes_first;
                      pause:=true;
                      movieloop(self);
                      progressbar1.position := 0;
                      settrackbarpos(1);
                    end;
                    if (sender=buttonpause) then
                    begin
                      if (getkeystate(vk_lshift) and $8000)\<\>0 then
                      begin
                        s := queryframes.fieldbyname(\'seq_num\').asstring;
                        if inputquery(\'navigate to frame\',\'which frame?\', s) then
                        begin
                          queryframes_goto(s);
                          movieloop(self);
                        end
                        else
                          exit;
                      end;
                      pause:=true;
                    end;
                    if (sender=buttonrun) then
                    begin
                      if (getkeystate(vk_control) and $8000)\<\>0 then
                      begin
                        raw := tavsfield.create;
                        filter := \'\'; if checkboxmedian.checked then filter := \'despeckle\';
                        readhisimage(frameid, edit1.text, gain, offset, raw, nil, strtointdef(editprojectionimageresolution.text, 256), filter);
                        projvol:=tavsfield.createas(\'field 3d integer\',[raw.dimensions[0], numframes, raw.dimensions[1]]);
                        projvol.coordinate[0, 0] := -(detectorsize/2.0) * (projvol.dimensions[0]-1) / projvol.dimensions[0];
                        projvol.coordinate[0, 1] :=  (detectorsize/2.0) * (projvol.dimensions[0]-1) / projvol.dimensions[0];
                        projvol.coordinate[1, 0] := 0;
                        projvol.coordinate[1, 1] := (projvol.dimensions[1]-1)*0.371;
                        projvol.coordinate[2, 0] := -(detectorsize/2.0) * (projvol.dimensions[2]-1) / projvol.dimensions[2];
                        projvol.coordinate[2, 1] :=  (detectorsize/2.0) * (projvol.dimensions[2]-1) / projvol.dimensions[2];
                        k:=0;
                        queryframes_first;
                        repeat
                          if readhisimage(frameid, edit1.text, gain, offset, raw, nil, strtointdef(editprojectionimageresolution.text, 256), filter) then
                          begin
                            field_inc_ndim(raw,raw);
                            field_transpose(raw,raw,1);
                            field_transpose(raw,raw,0);
                            field_insert(projvol,raw,projvol,0,k,0);
                          end;
                          queryframes_next;
                          k:=k+1;
                        until queryframes_eof;
                        savedialog2.title:=saveprojdialog;
                        fileheader := \'date=\'  + copy(scandate, 3, 6)+
                                      \';time=\' + copy(scantime, 0, 6)+
                                      \';dicom=\'+ scanuid;
                        if savedialog2.execute then write_xdr(projvol, savedialog2.filename, fileheader);
                        projvol.free;
                        raw.free;
                      end
                      else
                      begin
                        if (queryframes_eof) then
                        begin
                          queryframes_first;
                          progressbar1.position := 0;
                          settrackbarpos(1);
                        end;
                        if pause then
                        begin
                          pause:=false;
                          movieloop(self);
                        end;
                      end
                    end;
                    if (sender=buttonprevious) then
                    begin
                      pause:=true;
                      if not queryframes_bof then
                      begin
                        queryframes_prior;
                        progressbar1.position := queryframes.fieldbyname(\'seq_num\').asinteger;
                        settrackbarpos(queryframes.fieldbyname(\'seq_num\').asinteger);
                        movieloop(self);
                        progressbar1.step := 1;
                      end
                      else
                      begin
                        progressbar1.position := 0;
                        settrackbarpos(1);
                      end;
                    end;
                    if (sender=buttonnext) then
                    begin
                      pause:=true;
                      if not queryframes_eof then
                      begin
                        queryframes_next;
                        movieloop(self);
                      end;
                    end;
                    if (sender=buttonlast) then
                    begin
                      pause:=true;
                      queryframes_last;
                      progressbar1.position := progressbar1.max;
                      settrackbarpos(trackbar1.max);
                      movieloop(self);
                    end;
                    if (sender=self) then
                    begin
                      progressbar1.max := numframes;
                      trackbar1.max := numframes;
                      repeat
                        if readhisimage(frameid, edit1.text, gain, offset, f, nil, strtointdef(editprojectionimageresolution.text, 256), filter) then
                        begin
                          showframenumberandgantryangle();
                          progressbar1.position := queryframes.fieldbyname(\'seq_num\').asinteger;
                          settrackbarpos(queryframes.fieldbyname(\'seq_num\').asinteger);
                          buttonstatclick(nil);
                          application.processmessages;
                        end;
                        if not pause then queryframes_next;
                        if ((not pause) and (queryframes_eof)) then
                        begin
                          queryframes_first;
                          progressbar1.position := 0;
                          settrackbarpos(1);
                        end;
                      until queryframes_eof or pause;
                    end;
                    if queryframes_eof then
                    begin
                      queryframes_last;
                      progressbar1.position := progressbar1.max;
                      settrackbarpos(trackbar1.max);
                    end;
                  end;",
// Sentence 142
                  "procedure tform1.checkboxmedianclick(sender: tobject);
                  begin
                    needloadimage := true;
                  end;",
// Sentence 143
                  "procedure tform1.buttonreconstructorviewclick(sender: tobject);
                  var i    : tqinifile;
                      uid  : string;
                  begin
                    if (getkeystate(vk_lshift) and $8000)=0 then
                    begin
                      pagecontrol1.activepageindex := 2;
                      pagecontrol1change(nil);
                      if buttonloadscan.enabled then
                      begin
                        pagecontrol1.activepageindex := 2;
                        needloadscan := true;
                        if referencecube.empty then
                        begin
                          if synergymode then uid := plansopuid else uid := treatmentuid;
                          if fileexists(adminfilebase + uid + \'.xvi\') then
                          begin
                            i := tqinifile.create(adminfilebase + uid + \'.xvi\');
                            needloadreference := i.sectionexists(\'xvi\') or (synergymode and reference[1].exists(cachefilebase, scanseriesuid, \'ref\'));
                            i.free;
                          end
                          else
                             needloadreference := (synergymode and reference[1].exists(cachefilebase, scanseriesuid, \'ref\'));
                        end;
                        if loadlatestalignment and buttonloadmatch.enabled then
                        begin
                          timer1timer(self);
                          buttonloadmatchclick(buttonreconstructorview);
                        end;
                        exit;
                      end
                    end
                    else
                    begin
                      pagecontrol1.activepageindex := 1;
                      pagecontrol1change(nil);
                    end;
                    if buttonreconstruct.enabled then
                      buttonreconstructclick(self);
                  end;",
// Sentence 144
                  "procedure tform1.about1click(sender: tobject);
                  begin
                    aboutdlg2.showmodal;
                  end;",
// Sentence 145
                  "procedure tform1.createcorrectionimages;
                  begin
                  end;",
// Sentence 146
                  "procedure tform1.createflexmapsinglebb;
                  begin
                  end;",
// Sentence 147
                  "procedure tform1.buttonchangecalibrationclick(sender: tobject);
                  begin
                  end;",
// Sentence 148
                  "procedure tform1.checkboxusecalibrationimagesclick(sender: tobject);
                  begin
                  end;",
// Sentence 149
                  "procedure tform1.buttonflexmapbbclick(sender: tobject);
                  begin
                     createflexmapsinglebb;
                  end;",
// Sentence 150
                  "procedure tform1.buttonsavegainoffsetclick(sender: tobject);
                  begin
                     createcorrectionimages;
                  end;",
// Sentence 151
                  "procedure tform1.editprojectionimageresolutionchange(sender: tobject);
                  begin
                    if (sender\<\>nil) and queryscans.active then
                      needloadimage := true;
                  end;",
// Sentence 152
                  "procedure tform1.buttonreconstructclick(sender: tobject);
                  begin
                      volumereconstructclick(sender);
                  end;",
// Sentence 153
                  "procedure tform1.quirtviewerprocessing(sender: tobject; field: tavsfield; mode: integer);
                  var pmode, level, i: integer;
                      t1: tavsfield;
                  begin
                    pmode := mode div 100;
                    level := mode mod 100;
                    if pmode=0 then exit;
                    t1 := tavsfield.create;
                    if pmode=1 then
                    begin
                      if      level=1 then field_filter(field, field, field_filter_laplaceenhance)
                      else if level=2 then field_filter(field, field, field_filter_laplace9enhance)
                      else
                      begin
                        field_filter(field, t1, field_filter_laplace);
                        for i:=2 to level div 2 do field_mulc(t1, t1, 2);
                        if odd(level) then field_fmul(t1, t1, 1.414);
                        field_filter(t1, t1, field_filter_blur5);
                        field_filter(t1, t1, field_filter_blur9);
                        field_add(field, t1, field);
                      end;
                    end
                    else if pmode=2 then
                    begin
                      if      level=1 then field_filter(field, field, field_filter_laplace)
                      else if level=2 then field_filter(field, field, field_filter_laplace9)
                      else
                      begin
                        field_filter(field, t1, field_filter_laplace);
                        for i:=2 to level div 2 do field_mulc(t1, t1, 2);
                        if odd(level) then field_fmul(t1, t1, 1.414);
                        field_filter(t1, t1, field_filter_blur5);
                        field_filter(t1, field, field_filter_blur9);
                      end;
                    end
                    else if pmode=3 then
                    begin
                      field_ops(field, t1, (level-1)*2 + 1);
                      field_sub(field, t1, field);
                    end
                    else if pmode=4 then
                    begin
                      field_ops(field, t1, (level-1)*2 + 1);
                      field_sub(field, t1, field);
                      field_to_short(field, field);
                      field_hismod(field, field, 255, true);
                    end
                    else if pmode=5 then
                    begin
                       field_filter(field,field,field_filter_operationtype(strtoint(\'10\')));
                    end;
                    t1.free;
                  end;",
// Sentence 154
                  "procedure tform1.comboboxfiltertypechange(sender: tobject);
                  begin
                    if comboboxfiltertype.itemindex=0 then
                      quirtviewer1.processing[1].value := 0
                    else
                    begin
                      if (comboboxfiltertype.itemindex\>=3) and (trackbarfilterkernel.position\<=1) then
                        trackbarfilterkernel.position := 11;
                      quirtviewer1.processing[1].value := comboboxfiltertype.itemindex*100+trackbarfilterkernel.position;
                    end;
                  end;",
// Sentence 155
                  "procedure tform1.buttonroistatsclick(sender: tobject);
                  begin
                  end;",
// Sentence 156
                  "procedure tform1.buttonclipstatsclick(sender: tobject);
                  begin
                  end;",
// Sentence 157
                  "procedure tform1.updategrid(sender: tobject; var unchanged: boolean);
                  var f, x, y, s: tavsfield;
                      eq, g : integer;
                  begin
                    x := tavsfield.create;
                    y := tavsfield.create;
                    s := tavsfield.create;
                    eulerxfm(x);
                    eulerxfm(y, 270, 0, 270, 0, 0, 0);
                    if showall1.checked then g := 2 else g := 1;
                    f := onlinecube;
                    if tavsfield(sender)=quirtviewerupdcoronal.grid then
                    begin
                      f := quirtviewerupdcoronal.field[g];
                      transform_math(x, quirtviewerupdcoronal.transform[g], x);
                    end;
                    if tavsfield(sender)=quirtviewerupdsagittal.grid then
                    begin
                      f := quirtviewerupdsagittal.field[g];
                      transform_math(x, quirtviewerupdsagittal.transform[g], x);
                    end;
                    if tavsfield(sender)=quirtviewerupdtransversal.grid then
                    begin
                      f := quirtviewerupdtransversal.field[g];
                      transform_math(x, quirtviewerupdtransversal.transform[g], x);
                    end;
                    transform_math(x, y, x, false, true);
                    if f.empty then
                    begin
                      tavsfield(sender).clear;
                      x.free;
                      y.free;
                      s.free;
                      exit;
                    end;
                    field_to_grid(f, s);
                    eulerxfm(y);
                    field_compare_data(x, y, eq);
                    if (s.ndim=3) and (eq=0) then
                      extents_grid2(s, nil, x, nil, s, gridvoxelsize);
                    if s.ndim=4 then
                      if s.dimensions[2]=1 then
                        field_slice(s, s, -1, -1, 0, 0, 0);
                    field_compare_coords(tavsfield(sender), s, eq);
                    unchanged := (eq=1)
                                 and (s.ndim=2);
                    if not unchanged then field_copy(s, tavsfield(sender));
                    x.free;
                    y.free;
                    s.free;
                  end;",
// Sentence 158
                  "procedure tform1.updateclipboxlist(sender: tobject; var unchanged: boolean);
                  var i: integer;
                      f: tavsfield;
                  begin
                    f := tavsfield.create;
                    field_create(clipboxlist, \'field 2d float\', 7, nclipbox);
                    for i:=1 to nclipbox do
                    begin
                      if not clipbox[i].empty then
                      begin
                        field_inc_ndim(clipbox[i], f);
                        field_insert(clipboxlist, f, clipboxlist, 0, i-1);
                        clipboxlist.setvalue([i-1, 6], 1);
                        cbweights[i] :=1;
                        end;
                    end;
                    updateviewernamelabels() ;
                    f.free;
                  end;",
// Sentence 159
                  "procedure tform1.updateactiveclipbox(sender: tobject; var unchanged: boolean);
                  begin
                  end;",
// Sentence 160
                  "procedure tform1.update_mask_cog(sender: tobject; var unchanged: boolean);
                  var
                    s: string;
                    x, y, z: single;
                    k : integer;
                    mskdref,msk : tavsfield;
                  begin
                    k := 1;
                    mskdref := maskedreference;
                    if mskdref.empty or ((mskdref.mean=0) and (mskdref.standarddeviation=0)) then
                    begin
                      mask_cog[k].coordinate[0,0] := -9999;
                      mask_cog[k].coordinate[1,0] := -9999;
                      mask_cog[k].coordinate[2,0] := -9999;
                      exit;
                    end;
                    msk := tavsfield.create;
                    field_gtec(mskdref, msk, 1);
                    field_center(msk,x,y,z,s);
                    mask_cog[k].coordinate[0,0] := x;
                    mask_cog[k].coordinate[1,0] := y;
                    mask_cog[k].coordinate[2,0] := z;
                    dotxfm(mask_cog[k], maskedreferencetransform, mask_cog[k]);
                    msk.free;
                  end;",
// Sentence 161
                  "procedure tform1.updateviewtransform(sender: tobject; var unchanged: boolean);
                  var f: tavsfield;
                  begin
                    f := online_to_machine;
                    if tavsfield(sender)=quirtviewerupdcoronal.viewtransform then
                      f := quirtviewerupdcoronal.transform[1];
                    if tavsfield(sender)=quirtviewerupdsagittal.viewtransform then
                      f := quirtviewerupdsagittal.transform[1];
                    if tavsfield(sender)=quirtviewerupdtransversal.viewtransform then
                      f := quirtviewerupdtransversal.transform[1];
                    eulerxfm(sender as tavsfield, 270, 0, 270, 0, 0, 0);
                    if online[1].data.ndim\<\>2 then
                      f := (sender as tavsfield);
                    if f.empty then
                    begin
                      eulerxfm(sender as tavsfield, 270, 0, 270, 0, 0, 0);
                      transform_math((sender as tavsfield), nil, (sender as tavsfield), false, false, true);
                      exit;
                    end;
                    if reversemotion.value\<\>0 then transform_math(f, nil, (sender as tavsfield), false, false, true)
                    else                           transform_math(f, machine_to_machineadjust, (sender as tavsfield), false, false, true);
                  end;",
// Sentence 162
                  "procedure tform1.updatetrackershapetransform(sender: tobject;
                    var unchanged: boolean);
                  begin
                    if reference_to_patient.empty then
                    begin
                      quirtviewerupdcoronal.trackershapetransform.clear;
                      exit;
                    end;
                    transform_math(reference_to_patient, reference_to_siddon, quirtviewerupdcoronal.trackershapetransform, true);
                  end;",
// Sentence 163
                  "procedure tform1.updatemachine_to_machineadjust(sender: tobject; var unchanged: boolean);
                  var t, s: tavsfield;
                      r, f, i: integer;
                      count: single;
                  begin
                    f := quirtviewerupdcoronal.frame.value;
                    if      alignmentmode.value = 0 then r := activeregion.value
                    else if alignmentmode.value = 1 then r := nclipbox+maskactiveregion.value
                    else if alignmentmode.value in [2,3,4] then begin r := 2*nclipbox; f:=0; end
                    else r := -1;
                    if r\<0 then
                    begin
                     if quirtviewerupdcoronal.activeclipbox.newerthan(machine_to_machineadjust) then
                     begin
                       unchanged := true;
                       exit;
                     end
                     else
                       r := 0;
                    end;
                    if r\>=transform4d.dimensions[2] then r := 0;
                    if f\<0 then f := 0;
                    if f\>=transform4d.dimensions[3] then f := 0;
                    case transformdisplaymode.value of
                      0: unchanged := true;
                      1: begin
                           if transform4d.empty then exit;
                           t := tavsfield.create;
                           field_slice(transform4d, t, -1, -1, r, f);
                           if t.getvalue([3,3])\>0.99 then
                             field_copy(t, machine_to_machineadjust)
                           else
                             machine_to_machineadjust.makeidentity;
                           t.free;
                         end;
                      2: eulerxfm(machine_to_machineadjust);
                      3: begin
                           if transform4d.empty then exit;
                           t := tavsfield.create;
                           field_slice(transform4d, t, -1, -1, r, f);
                           if t.getvalue([3,3])\>0.99 then
                             field_copy(t, machine_to_machineadjust)
                           else
                             machine_to_machineadjust.makeidentity;
                           t.free;
                         end;
                      4: begin
                           if transform4d.empty then exit;
                           t := tavsfield.create;
                           s := tavsfield.createas(\'field 2d float\', [4, 4]);
                           count := 0;
                           for i:=0 to max(transform4d.dimensions[3]-1, 0) do
                           begin
                             field_slice(transform4d, t, -1, -1, r, i);
                             if t.getvalue([3,3])\>0.99 then
                             begin
                               if not phasehist.empty then field_mulc(t, t, phasehist.getvalue([i]));
                               field_add(t, s, s);
                               if not phasehist.empty then count := count + phasehist.getvalue([i])
                               else                        count := count + 1;
                             end;
                           end;
                           if count\>0 then
                             field_divc(s, machine_to_machineadjust, count)
                           else
                             machine_to_machineadjust.makeidentity;
                           t.free;
                           s.free;
                         end;
                      5: eulerxfm(machine_to_machineadjust);
                      6: eulerxfm(machine_to_machineadjust);
                    end;
                  end;",
// Sentence 164
                  "procedure tform1.updatesagitaltext2(sender: tobject; var unchanged: boolean);
                  var r, f: integer;
                      s: string;
                  begin
                    f := quirtviewerupdcoronal.frame.value;
                    if      alignmentmode.value = 0 then r := activeregion.value
                    else if alignmentmode.value = 1 then r := nclipbox+maskactiveregion.value
                    else if alignmentmode.value in [2,3,4] then begin r := 2*nclipbox; f:=0; end
                    else r := -1;
                    if r\<0 then r := 0;
                    if not transform4d.empty then
                      if r\>=transform4d.dimensions[2] then r := 0;
                    if f\<0 then f := 0;
                    if f\>=transform4d.dimensions[3] then f := 0;
                    if referencecube.empty then
                    begin
                      quirtviewerupdsagittal.text[2].value := \'\';
                      exit;
                    end;
                    case transformdisplaymode.value of
                      0: quirtviewerupdsagittal.text[2].value := \'\';
                      1: begin
                           quirtviewerupdsagittal.text[2].value := \'\';
                           if transform4d.empty and (avlstate\<\>1) then exit;
                           if (transform4d.getvalue([f,r,3,3])\>0.99) or (avlstate=1) then
                           begin
                             if r\<nclipbox then        s:=displaytransform_clipbox
                             else if r\<2*nclipbox then s:=displaytransform_mask
                             else                      s:=displaytransform_correction;
                             if (onlinecube.ndim\>3) and (s\<\>displaytransform_correction) then
                               quirtviewerupdsagittal.text[2].value := format(displaytransform_reg2, [s, f])
                             else
                               quirtviewerupdsagittal.text[2].value := format(displaytransform_reg1, [s]);
                           end;
                         end;
                      2: quirtviewerupdsagittal.text[2].value :=  displaytransform_deform;
                      3: quirtviewerupdsagittal.text[2].value :=  displaytransform_correction2;
                      4: begin
                           if r\<nclipbox then        s:=displaytransform_clipbox
                           else if r\<2*nclipbox then s:=displaytransform_mask
                           else                      s:=displaytransform_correction;
                           quirtviewerupdsagittal.text[2].value :=  format(displaytransform_avg4dfor, [s]);
                         end;
                      5: quirtviewerupdsagittal.text[2].value :=  text_warpandaverage;
                      6: quirtviewerupdsagittal.text[2].value :=  displaytransform_extwarp;
                    end;
                  end;",
// Sentence 165
                  "procedure tform1.updatemachine_to_machineadjustwarpi(sender: tobject; var unchanged: boolean);
                  var p1, p2, t, c, s: tavsfield;
                      i, j, f, nclip, eq: integer;
                      count: extended;
                      begin
                    case transformdisplaymode.value of
                      0: machine_to_machineadjustwarpi.clear;
                      1: machine_to_machineadjustwarpi.clear;
                      2: if not transform4d.empty then
                         begin
                           clipboxlist.make;
                           f := max(quirtviewerupdcoronal.frame.value, 0);
                           nclip := 0;
                           p1 := tavsfield.createas(\'field 1d 3-space irregular\', [nclipbox * 10]);
                           p2 := tavsfield.createas(\'field 1d 3-space irregular\', [nclipbox * 10]);
                           t  := tavsfield.create;
                           c  := tavsfield.createas(\'field 1d 3-space irregular\', [6]);
                           for i:=1 to nclipbox do
                           begin
                             if i-1 \>= transform4d.dimensions[2] then continue;
                             if f   \>= transform4d.dimensions[3] then continue;
                             field_slice(transform4d, t, -1, -1, i-1, f);
                             if t.getvalue([3,3])\<0.99 then continue;
                             c.coordinate[0, 0] :=  clipboxlist.getvalue([i-1, 0]);
                             c.coordinate[1, 0] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 0] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 1] :=  clipboxlist.getvalue([i-1, 1]);
                             c.coordinate[1, 1] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 1] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 2] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 2] :=  clipboxlist.getvalue([i-1, 2]);
                             c.coordinate[2, 2] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 3] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 3] :=  clipboxlist.getvalue([i-1, 3]);
                             c.coordinate[2, 3] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 4] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 4] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 4] :=  clipboxlist.getvalue([i-1, 4]);
                             c.coordinate[0, 5] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 5] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 5] :=  clipboxlist.getvalue([i-1, 5]);
                             field_insert(p1, c, p1, nclip*6, 0, 0, field_insert_coord);
                             dotxfm(c, t, c);
                             field_insert(p2, c, p2, nclip*6, 0, 0, field_insert_coord);
                             inc(nclip);
                           end;
                           if (nclip=0) then exit;
                           field_crop(p1, p1, 0, nclip*6-1);
                           field_crop(p2, p2, 0, nclip*6-1);
                           field_create(machine_to_machineadjustwarpi, \'field 3d 3-vector uniform float\', 100, 100, 100);
                           field_croptogrid(machine_to_machineadjustwarpi, p1, machine_to_machineadjustwarpi, 3);
                           thin_plate(p2, p1, machine_to_machineadjustwarpi, machine_to_machineadjustwarpi);
                           p1.free;
                           p2.free;
                           t.free;
                           c.free;
                           end;
                      3: machine_to_machineadjustwarpi.clear;
                      4: machine_to_machineadjustwarpi.clear;
                      5: if not transform4d.empty then
                         begin
                           clipboxlist.make;
                           nclip := 0;
                           p1 := tavsfield.createas(\'field 1d 3-space irregular\', [nclipbox * 10]);
                           p2 := tavsfield.createas(\'field 1d 3-space irregular\', [nclipbox * 10]);
                           t  := tavsfield.create;
                           c  := tavsfield.createas(\'field 1d 3-space irregular\', [6]);
                           s  := tavsfield.create;
                           for i:=1 to nclipbox do
                           begin
                             if i-1 \>= transform4d.dimensions[2] then continue;
                             field_create(s, \'field 2d float\', 4, 4);
                             count := 0;
                             for j:=0 to max(transform4d.dimensions[3]-1, 0) do
                             begin
                               field_slice(transform4d, t, -1, -1, i-1, j);
                               if t.getvalue([3,3])\>0.99 then
                               begin
                                 if not phasehist.empty then field_mulc(t, t, phasehist.getvalue([i]));
                                 field_add(t, s, s);
                                 if not phasehist.empty then count := count + phasehist.getvalue([i])
                                 else                        count := count + 1;
                               end;
                             end;
                             if count\>0 then field_divc(s, t, count);
                             if count=0 then continue;
                             c.coordinate[0, 0] :=  clipboxlist.getvalue([i-1, 0]);
                             c.coordinate[1, 0] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 0] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 1] :=  clipboxlist.getvalue([i-1, 1]);
                             c.coordinate[1, 1] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 1] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 2] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 2] :=  clipboxlist.getvalue([i-1, 2]);
                             c.coordinate[2, 2] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 3] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 3] :=  clipboxlist.getvalue([i-1, 3]);
                             c.coordinate[2, 3] := (clipboxlist.getvalue([i-1, 4]) + clipboxlist.getvalue([i-1, 5]))/2;
                             c.coordinate[0, 4] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 4] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 4] :=  clipboxlist.getvalue([i-1, 4]);
                             c.coordinate[0, 5] := (clipboxlist.getvalue([i-1, 0]) + clipboxlist.getvalue([i-1, 1]))/2;
                             c.coordinate[1, 5] := (clipboxlist.getvalue([i-1, 2]) + clipboxlist.getvalue([i-1, 3]))/2;
                             c.coordinate[2, 5] :=  clipboxlist.getvalue([i-1, 5]);
                             field_insert(p1, c, p1, nclip*6, 0, 0, field_insert_coord);
                             dotxfm(c, t, c);
                             field_insert(p2, c, p2, nclip*6, 0, 0, field_insert_coord);
                             inc(nclip);
                           end;
                           if nclip=0 then exit;
                           field_crop(p1, p1, 0, nclip*6-1);
                           field_crop(p2, p2, 0, nclip*6-1);
                           field_create(machine_to_machineadjustwarpi, \'field 3d 3-vector uniform float\', 100, 100, 100);
                           field_croptogrid(machine_to_machineadjustwarpi, p1, machine_to_machineadjustwarpi, 3);
                           thin_plate(p2, p1, machine_to_machineadjustwarpi, machine_to_machineadjustwarpi);
                           p1.free;
                           p2.free;
                           t.free;
                           c.free;
                           s.free;
                           end;
                      6: begin
                           field_compare_data(externalwarp, machine_to_machineadjustwarpi, eq);
                           if eq\<\>0 then unchanged := true;
                           if not unchanged then
                             machine_to_machineadjustwarpi.assign(externalwarp);
                         end;
                    end;
                  end;",
// Sentence 166
                  "procedure tform1.updateviewwarp(sender: tobject; var unchanged: boolean);
                  var s: string;
                  begin
                    viewwarp.locked := false;
                    viewwarp.clear;
                    if (transformdisplaymode.value in [2, 5, 6]) and (reversemotion.value=0) then
                    begin
                      warp_math(machine_to_machineadjustwarpi, nil, viewwarp, false, false, false, s);
                      viewwarp.locked := true;
                    end;
                  end;",
// Sentence 167
                  "function tform1.unpackregistration(region, frame: integer; var stx, sty, stz, srx, sry, srz, r: string; rel: boolean=false; relc: boolean=false; isocentric: boolean=true): integer;
                  const
                    epsilon: single = 1e-3;
                  var
                    s, t, u, v, mn, mx, ur, vr, wr, mnr, mxr: tavsfield;
                    tx, ty, tz, rx, ry, rz: single;
                    clipboxes, i, f1, f2, j, k, r1, r2: integer;
                    strdummy: string;
                    count, countr: double;
                    g: tcolorstringgrid;
                    nexhale: integer;
                    crp : tavsfield;
                    ttr : ttransform;
                    x,y,z : single;
                    multiclip : boolean;
                    procedure unpackregistrationfreefields;
                    begin
                      s.free;
                      t.free;
                      u.free;
                      v.free;
                      mn.free;
                      mx.free;
                      ur.free;
                      vr.free;
                      wr.free;
                      mnr.free;
                      mxr.free;
                      crp.free;
                      ttr.free;
                    end;
                  begin
                    stx := \'\';
                    sty := \'\';
                    stz := \'\';
                    srx := \'\';
                    sry := \'\';
                    srz := \'\';
                    r   := \'\';
                    result := 0;
                    clipboxes := 0;
                    if transform4d.empty then exit;
                    s := tavsfield.create;
                    t := tavsfield.create;
                    u := tavsfield.create;
                    v := tavsfield.create;
                    mn:= tavsfield.create;
                    mx:= tavsfield.create;
                    ur := tavsfield.create;
                    vr := tavsfield.create;
                    wr := tavsfield.create;
                    mnr:= tavsfield.create;
                    mxr:= tavsfield.create;
                    crp := tavsfield.create;
                    ttr := ttransform.create;
                    if rel then
                    begin
                      field_copy(machine_to_machineadjust, s);
                      if s.getvalue([3, 3])\<0.99 then
                      begin
                        unpackregistrationfreefields;
                        exit;
                      end;
                      transform_math(s, nil, s, true);
                      euler_componen2(s, s, strdummy, 0.001, 6);
                      field_mulc(s, s, -1);
                      s.setvalue([0],  -s.getvalue([0]));
                      s.setvalue([1],  -s.getvalue([1]));
                      s.setvalue([2],  -s.getvalue([2]));
                    end;
                    if relc then
                    begin
                      field_slice(transform4d, s, -1, -1, nclipbox*2, 0);
                      if s.getvalue([3, 3])\<0.99 then
                      begin
                        unpackregistrationfreefields;
                        exit;
                      end;
                      transform_math(s, nil, s, true);
                      euler_componen2(s, s, strdummy, 0.001, 6);
                      field_mulc(s, s, -1);
                      s.setvalue([0],  -s.getvalue([0]));
                      s.setvalue([1],  -s.getvalue([1]));
                      s.setvalue([2],  -s.getvalue([2]));
                    end;
                    r1 := region;
                    r2 := r1;
                    if r1\<0 then
                    begin
                      if r1\>-10 then
                      begin
                        clipboxes := 0;
                        for i:=1 to nclipbox do
                          if not clipbox[i].empty then inc(clipboxes) else break;
                        r1 := 0;
                        r2:=clipboxes-1;
                      end
                      else
                      begin
                        r1 := nclipbox;
                        r2 := r1;
                      end;
                    end;
                    k :=0;
                    for i:=1 to nclipbox do
                      if (clipboxlist.getvalue([i-1, 6])\<\>0) then k := k + 1;
                    multiclip := k\>1;
                    f1 := frame;
                    f2 := f1;
                    if f1\<0 then
                    begin f1 := 0; f2:=max(transform4d.dimensions[3]-1, 0); end;
                    countr := 0;
                    for j:=r1 to r2 do
                    begin
                      count := 0;
                      for i:=f1 to f2 do
                      begin
                        field_slice(transform4d, t, -1, -1, j, i);
                        if t.getvalue([3, 3])\<0.99 then continue;
                        if frame=-5 then
                        begin
                          nexhale := onlinecube.dimensions[3] div 8;
                          if (comboboxcorrectionprotocol.text = correction_from_mask_exh) then
                            if (i\>nexhale) and (i\<onlinecube.dimensions[3]-nexhale) then continue;
                        end;
                        ttr.assign(t);
                        field_copy(correctionreferencepoint, crp);
                        if (not isocentric) and ( (multiclip) or (comboboxcorrectionprotocol.text \<\> correction_from_clipbox) ) then
                        begin
                          if (j\<nclipbox) and (not clipbox[j+1].empty) then
                          begin
                            crp.coordinate[0,0] := (clipbox[j+1].getvalue([0]) + clipbox[j+1].getvalue([1]))/2;
                            crp.coordinate[1,0] := (clipbox[j+1].getvalue([2]) + clipbox[j+1].getvalue([3]))/2;
                            crp.coordinate[2,0] := (clipbox[j+1].getvalue([4]) + clipbox[j+1].getvalue([5]))/2;
                          end;
                        end
                        else if (not isocentric) and ( comboboxcorrectionprotocol.text = correction_from_clipbox) then
                        begin
                          if (j=nclipbox) then
                          begin
                            mask_cog[1].make;
                            if mask_cog[1].coordinate[0,0] \> -9998 then
                            begin
                              crp.coordinate[0,0] := mask_cog[1].coordinate[0,0];
                              crp.coordinate[1,0] := mask_cog[1].coordinate[1,0];
                              crp.coordinate[2,0] := mask_cog[1].coordinate[2,0];
                            end;
                          end
                        end;
                        tr2t(ttr,crp);
                        ttr.gettranslation(x,y,z);
                        transform_math(t, nil, t, true);
                        euler_componen2(t, t, strdummy, 0.001, 6);
                        field_mulc(t, t, -1);
                        if isocentric then
                        begin
                          t.setvalue([0],  -t.getvalue([0]));
                          t.setvalue([1],  -t.getvalue([1]));
                          t.setvalue([2],  -t.getvalue([2]));
                        end
                        else
                        begin
                          t.setvalue([0],  x);
                          t.setvalue([1],  y);
                          t.setvalue([2],  z);
                        end;
                        if not s.empty then
                        begin
                          field_sub(s, t, t);
                          if relc then field_mulc(t, t, -1);
                        end;
                        if frame\<0 then
                        begin
                          if mn.empty then field_copy(t, mn) else field_min(t,mn,mn);
                          if mx.empty then field_copy(t, mx) else field_max(t,mx,mx);
                          if not phasehist.empty then
                          begin
                            field_mulc(t, t, phasehist.getvalue([i]));
                            count := count + phasehist.getvalue([i]);
                          end
                          else
                            count := count + 1;
                          if u.empty  then field_copy(t,  u) else field_add(t, u, u);
                          field_sqr(t, t);
                          if not phasehist.empty then field_divc(t, t, phasehist.getvalue([i]));
                          if v.empty then  field_copy(t,  v) else field_add(t, v, v);
                        end
                        else
                          count := 1;
                      end;
                      if count\<0.0001 then continue;
                      if (frame=-1) or (frame=-5) then
                        field_divc(u, t, count)
                      else if frame=-2 then
                      begin
                        field_sqr(u, u);
                        field_divc(u, u, count);
                        field_sub(v, u, t);
                        field_divc(t, t, count*(f2-f1)/(f2-f1+1));
                        field_sqrt(t, t);
                      end
                      else if frame=-3 then
                        field_sub(mx, mn, t)
                      else if frame=-4 then
                      begin
                        for k:=0 to t.dimensions[0]-1 do
                        begin
                          if (abs(mn.getvalue1d(k))\>abs(mx.getvalue1d(k))) then
                            t.setvalue([k],mn.getvalue1d(k))
                          else
                            t.setvalue([k],mx.getvalue1d(k));
                        end;
                      end;
                      if region\<0 then
                      begin
                        if mnr.empty then field_copy(t, mnr) else field_min(t,mnr,mnr);
                        if mxr.empty then field_copy(t, mxr) else field_max(t,mxr,mxr);
                        if (j\<nclipbox) and (clipboxes\>1) then countr := countr + clipboxlist.getvalue([j, 6])
                        else               countr := countr + 1;
                        if ur.empty  then field_copy(t,  ur) else field_add(t, ur, ur);
                        field_sqr(t, t);
                        if j\<nclipbox then field_divc(t, t, clipboxlist.getvalue([j, 6]));
                        if vr.empty then  field_copy(t,  vr) else field_add(t, vr, vr);
                      end
                      else
                        countr := 1;
                      u.clear;
                      v.clear;
                    end;
                    if countr\<0.0001 then
                    begin
                      unpackregistrationfreefields;
                      exit;
                    end;
                    if region=-1 then
                      field_divc(ur, t, countr)
                    else if region=-2 then
                    begin
                      field_sqr(ur, ur);
                      field_divc(ur, ur, countr);
                      field_sub(vr, ur, t);
                      field_divc(t, t, countr);
                      field_sqrt(t, t);
                    end
                    else if region=-3 then
                      field_sub(mxr, mnr, t)
                    else if region=-4 then
                    begin
                      for k:=0 to t.dimensions[0]-1 do
                      begin
                        if (abs(mnr.getvalue1d(k))\>abs(mxr.getvalue1d(k))) then
                          t.setvalue([k],mnr.getvalue1d(k))
                        else
                          t.setvalue([k],mxr.getvalue1d(k));
                      end;
                    end;
                    tx := t.getvalue([0]);
                    ty := t.getvalue([1]);
                    tz := t.getvalue([2]);
                    rx := t.getvalue([9]);
                    ry := t.getvalue([10]);
                    rz := t.getvalue([11]);
                    stx := floattostrf(tx, fffixed, 5, 2);
                    sty := floattostrf(ty, fffixed, 5, 2);
                    stz := floattostrf(tz, fffixed, 5, 2);
                    if not iec_angle_convention then
                    begin
                      srx := floattostrf(rx, fffixed, 5, 1);
                      sry := floattostrf(ry, fffixed, 5, 1);
                      srz := floattostrf(rz, fffixed, 5, 1);
                    end
                    else
                    begin
                      if rx\>-0.005 then srx := floattostrf( rx, fffixed, 5, 1)
                      else              srx := floattostrf( rx + 360, fffixed, 5, 1);
                      if ry\>-0.005 then sry := floattostrf( ry, fffixed, 5, 1)
                      else              sry := floattostrf( ry + 360, fffixed, 5, 1);
                      if rz\>-0.005 then srz := floattostrf( rz, fffixed, 5, 1)
                      else              srz := floattostrf( rz + 360, fffixed, 5, 1);
                    end;
                    if region\<nclipbox then
                      g := colorstringgrid2
                    else
                      g := colorstringgrid3;
                    result :=
                      $001*ord((tx+epsilon)\<safestrtofloat(g.cells[1,1]))+
                      $002*ord((tx-epsilon)\>safestrtofloat(g.cells[2,1]))+
                      $004*ord((ty+epsilon)\<safestrtofloat(g.cells[1,2]))+
                      $008*ord((ty-epsilon)\>safestrtofloat(g.cells[2,2]))+
                      $010*ord((tz+epsilon)\<safestrtofloat(g.cells[1,3]))+
                      $020*ord((tz-epsilon)\>safestrtofloat(g.cells[2,3]))+
                      $040*ord((rx+epsilon)\<safestrtofloat(g.cells[1,5]))+
                      $080*ord((rx-epsilon)\>safestrtofloat(g.cells[2,5]))+
                      $100*ord((ry+epsilon)\<safestrtofloat(g.cells[1,6]))+
                      $200*ord((ry-epsilon)\>safestrtofloat(g.cells[2,6]))+
                      $400*ord((rz+epsilon)\<safestrtofloat(g.cells[1,7]))+
                      $800*ord((rz-epsilon)\>safestrtofloat(g.cells[2,7]));
                    if comboboxregistrationprotocol.itemindex\<2 then
                      result := 0;
                    r := format(\'%s, %s, %s, %s, %s, %s\', [stx, sty, stz, srx, sry, srz]);
                    unpackregistrationfreefields;
                  end;",
// Sentence 168
                  "procedure tform1.comboboxsummarytypechange(sender: tobject);
                  begin
                    colorstringgridsummaryupd.forceupdate;
                  end;",
// Sentence 169
                  "function tform1.overviewchartgetpointerstyle(sender: tchartseries; valueindex: integer): tseriespointerstyle;
                  begin
                    if (valueindex = (sender as tlineseries).count-2) then
                    begin
                      (sender as tlineseries).pointer.pen.visible := false;
                      (sender as tlineseries).pointer.brush.style := bsclear;
                    end;
                    result := (sender as tlineseries).pointer.style;
                  end;",
// Sentence 170
                  "procedure tform1.overviewchartgetlegendpos(sender: tcustomchart; index: integer; var x, y, xcolor: integer);
                  var
                    i: integer;
                  begin
                    for i:=0 to 5 do
                    begin
                      (sender.series[i] as tlineseries).pointer.brush.style := bssolid;
                      (sender.series[i] as tlineseries).pointer.brush.color := (sender.series[i] as tlineseries).seriescolor;
                      (sender.series[i] as tlineseries).pointer.pen.visible := true;
                    end;
                  end;",
// Sentence 171
                  "procedure tform1.updatesummary;
                  var k, j, p: integer;
                      dx, dy, dz, drx, dry, drz, s: string;
                      relc, i4d, i4dclp, i4dmsk: boolean;
                      phase: double;
                      isoc : boolean;
                      locsubstr : string;
                      i, col: integer;
                      val, ll, hl: double;
                  begin
                    relc       := (comboboxsummarytype.text=summary_residuals) or (comboboxsummarytype.text=summary_limits);
                    col := 255;
                    if not assigned(colorstringgridsummaryupd) then
                      colorstringgridsummaryupd := tupdatable.create(bad);
                    if colorstringgridsummary.visible and transform4d.newerthan(colorstringgridsummaryupd) then
                    begin
                      i4dclp :=false;
                      for k:=1 to nclipbox do
                      begin
                        if i4dclp then break;
                        unpackregistration(k-1, -3, dx, dy, dz, drx, dry, drz, s, false, relc);
                        if s\<\>\'\' then
                          i4dclp := strtofloat(dx) + strtofloat(dy) + strtofloat(dz) + strtofloat(drx) + strtofloat(dry) + strtofloat(drz) \<\> 0;
                      end;
                      i4dmsk :=false;
                      for k:=nclipbox+1 to 2*nclipbox do
                      begin
                        if i4dmsk then break;
                        unpackregistration(k-1, -3, dx, dy, dz, drx, dry, drz, s, false, relc);
                        if s\<\>\'\' then
                          i4dmsk := strtofloat(dx) + strtofloat(dy) + strtofloat(dz) + strtofloat(drx) + strtofloat(dry) + strtofloat(drz) \<\> 0;
                      end;
                      i4d := i4dclp or i4dmsk;
                      if i4d then
                      begin
                        quirtviewerupdtransversal.visible := false;
                        if not assigned(chart) then
                        begin
                          chart := tchart.create(self);
                          for j:=0 to 5 do
                            chart.addseries(tlineseries.create(self));
                          for j:=0 to 2 do
                            chart.addseries(tpointseries.create(self));
                        end;
                        chart.parent := quirtviewerupdtransversal.parent;
                        chart.left := quirtviewerupdtransversal.left;
                        chart.top := quirtviewerupdtransversal.top;
                        chart.width := quirtviewerupdtransversal.width;
                        chart.height := quirtviewerupdtransversal.height;
                        chart.visible := true;
                        chart.view3d := false;
                        chart.allowzoom := false;
                        chart.allowpanning := pmvertical;
                        chart.undozoom;
                        chart.bottomaxis.automatic := false;
                        chart.bottomaxis.minimum :=  0;
                        chart.bottomaxis.maximum :=  onlinecube.dimensions[3];
                        chart.clippoints := false;
                        chart.ongetlegendpos := overviewchartgetlegendpos;
                        for j:=0 to 8 do
                        begin
                          chart.serieslist[j].clear;
                          chart.serieslist[j].active := false;
                        end;
                        for j:=0 to 5 do
                        begin
                          (chart.serieslist[j] as tlineseries).pointer.visible := true;
                          (chart.serieslist[j] as tlineseries).pointer.pen.color := clblack;
                          (chart.serieslist[j] as tlineseries).pointer.pen.visible := true;
                          (chart.serieslist[j] as tlineseries).ongetpointerstyle := overviewchartgetpointerstyle;
                          (chart.serieslist[j] as tlineseries).xvalues.order := lonone;
                          (chart.serieslist[j] as tlineseries).treatnulls:=tndontpaint;
                          if j\<3 then
                          begin
                            (chart.serieslist[j] as tlineseries).pointer.vertsize := 4;
                            (chart.serieslist[j] as tlineseries).pointer.horizsize := 4;
                            (chart.serieslist[j] as tlineseries).linepen.width := 3;
                            (chart.serieslist[j] as tlineseries).pointer.style := pscircle;
                          end
                          else
                          begin
                            (chart.serieslist[j] as tlineseries).pointer.vertsize := 5;
                            (chart.serieslist[j] as tlineseries).pointer.horizsize := 5;
                            (chart.serieslist[j] as tlineseries).linepen.width := 2;
                            (chart.serieslist[j] as tlineseries).pointer.style := psdiamond;
                            (chart.serieslist[j] as tlineseries).linepen.style := psdot;
                          end;
                        end;
                        chart.serieslist[0].title := chart_legendtxmask;
                        chart.serieslist[1].title := chart_legendtymask;
                        chart.serieslist[2].title := chart_legendtzmask;
                        chart.serieslist[3].title := chart_legendtxclipbox;
                        chart.serieslist[4].title := chart_legendtyclipbox;
                        chart.serieslist[5].title := chart_legendtzclipbox;
                        chart.serieslist[6].title := chart_legendtxcorr;
                        chart.serieslist[7].title := chart_legendtycorr;
                        chart.serieslist[8].title := chart_legendtzcorr;
                        chart.serieslist[3].seriescolor := chart.serieslist[0].seriescolor;
                        chart.serieslist[4].seriescolor := chart.serieslist[1].seriescolor;
                        chart.serieslist[5].seriescolor := chart.serieslist[2].seriescolor;
                        chart.serieslist[6].seriescolor := chart.serieslist[0].seriescolor;
                        chart.serieslist[7].seriescolor := chart.serieslist[1].seriescolor;
                        chart.serieslist[8].seriescolor := chart.serieslist[2].seriescolor;
                        if phasehist.empty then
                          chart.bottomaxis.title.caption := chart_captionframes
                        else
                          chart.bottomaxis.title.caption := chart_captionphase;
                        if relc then
                          chart.leftaxis.title.caption := chart_captionresidual
                        else
                          chart.leftaxis.title.caption := chart_captiondisplacement;
                        chart.leftaxis.automatic := false;
                        chart.leftaxis.minimum := -2.5;
                        chart.leftaxis.maximum := 2.5;
                      end
                      else
                      begin
                        quirtviewerupdtransversal.visible := true;
                        if assigned(chart) then chart.visible := false;
                      end;
                      colorstringgridsummaryupd.hasnewvalue;
                      for k := 0 to colorstringgridsummary.colcount-1 do
                        for j := 0 to colorstringgridsummary.rowcount-1 do
                        begin
                          colorstringgridsummary.cells[k,j] := \'\';
                          if k\>0 then colorstringgridsummary.cellprops[k,j].color := 0;
                        end;
                      colorstringgridsummary.defaultcolwidth := round(55*abs(form1.font.height)/11);
                      colorstringgridsummary.colwidths[0] := round(100*abs(form1.font.height)/11);
                      colorstringgridsummary.colcount := 7;
                      colorstringgridsummary.rowcount := 1;
                      colorstringgridsummary.cells[1, 0] := grid_tx;
                      colorstringgridsummary.cells[2, 0] := grid_ty;
                      colorstringgridsummary.cells[3, 0] := grid_tz;
                      colorstringgridsummary.cells[4, 0] := grid_rx;
                      colorstringgridsummary.cells[5, 0] := grid_ry;
                      colorstringgridsummary.cells[6, 0] := grid_rz;
                      for isoc:=false to true do
                      begin
                        if not isoc then
                         locsubstr := grid_local
                        else
                         locsubstr := \'\';
                        for k:=1 to nclipbox do
                        begin
                          unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc);
                          if s\<\>\'\' then
                          begin
                            if not i4dclp then
                            begin
                              unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if s\<\>\'\' then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + locsubstr;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                    unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, true, false);
                                for i := 1 to 6 do
                                begin
                                  hl  := safestrtofloat(colorstringgrid2.cells[2,i+ord(i\>3)]);
                                  ll  := safestrtofloat(colorstringgrid2.cells[1,i+ord(i\>3)]);
                                  case i of
                                    1 : val := safestrtofloat(dx);
                                    2 : val := safestrtofloat(dy);
                                    3 : val := safestrtofloat(dz);
                                    4 : val := safestrtofloat(drx);
                                    5 : val := safestrtofloat(dry);
                                    6 : val := safestrtofloat(drz);
                                    else
                                      val := min(hl,ll);
                                  end;
                                  if (val \> hl) or (val \< ll) then
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := col
                                  else
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := 0;
                                end;
                    if comboboxsummarytype.text=summary_limits then
                                begin
                                  colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                      colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_limit1;
                      colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,1];
                                  colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,2];
                                  colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,3];
                                  colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,5];
                                  colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,6];
                                  colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,7];
                                  colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                      colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_limit2;
                      colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,1];
                                  colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,2];
                                  colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,3];
                                  colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,5];
                                  colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,6];
                                  colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,7];
                                end;
                                if isoc and assigned(chart) and chart.visible then
                                begin
                                  unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                                  chart.serieslist[3].addxy(0, strtofloat(dx));
                                  chart.serieslist[4].addxy(0, strtofloat(dy));
                                  chart.serieslist[5].addxy(0, strtofloat(dz));
                                  chart.serieslist[3].addxy(0.5, strtofloat(dx));
                                  chart.serieslist[4].addxy(0.5, strtofloat(dy));
                                  chart.serieslist[5].addxy(0.5, strtofloat(dz));
                                  chart.serieslist[3].active := true;
                                  chart.serieslist[4].active := true;
                                  chart.serieslist[5].active := true;
                               end;
                              end;
                            end
                            else
                            begin
                              unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if s\<\>\'\' then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_mean + locsubstr;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                    unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, true, false);
                                for i := 1 to 6 do
                                begin
                                  hl  := safestrtofloat(colorstringgrid2.cells[2,i+ord(i\>3)]);
                                  ll  := safestrtofloat(colorstringgrid2.cells[1,i+ord(i\>3)]);
                                  case i of
                                    1 : val := safestrtofloat(dx);
                                    2 : val := safestrtofloat(dy);
                                    3 : val := safestrtofloat(dz);
                                    4 : val := safestrtofloat(drx);
                                    5 : val := safestrtofloat(dry);
                                    6 : val := safestrtofloat(drz);
                                    else
                                      val := min(hl,ll);
                                  end;
                                  if (val \> hl) or (val \< ll) then
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := col
                                  else
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := 0;
                                end;
                              end;
                    unpackregistration(k-1, -5, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if (s\<\>\'\')  and
                                 (comboboxcorrectionprotocol.text = correction_from_mask_exh)
                                 then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_exhale + locsubstr;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              unpackregistration(k-1, -2, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                              if isoc and (s\<\>\'\') and (comboboxsummarytype.text\<\>summary_limits) then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_sd;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              unpackregistration(k-1, -3, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                              if isoc and (s\<\>\'\') and (comboboxsummarytype.text\<\>summary_limits) then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_a;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              if comboboxsummarytype.text=summary_limits then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_limit1;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,5];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,6];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[1,7];
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + grid_limit2;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,4];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,5];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid2.cells[2,6];
                              end;
                              for j:=0 to max(transform4d.dimensions[3]-1, 0) do
                              begin
                                unpackregistration(k-1, j, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                                if s\<\>\'\' then
                                begin
                                  if comboboxsummarytype.text=summary_details then
                                  begin
                                    colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_clipbox + \';\' + grid_frame + inttostr(j) + locsubstr;
                    colorstringgridsummary.colcount := 8;
                                    colorstringgridsummary.cells[7, 0] := grid_weight;
                                    colorstringgridsummary.cells[7, colorstringgridsummary.rowcount-1] := format(\'%.1f\', [phasehist.getvalue([j])*100.0]);
                                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                    colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                    colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                    colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                    colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                    colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                                  end;
                                  if isoc and assigned(chart) and chart.visible then
                                  begin
                                    if phasehist.empty then
                                    begin
                                      chart.serieslist[3].add(strtofloat(dx));
                                      chart.serieslist[4].add(strtofloat(dy));
                                      chart.serieslist[5].add(strtofloat(dz));
                                    end
                                    else
                                    begin
                                      if (k\>1) and (j=0) then
                                      begin
                                        chart.serieslist[3].addnullxy(0,0);
                                        chart.serieslist[4].addnullxy(0,0);
                                        chart.serieslist[5].addnullxy(0,0);
                                      end;
                                      phase := 0;
                                      for p:=0 to j-1 do phase := phase + phasehist.getvalue([p]);
                                      chart.serieslist[3].addxy(phase * transform4d.dimensions[3], strtofloat(dx));
                                      chart.serieslist[4].addxy(phase * transform4d.dimensions[3], strtofloat(dy));
                                      chart.serieslist[5].addxy(phase * transform4d.dimensions[3], strtofloat(dz));
                                    end;
                                    chart.serieslist[3].active := true;
                                    chart.serieslist[4].active := true;
                                    chart.serieslist[5].active := true;
                                  end;
                                end;
                              end;
                              if isoc and assigned(chart) and chart.visible and i4dclp then
                              begin
                                unpackregistration(k-1, 0, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                                chart.serieslist[3].addxy(transform4d.dimensions[3], strtofloat(dx));
                                chart.serieslist[4].addxy(transform4d.dimensions[3], strtofloat(dy));
                                chart.serieslist[5].addxy(transform4d.dimensions[3], strtofloat(dz));
                              end;
                            end
                          end
                        end;
                        for k:=nclipbox+1 to 2*nclipbox do
                        begin
                          unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                          if s\<\>\'\' then
                          begin
                            if not i4dmsk then
                            begin
                              unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if s\<\>\'\' then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + locsubstr;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                    unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, true, false);
                                for i := 1 to 6 do
                                begin
                                  hl  := safestrtofloat(colorstringgrid3.cells[2,i+ord(i\>3)]);
                                  ll  := safestrtofloat(colorstringgrid3.cells[1,i+ord(i\>3)]);
                                  case i of
                                    1 : val := safestrtofloat(dx);
                                    2 : val := safestrtofloat(dy);
                                    3 : val := safestrtofloat(dz);
                                    4 : val := safestrtofloat(drx);
                                    5 : val := safestrtofloat(dry);
                                    6 : val := safestrtofloat(drz);
                                    else
                                      val := min(hl,ll);
                                  end;
                                  if (val \> hl) or (val \< ll) then
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := col
                                  else
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := 0;
                                end;
                    end;
                              if comboboxsummarytype.text=summary_limits then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                                colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_limit1;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,5];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,6];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,7];
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                                colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_limit2;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,5];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,6];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,7];
                              end;
                              if isoc and assigned(chart) and chart.visible then
                              begin
                                unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                                chart.serieslist[0].addxy(0, strtofloat(dx));
                                chart.serieslist[1].addxy(0, strtofloat(dy));
                                chart.serieslist[2].addxy(0, strtofloat(dz));
                                chart.serieslist[0].addxy(0.5, strtofloat(dx));
                                chart.serieslist[1].addxy(0.5, strtofloat(dy));
                                chart.serieslist[2].addxy(0.5, strtofloat(dz));
                                chart.serieslist[0].active := true;
                                chart.serieslist[1].active := true;
                                chart.serieslist[2].active := true;
                              end;
                            end
                            else
                            begin
                              unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if s\<\>\'\' then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_mean + locsubstr;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                    unpackregistration(k-1, -1, dx, dy, dz, drx, dry, drz, s, false, true, false);
                                for i := 1 to 6 do
                                begin
                                  hl  := safestrtofloat(colorstringgrid3.cells[2,i+ord(i\>3)]);
                                  ll  := safestrtofloat(colorstringgrid3.cells[1,i+ord(i\>3)]);
                                  case i of
                                    1 : val := safestrtofloat(dx);
                                    2 : val := safestrtofloat(dy);
                                    3 : val := safestrtofloat(dz);
                                    4 : val := safestrtofloat(drx);
                                    5 : val := safestrtofloat(dry);
                                    6 : val := safestrtofloat(drz);
                                    else
                                      val := min(hl,ll);
                                  end;
                                  if (val \> hl) or (val \< ll) then
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := col
                                  else
                                    colorstringgridsummary.cellprops[i, colorstringgridsummary.rowcount-1].color := 0;
                                end;
                    end;
                    unpackregistration(k-1, -5, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                              if (s\<\>\'\')  and
                                 (comboboxcorrectionprotocol.text = correction_from_mask_exh)
                                 then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_exhale + locsubstr;
                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              unpackregistration(k-1, -2, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                              if isoc and (s\<\>\'\') and (comboboxsummarytype.text\<\>summary_limits) then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_sd;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              unpackregistration(k-1, -3, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                              if isoc and (s\<\>\'\') and (comboboxsummarytype.text\<\>summary_limits) then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_a;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                              end;
                              if comboboxsummarytype.text=summary_limits then
                              begin
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                                colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_limit1;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,5];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,6];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[1,7];
                                colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                                colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + grid_limit2;
                                colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,1];
                                colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,2];
                                colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,3];
                                colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,5];
                                colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,6];
                                colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := colorstringgrid3.cells[2,7];
                              end;
                              for j:=0 to max(transform4d.dimensions[3]-1, 0) do
                              begin
                                unpackregistration(k-1, j, dx, dy, dz, drx, dry, drz, s, false, relc, isoc);
                                if s\<\>\'\' then
                                begin
                                  if comboboxsummarytype.text=summary_details then
                                  begin
                                    colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                    colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_mask + \';\' + grid_frame + inttostr(j) + locsubstr;
                    colorstringgridsummary.colcount := 8;
                                    colorstringgridsummary.cells[7, 0] := grid_weight;
                                    colorstringgridsummary.cells[7, colorstringgridsummary.rowcount-1] := format(\'%.0f\', [phasehist.getvalue([j])*100.0]);
                                    colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                                    colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                                    colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                                    colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                                    colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                                    colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                                  end;
                                  if isoc and assigned(chart) and chart.visible then
                                  begin
                                    if phasehist.empty then
                                    begin
                                      chart.serieslist[0].add(strtofloat(dx));
                                      chart.serieslist[1].add(strtofloat(dy));
                                      chart.serieslist[2].add(strtofloat(dz));
                                    end
                                    else
                                    begin
                                      if (k\>(nclipbox+1)) and (j=0) then
                                      begin
                                        chart.serieslist[3].addnullxy(0,0);
                                        chart.serieslist[4].addnullxy(0,0);
                                        chart.serieslist[5].addnullxy(0,0);
                                      end;
                                      phase := 0;
                                      for p:=0 to j-1 do phase := phase + phasehist.getvalue([p]);
                                      chart.serieslist[0].addxy(phase * transform4d.dimensions[3], strtofloat(dx));
                                      chart.serieslist[1].addxy(phase * transform4d.dimensions[3], strtofloat(dy));
                                      chart.serieslist[2].addxy(phase * transform4d.dimensions[3], strtofloat(dz));
                                    end;
                                    chart.serieslist[0].active := true;
                                    chart.serieslist[1].active := true;
                                    chart.serieslist[2].active := true;
                                  end;
                                end;
                              end;
                              if isoc and assigned(chart) and chart.visible and i4dmsk then
                              begin
                                unpackregistration(k-1, 0, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                                chart.serieslist[0].addxy(transform4d.dimensions[3], strtofloat(dx));
                                chart.serieslist[1].addxy(transform4d.dimensions[3], strtofloat(dy));
                                chart.serieslist[2].addxy(transform4d.dimensions[3], strtofloat(dz));
                              end;
                            end
                          end
                        end;
                      end;
                      unpackregistration(2*nclipbox, -1, dx, dy, dz, drx, dry, drz, s, false, relc, true);
                      if s\<\>\'\' then
                      begin
                        colorstringgridsummary.rowcount := colorstringgridsummary.rowcount+1;
                        colorstringgridsummary.cells[0, colorstringgridsummary.rowcount-1] := grid_corr;
                        colorstringgridsummary.cells[1, colorstringgridsummary.rowcount-1] := dx;
                        colorstringgridsummary.cells[2, colorstringgridsummary.rowcount-1] := dy;
                        colorstringgridsummary.cells[3, colorstringgridsummary.rowcount-1] := dz;
                        colorstringgridsummary.cells[4, colorstringgridsummary.rowcount-1] := drx;
                        colorstringgridsummary.cells[5, colorstringgridsummary.rowcount-1] := dry;
                        colorstringgridsummary.cells[6, colorstringgridsummary.rowcount-1] := drz;
                        if assigned(chart) and chart.visible then
                        begin
                          chart.serieslist[6].addxy(onlinecube.dimensions[3], strtofloat(dx));
                          chart.serieslist[7].addxy(onlinecube.dimensions[3], strtofloat(dy));
                          chart.serieslist[8].addxy(onlinecube.dimensions[3], strtofloat(dz));
                          chart.serieslist[6].active := true;
                          chart.serieslist[7].active := true;
                          chart.serieslist[8].active := true;
                        end;
                      end;
                    end;
                  end;",
// Sentence 172
                  "procedure tform1.colorstringgridsummarydblclick(sender: tobject);
                  var r,c: integer;
                      s: string;
                  begin
                    s := caption + #9 +
                         clipboard_ref  + referenceoverlaystring + #9 +
                         clipboard_loc  + onlineoverlaystring + #9 +
                         clipboard_sign + copy(quirtviewerupdcoronal.text[2].value, 5, 250) + #9 +
                         clipboard_disp + comboboxsummarytype.text;
                    for r:=0 to colorstringgridsummary.rowcount-1 do
                    begin
                      s := s + #13#10;
                      for c:=0 to colorstringgridsummary.colcount-1 do
                        s := s + colorstringgridsummary.cells[c, r] + #9;
                    end;
                    clipboard.astext := s;
                    showmessage(message_copiedtexttoclpbrd);
                  end;",
// Sentence 173
                  "procedure tform1.timer1timer(sender: tobject);
                  var t: ttransform;
                      tx, ty, tz, rx, ry, rz, w: single;
                      i, i2, clipboxes, rois, nexhale, equalclip, equalroi, icb:  integer;
                      tm : longint;
                      tc: tcontrol;
                      onlinepresent, referencepresent, planar: boolean;
                      s, dx, dy, dz, drx, dry, drz, name: string;
                      formimage: tbitmap;
                      pixmap: tavsfield;
                      v: tlightquirtviewerupd;
                      activeflag   : boolean;
                      limits1, limits2: integer;
                      cursorposition: tpoint;
                  begin
                    if not visible then exit;
                    if form1timer1enabled\>0 then exit;
                    if not windows.getcursorpos(cursorposition) then
                    begin
                      cursorposition.x := -1;
                      cursorposition.y := -1;
                    end;
                    inc(form1timer1enabled);
                    clipboxes := 0;
                    for i:=1 to nclipbox do
                      if not clipbox[i].empty then inc(clipboxes) else break;
                    rois := ord(checkboxreferencemask.enabled);
                    equalclip := compareregistrationbackuppartial(0, clipboxes-1);
                    equalroi := compareregistrationbackuppartial(nclipbox, nclipbox+rois-1);
                    if testmode then
                    begin
                      quirtviewerupdcoronal.textcolor[6].value := rgb(255, 255, 200);
                      quirtviewerupdcoronal.text[6].value :=
                      format(\'clipboxes: %d\'+#10+
                             \'masks: %d\'+#10+
                             \'invalid clipbox match: %d\'+#10+
                             \'invalid mask match: %d\'+#10+
                             \'valid correction: %d\'+#10+
                             \'correction label: %s\'+#10+
                             \'correctionapprovalby: %s\'+#10+
                             \'hit clipbox limit:  %d\'+#10+
                             \'hit mask limit: %d\'+#10+
                             \'version: %s\'+#10+
                             \'mask id: %s\' + #10 +
                             \'threshold 1: %d\' + #10 +
                             \'threshold 2: %d\',
                      [clipboxes, rois, equalclip, equalroi,
                       compareregistrationbackuppartial(2*nclipbox, 2*nclipbox+rois-1),
                       labelcomputedlat2.caption,
                       correctionapprovalby,
                       (unpackregistration(-4, -1, s, s, s, s, s, s, s, false, true, false)),
                       (unpackregistration(nclipbox, -5, s, s, s, s, s, s, s, false, true, false)),
                       xvi_version + \' (\' + xvi_builddate + \')\', maskid,
                       githreshold1, githreshold2
                      ])
                    end
                    else
                      quirtviewerupdcoronal.text[6].value := \'\';
                    paneltest.visible := testmode;
                    if avlstate in [1..6] then
                      buttonelektaaccept.enabled := not readonly and not reconstructing
                                                    and (((alignmentmode.value = 3) and (labelcomputedlat2.caption \<\> \'-\'))
                                                    and labelcomputedlat2.enabled or (avlstate\<\>3));
                    exitaccept1.enabled := buttonelektaaccept.enabled;
                    viewerhelp1.checked := bool(quirtviewerupdsagittal.showhelp.value);
                    if (not viewerhelp1.checked) or
                      (quirtviewerupdtransversal.showhelp.value\<\>0) or
                      (quirtviewerupdcoronal.showhelp.value\<\>0) then
                    begin
                      if  quirtviewerupdtransversal.showhelp \<\> quirtviewerupdsagittal.showhelp then
                        quirtviewerupdtransversal.showhelp := quirtviewerupdsagittal.showhelp;
                      if  quirtviewerupdcoronal.showhelp \<\> quirtviewerupdsagittal.showhelp then
                        quirtviewerupdcoronal.showhelp := quirtviewerupdsagittal.showhelp;
                    end;
                    if needloadimage then
                      loadimage;
                    if needloadscan  then
                      buttonloadscanclick(self);
                    if needloadmatch  then
                    begin
                      buttonloadmatchclick(self);
                      needloadmatch := false ;
                    end;
                    if needloadreference then
                      buttonloadreferenceclick(self);
                    if assigned(sf) then
                    begin
                      visible := true;
                      sf.free;
                      sf := nil;
                    end;
                    if pagecontrol1.activepageindex=1 then
                    begin
                      if (formstyle \<\> fsstayontop) and active then
                      begin
                        tc := findvclwindow(cursorposition);
                        if tc=quirtviewer1 then quirtviewer1.setfocus;
                      end;
                      quirtviewer1.make;
                    end;
                    if pagecontrol1.activepageindex=2 then
                    begin
                      onlinepresent    := not (onlinecube.empty or (onlinecube.veclen=0));
                      referencepresent := not referencecube.empty;
                      if onlinepresent then planar := onlinecube.ndim=2 else planar := false;
                      scanis4d         := onlinecube.ndim\>3;
                      if referencepresent then
                        clipboxlist.make;
                      clipboxes := 0;
                      for i:=1 to nclipbox do
                        if not clipbox[i].empty then inc(clipboxes) else break;
                      rois := ord(checkboxreferencemask.enabled);
                      if          onlinepresent and not (referencepresent and checkboxscan.checked) then
                        begin
                          quirtviewerupdsagittal.cutmode.value := 11;
                        end
                      else if not onlinepresent and     (referencepresent and checkboxscan.checked) then
                        begin
                          quirtviewerupdsagittal.cutmode.value := 12;
                        end
                      else if not onlinepresent and not (referencepresent and checkboxscan.checked) then
                        begin
                          quirtviewerupdsagittal.cutmode.value := 11;
                        end
                      else
                        case comboboxdisplaymode.itemindex of
                          0: quirtviewerupdsagittal.cutmode.value := 212;
                          1:begin
                               if quirtviewerupdsagittal.cutmode.value\<14 then quirtviewerupdsagittal.cutmode.value := 14;
                               if quirtviewerupdsagittal.cutmode.value\>19 then quirtviewerupdsagittal.cutmode.value := 14;
                             end;
                          2: quirtviewerupdsagittal.cutmode.value := 11;
                          3: quirtviewerupdsagittal.cutmode.value := 12;
                        end;
                      if visualizebonesegmentation1.checked or
                       ((pos(match_substring_seed, comboboxmaskmatch.text)\>0) and editmask.checked)
                      then
                      begin
                        if chamferdotsreference.empty then chamferdotsreference.forceupdate;
                        case comboboxdisplaymode.itemindex of
                          0: begin
                               quirtviewerupdcoronal.polydots[5].blanking := false;
                               quirtviewerupdcoronal.polydots[9].blanking := false;
                             end;
                          1: begin
                               quirtviewerupdcoronal.polydots[5].blanking := false;
                               quirtviewerupdcoronal.polydots[9].blanking := false;
                             end;
                          2: begin
                               quirtviewerupdcoronal.polydots[5].blanking := false;
                               quirtviewerupdcoronal.polydots[9].blanking := not ((pos(match_substring_seed, comboboxmaskmatch.text)\>0) and editmask.checked);
                             end;
                          3: begin
                               quirtviewerupdcoronal.polydots[5].blanking := true;
                               quirtviewerupdcoronal.polydots[9].blanking := false;
                             end;
                        end;
                      end
                      else
                      begin
                        if assigned(chamferdotsonline) and not chamferdotsonline.empty then
                          chamferdotsonline.clear;
                        if assigned(chamferdotsreference) and not chamferdotsreference.empty then
                          chamferdotsreference.clear;
                      end;
                      if (comboboxsliceaveraging.itemindex\>=0) and not planar then
                        quirtviewerupdsagittal.sliceblur.value := comboboxsliceaveraging.itemindex;
                      if  striphotkey(menushowunlockpresentclipbox.caption) \<\> menu_menushowall_caption then
                      begin
                        for i:=1 to nclipbox do
                        begin
                          if clipbox[i].blanking \<\> not checkboxroi.checked then
                             clipbox[i].blanking := not checkboxroi.checked;
                        end;
                      end
                      else
                      begin
                        activeflag := false;
                        for i:= 1 to nclipbox do
                        begin
                          if i = quirtviewerupdsagittal.activeclipbox.value then
                          begin
                            if clipbox[i].blanking \<\> not checkboxroi.checked then
                              clipbox[i].blanking := not checkboxroi.checked;
                            activeflag := true;
                          end
                          else clipbox[i].blanking := true;
                        end;
                        if not activeflag then
                        begin
                          activeregion.value := updownrois.position;
                          if alignmentmode.value=0 then
                          begin
                            quirtviewerupdsagittal.activeclipbox.value :=  activeregion.value+1;
                            clipbox[activeregion.value+1].blanking := false;
                            clipbox[activeregion.value+1].ischangedby := self;
                          end;
                        end;
                      end;
                      if delineationdots.blanking \<\> not checkboxdelineation.checked then
                        delineationdots.blanking := not checkboxdelineation.checked;
                      maskedreference.blanking := true;
                      referencemask.blanking := true;
                      dosecube.blanking := true;
                      doseaccu.blanking := true;
                      if (beamdots.blanking \<\> not (checkboxplan.checked and not planar)) and not xviischildwindow then
                        beamdots.blanking := not (checkboxplan.checked and not planar);
                      if (bonetumormatchlist.find(comboboxmatch.text,i)) then
                        bonetumormatchstatus := 10 + bonetumormatchstatus mod 10
                      else
                        bonetumormatchstatus := bonetumormatchstatus mod 10;
                      if (
                          ((comboboxclipboxmatch.itemindex=0) and (alignmentmode.value=0) and onlinepresent) or
                          ((comboboxmaskmatch.itemindex=0) and (alignmentmode.value=1) and onlinepresent) or
                          radiobuttoncurrentframe.checked or radiobuttoncurrentroi.checked
                         )
                         and referencepresent and onlinepresent then
                        tm:=1
                      else
                        tm:=0;
                      if (tm\<\>0) and (editmask.checked) then
                        editmaskclick(self);
                      if reversemotion.value=0 then
                      begin
                        quirtviewerupdcoronal.trackermode.value := -tm;
                        quirtviewerupdsagittal.trackermode.value := -tm;
                        quirtviewerupdtransversal.trackermode.value := -tm;
                      end
                      else
                      begin
                        quirtviewerupdcoronal.trackermode.value := tm;
                        quirtviewerupdsagittal.trackermode.value := tm;
                        quirtviewerupdtransversal.trackermode.value := tm;
                      end;
                      if striphotkey(menushowunlockpresentclipbox.caption) \<\> menu_menulockall_caption then
                      begin
                        for i:=1 to nclipbox do
                           clipbox[i].locked := menuclipboxlocked.checked or (tm\<\>0) or (editmask.checked) or matchinprogress;
                      end
                      else
                      begin
                        activeflag := false;
                        for i:= 1 to nclipbox do
                        begin
                          if i = quirtviewerupdsagittal.activeclipbox.value then
                          begin
                            clipbox[i].locked := false;
                            activeflag := true;
                          end
                          else clipbox[i].locked := true;
                        end;
                        if not activeflag then
                        begin
                          activeregion.value := updownrois.position;
                          if alignmentmode.value=0 then
                          begin
                            quirtviewerupdsagittal.activeclipbox.value :=  activeregion.value+1;
                            clipbox[activeregion.value+1].blanking := false;
                            clipbox[activeregion.value+1].ischangedby := self;
                          end;
                        end;
                      end;
                      if referencepresent then
                      begin
                          quirtviewerupdcoronal.trackershape.value := 28;
                        quirtviewerupdcoronal.trackerdots.blanking := false;
                      end
                      else
                      begin
                        quirtviewerupdcoronal.trackershape.value := -1;
                        quirtviewerupdcoronal.trackerdots.blanking := true;
                      end;
                      if (quirtviewerupdcoronal.markerdots[1].newerthan(correctionreferencepoint)) and (strtoint(correctionreferencepoint.debugname)=2) then
                      begin
                        if quirtviewerupdcoronal.markerdots[1].empty then
                          quirtviewerupdcoronal.text[3].value := #27+#1+chr(255)+chr(255)+corr_ref_marker_ns
                        else
                          quirtviewerupdcoronal.text[3].value := #27+#1+chr(255)+chr(255)+corr_ref_marker_ch;
                      end;
                      if referencepresent then
                        if hideisoccorrefpoint1.checked\<\>correctionreferencepoint.blanking then
                          correctionreferencepoint.blanking := hideisoccorrefpoint1.checked;
                      if hideisoccorrefpoint1.checked\<\>isocdots.blanking then
                          isocdots.blanking := hideisoccorrefpoint1.checked;
                      if (tm\<\>0) and radiobuttoncurrentframe.checked then
                        transformdisplaymode.value := 1
                      else if (tm\<\>0) then
                        transformdisplaymode.value := 1
                                                                                  else if alignmentmode.value in [2,3,4] then
                        transformdisplaymode.value := 3
                      else
                      begin
                        if not (externalwarp.empty) and radiobuttonwarpallrois.checked then
                          transformdisplaymode.value := 6
                        else if scanis4d and (radiobuttonaverageframes.checked or (quirtviewerupdcoronal.frame.value=-1)) then
                        begin
                          if radiobuttonwarpallrois.checked then
                            transformdisplaymode.value := 5
                          else
                            transformdisplaymode.value := 4;
                        end
                        else if radiobuttonwarpallrois.checked and radiobuttoneachframe.checked then
                          transformdisplaymode.value := 2
                        else if radiobuttoneachroi.checked     and radiobuttoneachframe.checked then
                          transformdisplaymode.value := 1
                      end;
                      s := \'\';
                      if not onlinecube.empty then
                      begin
                        if onlinecube.ndim=4 then
                        begin
                          if reversemotion.value=1 then s := s + #27 + #1 + chr(255) + #1
                          else                          s := s + #27 + chr(255) + #1 + chr(255);
                          if quirtviewerupdcoronal.frame.value = -1 then
                            s := s + avg_overlay_avg
                          else
                            s := s + format(overlay_4d, [quirtviewerupdcoronal.frame.value, onlinecube.dimensions[3]]);
                        end;
                      end;
                      if not referencecube.empty then
                        if referencecube.ndim=4 then
                        begin
                          s := s + #10 + #27 + chr(255) + #1 + chr(255);
                          if quirtviewerupdcoronal.frame.value = -1 then
                            s := s + avg_overlay_avg
                          else
                            s := s + format(overlay_4d, [quirtviewerupdcoronal.frame.value, referencecube.dimensions[3]]);
                        end;
                      quirtviewerupdsagittal.text[4].value := s;
                      if not xviischildwindow then
                      begin
                        paneltranslation.visible      := onlinepresent and referencepresent and (alignmentmode.value in [0,1,2,3]);
                        panelrotation.visible         := onlinepresent and referencepresent and (alignmentmode.value in [0,1,2,3]);
                        panelelektacouchshift.visible := onlinepresent and referencepresent and (alignmentmode.value = 3) and true;
                        labelcomputedlat2.visible := ((comboboxcorrectionby.text\<\>nameof6dofsystem) or (nameof6dofsystem=\'\'));
                        labelcomputedlong2.visible := labelcomputedlat2.visible;
                        labelcomputedheight2.visible := labelcomputedlat2.visible;
                        bitbtndismisscorrection.visible := onlinepresent and referencepresent and (alignmentmode.value = 3);
                        label18.visible := paneltranslation.visible;
                        panelimage.visible            := onlinepresent or referencepresent;
                          panelreferencepreset.visible  := referencepresent;
                        panelalignment.visible        := referencepresent;
                        tabcontrol1.visible           := referencepresent;
                        panelregistration.visible     := alignmentmode.value in [0,1,2];
                        colorstringgridsummary.visible     := alignmentmode.value=4;
                        comboboxsummarytype.visible   := alignmentmode.value=4;
                        comboboxclipboxmatch.visible  := alignmentmode.value=0;
                        comboboxmaskmatch.visible     := alignmentmode.value=1;
                        label79.visible               := alignmentmode.value in [0, 1];
                        buttonresetmatch.visible      := onlinepresent and referencepresent and (alignmentmode.value in [0,1]);
                        buttoncopytohexapod1.visible  := onlinepresent and referencepresent and (alignmentmode.value in [3]) and (correctionbyhexapod) and (runtableshift\<\>\'\');
                        buttonnextstep.visible        := onlinepresent and referencepresent;
                        buttonmatch2.visible          := onlinepresent and referencepresent and (alignmentmode.value\<\>2);
                        if alignmentmode.value=0 then s := comboboxclipboxmatch.text else s := comboboxmaskmatch.text;
                        bitbtnplaygreen.enabled := referencepresent and not radiobuttoncurrentframe.checked
                                                   and (pos(match_substring_4d,s)\>0) and (alignmentmode.value in [0,1]);
                        bitbtnplaypurple.enabled := not radiobuttoncurrentframe.checked;
                        bitbtnstop4d.enabled := not radiobuttoncurrentframe.checked;
                        bitbtnaverage4d.enabled := not radiobuttoncurrentframe.checked;
                        if not bitbtnplaygreen.enabled then reversemotion.value := 0;
                        labelrois.visible             := ((alignmentmode.value = 0) and (clipboxes\>1)) or ((alignmentmode.value = 1) and (rois\>1));
                        updownrois.visible            := labelrois.visible;
                        bitbtnlockregistrationmethod.visible := labelrois.visible;
                        updownrois.enabled            := (not match2inprogress) ;
                        panelallrois.visible          := labelrois.visible and onlinepresent and (s\<\>match_manual);
                        bitbtnwarp.visible            := (labelrois.visible or not externalwarp.empty) and onlinepresent and (s\<\>match_manual);
                        panelallframes.visible        := (onlinecube.ndim=4) and (alignmentmode.value in [0,1]) and (pos(match_substring_4d,s)\>0);
                        bitbtnaverage4dtransform.visible    := false;
                        label4d.visible        := (onlinecube.ndim=4) or (referencecube.ndim=4);
                        panelcontrol4d.visible := (onlinecube.ndim=4) or (referencecube.ndim=4);
                        showdvf1.visible       := false;
                        applydvf.visible       := false;
                        loaddvf1.visible       := false;
                        labelpitch2.visible := false;
                        labelroll2.visible := false;
                        labelyaw2.visible := false;
                        labelcomputedpitch2.visible := false;
                        labelcomputedroll2.visible := false;
                        labelcomputedyaw2.visible := false;
                        label24.visible := false;
                        if not labelcomputedlat2.visible then
                        begin
                          label16.caption := \'\';
                          label17.caption := \'\';
                          label18.caption := format(label_label18_caption2, [nameof6dofsystem]);
                          labellat2.caption := \'\';
                          labelheight2.caption := \'\';
                          labellong2.caption := \'\';
                        end
                        else
                        begin
                          label16.caption := label_label16_caption;
                          label17.caption := label_label17_caption;
                          label18.caption := label_label18_caption;
                          labellat2.caption := label_labellat2_caption;
                          labelheight2.caption := label_labelheight2_caption;
                          labellong2.caption := label_labellong2_caption;
                        end;
                        memomaskclipboxdifference.visible := onlinepresent and referencepresent and
                                                             (((alignmentmode.value = 2) and (comboboxregistrationprotocol.itemindex\<\>1)) or ((alignmentmode.value = 1) and (comboboxregistrationprotocol.itemindex=2)));
                        memoclipboxcorrectiondifference.visible := onlinepresent and referencepresent and
                                                             (((alignmentmode.value = 2) and (comboboxregistrationprotocol.itemindex\<\>0)));
                        memoclipboxcorrectiondifference.height := 0;
                        memomaskclipboxdifference.height := 0;
                        memoclipboxcorrectiondifference.enabled := false;
                        memomaskclipboxdifference.enabled := false;
                        trackbarweight.visible := memomaskclipboxdifference.visible and memoclipboxcorrectiondifference.visible;
                        label44.visible := trackbarweight.visible;
                        label45.visible := trackbarweight.visible;
                        label44.visible          := memomaskclipboxdifference.visible and memoclipboxcorrectiondifference.visible;
                        label45.visible          := memomaskclipboxdifference.visible and memoclipboxcorrectiondifference.visible;
                        trackbarweight.visible   := memomaskclipboxdifference.visible and memoclipboxcorrectiondifference.visible;
                        colorstringgrid1.cells[3,0] := grid_adjust;
                        for i:= 1 to 3 do
                          colorstringgrid1.cellprops[3,i].box.visible := trackbarweight.visible;
                        for i:= 4 to 6 do
                          colorstringgrid1.cellprops[3,i].box.visible := trackbarweight.visible and (correctionbyhexapod);
                        colorstringgrid1.visible := (memomaskclipboxdifference.visible or memoclipboxcorrectiondifference.visible) and
                                                    (comboboxregistrationprotocol.itemindex=2) and
                                                    (alignmentmode.value = 2);
                        colorstringgrid2.visible       := (not onlinepresent) and referencepresent and
                                                          (comboboxregistrationprotocol.itemindex=2) and
                                                          (alignmentmode.value=0);
                        colorstringgrid3.visible       := (not onlinepresent) and referencepresent and
                                                          (comboboxregistrationprotocol.itemindex=2) and
                                                          (alignmentmode.value=1);
                        buttonlimitinformation.visible := false;
                        panellimitsinformation.visible := colorstringgrid2.visible or colorstringgrid3.visible;
                        if not quirtviewerupdcoronal.toolbar[1].empty then
                          case ord(colorstringgrid2.visible) + 2*ord(colorstringgrid3.visible) + 10 * ord(comboboxregistrationprotocol.text=protocol_clipbox_mask)
                          of
                            1:  labellimitshelp.caption := labellimitshelp_caption1;
                            2:  labellimitshelp.caption := labellimitshelp_caption2;
                            11: labellimitshelp.caption := labellimitshelp_caption11;
                            12: labellimitshelp.caption := labellimitshelp_caption12;
                          end
                        else
                          labellimitshelp.caption := \'\';
                        editmask.visible              := false;
                        masklocked.visible            := not referencemask.empty;
                        clearmask.visible             := not referencemask.empty;
                        paintbrushsize.visible        := (editmask.checked) and not referencemask.empty;
                        if alignmentmode.value=0 then s := comboboxclipboxmatch.text else s := comboboxmaskmatch.text;
                        paneltranslation.enabled := (radiobuttoneachroi.checked and radiobuttoneachframe.checked and
                                                    (alignmentmode.value in [0, 1, 2]) and
                                                    onlinepresent and referencepresent and
                                                    (not matchinprogress) and
                                                    ((pos(match_substring_4d,s)=0) or not scanis4d or radiobuttoncurrentframe.checked))
                                                    or (alignmentmode.value = 2);
                        panelrotation.enabled := (paneltranslation.enabled and
                          (((pos(\'(t)\',comboboxclipboxmatch.mappedtext)=0) and comboboxclipboxmatch.visible) or
                           ((pos(\'(t)\',comboboxmaskmatch.mappedtext)=0) and comboboxmaskmatch.visible) or
                           ((correctionbyhexapod) and (alignmentmode.value\>1))))
                           or ((alignmentmode.value = 2) and (correctionbyhexapod));
                        for i:=0 to paneltranslation.controlcount-1 do
                          if paneltranslation.controls[i].enabled \<\> paneltranslation.enabled then
                            paneltranslation.controls[i].enabled := paneltranslation.enabled;
                        for i:=0 to panelrotation.controlcount-1 do
                          if panelrotation.controls[i].enabled \<\> panelrotation.enabled then
                            panelrotation.controls[i].enabled := panelrotation.enabled;
                        if paneltranslation.enabled then
                        begin
                          if edittranslationlr.color \<\> clwindow then
                          begin
                            edittranslationlr.color := clwindow;
                            edittranslationap.color := clwindow;
                            edittranslationcc.color := clwindow;
                          end;
                        end
                        else
                        begin
                          if edittranslationlr.color \<\> clmenu then
                          begin
                            edittranslationlr.color := clmenu;
                            edittranslationap.color := clmenu;
                            edittranslationcc.color := clmenu;
                          end;
                        end;
                        if panelrotation.enabled then
                        begin
                          if editrotationlr.color \<\> clwindow then
                          begin
                            editrotationlr.color := clwindow;
                            editrotationap.color := clwindow;
                            editrotationcc.color := clwindow;
                          end;
                        end
                        else
                        begin
                          if editrotationlr.color \<\> clmenu then
                          begin
                            editrotationlr.color := clmenu;
                            editrotationap.color := clmenu;
                            editrotationcc.color := clmenu;
                          end;
                        end;
                        buttonclipbox.enabled := (tm = 0) and referencepresent
                        and (((avlstate=-1) or (avlstate in [0, 1, 3, 4])) and (comboboxregistrationprotocol.itemindex in [0,2,3,5])) and (not matchinprogress);
                        checkboxscan.enabled          := false;
                        comboboxdisplaymode.enabled   := referencepresent;
                        bitbtngreenpurplecut.enabled  := referencepresent;
                        bitbtnrefloc.enabled          := referencepresent;
                        label54.enabled               := referencepresent;
                        checkboxplan.enabled          := not beamdots.empty and not planar;
                        checkboxdelineation.enabled   := not delineationdots.empty;
                        buttonstructures.enabled      := not delineationdots.empty;
                        checkboxreferencemask.enabled := not referencemask.empty;
                        checkboxdose.enabled          := not dosecube.empty;
                        checkboxdoseaccu.enabled      := not doseaccu.empty;
                        buttondoseaccumulate.enabled  := not dosecube.empty;
                        checkboxroi.enabled           := onlinepresent or referencepresent;
                        buttonconverttocorrection.enabled := onlinepresent and referencepresent and (not convertedtocorrections) and
                                                             (bonetumormatchstatus\<\>10) and
                                                             (not convertcorexcllist.find(comboboxmatch.text,i)) and
                                                             (not matchinprogress);
                        buttonsetcorrectionreferencepoint.enabled := ((avlstate=-1) or (avlstate in [0, 1])) and referencepresent;
                        buttonmask.enabled                        := ((avlstate=-1) or (avlstate in [0, 1, 3, 4])) and referencepresent and (comboboxregistrationprotocol.itemindex in [1,2,3,5]) and (not matchinprogress);
                        buttonmarkers.enabled                     := ((avlstate=-1) or (avlstate in [0, 1, 3, 4])) and referencepresent;
                        labelrois.enabled := quirtviewerupdcoronal.activeclipbox.value = activeregion.value + 1;
                       if alignmentmode.value=0 then
                         buttonnextstep.enabled := not match2inprogress and
                           (equalclip=0) and
                           ( (equalroi\<\>0)  or
                           (comboboxregistrationprotocol.itemindex=0));
                       if alignmentmode.value=1 then
                         buttonnextstep.enabled := not match2inprogress and
                         ((equalclip=0) or (comboboxregistrationprotocol.itemindex=1)) and
                         (equalroi=0)
                         and (correctionapprovalby=\'\');
                       if alignmentmode.value\>1 then buttonnextstep.enabled := true;
                        buttonmatch2.enabled := onlinepresent and referencepresent and
                        (((alignmentmode.value=0) and (comboboxclipboxmatch.itemindex\>0)) or ((alignmentmode.value=1) and (comboboxmaskmatch.itemindex\>0)));
                        buttoncopytohexapod1.enabled := labelcomputedlat2.caption \<\> \'-\';
                        bitbtnunlockprotocol.visible := onlinepresent;
                        label80.enabled := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        label81.enabled := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        label21.enabled := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        comboboxregistrationprotocol.enabled := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        comboboxcorrectionprotocol.enabled   := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        comboboxcorrectionby.enabled         := (not onlinepresent) or (bitbtnunlockprotocol.tag=1);
                        nexhale := 1000;
                        if (not onlinecube.empty) and (onlinecube.ndim=4) then
                          if comboboxcorrectionprotocol.text = correction_from_mask_exh then nexhale := onlinecube.dimensions[3] div 8;
                        if (((alignmentmode.value in [1,2,3,4]) and (comboboxcorrectionprotocol.text = correction_from_mask_mean)) or
                            ((alignmentmode.value in [1,2,3,4]) and (comboboxcorrectionprotocol.text = correction_from_mask_exh)) or
                            ((alignmentmode.value in [0,2,3,4]) and (comboboxcorrectionprotocol.text = correction_from_clipbox)))
                          and (quirtviewerupdcoronal.frame.value\>=0)
                          and not ((quirtviewerupdcoronal.frame.value\>nexhale) and (quirtviewerupdcoronal.frame.value\<onlinecube.dimensions[3]-nexhale)) then
                           label4d.font.color := clgreen
                         else
                           label4d.font.color := clblack;
                        buttonsavescan.enabled        := onlinepresent and (not viewonly);
                        buttonexport.enabled          := onlinepresent and (not readonly) and (not viewonly);
                    buttontoreference.enabled     := onlinepresent;
                    buttonzoom.enabled            := onlinepresent or referencepresent;
                        buttonzoomout.enabled         := onlinepresent or referencepresent;
                        buttongotoisoc.enabled        := (onlinepresent or referencepresent) and not planar;
                        bitbtnpresetlevelwindows.enabled  := onlinepresent or referencepresent;
                    comboboxsliceaveraging.enabled:= (onlinepresent or referencepresent) and not planar;
                        label55.enabled               := (onlinepresent or referencepresent) and not planar;
                        buttonmatch.enabled           := onlinepresent and referencepresent and (not (tm=1)) and not planar;
                        buttonresetmatch.enabled      := onlinepresent and referencepresent and (not matchinprogress);
                        buttonsavereference.enabled   := (referencepresent or (not delineationdots.empty and not beamdots.empty)) and
                        (not readonly)
                  ;
                        buttonclearreference.enabled  := referencepresent or (not delineationdots.empty and not beamdots.empty);
                        buttonacceptmatch.enabled     := onlinepresent and referencepresent and
                                                         (not beamdots.empty or synergymode) and buttonloadreference.enabled
                                                         and (not referencedatachanged) and (not readonly) and
                                                         (convertedtocorrections or (bonetumormatchstatus=10) or
                                                          convertcorexcllist.find(comboboxmatch.text,i));
                        buttonsetreferencemask.enabled := referencepresent and (not delineationdots.empty);
                        gotoisocenter.enabled                := onlinepresent;
                        gotocorrectionreferencepoint.enabled := referencepresent;
                        gotomarker.enabled                   := not quirtviewerupdcoronal.markerdots[1].empty;
                        viewpoint1.enabled                   := not quirtviewerupdcoronal.markerdots[3].empty;
                        plannedisoc1.enabled                 := referencepresent;
                        centerofclipbox1.enabled             := (not clipbox[1].empty) and (comboboxregistrationprotocol.itemindex \<\> 1);
                        centerofmask1.enabled                := (not referencemask.empty) and (comboboxregistrationprotocol.itemindex \<\> 0);
                        centerofmask1.visible                := (admincount and admincount_roi3d)\<\>0;
                        refpointatcenterofclipbox1.enabled := not clipbox[1].empty and (comboboxregistrationprotocol.itemindex \<\> 1);
                        refpointatmarker.enabled := not quirtviewerupdcoronal.markerdots[1].empty;
                        refpointatcenterofdelineation.enabled := not delineationdots.empty;
                        for i:=0 to refpointatcenterofdelineation.count-1 do
                          refpointatcenterofdelineation.items[i].checked :=
                            striphotkey(refpointatcenterofdelineation.items[i].caption)=correctionreferencepointstructure;
                        if quirtviewerupdcoronal.markerdots[1].empty then
                        begin
                          matchrotmark := false;
                          if (popupmenucomboboxmatch.items.count \<\> 0) then
                          begin
                            popupmenucomboboxmatch.items.items[1].enabled := false;
                            popupmenucomboboxmatch.items.items[1].checked := false;
                          end
                        end
                        else if (popupmenucomboboxmatch.items.count \<\> 0) then
                            popupmenucomboboxmatch.items.items[1].enabled := true;
                        panelaverageframes.enabled := (quirtviewerupdcoronal.frame.value\<\>-1) and not radiobuttoncurrentframe.checked;
                        radiobuttonaverageframes.enabled := panelaverageframes.enabled;
                        radiobuttoneachframe.enabled := panelaverageframes.enabled;
                        panelwarpallrois.enabled := (not radiobuttoncurrentroi.checked) or (not externalwarp.empty);
                        radiobuttonwarpallrois.enabled := panelwarpallrois.enabled;
                        radiobuttoneachroi.enabled := panelwarpallrois.enabled;
                        if clipbox[1].empty then checkboxroi.checked := false;
                        if radiobuttoncurrentframe.checked then
                        begin
                          timer4d.enabled := false;
                          reversemotion.value := 0;
                          if quirtviewerupdcoronal.frame.value\<-0 then quirtviewerupdcoronal.frame.value := 0;
                        end;
                        comboboxclipboxmatch.enabled := (not radiobuttoncurrentframe.checked) and (not radiobuttoncurrentroi.checked) and (not matchinprogress);
                        comboboxmaskmatch.enabled    := (not radiobuttoncurrentframe.checked) and (not radiobuttoncurrentroi.checked) and (not matchinprogress);
                        if radiobuttoncurrentframe.checked then
                          buttonresetmatch.caption := buttonresetmatch_caption2
                        else
                          buttonresetmatch.caption := buttonresetmatch_caption;
                        if radiobuttoncurrentframe.checked then radiobuttoneachframe.checked := true;
                        if not panelallframes.visible      then radiobuttonallframes.checked := true;
                        if radiobuttoncurrentroi.checked then radiobuttoneachroi.checked := true;
                        if not panelallrois.visible        then radiobuttonallrois.checked := true;
                        if not ((onlinecube.ndim=4) and (alignmentmode.value in [0,1]) and (pos(match_substring_4d,s)\>0)) then
                          radiobuttoneachframe.checked := true;
                        if not bitbtnwarp.visible    then radiobuttoneachroi.checked := true;
                        case alignmentmode.value of
                          0: if onlinepresent or not colorstringgrid2.visible then labeltabpage.caption := tab_registrationclipbox else labeltabpage.caption := tab_registrationclipbox2;
                          1: if onlinepresent or not colorstringgrid3.visible then labeltabpage.caption := tab_registrationmask else labeltabpage.caption := tab_registrationmask2;
                          2: labeltabpage.caption := tab_reviewcorrection;
                          3: labeltabpage.caption := tab_correction;
                          4: labeltabpage.caption := tab_overview;
                        end;
                        if (transform4d.dimensions[3]\>1) and
                           ((pos(match_4d, comboboxmatch.text)\>0) or (pos(match_manualcc, comboboxmatch.text)\>0)) and
                           not converted4dtomean then
                          buttonconverttocorrection.caption := convert_to_corr_button_caption2
                        else
                          buttonconverttocorrection.caption := convert_to_corr_button_caption;
                        if alignmentmode.value=4 then
                          updatesummary
                        else if assigned(chart) and chart.visible then
                        begin
                          chart.visible := false;
                          quirtviewerupdtransversal.visible := true;
                        end;
                        updownrois.min := 0;
                        if alignmentmode.value=0 then
                        begin
                          updownrois.max := clipboxes-1;
                          labelrois.caption := format(label_clipbox, [activeregion.value+1, clipboxes]);
                          end
                        else if alignmentmode.value=1 then
                        begin
                          updownrois.max := rois-1;
                          labelrois.caption := format(label_mask, [maskactiveregion.value+1, rois]);
                        end;
                        case alignmentmode.value of
                          0:  if (comboboxregistrationprotocol.itemindex in [0,3,4]) then
                              begin
                                  buttonnextstep.caption := convert_to_corr_button_caption;
                              end
                              else
                                buttonnextstep.caption := next_registermask;
                          1:
                               buttonnextstep.caption := convert_to_corr_button_caption;
                             2: buttonnextstep.caption := next_acceptcorrection
                          else
                            buttonnextstep.caption := next_invalid;
                        end;
                        if onlinepresent and referencepresent and (not (tm=1) or radiobuttoncurrentframe.checked or radiobuttoncurrentroi.checked)
                           and not planar  then
                        begin
                          if buttonmatch2.caption = match_manual2 then
                            buttonmatch2.caption := match_automatic;
                        end
                        else
                          buttonmatch2.caption := match_manual2;
                        if quirtviewerupdcoronal.frame.value=-1 then
                          label4d.caption := label_4davg
                        else
                          label4d.caption := format(label_4d, [quirtviewerupdcoronal.frame.value, onlinecube.dimensions[3]]);
                        if loadedalignmentdatachanged = false then
                          buttonacceptmatch.caption := confirm_caption
                        else
                          buttonacceptmatch.caption := accept_caption;
                          buttonelektaaccept.caption := button_buttonelektaaccept_caption;
                        if manualmatchactive then
                        begin
                          if      (alignmentmode.value=0) and (pos(match_substring_4d, comboboxclipboxmatch.text)=0) then
                            externalmanualmatchto4d(-1, activeregion.value)
                          else if (alignmentmode.value=0) and (pos(match_substring_4d, comboboxclipboxmatch.text)\>0) and radiobuttonallframes.checked then
                            externalmanualmatchto4d(-1, activeregion.value)
                          else if (alignmentmode.value=0) and (pos(match_substring_4d, comboboxclipboxmatch.text)\>0) and radiobuttoncurrentframe.checked then
                            externalmanualmatchto4d(quirtviewerupdcoronal.frame.value, activeregion.value)
                          else if (alignmentmode.value=1) and (pos(match_substring_4d, comboboxmaskmatch.text)=0) then
                            externalmanualmatchto4d(-1, nclipbox+maskactiveregion.value)
                          else if (alignmentmode.value=1) and (pos(match_substring_4d, comboboxmaskmatch.text)\>0) and radiobuttonallframes.checked then
                            externalmanualmatchto4d(-1, nclipbox+maskactiveregion.value)
                          else if (alignmentmode.value=1) and (pos(match_substring_4d, comboboxmaskmatch.text)\>0) and radiobuttoncurrentframe.checked then
                            externalmanualmatchto4d(quirtviewerupdcoronal.frame.value, nclipbox+maskactiveregion.value)
                          else if (alignmentmode.value in [2, 3]) then
                          begin
                            externalmanualmatchto4d(-1, nclipbox*2);
                            matchperformed := true;
                            alignmentmode.value := 2;
                            correctionapprovalby := \'\';
                          end;
                          if not radiobuttoncurrentframe.checked then
                          begin
                          if alignmentmode.value=0 then
                            appliedclipboxmatchmethod := \'manual\'
                          else if alignmentmode.value=1 then
                            appliedmaskmatchmethod := \'manual\';
                          end;
                          manualmatchactive := false;
                          if (not testmode) and (alignmentmode.value\<\>2) then
                            invalidatecorrection;
                        end;
                        if memomaskclipboxdifference.visible or memoclipboxcorrectiondifference.visible then
                        begin
                          if alignmentmode.value=1 then
                          begin
                            end
                          else if alignmentmode.value=2 then
                          begin
                            limits1 := unpackregistration(-4, -1, dx, dy, dz, drx, dry, drz, s, false, true, false);
                            if colorstringgrid1.cells[1,1] \<\> dx then colorstringgrid1.cells[1,1] := dx;
                            if colorstringgrid1.cells[1,2] \<\> dy then colorstringgrid1.cells[1,2] := dy;
                            if colorstringgrid1.cells[1,3] \<\> dz then colorstringgrid1.cells[1,3] := dz;
                            if colorstringgrid1.cells[1,4] \<\> drx then colorstringgrid1.cells[1,4] := drx;
                            if colorstringgrid1.cells[1,5] \<\> dry then colorstringgrid1.cells[1,5] := dry;
                            if colorstringgrid1.cells[1,6] \<\> drz then colorstringgrid1.cells[1,6] := drz;
                            if comboboxregistrationprotocol.itemindex\>=2 then
                            begin
                              colorstringgrid1.cellprops[1,1].color := ord(((limits1 and $003))\<\>0) * 255;
                              colorstringgrid1.cellprops[1,2].color := ord(((limits1 and $00c))\<\>0) * 255;
                              colorstringgrid1.cellprops[1,3].color := ord(((limits1 and $030))\<\>0) * 255;
                              colorstringgrid1.cellprops[1,4].color := ord(((limits1 and $0c0))\<\>0) * 255;
                              colorstringgrid1.cellprops[1,5].color := ord(((limits1 and $300))\<\>0) * 255;
                              colorstringgrid1.cellprops[1,6].color := ord(((limits1 and $c00))\<\>0) * 255;
                            end;
                            for i:=1 to 6 do
                              colorstringgrid1.cellprops[1,i].style := [tfontstyle(ord(colorstringgrid1.cellprops[1,i].color = clred)*ord(fsbold))];
                            memomaskclipboxdifference.lines.text := format(\'clipbox\'#13\'- correction\'#13#13\'tx = %s\'#13\'ty = %s\'#13\'tz = %s\'#13\'rx = %s\'#13\'ry = %s\'#13\'rz = %s\', [dx, dy, dz, drx, dry, drz]);
                            memomaskclipboxdifference.hint := \'\';
                          end;
                        end;
                        if memomaskclipboxdifference.visible or memoclipboxcorrectiondifference.visible then
                        begin
                          limits2 := unpackregistration(nclipbox, -5, dx, dy, dz, drx, dry, drz, s, false, true, false);
                          if colorstringgrid1.cells[2,1] \<\> dx then colorstringgrid1.cells[2,1] := dx;
                          if colorstringgrid1.cells[2,2] \<\> dy then colorstringgrid1.cells[2,2] := dy;
                          if colorstringgrid1.cells[2,3] \<\> dz then colorstringgrid1.cells[2,3] := dz;
                          if colorstringgrid1.cells[2,4] \<\> drx then colorstringgrid1.cells[2,4] := drx;
                          if colorstringgrid1.cells[2,5] \<\> dry then colorstringgrid1.cells[2,5] := dry;
                          if colorstringgrid1.cells[2,6] \<\> drz then colorstringgrid1.cells[2,6] := drz;
                          colorstringgrid1.cellprops[2,1].color := ord(((limits2 and $003))\<\>0) * 255;
                          colorstringgrid1.cellprops[2,2].color := ord(((limits2 and $00c))\<\>0) * 255;
                          colorstringgrid1.cellprops[2,3].color := ord(((limits2 and $030))\<\>0) * 255;
                          colorstringgrid1.cellprops[2,4].color := ord(((limits2 and $0c0))\<\>0) * 255;
                          colorstringgrid1.cellprops[2,5].color := ord(((limits2 and $300))\<\>0) * 255;
                          colorstringgrid1.cellprops[2,6].color := ord(((limits2 and $c00))\<\>0) * 255;
                          for i:=1 to 6 do
                            colorstringgrid1.cellprops[2,i].style := [tfontstyle(ord(colorstringgrid1.cellprops[2,i].color = clred)*ord(fsbold))];
                          memoclipboxcorrectiondifference.lines.text := format(\'mask\'#13\'- correction\'#13#13\'tx = %s\'#13\'ty = %s\'#13\'tz = %s\'#13\'rx = %s\'#13\'ry = %s\'#13\'rz = %s\', [dx, dy, dz, drx, dry, drz]);
                          memoclipboxcorrectiondifference.hint := \'\';
                        end;
                      end;
                      machine_to_machineadjust.make;
                      if machine_to_machineadjust.newerthan(quirtviewerupdcoronal.viewtransform) then
                      begin
                        t := ttransform.create;
                        t.assign(machine_to_machineadjust);
                        t.invert;
                        t.gettranslation(tx, ty, tz);
                        t.getrotationafterscaling(rx, ry, rz);
                        tx := -tx;
                        ty := -ty;
                        tz := -tz;
                        rx := -rx;
                        ry := -ry;
                        rz := -rz;
                        locktrackerupdate := true;
                        trackbartranslationlr.position := round(-tx * 10);
                        trackbartranslationcc.position := round(-ty * 10);
                        trackbartranslationap.position := round( tz * 10);
                        trackbarrotationlr.position := round( rx * 4);
                        trackbarrotationcc.position := round(-ry * 4);
                        trackbarrotationap.position := round( rz * 4);
                        edittranslationlr.text := floattostrf(-tx, fffixed, 5, 2);
                        edittranslationcc.text := floattostrf(-ty, fffixed, 5, 2);
                        edittranslationap.text := floattostrf(-tz, fffixed, 5, 2);
                        if not iec_angle_convention then
                        begin
                          editrotationlr.text := floattostrf( rx, fffixed, 5, 1);
                          editrotationcc.text := floattostrf(-ry, fffixed, 5, 1);
                          editrotationap.text := floattostrf( rz, fffixed, 5, 1);
                        end
                        else
                        begin
                          if rx\>-0.05 then
                            editrotationlr.text := floattostrf( rx, fffixed, 5, 1)
                          else
                            editrotationlr.text := floattostrf( rx + 360, fffixed, 5, 1);
                          if ry\<0.05 then
                            editrotationcc.text := floattostrf(-ry, fffixed, 5, 1)
                          else
                            editrotationcc.text := floattostrf(-ry + 360, fffixed, 5, 1);
                          if rz\>-0.05 then
                            editrotationap.text := floattostrf( rz, fffixed, 5, 1)
                          else
                            editrotationap.text := floattostrf( rz + 360, fffixed, 5, 1);
                        end;
                        locktrackerupdate := false;
                        t.free;
                      end;
                      if (formstyle \<\> fsstayontop) and active then
                      begin
                        tc := findvclwindow(cursorposition);
                        if tc=quirtviewer1 then quirtviewer1.setfocus;
                        if tc=quirtviewerupdcoronal then quirtviewerupdcoronal.setfocus;
                        if tc=quirtviewerupdsagittal then quirtviewerupdsagittal.setfocus;
                        if tc=quirtviewerupdtransversal then quirtviewerupdtransversal.setfocus;
                      end;
                      if xviischildwindow and (allowautofocus or quirtviewerupdcoronal.focused or
                        quirtviewerupdtransversal.focused or quirtviewerupdsagittal.focused)  then
                      begin
                        tc := findvclwindow(cursorposition);
                        if tc=quirtviewer1 then quirtviewer1.setfocus;
                        if tc=quirtviewerupdcoronal then quirtviewerupdcoronal.setfocus;
                        if tc=quirtviewerupdsagittal then quirtviewerupdsagittal.setfocus;
                        if tc=quirtviewerupdtransversal then quirtviewerupdtransversal.setfocus;
                      end;
                      quirtviewerupdtransversal.grid.make;
                      quirtviewerupdcoronal.grid.make;
                      quirtviewerupdsagittal.grid.make;
                      if quirtviewerupdtransversal.grid.ndim \<\> 2  then
                        quirtviewerupdtransversal.slicedir.value := 1
                      else
                        quirtviewerupdtransversal.slicedir.value := 3;
                      if quirtviewerupdcoronal.grid.ndim \<\> 2  then
                        quirtviewerupdcoronal.slicedir.value := 2
                      else
                        quirtviewerupdcoronal.slicedir.value := 3;
                      if quirtviewerupdsagittal.grid.ndim \<\> 2  then
                        quirtviewerupdsagittal.slicedir.value := 3
                      else
                        quirtviewerupdsagittal.slicedir.value := 3;
                      if quirtviewerupdcoronal.markerdots[1].empty then
                        s := \'\'
                      else
                        s := #10 + #27+chr(255)+#0+#0 + marker_overlay;
                      if      (quirtviewerupdcoronal.grid.ndim=2) and (quirtviewerupdcoronal.field[1].ndim=2) then
                        quirtviewerupdcoronal.text[4].value := text_planar + s
                      else if (quirtviewerupdcoronal.grid.ndim=2) and (quirtviewerupdcoronal.field[1].ndim=4) then
                        quirtviewerupdcoronal.text[4].value := text_motion + s
                      else
                        quirtviewerupdcoronal.text[4].value := format(slice_overlay, [quirtviewerupdcoronal.slice.value, quirtviewerupdcoronal.grid.dimensions[quirtviewerupdcoronal.slicedir.value-1]]) + s;
                      if      (quirtviewerupdsagittal.grid.ndim=2) and (quirtviewerupdsagittal.field[1].ndim=2) then
                        quirtviewerupdsagittal.text[3].value := text_planar
                      else if (quirtviewerupdsagittal.grid.ndim=2) and (quirtviewerupdsagittal.field[1].ndim=4) then
                        quirtviewerupdsagittal.text[3].value := text_motion
                      else
                        quirtviewerupdsagittal.text[3].value := format(slice_overlay, [quirtviewerupdsagittal.slice.value, quirtviewerupdsagittal.grid.dimensions[quirtviewerupdsagittal.slicedir.value-1]]);
                      if      (quirtviewerupdtransversal.grid.ndim=2) and (quirtviewerupdtransversal.field[1].ndim=2) then
                        quirtviewerupdtransversal.text[2].value := text_planar
                      else if (quirtviewerupdtransversal.grid.ndim=2) and (quirtviewerupdtransversal.field[1].ndim=4) then
                        quirtviewerupdtransversal.text[2].value := text_motion
                      else
                        quirtviewerupdtransversal.text[2].value := format(slice_overlay, [quirtviewerupdtransversal.slice.value, quirtviewerupdtransversal.grid.dimensions[quirtviewerupdtransversal.slicedir.value-1]]);
                      if not enabletestmode then
                      begin
                        if quirtviewerupdcoronal.grid.ndim = 2  then
                          quirtviewerupdcoronal.text[1].value := \'\'
                        else
                          quirtviewerupdcoronal.text[1].value := overlaycor;
                        if quirtviewerupdsagittal.grid.ndim = 2  then
                          quirtviewerupdsagittal.text[1].value := \'\'
                        else
                          quirtviewerupdsagittal.text[1].value := overlaysag;
                        if quirtviewerupdtransversal.grid.ndim = 2  then
                          quirtviewerupdtransversal.text[1].value := \'\'
                        else
                          quirtviewerupdtransversal.text[1].value := overlaytrans;
                      end
                      else
                      begin
                        if quirtviewerupdcoronal.grid.ndim = 2  then
                          quirtviewerupdcoronal.text[1].value := \'\'
                        else
                          quirtviewerupdcoronal.text[1].value := overlaycor + #10+ #27+ chr(255) + #1+ #1+ copy(xvi_version, 1, pos(\'(\', xvi_version) - 2);
                        if quirtviewerupdsagittal.grid.ndim = 2  then
                          quirtviewerupdsagittal.text[1].value := \'\'
                        else
                          quirtviewerupdsagittal.text[1].value := overlaysag + #10+ #27+ chr(255) + #1+ #1+ copy(xvi_version, 1, pos(\'(\', xvi_version) - 2);
                        if quirtviewerupdtransversal.grid.ndim = 2  then
                          quirtviewerupdtransversal.text[1].value := \'\'
                        else
                          quirtviewerupdtransversal.text[1].value := overlaytrans + #10+ #27+ chr(255) + #1+ #1+ copy(xvi_version, 1, pos(\'(\', xvi_version) - 2);
                      end;
                      quirtviewerupdcoronal.viewercaption.value     := overlaycor   + \' - \';
                      quirtviewerupdsagittal.viewercaption.value    := overlaysag   + \' - \';
                      quirtviewerupdtransversal.viewercaption.value := overlaytrans + \' - \';
                      myzoom := quirtviewerupdcoronal.zoom.value;
                      inc(countmakes);
                      v := nil;
                      if machine_to_machineadjust.ischangedby is tlightquirtviewerupd then
                        v := machine_to_machineadjust.ischangedby as tlightquirtviewerupd
                      else if prevmachine_to_machineadjust.ischangedby is tlightquirtviewerupd then
                        v := prevmachine_to_machineadjust.ischangedby as tlightquirtviewerupd;
                      if ((online[1].data.ndim=2) and (reversemotion.value=0)) then
                        if assigned(v) then
                         if machine_to_machineadjust.newerthan(v.viewtransform) then
                          begin
                            v.interpolate.value := 0;
                            v.make;
                            countmakes:=0;
                          end;
                      if (countmakes\>8) or (online[1].data.ndim\>2) or (reversemotion.value\<\>0) then
                      begin
                        quirtviewerupdcoronal.interpolate.value := 1;
                        quirtviewerupdsagittal.interpolate.value := 1;
                        quirtviewerupdtransversal.interpolate.value := 1;
                        quirtviewerupdsagittal.make;
                        quirtviewerupdcoronal.make;
                        quirtviewerupdtransversal.make;
                      end;
                      if checkboxrecordform.checked and (avihandle\>=0) then
                      begin
                        timer1.enabled := false;
                        formimage := getformimage;
                        formimage.pixelformat := pf24bit;
                        pixmap := tavsfield.createas(\'field 2d 3-vector byte\', [formimage.width, formimage.height]);
                        for i := 0 to formimage.height - 1 do
                          move( formimage.scanline[i]^,
                            pchar(cardinal(pixmap.data)+ cardinal(i * formimage.width * 3))^, formimage.width * 3);
                        formimage.free;
                        avi_write(pixmap, avihandle);
                        pixmap.free;
                        inc(avicount);
                        timer1.enabled := true;
                      end;
                    end;
                    dec(form1timer1enabled);
                  end;",
// Sentence 174
                  "procedure tform1.changemachine_to_machineadjust(sender: tobject);
                  var     g, u: tavsfield;
                          f: ttransform;
                          rx, ry, rz: single;
                          i : integer;
                          v : tlightquirtviewerupd;
                  begin
                    if machine_to_machineadjust.ischangedby\<\>nil then
                    begin
                      begin
                        if not testmode and (alignmentmode.value\<\>2) then
                          invalidatecorrection;
                        matchadjusted := true;
                        end;
                      if alignmentmode.value=0 then
                        lastclipboxmatchresult := \'\'
                      else if alignmentmode.value=1 then
                        lastmaskmatchresult    := \'\';
                      manualmatchactive := true;
                    end;
                    v := nil;
                    if (machine_to_machineadjust.ischangedby is tlightquirtviewerupd) and
                       machine_to_machineadjust.newerthan(prevmachine_to_machineadjust) then
                    begin
                      v := machine_to_machineadjust.ischangedby as tlightquirtviewerupd;
                      machine_to_machineadjust.enabled := false;
                      f := ttransform.create;
                      u := tavsfield.create;
                      g := tavsfield.create;
                      if (comboboxmatch.text=match_man_rot_mrk) and not quirtviewerupdcoronal.markerdots[1].empty then i:=1
                      else                                                                                             i:=4;
                      transform_math(machine_to_machineadjust, prevmachine_to_machineadjust, f, false, true);
                      f.getrotationafterscaling(rx,ry,rz);
                      if (i=1) or ((abs(rx)+abs(ry)+abs(rz)) \> 1e-4) then
                      begin
                        transform_math(prevmachine_to_machineadjust, nil, g, true);
                        dotxfm(quirtviewerupdcoronal.markerdots[i], g, u);
                                                                                                              dotxfm(u, f, g);
                        eulerxfm(g, 0, 0, 0,
                            u.coordinate[0,0]-g.coordinate[0,0],
                            u.coordinate[1,0]-g.coordinate[1,0],
                            u.coordinate[2,0]-g.coordinate[2,0]);
                        transform_math(f, g, f);
                        transform_math(f, prevmachine_to_machineadjust, machine_to_machineadjust);
                      end;
                      f.free;
                      g.free;
                      u.free;
                      machine_to_machineadjust.enabled := true;
                    end;
                    prevmachine_to_machineadjust.assign(machine_to_machineadjust);
                    prevmachine_to_machineadjust.ischangedby := v;
                  end;",
// Sentence 175
                  "procedure tform1.invalidatecorrection;
                  var f : tavsfield;
                      i : integer;
                  begin
                    labelcomputedlat2.caption := \'-\';
                    labelcomputedlong2.caption := \'-\';
                    labelcomputedheight2.caption := \'-\';
                    labelcomputedpitch2.caption := \'-\';
                    labelcomputedroll2.caption := \'-\';
                    labelcomputedyaw2.caption := \'-\';
                    labelcomputedlat2.hint := \'\';
                    labelcomputedlong2.hint := \'\';
                    labelcomputedheight2.hint := \'\';
                    labelcomputedpitch2.hint := \'\';
                    labelcomputedroll2.hint := \'\';
                    labelcomputedyaw2.hint := \'\';
                    labelcomputedlat2.enabled := false;
                    labelcomputedlong2.enabled := false;
                    labelcomputedheight2.enabled := false;
                    labelcomputedpitch2.enabled := false;
                    labelcomputedroll2.enabled := false;
                    labelcomputedyaw2.enabled := false;
                    if transform4d.getvalue([0,2*nclipbox,3,3])\>0.99 then
                    begin
                      f := tavsfield.createas(\'field 4d float\', [4, 4, 1, 1]);
                      field_setc(f,f,-1);
                      for i:=0 to max(0, min(onlinecube.dimensions[3]-1, transform4d.dimensions[3]-1)) do
                        field_insert2(transform4d, f, transform4d, 0, 0, 2*nclipbox, i);
                      invalidateregistrationbackup(2*nclipbox, 3*nclipbox-1);
                      f.free;
                    end;
                    for i:=1 to 6 do
                      colorstringgrid1.cellprops[3,i].box.checked := false;
                    if (comboboxcorrectionprotocol.text = correction_from_clipbox) then trackbarweight.position := 0
                    else trackbarweight.position := trackbarweight.max;
                    correctionapprovalby := \'\';
                    convertedtocorrections := false;
                  end;",
// Sentence 176
                  "procedure tform1.changetransform4d(sender: tobject);
                  begin
                    buttonelektaaccept.caption := button_elekta_accept;
                    alignmentchanged := true;
                  end;",
// Sentence 177
                  "procedure tform1.pagecontrol1change(sender: tobject);
                  begin
                    timer1timer(self);
                    if pagecontrol1.activepage=tabsheet4 then
                    begin
                      if gneedtogglebuttonloadreference then
                        togglebuttonloadreference;
                    end;
                  end;",
// Sentence 178
                  "procedure tform1.quirtviewerupdcoronalpanchanged(sender: tobject; x,
                    y: integer);
                  var ix, iy: integer;
                  begin
                    if not assigned(quirtviewerupdsagittal.grid) then exit;
                    quirtviewerupdsagittal.grid.make;
                    if quirtviewerupdsagittal.grid.ndim=2 then
                    begin
                      ix := round((quirtviewerupdsagittal.width -2)/2 - myzoom*quirtviewerupdsagittal.grid.dimensions[1]/2);
                      iy := round((quirtviewerupdsagittal.height-2)/2 - myzoom*quirtviewerupdsagittal.grid.dimensions[0]/2);
                    end
                    else
                    begin
                      ix := round((quirtviewerupdsagittal.width -2)/2 - myzoom*quirtviewerupdsagittal.grid.dimensions[2]/2);
                      iy := round((quirtviewerupdsagittal.height-2)/2 - myzoom*quirtviewerupdsagittal.grid.dimensions[0]/2);
                    end;
                    quirtviewerupdsagittal.panx.value := 99999;
                    quirtviewerupdsagittal.pany.value := 99999;
                    quirtviewerupdsagittal.panx.value := ix;
                    quirtviewerupdsagittal.pany.value := iy;
                    quirtviewerupdsagittal.zoom.value := myzoom;
                    quirtviewerupdcoronal.grid.make;
                    ix := round((quirtviewerupdcoronal.width -2)/2 - myzoom*quirtviewerupdcoronal.grid.dimensions[1]/2);
                    iy := round((quirtviewerupdcoronal.height-2)/2 - myzoom*quirtviewerupdcoronal.grid.dimensions[0]/2);
                    quirtviewerupdcoronal.panx.value := 99999;
                    quirtviewerupdcoronal.pany.value := 99999;
                    quirtviewerupdcoronal.panx.value := ix;
                    quirtviewerupdcoronal.pany.value := iy;
                    quirtviewerupdcoronal.zoom.value := myzoom;
                    quirtviewerupdtransversal.grid.make;
                    if quirtviewerupdtransversal.grid.ndim=2 then
                    begin
                      ix := round((quirtviewerupdtransversal.width -2)/2 - myzoom*quirtviewerupdtransversal.grid.dimensions[1]/2);
                      iy := round((quirtviewerupdtransversal.height-2)/2 - myzoom*quirtviewerupdtransversal.grid.dimensions[0]/2);
                    end
                    else
                    begin
                      ix := round((quirtviewerupdtransversal.width -2)/2 - myzoom*quirtviewerupdtransversal.grid.dimensions[1]/2);
                      iy := round((quirtviewerupdtransversal.height-2)/2 - myzoom*quirtviewerupdtransversal.grid.dimensions[2]/2);
                    end;
                    quirtviewerupdtransversal.panx.value := 99999;
                    quirtviewerupdtransversal.pany.value := 99999;
                    quirtviewerupdtransversal.panx.value := ix;
                    quirtviewerupdtransversal.pany.value := iy;
                    quirtviewerupdtransversal.zoom.value := myzoom;
                  end;",
// Sentence 179
                  "procedure tform1.quirtviewerupdcoronalactiveclipboxchanged(sender: tobject);
                  begin
                   if (quirtviewerupdcoronal.activeclipbox.value \<\> 0) and (alignmentmode.value=0) then
                     begin
                       activeregion.value :=  quirtviewerupdcoronal.activeclipbox.value-1;
                       updownrois.position := activeregion.value;
                     end;
                  end;",
// Sentence 180
                  "procedure tform1.buttonzoomclick(sender: tobject);
                  begin
                    myzoom := quirtviewerupdcoronal.zoom.value;
                    if sender=buttonzoomout then
                    begin
                      if      myzoom\>2.501 * zoomfix then myzoom := 2.5 * zoomfix
                      else if myzoom\>2.001 * zoomfix then myzoom := 2   * zoomfix
                      else if myzoom\>1.501 * zoomfix then myzoom := 1.5 * zoomfix
                      else if myzoom\>1.001 * zoomfix then myzoom := 1   * zoomfix
                      else if myzoom\>0.501 * zoomfix then myzoom := 0.5 * zoomfix;
                    end
                    else
                    begin
                      if      myzoom\<0.499 * zoomfix then myzoom := 0.5 * zoomfix
                      else if myzoom\<0.999 * zoomfix then myzoom := 1   * zoomfix
                      else if myzoom\<1.499 * zoomfix then myzoom := 1.5 * zoomfix
                      else if myzoom\<1.999 * zoomfix then myzoom := 2   * zoomfix
                      else if myzoom\<2.499 * zoomfix then myzoom := 2.5 * zoomfix
                      else if myzoom\<2.999 * zoomfix then myzoom := 3   * zoomfix;
                    end;
                    quirtviewerupdcoronalpanchanged(self, 0, 0);
                  end;",
// Sentence 181
                  "procedure tform1.buttongenerateanglefilesclick(sender: tobject);
                  var
                    i: integer;
                    ini: tqinifile;
                    stgtdir: string;
                    ssection: string;
                    flex: tavsfield;
                  begin
                    stgtdir := edit1.text + \'\\patient_\' + patientid + \'\\images\\img_\' +
                               trimright(queryscans.fieldbyname(\'dicom_uid\').asstring) + \'\\reconstruction\\\';
                    queryframes.disablecontrols;
                    queryframes.first;
                    i:= 0;
                    while not queryframes.eof do
                    begin
                      ssection := format(\'%.4d\', [i]);
                      ini := tqinifile.create(stgtdir + \'angle.\' + ssection);
                      ini.erasesection(ssection);
                      ini.writestring(ssection, \'projectiondatafile\',
                        format(\'%.8x.his\', [strtointdef(queryframes.fieldbyname(\'dbid\').asstring, 0)]));
                      ini.writestring(ssection, \'angle\', queryframes.fieldbyname(\'proj_ang\').asstring);
                      queryframes.next;
                      if queryframes.eof then
                        ini.writestring(ssection, \'status\', \'1\')
                      else
                        ini.writestring(ssection, \'status\', \'0\');
                      ini.free;
                      inc(i);
                    end;
                    queryframes.first;
                    queryframes.enablecontrols;
                    flex := tavsfield.create;
                    createflexmapfromframedb(flex);
                    write_xdr(flex, stgtdir + \'flex.xdr\');
                    flex.free;
                    showmessage(generated_angle_and_flex + stgtdir)
                  end;",
// Sentence 182
                  "procedure tform1.buttongotoisocclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenu1.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;",
// Sentence 183
                  "procedure tform1.gotoisocenterclick(sender: tobject);
                  begin
                    quirtviewerupdsagittal.slice.maximum := 2000;
                    quirtviewerupdcoronal.slice.maximum := 2000;
                    quirtviewerupdtransversal.slice.maximum := 2000;
                    quirtviewerupdsagittal.slice.value :=  quirtviewerupdsagittal.grid.nearestpixel[2,0];
                    quirtviewerupdcoronal.slice.value := quirtviewerupdcoronal.grid.nearestpixel[1, 0];
                    quirtviewerupdtransversal.slice.value := quirtviewerupdtransversal.grid.nearestpixel[0, 0];
                  end;",
// Sentence 184
                  "procedure tform1.gotocorrectionreferencepointclick(sender: tobject);
                  begin
                    correctionreferencepoint.ischangedby := self;
                  end;",
// Sentence 185
                  "procedure tform1.gotomarkerclick(sender: tobject);
                  begin
                    quirtviewerupdcoronal.markerdots[1].ischangedby := self;
                  end;",
// Sentence 186
                  "procedure tform1.viewpoint1click(sender: tobject);
                  begin
                    quirtviewerupdcoronal.markerdots[3].ischangedby := self;
                  end;",
// Sentence 187
                  "procedure tform1.plannedisoc1click(sender: tobject);
                  begin
                    quirtviewerupdcoronal.markerdots[4].ischangedby := self;
                  end;",
// Sentence 188
                  "procedure tform1.centerofclipbox1click(sender: tobject);
                  begin
                    if alignmentmode.value=0 then
                    begin
                      quirtviewerupdcoronal.clipbox[activeregion.value+1].ischangedby := self;
                      quirtviewerupdcoronal.activeclipbox.value :=  activeregion.value+1;
                    end
                    else
                      quirtviewerupdcoronal.clipbox[1].ischangedby := self;
                  end;",
// Sentence 189
                  "procedure tform1.centerofmask1click(sender: tobject);
                  begin
                    if referencemask.empty then exit;
                    visitcenterofmask;
                  end;",
// Sentence 190
                  "procedure tform1.changeclipbox(sender: tobject);
                  var t, s, clipboxsender: tavsfield;
                  begin
                    clipboxsender := tavsfield(sender);
                    if clipboxsender.empty or (clipboxsender.ischangedby=nil) then exit;
                    if onlinecube.empty or (onlinecube.ndim=2) then exit;
                    t := tavsfield.create;
                    s := tavsfield.create;
                    if reversemotion.value\<\>0 then
                      eulerxfm(s)
                    else
                      transform_math(machine_to_machineadjust, nil, s, true);
                    cropbox_transform(clipboxsender, s, t);
                    if clipboxsender.ischangedby\<\>quirtviewerupdcoronal then quirtviewerupdcoronal.slice.value :=
                      quirtviewerupdcoronal.grid.nearestpixel[1, -(t.getvalue([4]) + t.getvalue([5]))/2];
                    if clipboxsender.ischangedby\<\>quirtviewerupdtransversal then quirtviewerupdtransversal.slice.value :=
                      quirtviewerupdtransversal.grid.nearestpixel[0, -(t.getvalue([2]) + t.getvalue([3]))/2];
                    if clipboxsender.ischangedby\<\>quirtviewerupdsagittal then quirtviewerupdsagittal.slice.value :=
                      quirtviewerupdsagittal.grid.nearestpixel[2, (t.getvalue([0]) + t.getvalue([1]))/2];
                    if (clipboxsender.ischangedby=quirtviewerupdcoronal) or
                       (clipboxsender.ischangedby=quirtviewerupdtransversal) or
                       (clipboxsender.ischangedby=quirtviewerupdsagittal) then
                    begin
                      makeregistrationbackup(0, nclipbox-1, 0, 9999);
                      invalidatecorrection;
                    end;
                    t.free;
                    s.free;
                  end;",
// Sentence 191
                  "procedure tform1.changeclipboxtext(sender: tobject);
                  begin
                  end;",
// Sentence 192
                  "procedure tform1.buttonloadscanclick(sender: tobject);
                  var filename, t, uid, es: string;
                      save: tcursor;
                      oldres, i,j: integer;
                  begin
                    needloadscan := false;
                    if onlinecube.veclen\<\>0 then
                      oldres := onlinecube.dimensions[1]
                    else
                      oldres := 0;
                    if assigned(sf) then
                    begin
                      sl.caption := wait_loadloc;
                      sl.update;
                      sf.update;
                    end;
                    es  := exportedscan;
                    uid := scanuid;
                    if avlstate\>0 then
                    begin
                      if onlineoverlaystring\<\>\'\' then
                        quirtviewerupdtransversal.text[3].value := onlineoverlaystring
                      else
                        quirtviewerupdtransversal.text[3].value := online_overlay + scandate;
                    end;
                    buttonresetmatchclick(self);
                    begin
                      if not online[1].exists(reconfilebase, scanuid, \'image1\') and
                         not online[1].exists(reconfilebase, scanuid, \'scan\') then
                      begin
                        showmessage(recon_notfound);
                        exit;
                      end;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    try
                      if online[1].exists(reconfilebase, scanuid, \'image1\') then
                      begin
                        online[1].load(reconfilebase, scanuid, \'image1\');
                        online[2].load(reconfilebase, scanuid, \'image2\');
                        online[3].load(reconfilebase, scanuid, \'image3\');
                        reference[1].processing.value := 411;
                        online[1].processing.value := 411;
                        online[2].processing.value := 411;
                        online[3].processing.value := 411;
                        online[1].connectviewer(quirtviewerupdtransversal, 1);
                        online[2].connectviewer(quirtviewerupdsagittal, 1);
                        online[3].connectviewer(quirtviewerupdcoronal, 1);
                      end
                      else
                      begin
                        if online[1].exists(reconfilebase, scanuid, \'scan\') then
                          online[1].load(reconfilebase, scanuid, \'scan\')
                        else
                          online[1].load(filename, \'\', \'\');
                        if online[1].tomachine.empty then
                          online[1].tomachine.makerotation(270, 0, 270);
                        online[1].processing.value := 0;
                        reference[1].processing.value := 0;
                        online[1].connectviewer(quirtviewerupdsagittal, 1);
                        online[1].connectviewer(quirtviewerupdtransversal, 1);
                        online[1].connectviewer(quirtviewerupdcoronal, 1);
                      end;
                      if onlinecube.ndim=4 then
                      begin
                        t := online[1].readheader(\'#$$ph\');
                        if length(t) \<\> 0 then
                        begin
                          t := trimleft(t)+\' \';
                          field_create(phasehist,\'field 1d float\',onlinecube.dimensions[3]);
                          for i := 0 to onlinecube.dimensions[3]-1 do
                          begin
                            j := pos(\' \', t);
                            phasehist.setvalue([i],safestrtofloat(copy(t,0,j-1)));
                            t := trimleft(copy(t,j,250));
                          end;
                        end
                        else
                        begin
                          showmessage(warning_nophasehist);
                          field_create(phasehist,\'field 1d float\',onlinecube.dimensions[3]);
                          field_setc(phasehist,phasehist,1/phasehist.dimensions[0]);
                        end;
                      end;
                    finally
                      screen.cursor := save;
                    end;
                    quirtviewerupdtransversal.level[1].value       := 1000;
                    quirtviewerupdtransversal.level[1].maximum     := 2000;
                    quirtviewerupdtransversal.level[1].minimum     := 0;
                    quirtviewerupdtransversal.window[1].value      := 500;
                    quirtviewerupdtransversal.window[1].maximum     := 1000;
                    quirtviewerupdtransversal.window[1].minimum     := 0;
                    if oldres \<\> onlinecube.dimensions[1] then
                    begin
                      if onlinecube.dimensions[1]\<=128      then myzoom := 3    * zoomfix
                      else if onlinecube.dimensions[1]\<=256 then myzoom := 1.5  * zoomfix
                      else if onlinecube.dimensions[1]\<=400 then myzoom := 1.2  * zoomfix
                      else if onlinecube.dimensions[1]\<=512 then myzoom := 0.75 * zoomfix
                      else                                       myzoom := 1    * zoomfix;
                      quirtviewerupdcoronalpanchanged(self, 0, 0);
                      gotoisocenterclick(self);
                      viewpoint1click(self);
                    end;
                    scanuid := uid;
                    exportedscan := es;
                    if onlinecube.ndim=4 then buttonplay4dclick(bitbtnplaygreen);
                    comboboxregistrationprotocolchange(nil);
                  end;",
// Sentence 193
                  "procedure tform1.buttonsavescanclick(sender: tobject);
                  var section: string;
                      i: tqinifile;
                  begin
                    if not saveonlinescan then exit;
                    if readonly then exit;
                    buttonloadscan.enabled := true;
                    quirtviewerupdtransversal.text[3].value := viewtext_online + scandate;
                    if not (sender=buttonreconstruct) then
                    begin
                      if synergymode then i := tqinifile.create(adminfilebase + plansopuid + \'.xvi\')
                      else i := tqinifile.create(adminfilebase + treatmentuid + \'.xvi\');
                      section := scanuid + \' \' + formatdatetime(\'yyyymmdd hh:nn:ss\', now) + \'.recon\';
                      i.erasesection(section);
                      i.writestring (section, \'version\',       xvi_version);
                      i.writestring (section, \'datetime\',      formatdatetime(\'yyyymmdd; hh:nn:ss\', now));
                      i.writestring (section, \'patientid\',     patientid);
                      i.writestring (section, \'treatmentid\',   treatmentid);
                      i.writestring (section, \'portid\',        portid);
                      i.writestring (section, \'scanuid\',       scanuid);
                      i.writestring (section, \'scandate\',      scandate);
                      i.writestring (section, \'scantime\',      scantime);
                      i.writestring (section, \'reconstruction\',scanuid + \'.scan\');
                      i.writestring (section, \'gain\',          gainfilename);
                      i.writestring (section, \'offset\',        offsetfilename);
                      i.writestring (section, \'badmap\',        \'\');
                      i.writestring (section, \'flexmap\',       flexmapfilename);
                      i.writestring (section, \'acqpars\',       acqpars);
                      i.writeinteger(section, \'recon_dimx\',    onlinecube.dimensions[0]);
                      i.writeinteger(section, \'recon_dimy\',    onlinecube.dimensions[1]);
                      i.writeinteger(section, \'recon_dimz\',    onlinecube.dimensions[2]);
                      i.writefloat  (section, \'recon_firstx\',  onlinecube.coordinate[0, 0]);
                      i.writefloat  (section, \'recon_firsty\',  onlinecube.coordinate[1, 0]);
                      i.writefloat  (section, \'recon_firstz\',  onlinecube.coordinate[2, 0]);
                      i.writefloat  (section, \'recon_lastx\',   onlinecube.coordinate[0, onlinecube.dimensions[0]-1]);
                      i.writefloat  (section, \'recon_lasty\',   onlinecube.coordinate[1, onlinecube.dimensions[1]-1]);
                      i.writefloat  (section, \'recon_lastz\',   onlinecube.coordinate[2, onlinecube.dimensions[2]-1]);
                      i.writestring (section, \'*\',            \'*****************************************************************\');
                      i.writestring (section, \'#\',            \'\');
                      i.updatefile;
                      i.free;
                    end;
                  end;",
// Sentence 194
                  "function tform1.saveonlinescan: boolean;
                  var fileheader, t1: string;
                      save: tcursor;
                      t: ttransform;
                      j: integer;
                  begin
                    result := false;
                    fileheader := #10 + \'kv=\'   + inttostr(scankv)+
                                   #10 + \'ma=\'   + inttostr(scanma)+
                                   #10 + \'ms=\'   + inttostr(scanms)+
                                   #10 + \'date=\' + copy(scandate, 1, 8)+
                                   #10 + \'time=\' + copy(scantime, 1, 6)+
                                   #10 + \'cd=\'   + caldir;
                    if true then
                    begin
                      fileheader := fileheader + #10 + \'df=\'   + offsetfilename;
                      t := ttransform.create;
                      t.assign(machine_to_siddon);
                      t.postmultiply(online_to_machine);
                      display_xfm(t, t1, 4);
                      for j:=1 to length(t1) do if t1[j]=#10 then t1[j]:=\' \';
                      fileheader := fileheader + #10 + \'#$$scantosiddon=\'+t1+#10+\'#$$matchtosiddon=\'+t1+#10;
                      t.free;
                      if (onlinecube.ndim=4) and (not phasehist.empty) then
                        fileheader := fileheader + #10 +\'#$$ph=\' + trimright(writematrix(phasehist, false));
                    end;
                    if ((online[1].data.ndim=2) and online[1].exists(reconfilebase, scanuid, \'image1\')) or
                       ((online[1].data.ndim\>2) and online[1].exists(reconfilebase, scanuid, \'scan\'))  then
                    begin
                      if messagedlg(recon_replace, mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                        exit;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    try
                      sysutils.forcedirectories(extractfilepath(reconfilebase));
                      if online[1].data.ndim=2 then
                      begin
                        online[1].delete(reconfilebase, scanuid, \'scan\');
                        online[1].save(reconfilebase, scanuid, \'image1\');
                        online[2].save(reconfilebase, scanuid, \'image2\');
                        online[3].save(reconfilebase, scanuid, \'image3\');
                      end
                      else
                      begin
                        online[1].delete(reconfilebase, scanuid, \'image1\');
                        online[1].delete(reconfilebase, scanuid, \'image2\');
                        online[1].delete(reconfilebase, scanuid, \'image3\');
                        online[1].headerstring := fileheader;
                        online[1].save(reconfilebase, scanuid, \'scan\');
                        online[1].headerstring := \'\';
                      end;
                    finally
                      screen.cursor := save;
                    end;
                    buttonloadscan.enabled := true;
                    quirtviewerupdtransversal.text[3].value := viewtext_online + scandate;
                    result := true;
                  end;",
// Sentence 195
                  "procedure tform1.trackbartranslationlrchange(sender: tobject);
                  var t: ttransform;
                  var tx, ty, tz, rx, ry, rz: single;
                  begin
                    if locktrackerupdate then exit;
                    if safestrtofloat(edittranslationlr.text)\>1000 then edittranslationlr.text:=\'1000\';
                    if safestrtofloat(edittranslationlr.text)\<-1000 then edittranslationlr.text:=\'-1000\';
                    if safestrtofloat(edittranslationcc.text)\>1000 then edittranslationcc.text:=\'1000\';
                    if safestrtofloat(edittranslationcc.text)\<-1000 then edittranslationcc.text:=\'-1000\';
                    if safestrtofloat(edittranslationap.text)\>1000 then edittranslationap.text:=\'1000\';
                    if safestrtofloat(edittranslationap.text)\<-1000 then edittranslationap.text:=\'-1000\';
                    if not iec_angle_convention then
                    begin
                      if safestrtofloat(editrotationlr.text)\>180 then editrotationlr.text:=\'180\';
                      if safestrtofloat(editrotationlr.text)\<-180 then editrotationlr.text:=\'-180\';
                      if safestrtofloat(editrotationcc.text)\>180 then editrotationcc.text:=\'180\';
                      if safestrtofloat(editrotationcc.text)\<-180 then editrotationcc.text:=\'-180\';
                      if safestrtofloat(editrotationap.text)\>180 then editrotationap.text:=\'180\';
                      if safestrtofloat(editrotationap.text)\<-180 then editrotationap.text:=\'-180\';
                    end
                    else
                    begin
                      if safestrtofloat(editrotationlr.text)\>360 then editrotationlr.text:=\'360\';
                      if safestrtofloat(editrotationlr.text)\<0 then editrotationlr.text:=\'0\';
                      if safestrtofloat(editrotationcc.text)\>360 then editrotationcc.text:=\'360\';
                      if safestrtofloat(editrotationcc.text)\<0 then editrotationcc.text:=\'0\';
                      if safestrtofloat(editrotationap.text)\>360 then editrotationap.text:=\'360\';
                      if safestrtofloat(editrotationap.text)\<0 then editrotationap.text:=\'0\';
                    end;
                    t := ttransform.create;
                    rx := 0;
                    ry := 0;
                    rz := 0;
                    tx := -safestrtofloat(edittranslationlr.text);
                    ty := -safestrtofloat(edittranslationcc.text);
                    tz := -safestrtofloat(edittranslationap.text);
                    if checkboxenablerotation.checked then
                    begin
                      rx :=  safestrtofloat(editrotationlr.text);
                      ry := -safestrtofloat(editrotationcc.text);
                      rz :=  safestrtofloat(editrotationap.text);
                    end;
                    if sender is ttrackbar then
                    begin
                      if (sender as ttrackbar).tag=1 then tx := trackbartranslationlr.position / -10;
                      if (sender as ttrackbar).tag=2 then ty := trackbartranslationcc.position / -10;
                      if (sender as ttrackbar).tag=3 then tz := trackbartranslationap.position / 10;
                      if checkboxenablerotation.checked then
                      begin
                        if (sender as ttrackbar).tag=4 then rx := trackbarrotationlr.position /  4;
                        if (sender as ttrackbar).tag=5 then ry := trackbarrotationcc.position / -4;
                        if (sender as ttrackbar).tag=6 then rz := trackbarrotationap.position /  4;
                      end;
                    end;
                    tx := -tx;
                    ty := -ty;
                    tz := -tz;
                    rx := -rx;
                    ry := -ry;
                    rz := -rz;
                    t.maketranslationafterrotation(tx, ty, tz, rx, ry, rz);
                    t.invert;
                    tx := -tx;
                    ty := -ty;
                    tz := -tz;
                    rx := -rx;
                    ry := -ry;
                    rz := -rz;
                    locktrackerupdate := true;
                    if sender is ttrackbar then
                    begin
                      if (sender as ttrackbar).tag=1 then edittranslationlr.text := floattostrf(-tx, fffixed, 5, 2);
                      if (sender as ttrackbar).tag=2 then edittranslationcc.text := floattostrf(-ty, fffixed, 5, 2);
                      if (sender as ttrackbar).tag=3 then edittranslationap.text := floattostrf(-tz, fffixed, 5, 2);
                      if checkboxenablerotation.checked then
                      begin
                        if (sender as ttrackbar).tag=4 then
                        begin
                          if (iec_angle_convention) and (rx\<-0.005) then
                            editrotationlr.text := floattostrf( rx + 360, fffixed, 5, 1)
                          else
                            editrotationlr.text := floattostrf( rx, fffixed, 5, 1)
                        end;
                        if (sender as ttrackbar).tag=5 then
                        begin
                          if (iec_angle_convention) and (ry\>0.005) then
                            editrotationcc.text := floattostrf(-ry + 360, fffixed, 5, 1)
                          else
                            editrotationcc.text := floattostrf(-ry, fffixed, 5, 1);
                        end;
                        if (sender as ttrackbar).tag=6 then
                        begin
                          if (iec_angle_convention) and (rz\<-0.005) then
                            editrotationap.text := floattostrf( rz + 360, fffixed, 5, 1)
                          else
                            editrotationap.text := floattostrf( rz, fffixed, 5, 1);
                        end;
                      end;
                    end
                    else if sender is tedit then
                    begin
                      if (sender as tedit).tag=1 then trackbartranslationlr.position := round(-tx * 10);
                      if (sender as tedit).tag=2 then trackbartranslationcc.position := round(-ty * 10);
                      if (sender as tedit).tag=3 then trackbartranslationap.position := round( tz * 10);
                      if checkboxenablerotation.checked then
                      begin
                        if (sender as tedit).tag=4 then trackbarrotationlr.position := round( rx * 4);
                        if (sender as tedit).tag=5 then trackbarrotationcc.position := round(-ry * 4);
                        if (sender as tedit).tag=6 then trackbarrotationap.position := round( rz * 4);
                      end;
                    end;
                    locktrackerupdate := false;
                    machine_to_machineadjust.assign(t);
                    if not ( (sender = edittranslationlr) or (sender = edittranslationcc) or (sender = edittranslationap) or
                           (sender = editrotationlr) or (sender = editrotationcc) or (sender = editrotationap) ) then
                       machine_to_machineadjust.ischangedby := sender;
                    quirtviewerupdcoronal.viewtransform.make;
                    quirtviewerupdsagittal.viewtransform.make;
                    quirtviewerupdtransversal.viewtransform.make;
                    t.free;
                  end;",
// Sentence 196
                  "procedure tform1.edittranslationlrexit(sender: tobject);
                  begin
                    if locktrackerupdate then exit;
                    machine_to_machineadjust.ischangedby := sender;
                  end;",
// Sentence 197
                  "procedure tform1.edittranslationlrkeydown(sender: tobject; var key: word;
                    shift: tshiftstate);
                  begin
                    timer4d.enabled := false;
                    if key=vk_return then edittranslationlrexit(self);
                  end;",
// Sentence 198
                  "procedure tform1.updowntranslationlrclick(sender: tobject; button: tudbtntype);
                  var incr, v: double;
                  begin
                    if button=btnext then incr := 0.1 else incr := -0.1;
                    if sender=updowntranslationlr then edittranslationlr.text := format(\'%.2f\', [safestrtofloat(edittranslationlr.text)+incr]);
                    if sender=updowntranslationcc then edittranslationcc.text := format(\'%.2f\', [safestrtofloat(edittranslationcc.text)+incr]);
                    if sender=updowntranslationap then edittranslationap.text := format(\'%.2f\', [safestrtofloat(edittranslationap.text)+incr]);
                    if button=btnext then incr := 1 else incr := -1;
                    if not iec_angle_convention then
                    begin
                      if sender=updownrotationlr then editrotationlr.text := format(\'%.1f\', [safestrtofloat(editrotationlr.text)+incr]);
                      if sender=updownrotationcc then editrotationcc.text := format(\'%.1f\', [safestrtofloat(editrotationcc.text)+incr]);
                      if sender=updownrotationap then editrotationap.text := format(\'%.1f\', [safestrtofloat(editrotationap.text)+incr]);
                    end
                    else
                    begin
                      v := 0;
                      if sender=updownrotationlr then v := safestrtofloat(editrotationlr.text)+incr + 360;
                      if sender=updownrotationcc then v := safestrtofloat(editrotationcc.text)+incr + 360;
                      if sender=updownrotationap then v := safestrtofloat(editrotationap.text)+incr + 360;
                      while v\>360 do v := v-360;
                      if sender=updownrotationlr then editrotationlr.text := format(\'%.1f\', [v]);
                      if sender=updownrotationcc then editrotationcc.text := format(\'%.1f\', [v]);
                      if sender=updownrotationap then editrotationap.text := format(\'%.1f\', [v]);
                    end;
                    manualmatchactive := true;
                    matchadjusted := true;
                  end;",
// Sentence 199
                  "procedure tform1.checkboxenablerotationclick(sender: tobject);
                  begin
                    trackbartranslationlrchange(self);
                  end;",
// Sentence 200
                  "procedure tform1.buttonresetmatchclick(sender: tobject);
                  var
                    f : tavsfield;
                    activereg: integer;
                  begin
                    invalidatecorrection;
                    if alignmentmode.value=0 then
                      activereg := activeregion.value
                    else
                      activereg := nclipbox+maskactiveregion.value;
                    if (radiobuttoncurrentroi.checked or radiobuttoncurrentframe.checked) and (sender = buttonresetmatch) then
                    begin
                      case 2*ord(radiobuttoncurrentroi.checked) + ord(radiobuttoncurrentframe.checked) of
                        2: begin
                             eulerxfm(machine_to_machineadjust);
                              externalmanualmatchto4d(-1, activereg);
                              makeregistrationbackup(activereg, activereg, 0, 9999);
                           end;
                        1: begin
                             eulerxfm(machine_to_machineadjust);
                             externalmanualmatchto4d(quirtviewerupdcoronal.frame.value, activereg);
                             makeregistrationbackup(alignmentmode.value*nclipbox, alignmentmode.value*nclipbox + nclipbox-1, quirtviewerupdcoronal.frame.value, quirtviewerupdcoronal.frame.value);
                           end;
                        3: begin
                             eulerxfm(machine_to_machineadjust);
                             externalmanualmatchto4d(quirtviewerupdcoronal.frame.value, activereg);
                             makeregistrationbackup(activereg, activereg, quirtviewerupdcoronal.frame.value, quirtviewerupdcoronal.frame.value);
                           end;
                      end;
                      exit;
                    end;
                    eulerxfm(machine_to_machineadjust);
                    if (sender = buttonresetmatch) and not transform4d.empty then
                    begin
                      f := tavsfield.create;
                      field_create(f, \'field 4d float\', 4, 4, nclipbox, max(onlinecube.dimensions[3], 1));
                      field_setc(f,f,-1);
                      field_insert2(transform4d, f, transform4d, 0, 0, alignmentmode.value*nclipbox, 0);
                      f.free;
                      makeregistrationbackup(alignmentmode.value * nclipbox, alignmentmode.value * nclipbox + nclipbox -1, 0, 9999);
                    end;
                    comboboxtransformmode.itemindex := 0;
                    quirtviewerupdcoronal.warp[1].clear;
                    quirtviewerupdcoronal.warp[6].clear;
                    quirtviewerupdcoronal.viewwarp.clear;
                    oldmachine_to_machineadjust.clear;
                    if (sender \<\> buttonresetmatch) or (comboboxregistrationprotocol.itemindex in [0,1,4,5]) then
                    begin
                      transform4d.clear;
                      makeregistrationbackup(0, 9999, 0, 9999);
                    end
                    else
                    begin
                      if alignmentmode.value=0 then
                      begin
                        if messagedlg(message_reset_maskaswell, mtconfirmation, [mbyes, mbno], 0) = mryes then
                        begin
                          transform4d.clear;
                          makeregistrationbackup(0, 9999, 0, 9999);
                        end;
                      end;
                      if alignmentmode.value=1 then
                      begin
                        if messagedlg(message_reset_clipboxaswell, mtconfirmation, [mbyes, mbno], 0) = mryes then
                        begin
                          transform4d.clear;
                          makeregistrationbackup(0, 9999, 0, 9999);
                        end;
                        tabcontrol1.tabindex := 0;
                        tabcontrol1change(self);
                      end;
                    end;
                    vistransform4d2.clear;
                    lastmatchresult := \'\';
                    lastclipboxmatchresult := \'\';
                    lastmaskmatchresult    := \'\';
                    onlinetoreftransformmatched := \'\';
                    matchadjusted   := false;
                    matchrotation   := true;
                    bonetumormatchstatus := 0;
                    loadbonematch.checked:=false;
                    loadtumormatch.checked := false;
                    loadacceptedmatch.checked := false;
                    loadedalignmentdatachanged := true;
                    convertedtocorrections := false;
                    converted4dtomean := false;
                    edittranslationlr.imename := \'\';
                    edittranslationcc.imename := \'\';
                    edittranslationap.imename := \'\';
                    editrotationlr.imename := \'\';
                    editrotationcc.imename := \'\';
                    editrotationap.imename := \'\';
                  end;",
// Sentence 201
                  "procedure tform1.savesettings(i: tqinifile; mode: safesettingmode; initials: string; approval : boolean = false);
                  var tx, ty, tz, rx, ry, rz: string;
                      a, x: tavsfield;
                      s, t, section, str1: string;
                      j, k: integer;
                      t1: ttransform;
                      date_time :  tdatetime;
                  begin
                    date_time := now;
                    if mode in  [elektaref, elektaalign, elektareconalign, avlref, avlstrippedref, avlalign, avlrefr, avlalignr] then
                    begin
                      if mode in [elektaref, elektaalign, elektareconalign] then
                        section := \'reference\'
                      else if mode in [avlref, avlstrippedref] then
                        section := \'xvi\'
                      else if mode in [avlalign] then
                      begin
                        if comboboxregistrationprotocol.itemindex in [4,5] then
                          section := scanuid + \'.alignart\'
                        else
                          section := scanuid + \'.align\';
                      end
                      else if mode in [avlalignr] then
                      begin
                        if comboboxregistrationprotocol.itemindex in [4,5] then
                          section := scanuid + \'.alignart\' + \'.research.\' + formatdatetime(\'yyyymmdd_hhnnss\', date_time)
                        else
                          section := scanuid + \'.align\' + \'.research.\' + formatdatetime(\'yyyymmdd_hhnnss\', date_time);
                      end
                      else if mode in [avlrefr] then
                      begin
                        s := sectionselector(i, \'xvi\' , avlrefr);
                        if s=\'\' then exit;
                        j := pos(#13,s);
                        section := copy(s,0,j-1);
                        initials := copy(s,j+1,250);
                      end;
                      if i.sectionexists(section) then
                      begin
                        str1 := i.readstring(section, \'datetime\', formatdatetime(\'yyyymmdd_hhnnss\', now));
                        inifilecopysection(i, section, section + \'.\' + str1);
                        i.erasesection(section);
                      end;
                    end;
                    if mode in  [elektaref] then
                    begin
                      i.writebool(  \'reference\', \'referenceapprovalstatus\', approval);
                      i.writestring(\'reference\', \'referenceapprovaldate\', formatdatetime(\'yyyymmdd\', date_time));
                      i.writestring(\'reference\', \'referenceapprovaltime\', formatdatetime(\'hh:nn:ss\', date_time));
                      i.writestring(\'reference\', \'referenceapprovalby\',   initials);
                    end;
                    if mode in  [elektarecon, elektareconalign] then
                    begin
                      i.writebool(  \'reconstruction\', \'reconstructionapprovalstatus\',  approval);
                      i.writebool(  \'reconstruction\', \'reconstructioncompletedstatus\', reconstructioncompletedstatus);
                      i.writestring(\'reconstruction\', \'reconstructiondate\',            formatdatetime(\'yyyymmdd\', date_time));
                      i.writestring(\'reconstruction\', \'reconstructiontime\',            formatdatetime(\'hh:nn:ss\', date_time));
                    end;
                    if mode in [elektaref, elektaalign, elektareconalign, avlref, avlstrippedref, avlalign, avlrefr, avlalignr] then
                    begin
                      if mode in [elektaref, elektaalign, elektareconalign] then
                        i.writestring (section, \'avlversion\',  xvi_version)
                      else
                        i.writestring (section, \'version\',  xvi_version);
                      i.writestring (section, \'datetime\',    formatdatetime(\'yyyymmdd; hh:nn:ss\', date_time));
                      if mode in [avlref, avlalign, avlrefr, avlalignr] then
                        i.writestring (section, \'signature\',   initials)
                      else if mode in [avlstrippedref] then
                        i.writestring (\'xvi\', \'signature\',       i.readstring (\'xvi\', \'signature\',\'\') + \' modified by \' + initials);
                      if mode in [avlrefr] then
                        i.writestring(section, \'referencecomment\', initials);
                      i.writebool   (section, \'showscan\',        checkboxscan.checked);
                      i.writebool   (section, \'showallscan\',     showall1.checked);
                      if (not beamdots.empty) and (beamdots.dimensions[0]\>1) then
                        i.writebool   (section, \'showplan\',        checkboxplan.checked);
                      i.writebool   (section, \'showdelineation\', checkboxdelineation.checked);
                      i.writebool   (section, \'showroi\',         checkboxroi.checked);
                      if not referencemask.empty then
                      begin
                        i.writebool   (section, \'showmask\',        checkboxreferencemask.checked);
                        i.writefloat  (section, \'maskmargin\',      maskmargin);
                        i.writestring (section, \'maskdelineation\', maskdelineation);
                        i.writeinteger(section, \'masklevel\',       masklevel);
                        i.writeinteger(section, \'maskwindow\',      maskwindow);
                        i.writestring (section, \'maskid\',          maskid);
                        i.writebool   (section, \'maskedited\',      maskedited);
                      end;
                    i.writeinteger(section, \'sliceaveraging\',  comboboxsliceaveraging.itemindex);
                      if mode in [elektaalign, elektareconalign, avlalign, avlalignr] then
                      begin
                        i.writestring (section, \'registrationprotocol\',   appliedcorrectionprotocol);
                        i.writestring (section, \'correctionfromprotocol\', appliedcorrectionfrom);
                        i.writestring (section, \'correctionbyprotocol\',   appliedcorrectionby);
                        i.writestring (section, \'clipboxmatchmethod\', appliedclipboxmatchmethod);
                        i.writestring (section, \'maskmatchmethod\',    appliedmaskmatchmethod);
                      end
                      else if mode in [elektaref, avlref, avlrefr] then
                      begin
                        i.writestring (section, \'registrationprotocol\',   comboboxregistrationprotocol.mappedtext);
                        i.writestring (section, \'correctionfromprotocol\', comboboxcorrectionprotocol.mappedtext);
                        i.writestring (section, \'clipboxmatchmethod\', comboboxclipboxmatch.mappedtext);
                        i.writestring (section, \'maskmatchmethod\',    comboboxmaskmatch.mappedtext);
                        i.writestring (section, \'correctionbyprotocol\',   comboboxcorrectionby.mappedtext);
                      end
                      else if mode in [avlstrippedref] then
                      begin
                        i.writestring (section, \'clipboxmatchmethod\', comboboxclipboxmatch.mappedtext);
                        i.writestring (section, \'maskmatchmethod\',    comboboxmaskmatch.mappedtext);
                      end;
                      if mode in [avlref, avlalign, avlrefr, avlalignr, elektaref] then
                      begin
                        i.deletekey (section, \'clipboxtranslationlimitsidentical\');
                        i.deletekey (section, \'clipboxrotationlimitsidentical\');
                        i.deletekey (section, \'masktranslationlimitsidentical\');
                        i.deletekey (section, \'maskrotationlimitsidentical\');
                        if comboboxregistrationprotocol.itemindex in [0, 2, 3, 4] then
                        begin
                        i.writebool (section, \'clipboxtranslationlimitsidentical\', colorstringgrid2.cellprops[1,0].box.checked);
                        i.writebool (section, \'clipboxrotationlimitsidentical\', colorstringgrid2.cellprops[1,4].box.checked);
                        end;
                        if comboboxregistrationprotocol.itemindex in [1, 2, 3, 5] then
                        begin
                        i.writebool (section, \'masktranslationlimitsidentical\', colorstringgrid3.cellprops[1,0].box.checked);
                        i.writebool (section, \'maskrotationlimitsidentical\', colorstringgrid3.cellprops[1,4].box.checked);
                        end;
                        i.deletekey (section, \'clipboxtranslationwarnlimit\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitright\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitleft\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitinf\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitsup\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitpost\');
                        i.deletekey (section, \'clipboxtranslationwarnlimitant\');
                        i.deletekey (section, \'clipboxrotationwarnlimit\');
                        i.deletekey (section, \'clipboxrotationwarnlimitlr_cc\');
                        i.deletekey (section, \'clipboxrotationwarnlimitlr_cw\');
                        i.deletekey (section, \'clipboxrotationwarnlimitsi_cc\');
                        i.deletekey (section, \'clipboxrotationwarnlimitsi_cw\');
                        i.deletekey (section, \'clipboxrotationwarnlimitap_cc\');
                        i.deletekey (section, \'clipboxrotationwarnlimitap_cw\');
                        if comboboxregistrationprotocol.itemindex in [0, 2, 3, 4] then
                        begin
                        if  colorstringgrid2.cellprops[1,0].box.checked then
                          begin
                            i.writestring (section, \'clipboxtranslationwarnlimit\', colorstringgrid2.cells[2,1]);
                          end
                        else
                        begin
                          i.writestring (section, \'clipboxtranslationwarnlimitright\', colorstringgrid2.cells[1,1]);
                          i.writestring (section, \'clipboxtranslationwarnlimitleft\', colorstringgrid2.cells[2,1]);
                          i.writestring (section, \'clipboxtranslationwarnlimitinf\', colorstringgrid2.cells[1,2]);
                          i.writestring (section, \'clipboxtranslationwarnlimitsup\', colorstringgrid2.cells[2,2]);
                          i.writestring (section, \'clipboxtranslationwarnlimitpost\', colorstringgrid2.cells[1,3]);
                          i.writestring (section, \'clipboxtranslationwarnlimitant\', colorstringgrid2.cells[2,3]);
                        end;
                        if  colorstringgrid2.cellprops[1,4].box.checked then
                          begin
                            i.writestring (section, \'clipboxrotationwarnlimit\',    colorstringgrid2.cells[2,5]);
                          end
                        else
                        begin
                          i.writestring (section, \'clipboxrotationwarnlimitlr_cc\', colorstringgrid2.cells[1,5]);
                          i.writestring (section, \'clipboxrotationwarnlimitlr_cw\', colorstringgrid2.cells[2,5]);
                          i.writestring (section, \'clipboxrotationwarnlimitsi_cc\', colorstringgrid2.cells[1,6]);
                          i.writestring (section, \'clipboxrotationwarnlimitsi_cw\', colorstringgrid2.cells[2,6]);
                          i.writestring (section, \'clipboxrotationwarnlimitap_cc\', colorstringgrid2.cells[1,7]);
                          i.writestring (section, \'clipboxrotationwarnlimitap_cw\', colorstringgrid2.cells[2,7]);
                        end;
                        end;
                        i.deletekey (section, \'masktranslationwarnlimit\');
                        i.deletekey (section, \'masktranslationwarnlimitright\');
                        i.deletekey (section, \'masktranslationwarnlimitleft\');
                        i.deletekey (section, \'masktranslationwarnlimitinf\');
                        i.deletekey (section, \'masktranslationwarnlimitsup\');
                        i.deletekey (section, \'masktranslationwarnlimitpost\');
                        i.deletekey (section, \'masktranslationwarnlimitant\');
                        i.deletekey (section, \'maskrotationwarnlimit\');
                        i.deletekey (section, \'maskrotationwarnlimitlr_cc\');
                        i.deletekey (section, \'maskrotationwarnlimitlr_cw\');
                        i.deletekey (section, \'maskrotationwarnlimitsi_cc\');
                        i.deletekey (section, \'maskrotationwarnlimitsi_cw\');
                        i.deletekey (section, \'maskrotationwarnlimitap_cc\');
                        i.deletekey (section, \'maskrotationwarnlimitap_cw\');
                        if comboboxregistrationprotocol.itemindex in [1, 2, 3, 5] then
                        begin
                        if  colorstringgrid3.cellprops[1,0].box.checked then
                          begin
                            i.writestring (section, \'masktranslationwarnlimit\',    colorstringgrid3.cells[2,1]);
                          end
                        else
                        begin
                          i.writestring (section, \'masktranslationwarnlimitright\', colorstringgrid3.cells[1,1]);
                          i.writestring (section, \'masktranslationwarnlimitleft\', colorstringgrid3.cells[2,1]);
                          i.writestring (section, \'masktranslationwarnlimitinf\', colorstringgrid3.cells[1,2]);
                          i.writestring (section, \'masktranslationwarnlimitsup\', colorstringgrid3.cells[2,2]);
                          i.writestring (section, \'masktranslationwarnlimitpost\', colorstringgrid3.cells[1,3]);
                          i.writestring (section, \'masktranslationwarnlimitant\', colorstringgrid3.cells[2,3]);
                        end;
                        if  colorstringgrid3.cellprops[1,4].box.checked then
                          begin
                            i.writestring (section, \'maskrotationwarnlimit\',       colorstringgrid3.cells[2,5]);
                          end
                        else
                        begin
                          i.writestring (section, \'maskrotationwarnlimitlr_cc\', colorstringgrid3.cells[1,5]);
                          i.writestring (section, \'maskrotationwarnlimitlr_cw\', colorstringgrid3.cells[2,5]);
                          i.writestring (section, \'maskrotationwarnlimitsi_cc\', colorstringgrid3.cells[1,6]);
                          i.writestring (section, \'maskrotationwarnlimitsi_cw\', colorstringgrid3.cells[2,6]);
                          i.writestring (section, \'maskrotationwarnlimitap_cc\', colorstringgrid3.cells[1,7]);
                          i.writestring (section, \'maskrotationwarnlimitap_cw\', colorstringgrid3.cells[2,7]);
                        end;
                      end;
                      end;
                      case comboboxdisplaymode.itemindex of
                        0: s := \'greenpurple\';
                        1: s := \'cut\';
                        2: s := \'onlineonly\';
                        3: s := \'referenceonly\';
                      end;
                      i.writestring(section, \'displaymode\', s);
                      k := 1;
                      if not delineationdotslut.empty then
                      for j:=0 to delineationdotslut.dimensions[0]-1 do
                      begin
                          dil_get_name(delineationdotslut, s, j);
                          if (s\<\>\'\') and (round(delineationdotslut.getvalue([j, 27]))=0) then
                          begin
                           i.writestring(section, \'displaystructure\'+inttostr(k), s);
                           inc(k);
                          end
                          else
                          begin
                           i.writestring(section, \'displaystructure\'+inttostr(k), \'.\');
                           inc(k);
                          end;
                      end;
                      if k=1 then i.writestring(section, \'displaystructure\'+inttostr(k), \'-- none --\');
                      for j:=1 to high(online) do
                        if not online[j].data.empty then
                        begin
                          i.writeinteger(section, \'online\'+inttostr(j)+\'.level\',  round(online[j].level.value));
                          i.writeinteger(section, \'online\'+inttostr(j)+\'.window\', round(online[j].window.value));
                        end;
                      if (onlinecube.empty or (onlinecube.veclen=0)) then
                      begin
                        i.writeinteger(section, \'online1.level\',   round(reference[1].level.value));
                        i.writeinteger(section, \'online1.window\',  round(reference[1].window.value));
                      end;
                      for j:=1 to high(reference) do
                        if not reference[j].data.empty then
                        begin
                          i.writeinteger(section, \'reference\'+inttostr(j)+\'.level\',  round(reference[j].level.value));
                          i.writeinteger(section, \'reference\'+inttostr(j)+\'.window\', round(reference[j].window.value));
                        end;
                      i.writefloat  (section, \'zoom\', myzoom * 0.1 / abs(quirtviewerupdtransversal.grid.coordinate[0, 1] - quirtviewerupdtransversal.grid.coordinate[0, 0]));
                      a := tavsfield.createas(\'field 1d 3-space irregular\', [1]);
                      x := tavsfield.create;
                      a.coordinate[0,0] := quirtviewerupdtransversal.grid.coordinate[0, quirtviewerupdtransversal.slice.value];
                      a.coordinate[1,0] := quirtviewerupdcoronal.grid.coordinate[1, quirtviewerupdcoronal.slice.value];
                      a.coordinate[2,0] := quirtviewerupdsagittal.grid.coordinate[2, quirtviewerupdsagittal.slice.value];
                      x.assign(quirtviewerupdcoronal.viewtransform);
                      transform_math(x, nil, x, true);
                      dotxfm(a, x, a);
                      i.writefloat  (section, \'viewpointx\', a.coordinate[0,0]);
                      i.writefloat  (section, \'viewpointy\', a.coordinate[1,0]);
                      i.writefloat  (section, \'viewpointz\', a.coordinate[2,0]);
                      a.free;
                      x.free;
                      i.deletekey  (\'xvi\', \'markerset\');
                      i.deletekey  (\'xvi\', \'markerx\');
                      i.deletekey  (\'xvi\', \'markery\');
                      i.deletekey  (\'xvi\', \'markerz\');
                      i.deletekey  (section, \'markerset\');
                      i.deletekey  (section, \'markerx\');
                      i.deletekey  (section, \'markery\');
                      i.deletekey  (section, \'markerz\');
                      if not quirtviewerupdcoronal.markerdots[1].empty then
                      begin
                        i.writebool  (\'xvi\', \'markerset\', true);
                        i.writefloat  (\'xvi\', \'markerx\', quirtviewerupdcoronal.markerdots[1].coordinate[0,0]);
                        i.writefloat  (\'xvi\', \'markery\', quirtviewerupdcoronal.markerdots[1].coordinate[1,0]);
                        i.writefloat  (\'xvi\', \'markerz\', quirtviewerupdcoronal.markerdots[1].coordinate[2,0]);
                      end;
                    i.deletekey  (section, \'clip1x1\');
                      i.deletekey  (section, \'clip1x2\');
                      i.deletekey  (section, \'clip1y1\');
                      i.deletekey  (section, \'clip1y2\');
                      i.deletekey  (section, \'clip1z1\');
                      i.deletekey  (section, \'clip1z2\');
                      i.deletekey  (section, \'clip1locked\');
                      if not clipbox[1].empty then
                      begin
                      end;
                      clipboxlist.make;
                      for j:=1 to nclipbox do
                      begin
                        i.deletekey(section, \'clip\'+inttostr(j));
                        if clipbox[j].empty then continue;
                        s := format(\'%f, %f, %f, %f, %f, %f, %s, %f, %s\',
                        [clipbox[j].getvalue([0]), clipbox[j].getvalue([1]), clipbox[j].getvalue([2]),
                         clipbox[j].getvalue([3]), clipbox[j].getvalue([4]), clipbox[j].getvalue([5]),
                         cbnames[j-1],
                         cbweights[j],
                         \'bone\']);
                        i.writestring(section, \'clip\'+inttostr(j),  s);
                      end;
                      i.writebool   (section, \'clipboxlocked\', clipbox[1].locked);
                      if mode in [elektaref, elektaalign, elektareconalign] then
                      begin
                        x := tavsfield.create;
                        t1 := ttransform.create;
                        t1.makerotation(270, 0, 270); t1.invert;
                        i.deletekey  (section, \'clipboxx1\');
                        i.deletekey  (section, \'clipboxx2\');
                        i.deletekey  (section, \'clipboxy1\');
                        i.deletekey  (section, \'clipboxy2\');
                        i.deletekey  (section, \'clipboxz1\');
                        i.deletekey  (section, \'clipboxz2\');
                        i.deletekey  (section, \'clipboxlocked\');
                      t1.free;
                        x.free;
                      end;
                      if not (mode in [avlstrippedref]) then
                      begin
                        i.writefloat  (section, \'isocx\',  machine_to_siddon.getvalue([3, 0]));
                        i.writefloat  (section, \'isocy\',  machine_to_siddon.getvalue([3, 1]));
                        i.writefloat  (section, \'isocz\',  machine_to_siddon.getvalue([3, 2]));
                        i.writeinteger(section, \'correctionreferencepointmode\',strtoint(correctionreferencepoint.debugname));
                        i.writefloat  (section, \'correctionreferencepointx\',   correctionreferencepoint.coordinate[0,0]);
                        i.writefloat  (section, \'correctionreferencepointy\',   correctionreferencepoint.coordinate[1,0]);
                        i.writefloat  (section, \'correctionreferencepointz\',   correctionreferencepoint.coordinate[2,0]);
                        i.writestring (section, \'correctionreferencepointstructure\', correctionreferencepointstructure);
                      end;
                    end;
                    if mode in  [elektaalign, elektareconalign, avlalign, avlalignr] then
                    begin
                      if mode in [elektaalign, elektareconalign] then
                      begin
                        section := \'alignment\';
                        if i.sectionexists(section) then
                        begin
                          str1 := i.readstring(section, \'datetime\', formatdatetime(\'yyyymmdd_hhnnss\', now));
                          inifilecopysection(i, section, section + \'.\' + str1);
                          i.erasesection(section);
                        end;
                      end;
                      i.writebool(  section, \'alignmentapprovalstatus\',  approval);
                      i.writestring(section, \'alignmentapprovaldate\',    formatdatetime(\'yyyymmdd\', date_time));
                      i.writestring(section, \'alignmentapprovaltime\',    formatdatetime(\'hh:nn:ss\', date_time));
                      i.writestring(section, \'alignmentapprovalby\',      initials);
                      i.writebool(  section, \'correctionapprovalstatus\',  approval);
                      i.writestring(section, \'correctionapprovaldate\',    formatdatetime(\'yyyymmdd\', date_time));
                      i.writestring(section, \'correctionapprovaltime\',    formatdatetime(\'hh:nn:ss\', date_time));
                      if (correctionapprovalby=\'\') or (correctionapprovalby=\'*\') then correctionapprovalby := initials;
                      i.writestring(section, \'correctionapprovalby\',      correctionapprovalby);
                      if mode in [elektaalign, elektareconalign] then
                        i.writestring (section, \'avlversion\',  xvi_version)
                      else
                        i.writestring (section, \'version\',  xvi_version);
                      i.writestring (section, \'datetime\',    formatdatetime(\'yyyymmdd; hh:nn:ss\', date_time));
                      if mode in [avlalign, avlalignr] then
                      begin
                        i.writestring (section, \'reconstruction\',  scanuid + \'.scan\');
                        i.writestring (section, \'scandate\',      scandate);
                        i.writestring (section, \'scantime\',      scantime);
                      end;
                      for k:=1 to nclipbox do
                      begin
                        if (i.readstring(section, \'align.clip\'+inttostr(k), \'\') = \'\') then break;
                        i.deletekey   (section, \'align.clip\'+inttostr(k));
                        for j:=0 to 100 do
                        begin
                          if (i.readstring(section, \'align.clip\'+inttostr(k)+\'.frame\'+inttostr(j), \'\') = \'\') then break;
                          i.deletekey   (section, \'align.clip\'+inttostr(k)+\'.frame\'+inttostr(j));
                        end;
                      end;
                      for k:=1 to nclipbox do
                      begin
                        if (i.readstring(section, \'align.mask\'+inttostr(k), \'\') = \'\') then break;
                        i.deletekey   (section, \'align.mask\'+inttostr(k));
                        for j:=0 to 100 do
                        begin
                          if (i.readstring(section, \'align.mask\'+inttostr(k)+\'.frame\'+inttostr(j), \'\') = \'\') then break;
                          i.deletekey   (section, \'align.mask\'+inttostr(k)+\'.frame\'+inttostr(j));
                        end;
                      end;
                      for k:=1 to nclipbox do
                      begin
                        unpackregistration(k-1, -1, tx, ty, tz, rx, ry, rz, s);
                        if s\<\>\'\' then i.writestring (section, \'align.clip\'+inttostr(k), s);
                        if (pos(match_substring_4d, appliedclipboxmatchmethod)\>0) and (scanis4d) then
                          for j:=0 to onlinecube.dimensions[3]-1 do
                        begin
                          unpackregistration(k-1, j, tx, ty, tz, rx, ry, rz, s);
                          if s\<\>\'\' then i.writestring (section, \'align.clip\'+inttostr(k)+\'.frame\'+inttostr(j), s);
                        end;
                      end;
                      for k:=1 to nclipbox do
                      begin
                        unpackregistration(nclipbox+k-1, -1, tx, ty, tz, rx, ry, rz, s);
                        if s\<\>\'\' then i.writestring (section, \'align.mask\'+inttostr(k), s);
                        if (pos(match_substring_4d, appliedmaskmatchmethod)\>0) and (scanis4d) then
                          for j:=0 to onlinecube.dimensions[3]-1 do
                        begin
                          unpackregistration(nclipbox+k-1, j, tx, ty, tz, rx, ry, rz, s);
                          if s\<\>\'\' then i.writestring (section, \'align.mask\'+inttostr(k)+\'.frame\'+inttostr(j), s);
                        end;
                      end;
                      unpackregistration(2*nclipbox, 0, tx, ty, tz, rx, ry, rz, s);
                      if s\<\>\'\' then i.writestring (section, \'align.correction\', s);
                      i.writestring (section, \'couchshiftlat\',        labelcomputedlat2.caption);
                      i.writestring (section, \'couchshiftlong\',       labelcomputedlong2.caption);
                      i.writestring (section, \'couchshiftheight\',     labelcomputedheight2.caption);
                      i.writestring (section, \'couchpitch\',      labelcomputedpitch2.caption);
                      i.writestring (section, \'couchroll\',       labelcomputedroll2.caption);
                      i.writestring (section, \'couchyaw\',        labelcomputedyaw2.caption);
                      t1 := ttransform.create;
                      t1.assign(online_to_machine);
                      transform_math(t1, reference_to_machine, t1, false, true, false);
                      t := t1.asstring;
                      for j:=1 to length(t) do
                      begin
                        if t[j]=#10 then t[j] := \' \';
                        if t[j]=#13 then t[j] := \' \';
                      end;
                      i.writestring (section, \'onlinetoreftransformunmatched\', t);
                      t1.assign(online_to_machine);
                      t1.premultiply(machine_to_machineadjust);
                      transform_math(t1, reference_to_machine, t1, false, true, false);
                      t := t1.asstring;
                      for j:=1 to length(t) do
                      begin
                        if t[j]=#10 then t[j] := \' \';
                        if t[j]=#13 then t[j] := \' \';
                      end;
                      i.writestring (section, \'onlinetoreftransformcorrection\', t);
                      if mode in [elektaalign, elektareconalign] then
                      begin
                        t := lastmatchresult;
                        for j:=1 to length(t) do
                        begin
                          if t[j]=#10 then t[j] := \';\';
                          if t[j]=#13 then t[j] := \' \';
                        end;
                        i.writebool   (section, \'matchadjusted\', matchadjusted);
                      end
                      else if mode in [avlalign, avlalignr] then
                      begin
                        if (appliedcorrectionprotocol = \'clipbox\') or
                           (appliedcorrectionprotocol = \'clipbox --\> mask\') then
                          i.writestring (section, \'clipboxmatchmessage\', lastclipboxmatchresult);
                        if (appliedcorrectionprotocol = \'mask\') or
                           (appliedcorrectionprotocol = \'clipbox --\> mask\') or
                           (appliedcorrectionprotocol = \'clipbox & art\') then
                          i.writestring (section, \'maskmatchmessage\', lastmaskmatchresult);
                        i.writebool   (section, \'matchadjusted\', matchadjusted);
                        i.writebool   (section, \'prerotate\', matchprerotate);
                        i.writebool   (section, \'rotatearoundmarker\', matchrotmark);
                        i.writestring (section, \'reconstructedscansdirectory\',  reconfilebase);
                        i.writestring (section, \'administrativefilesdirectory\', adminfilebase);
                        i.writestring (section, \'referencecachedirectory\',      cachefilebase);
                        i.deletekey   (section, \'*\');
                        i.deletekey   (section, \'#\');
                        i.writestring (section, \'*\',            \'*****************************************************************\');
                        i.writestring (section, \'#\',            \'\');
                      end;
                      t1.free;
                    end;
                  end;",
// Sentence 202
                  "procedure tform1.confirmmatch(inifilename, section, initials : string);
                  var matchname : string;
                      i : tqinifile;
                      apprvby : string;
                  begin
                        i := tqinifile.create(inifilename);
                        matchname := i.readstring(section, \'matchmethod\', \'\');
                        matchname := i.readstring(section, \'match\', matchname) + \', \' + initials;
                        i.writestring(section, \'match\', matchname);
                        apprvby := i.readstring(section, \'alignmentapprovalby\', \'\');
                        i.writestring (section, \'alignmentapprovalby\', apprvby + \', \' + initials);
                        apprvby := i.readstring(section, \'correctionapprovalby\', \'\');
                        i.writestring (section, \'correctionapprovalby\', apprvby + \', \' + initials);
                        initials := i.readstring(section, \'signature\', \'\') + \', \' + initials;
                        i.writestring (section, \'signature\',     initials);
                        writematchresultlogfile(initials);
                        i.updatefile;
                        i.free;
                  end;",
// Sentence 203
                  "procedure tform1.inifilecopysection(i: tqinifile; sourcesectionname, destinationsectionname : string);
                  var sectionitems : tstringlist;
                      k : integer;
                      key : string;
                  begin
                    if not i.sectionexists(sourcesectionname) then
                      exit;
                    sectionitems := tstringlist.create;
                    i.readsection(sourcesectionname, sectionitems);
                    for k:= 0 to sectionitems.count-1 do
                    begin
                      key := i.readstring(sourcesectionname,sectionitems[k],\'\');
                      i.writestring(destinationsectionname,sectionitems[k],key);
                    end;
                    sectionitems.free;
                  end;",
// Sentence 204
                  "procedure tform1.writematch(matchname :string; machinetomachineadjust :ttransform; matchonly :boolean);
                  var t1, t3, t4, avlreftopatientsiddon: ttransform;
                      t2 : tavsfield;
                      j  : integer;
                      matchfile, text : string;
                      f: textfile;
                      t5 : tavsfield;
                      t6 : ttransform;
                  begin
                    j := pos(\':\', patienturl);
                    if j\>0 then
                    begin
                      if datatype=\'quirt\' then
                        matchfile := datapath + \'images\\\' + copy(patienturl, j+1, 250) + \'\\\' + copy(patienturl, j+1, 250) + \'.mat\'
                      else
                        matchfile := datapath + copy(patienturl, j+1, 250) + \'\\\' + copy(patienturl, j+1, 250) + \'.mat\';
                    end
                    else
                    begin
                      showmessage(invalid_pat_url + patienturl);
                      exit;
                    end;
                    if not fileexists(matchfile) then
                    begin
                      showmessage(creating_matchfile + matchfile);
                      assignfile(f, matchfile);
                      rewrite(f);
                      writeln(f, \'match file created by xvi: \' + datetostr(date) + \' \' + timetostr(time));
                      closefile(f);
                    end;
                    t1 := ttransform.create;
                    t2 := tavsfield.create;
                    t3 := ttransform.create;
                    t4 := ttransform.create;
                    t5 := tavsfield.create;
                    t6 := ttransform.create;
                    t1.assign(reference_to_machine);
                    t1.invert;
                    t1.postmultiply(machinetomachineadjust);
                    t1.postmultiply(online_to_machine);
                    t3.assign(online_to_machine);
                    t3.premultiply(machine_to_siddon);
                    t4.assign(reference_to_siddon);
                    avlreftopatientsiddon := ttransform.create;
                    avlreftopatientsiddon.assign(reference_to_patient);
                    assignfile(f, matchfile);
                    append(f);
                    writeln(f, \'*******************************************************\');
                    writeln(f, \'match      : \' + matchname);
                    writeln(f, \'computed on: \' + formatdatetime(\'yyyymmdd; hh:nn:ss\', now));
                    writeln(f, \'version    : \' + \'xvi generated match \' + xvi_version);
                    writeln(f, \'\');
                    writeln(f, \'patientid    : \' + patientid);
                    writeln(f, \'treatmentid  : \' + treatmentid);
                    writeln(f, \'treatmentuid : \' + treatmentuid);
                    writeln(f, \'portid       : \' + portid);
                    writeln(f, \'portuid      : \' + portuid);
                    writeln(f, \'scanuid      : \' + scanuid);
                    writeln(f, \'scandate     : \' + scandate);
                    writeln(f, \'scantime     : \' + scantime);
                    writeln(f, \'\');
                    writeln(f, \'ct scan    : \' + scanurl);
                    writeln(f, \'actual transformation (ct to siddon)  :\');
                    writeln(f, writematrix(avlreftopatientsiddon, false));
                    writeln(f, \'\');
                    writeln(f, \'mri                  : \' + exportedscan);
                    if datatype\<\>\'quirt\' then
                      writeln(f, \'orientation          : axial\')
                    else
                      writeln(f, \'orientation          : coronal\');
                    writeln(f, \'actual transformation (mri to siddon) :\');
                    if datatype\<\>\'quirt\' then
                    begin
                     t3.invert;
                     shuffle_transform(t3, t3, shuffle_transform_kslice, false, true, false, false, 3);
                     t3.invert;
                     t1.invert;
                     shuffle_transform(t1, t1, shuffle_transform_kslice, false, true, false, false, 3);
                     t1.invert;
                    end;
                    writeln(f, writematrix(t3, false));
                    writeln(f, \'\');
                    writeln(f, \'transformation (mri to ct in scan coordinate system)    :\');
                    writeln(f, writematrix(t1, false));
                    writeln(f, \'\');
                    if matchonly then
                    begin
                      closefile(f);
                      t1.free;
                      t2.free;
                      t3.free;
                      t4.free;
                      t5.free;
                      t6.free;
                      avlreftopatientsiddon.free;
                      exit;
                    end;
                    writeln(f, \'*******************************************************\');
                    writeln(f, \'3d setup error:      \' + matchname);
                    writeln(f, \'computed on:         \' + formatdatetime(\'yyyymmdd; hh:nn:ss\', now));
                    writeln(f, \'version:             \' + xvi_version);
                    writeln(f, \'\');
                    writeln(f, \'patientid    : \' + patientid);
                    writeln(f, \'treatmentid  : \' + treatmentid);
                    writeln(f, \'treatmentuid : \' + treatmentuid);
                    writeln(f, \'portid       : \' + portid);
                    writeln(f, \'portuid      : \' + portuid);
                    writeln(f, \'scanuid      : \' + scanuid);
                    writeln(f, \'scandate     : \' + scandate);
                    writeln(f, \'scantime     : \' + scantime);
                    writeln(f, \'\');
                    writeln(f, \'reference scan:      \' + scanurl);
                    writeln(f, \'reference scan date: \' + \'unknown\');
                    writeln(f, \'reference scan time: \' + \'unknown\');
                    writeln(f, \'reference scan to siddon:\');;
                    writeln(f, writematrix(reference_to_siddon, false));
                    writeln(f, \'\');
                    writeln(f, \'on-line scan:        \' + exportedscan);
                    writeln(f, \'on-line scan in xvi: \' + scanuid + \'.scan\');
                    writeln(f, \'on-line scan date:   \' + copy(scandate, 3, 6));
                    writeln(f, \'on-line scan time:   \' + copy(scantime, 0, 2)+\':\'+copy(scantime, 3, 2)+\':\'+copy(scantime, 5, 2));
                    writeln(f, \'on-line scan to siddon:\');
                    writeln(f, writematrix(online_to_machine, false));
                    writeln(f, \'\');
                    writeln(f, \'current match:       \' + matchname);
                    writeln(f, \'\');
                    writeln(f, \'transformation (on-line to reference in scan coordinate system)    :\');
                    writeln(f, writematrix(t1, false));
                    if synergymode then writeln(f, \'xvi info  : \' + adminfilebase + plansopuid + \'.xvi\')
                    else                writeln(f, \'xvi info  : \' + adminfilebase + treatmentuid + \'.xvi\');
                    writeln(f, \'plan      : \' + planurl);
                    writeln(f, \'beam      : \' + beamurl);
                    writeln(f, \'beam_to_siddon :\');
                    writeln(f, writematrix(machine_to_siddon, false));
                    t1.assign(machinetomachineadjust);
                    t1.invert;
                    writeln(f, \'reference to actual patient setup in siddon coordinates:\');
                    writeln(f, writematrix(t1, false));
                    euler_components(t1, t2, text, 0.002);
                    writeln(f, \'transformation description in siddon coordinates (+x=left, +y=superior, +z=anterior):\');
                    for j:=1 to length(text) do
                      if text[j]=#10 then writeln(f, \'\') else write(f, text[j]);
                    writeln(f);
                    closefile(f);
                    t1.free;
                    t2.free;
                    t3.free;
                    t4.free;
                    t5.free;
                    t6.free;
                    avlreftopatientsiddon.free;
                  end;",
// Sentence 205
                  "procedure tform1.buttonwritematchclick(sender: tobject);
                  begin
                  end;",
// Sentence 206
                  "procedure tform1.buttonreadmatchclick(sender: tobject);
                  begin
                  end;",
// Sentence 207
                  "procedure tform1.matchfileselectionfill;
                  begin
                  end;",
// Sentence 208
                  "procedure tform1.buttonloadmatchclick(sender: tobject);
                  var section, uid, filename: string;
                      ini: tinifiles;
                      save: tcursor;
                  begin
                    section := scanuid + \'.align\';
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    buttonresetmatchclick(self);
                    manualmatchactive := false;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    if avlstate\>0 then filename := paramstr2
                    else               filename := adminfilebase + uid + \'.xvi\';
                    if sectiontoload=\'none\' then
                      ini := tinifiles.create([filename])
                    else
                      begin
                        if (avlstate=3) and (sectiontoload\<\>\'none\') then
                          ini := tinifiles.create([filename, filename + \'.xvi\'])
                        else
                          ini := tinifiles.create([filename + \'.xvi\', filename]);
                      end;
                      loadmatch(ini, section, nil);
                    labelcomputedlat2.enabled := true;
                    labelcomputedlong2.enabled := true;
                    labelcomputedheight2.enabled := true;
                    activesettingstolistview(ini, false);
                    ini.free;
                    alignmentchanged := false;
                    manualmatchactive := false;
                    screen.cursor := save;
                    end;",
// Sentence 209
                  "procedure tform1.packregistration(i: tinifiles; section: string; frame, region: integer);
                  var s: string;
                      tx, ty, tz, rx, ry, rz: single;
                      t: ttransform;
                  begin
                    if region\<nclipbox then
                      s:= \'align.clip\' + inttostr(region+1)
                    else if region\<2*nclipbox then
                      s:= \'align.mask\' + inttostr(region-nclipbox+1)
                    else
                      s:= \'align.correction\';
                    if frame\>=0 then s := s + \'.frame\'+inttostr(frame);
                    if assigned(i) then
                      s := i.readstring(section, s, \'\')
                    else
                      s := section;
                    if s=\'\' then exit;
                    tx := valuefromstr(s, 1);
                    ty := valuefromstr(s, 2);
                    tz := valuefromstr(s, 3);
                    rx := -valuefromstr(s, 4);
                    ry :=  valuefromstr(s, 5);
                    rz := -valuefromstr(s, 6);
                    t := ttransform.create;
                    t.maketranslationafterrotation(tx,ty,tz,rx,ry,rz);
                    t.invert;
                    machine_to_machineadjust.assign(t);
                    t.free;
                    externalmanualmatchto4d(frame, region);
                    end;",
// Sentence 210
                  "procedure tform1.loadmatch(i: tinifiles; section : string; f: ttransform);
                  var s: string;
                      tx, ty, tz, rx, ry, rz :single;
                      t    : ttransform;
                      j,k    : integer;
                      load4dtransform : boolean;
                  begin
                    if not i.sectionexists(section) then
                    begin
                      section := \'alignment\';
                      if not i.sectionexists(section) then
                      begin
                        if avlstate\<=0 then showmessage(alignsection_error);
                        quirtviewerupdcoronal.text[2].value := #27 + #1 + chr(255) + #1 + text_noprevious;
                        exit;
                      end;
                    end;
                    if avlstate\<=0 then
                    begin
                      if (fixscanurl(i.readstring (section, \'scanurl\', \'\'))\<\> fixscanurl(scanurl)) or
                         (i.readstring (section, \'planurl\', \'\')\<\> planurl) or
                         (i.readstring (section, \'beamurl\', \'\')\<\> beamurl) then
                      begin
                        showmessage(reference_error);
                        loadbonematch.checked:=false;
                        loadtumormatch.checked := false;
                        exit;
                      end;
                    end;
                    comboboxtransformmode.itemindex := 0;
                    s := i.readstring(section, \'matchmethod\', \'\');
                    if (((pos(match_4d, s)\>0) or (pos(match_manualcc, s)\>0)) and (alignmentmode.value = 1))
                        or (strcomp(pchar(match_4dmask), pchar(s))=0) then
                    begin
                      s := i.readstring (section, \'transformphase0\', \'\');
                      if (s = \'\') and (pos(match_manualcc, comboboxmatch.text)\>0) then
                        load4dtransform := false
                      else if (s = \'\') and (pos(match_4d, comboboxmatch.text)\>0) and (bonetumormatchstatus\<\>10) then
                      begin
                        showmessage(error_4dmatchnotfound);
                        load4dtransform := false;
                      end
                      else
                      begin
                        s := i.readstring (section, \'transformphase\'+inttostr(onlinecube.dimensions[3]), \'\');
                        if (s \<\> \'\') then
                        begin
                          showmessage(error_4dmatchphases);
                          load4dtransform := false;
                        end
                        else
                          load4dtransform := true;
                      end;
                    end
                    else
                      load4dtransform := false;
                    if load4dtransform then
                    begin
                      for k := 0 to onlinecube.dimensions[3]-1 do
                      begin
                        s := i.readstring (section, \'transformphase\'+inttostr(k), \'\');
                        if s = \'\' then
                        begin
                          showmessage(error_4dmatchread);
                          transform4d.clear;
                          makeregistrationbackup(0, 9999, 0, 9999);
                          break;
                        end
                        else
                        begin
                          stringtotransform(s,machine_to_machineadjust);
                          externalmanualmatchto4d(k, nclipbox);
                        end;
                      end;
                      convertedtocorrections := false;
                      converted4dtomean := false;
                    end;
                    correctionapprovalby := i.readstring (section, \'correctionapprovalby\',    \'\');
                    tx := i.readfloat (section, \'translationlr\', 0);
                    ty := i.readfloat (section, \'translationcc\', 0);
                    tz := i.readfloat (section, \'translationap\', 0);
                    tx := i.readfloat (section, \'matchtranslationlr\', tx);
                    ty := i.readfloat (section, \'matchtranslationcc\', ty);
                    tz := i.readfloat (section, \'matchtranslationap\', tz);
                    tx := i.readfloat (section, \'alignmenttranslationlr\', tx);
                    ty := i.readfloat (section, \'alignmenttranslationcc\', ty);
                    tz := i.readfloat (section, \'alignmenttranslationap\', tz);
                    rx := -i.readfloat (section, \'rotationlr\', 0);
                    ry :=  i.readfloat (section, \'rotationcc\', 0);
                    rz := -i.readfloat (section, \'rotationap\', 0);
                    rx := -i.readfloat (section, \'matchrotationlr\', -rx);
                    ry := i.readfloat (section, \'matchrotationcc\', ry);
                    rz := -i.readfloat (section, \'matchrotationap\', -rz);
                    rx := -i.readfloat (section, \'alignmentrotationlr\', -rx);
                    ry := i.readfloat (section, \'alignmentrotationcc\', ry);
                    rz := -i.readfloat (section, \'alignmentrotationap\', -rz);
                    labelcomputedlat2.caption := i.readstring (section, \'couchshiftlat\', \'-\');
                    labelcomputedlong2.caption := i.readstring (section, \'couchshiftlong\', \'-\');
                    labelcomputedheight2.caption := i.readstring (section, \'couchshiftheight\', \'-\');
                    if safestrtofloat(labelcomputedlat2.caption)\>0    then labelcomputedlat2.hint    := hint_right else labelcomputedlat2.hint    := hint_left;
                    if safestrtofloat(labelcomputedlong2.caption)\>0   then labelcomputedlong2.hint   := hint_in    else labelcomputedlong2.hint   := hint_out;
                    if iec_linear_convention in [0, 1, 3] then
                      if safestrtofloat(labelcomputedheight2.caption)\<0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down
                    else
                      if safestrtofloat(labelcomputedheight2.caption)\>0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down;
                    labelcomputedpitch2.caption :=  i.readstring (\'alignment\', \'couchpitch\',  \'-\');
                    labelcomputedroll2.caption :=  i.readstring (\'alignment\', \'couchroll\',  \'-\');
                    labelcomputedyaw2.caption :=  i.readstring (\'alignment\', \'couchyaw\',  \'-\');
                    t := ttransform.create;
                    t.maketranslationafterrotation(tx,ty,tz,rx,ry,rz);
                    t.invert;
                    if assigned(f) then
                    begin
                      f.assign(t);
                      t.free;
                      exit;
                    end;
                    if onlinecube.ndim=3 then
                      for j:=2*nclipbox downto 0 do
                        packregistration(i, section, -1, j)
                    else
                    begin
                      for k:=-1 to max(onlinecube.dimensions[3]-1, -1) do
                        packregistration(i, section, k, 2*nclipbox);
                      for k:=-1 to max(onlinecube.dimensions[3]-1, -1) do
                        packregistration(i, section, k, nclipbox);
                      for k:=-1 to max(onlinecube.dimensions[3]-1, -1) do
                        packregistration(i, section, k, 0);
                    end;
                    edittranslationlr.imename := \'\';
                    edittranslationcc.imename := \'\';
                    edittranslationap.imename := \'\';
                    editrotationlr.imename := \'\';
                    editrotationcc.imename := \'\';
                    editrotationap.imename := \'\';
                    loadedalignmentdatachanged := false;
                    convertedtocorrections := false;
                    if loadacceptedmatch.checked then
                      converted4dtomean := true
                    else
                      converted4dtomean := false;
                    t.free;
                    s := i.readstring (section, \'alignmentapprovalby\', \'xxnonexx\');
                    if s=\'xxnonexx\' then
                      quirtviewerupdcoronal.text[2].value := #27 + #1 + chr(255) + #1 + text_noprevious
                    else
                    begin
                      if length(s) \> 40 then
                        quirtviewerupdcoronal.text[2].value := #27 + chr(255) + #1 + #1 + \'matched by: \' + copy(s, 1, 40) + \'...\'
                      else
                        quirtviewerupdcoronal.text[2].value := #27 + chr(255) + #1 + #1 + \'matched by: \' + s;
                    end;
                  end;",
// Sentence 211
                  "procedure tform1.loadcorrection(i: tinifiles; section : string; f: ttransform);
                  var t    : ttransform;
                      tx, ty, tz, rx, ry, rz : single;
                  begin
                    if not i.sectionexists(section) then
                      exit;
                    tx := safestrtofloat(i.readstring(section, \'correctiontranslationlr\', \'-999\'));
                    ty := safestrtofloat(i.readstring(section, \'correctiontranslationcc\', \'-999\'));
                    tz := safestrtofloat(i.readstring(section, \'correctiontranslationap\', \'-999\'));
                    rx := -safestrtofloat(i.readstring(section, \'correctionrotationlr\', \'-999\'));
                    ry := safestrtofloat(i.readstring(section, \'correctionrotationcc\', \'-999\'));
                    rz := -safestrtofloat(i.readstring(section, \'correctionrotationap\', \'-999\'));
                    t := ttransform.create;
                    t.maketranslationafterrotation(tx,ty,tz,rx,ry,rz);
                    t.invert;
                    if assigned(f) then
                      f.assign(t)
                    else
                      machine_to_machineadjust.assign(t);
                    t.free;
                  end;",
// Sentence 212
                  "procedure tform1.buttonread4dtransformclick(sender: tobject);
                  begin
                  end;",
// Sentence 213
                  "procedure tform1.buttonloadmatchmousedown(sender: tobject;
                    button: tmousebutton; shift: tshiftstate; x, y: integer);
                  begin
                  end;",
// Sentence 214
                  "procedure tform1.trackbartranslationlrkeydown(sender: tobject;
                    var key: word; shift: tshiftstate);
                  begin
                    if key=vk_up then edittranslationcc.text := floattostrf(safestrtofloat(edittranslationcc.text)+0.1, fffixed, 5, 2);
                    if key=vk_down then edittranslationcc.text := floattostrf(safestrtofloat(edittranslationcc.text)-0.1, fffixed, 5, 2);
                    if key=vk_up   then key := 0;
                    if key=vk_down then key := 0;
                  end;",
// Sentence 215
                  "procedure tform1.trackbartranslationcckeydown(sender: tobject;
                    var key: word; shift: tshiftstate);
                  begin
                    if key=vk_right  then edittranslationlr.text := floattostrf(safestrtofloat(edittranslationlr.text)+0.1, fffixed, 5, 2);
                    if key=vk_left   then edittranslationlr.text := floattostrf(safestrtofloat(edittranslationlr.text)-0.1, fffixed, 5, 2);
                    if key=vk_left  then key := 0;
                    if key=vk_right then key := 0;
                    if key=vk_up    then key := vk_right;
                    if key=vk_down  then key := vk_left;
                  end;",
// Sentence 216
                  "procedure tform1.detectmarkers1click(sender: tobject);
                  begin
                    markerdetectionsettingsdlg.show;
                  end;",
// Sentence 217
                  "procedure tform1.viewerhelp1click(sender: tobject);
                  begin
                    if quirtviewerupdsagittal.showhelp.value \<\> ord(viewerhelp1.checked) then exit;
                    if quirtviewerupdsagittal.showhelp.value=0 then
                    begin
                      quirtviewerupdtransversal.showhelp := nil;
                      quirtviewerupdcoronal.showhelp  := nil;
                    end;
                    quirtviewerupdsagittal.showhelp.value := 1-quirtviewerupdsagittal.showhelp.value;
                  end;",
// Sentence 218
                  "procedure tform1.print1click(sender: tobject);
                  var
                    formimage: tbitmap;
                    info: pbitmapinfo;
                    infosize: dword;
                    image: pointer;
                    imagesize: dword;
                    bits: hbitmap;
                    dibwidth, dibheight: longint;
                    printwidth, printheight: longint;
                  begin
                    printer.orientation := polandscape;
                    printer.begindoc;
                    try
                      formimage := getformimage;
                      formimage.canvas.font.size := -14;
                      formimage.canvas.pen.style := psclear;
                      formimage.canvas.rectangle(panelelektamode.left+6, panelelektamode.top+8, panelelektamode.left+6 + panelelektamode.width-4, panelelektamode.top+8 + panelelektamode.height - 4);
                      formimage.canvas.textout(panelelektamode.left + 14, panelelektamode.top + 20, caption);
                      canvas.lock;
                      try
                        bits := formimage.handle;
                        getdibsizes(bits, infosize, imagesize);
                        info := allocmem(infosize);
                        try
                          image := allocmem(imagesize);
                          try
                            getdib(bits, 0, info^, image^);
                            dibwidth := info^.bmiheader.biwidth;
                            dibheight := info^.bmiheader.biheight;
                            case printscale of
                              poproportional:
                                begin
                                  printwidth := muldiv(dibwidth, getdevicecaps(printer.handle,
                                    logpixelsx), pixelsperinch);
                                  printheight := muldiv(dibheight, getdevicecaps(printer.handle,
                                    logpixelsy), pixelsperinch);
                                end;
                              poprinttofit:
                                begin
                                  printwidth := muldiv(dibwidth, printer.pageheight, dibheight);
                                  if printwidth \< printer.pagewidth  then
                                    printheight := printer.pageheight
                                  else
                                  begin
                                    printwidth := printer.pagewidth;
                                    printheight := muldiv(dibheight, printer.pagewidth, dibwidth);
                                  end;
                                end;
                              else
                                printwidth := dibwidth;
                                printheight := dibheight;
                            end;
                            stretchdibits(printer.canvas.handle, 0, 0, printwidth, printheight, 0, 0,
                              dibwidth, dibheight, image, info^, dib_rgb_colors, srccopy);
                          finally
                            freemem(image, imagesize);
                          end;
                        finally
                          freemem(info, infosize);
                        end;
                      finally
                        canvas.unlock;
                        formimage.free;
                      end;
                    finally
                      printer.enddoc;
                    end;
                  end;",
// Sentence 219
                  "procedure tform1.saveas1click(sender: tobject);
                  var formimage: tbitmap;
                      s: tsavedialog;
                      avifps, i, j: integer;
                      pixmap: tavsfield;
                  begin
                    if timer4d.enabled then
                    begin
                      avihandle := -1;
                      s := tsavedialog.create(self);
                      s.filter := saveasfilter_movie;
                      s.options := [ofoverwriteprompt, ofnochangedir];
                      s.defaultext := \'avi\';
                      if s.execute then
                      begin
                        avifps := 1000 div timer4d.tag;
                        formimage := getformimage;
                        formimage.pixelformat := pf24bit;
                        pixmap := tavsfield.createas(\'field 2d 3-vector byte\', [formimage.width, formimage.height]);
                        for i := 0 to formimage.height - 1 do
                          move( formimage.scanline[i]^,
                                pbyte(cardinal(pixmap.data)+ cardinal(i * formimage.width * 3))^, formimage.width * 3);
                        avi_creat(pixmap, avihandle, s.filename, avifps, avicodec);
                        for j:=0 to max(onlinecube.dimensions[3]-1, 0) do
                        begin
                          quirtviewerupdcoronal.frame.value := j;
                          timer1timer(self);
                          formimage := getformimage;
                          formimage.pixelformat := pf24bit;
                          for i := 0 to formimage.height - 1 do
                            move( formimage.scanline[i]^,
                                  pbyte(cardinal(pixmap.data)+ cardinal(i * formimage.width * 3))^, formimage.width * 3);
                          avi_write(pixmap, avihandle);
                        end;
                        formimage.free;
                        pixmap.free;
                        avi_close(avihandle);
                        avihandle := -1;
                      end;
                    end
                    else
                      begin
                      avihandle := -1;
                      s := tsavedialog.create(self);
                      s.filter := saveasfilter_image;
                      s.options := [ofoverwriteprompt, ofnochangedir];
                      s.defaultext := \'tif\';
                      if s.execute then
                      begin
                        formimage := getformimage;
                        formimage.pixelformat := pf24bit;
                        formimage.canvas.font.size := -14;
                        formimage.canvas.pen.style := psclear;
                        formimage.canvas.rectangle(panelelektamode.left+6, panelelektamode.top+8, panelelektamode.left+6 + panelelektamode.width-4, panelelektamode.top+8 + panelelektamode.height - 4);
                        formimage.canvas.textout(panelelektamode.left + 14, panelelektamode.top + 20, caption);
                        pixmap := tavsfield.createas(\'field 2d 3-vector byte\', [formimage.width, formimage.height]);
                        for i := 0 to formimage.height - 1 do
                          move( formimage.scanline[i]^,
                            pchar(cardinal(pixmap.data)+ cardinal(i * formimage.width * 3))^, formimage.width * 3);
                        field_tiff(pixmap, s.filename);
                        formimage.free;
                        pixmap.free;
                      end;
                    end
                  end;",
// Sentence 220
                  "procedure tform1.checkboxadvancedoptionsclick(sender: tobject);
                  begin
                    paneladvancedoptions.visible := checkboxadvancedoptions.checked;
                  end;",
// Sentence 221
                  "procedure tform1.formkeydown(sender: tobject; var key: word;
                    shift: tshiftstate);
                  const
                    bshowinghints: boolean=false;
                  begin
                    if (key=vk_f3) and (shift=[]) then
                    begin
                      if comboboxdisplaymode.itemindex=2 then
                        comboboxdisplaymode.itemindex := 3
                      else
                        comboboxdisplaymode.itemindex := 2;
                    end;
                    if (key=vk_f2) and (shift=[]) then
                    begin
                      if comboboxdisplaymode.itemindex=0 then
                        comboboxdisplaymode.itemindex := 1
                      else
                        comboboxdisplaymode.itemindex := 0;
                    end;
                    if (key=vk_f4) and (shift=[]) then
                    begin
                      if myzoom\>2.501 * zoomfix then
                      begin
                        myzoom := 0.5 * zoomfix;
                        quirtviewerupdcoronalpanchanged(self, 0, 0);
                      end
                      else
                        buttonzoomclick(buttonzoom);
                    end;
                    if (key=vk_f5) and (shift=[]) then
                    begin
                      bitbtnpresetlevelwindowsclick(self);
                    end;
                    if (key=vk_f6) and (shift=[]) then
                    begin
                      buttongotoisocclick(self);
                    end;
                    if (key=vk_f7) and (shift=[]) then
                    begin
                      bitbtnback4dclick(self);
                    end;
                    if (key=vk_f8) and (shift=[]) then
                    begin
                      bitbtnfwd4dclick(self);
                    end;
                    if key=vk_space then
                    begin
                      comboboxdisplaymode.itemindex := 1;
                    end;
                    if enabletestmode then
                    begin
                      if (key=ord(\'h\')) and (shift=[ssshift, ssalt, ssctrl]) then
                      begin
                        key := 0;
                        if not bshowinghints then
                        begin
                          buildhintlist;
                          showallhints;
                          bshowinghints := true
                        end
                        else
                        begin
                          hideallhints;
                          form1.show;
                          destroyhintlist;
                          bshowinghints := false;
                        end;
                      end
                      else if (key=ord(\'t\')) and (shift=[ssshift, ssalt, ssctrl]) then
                      begin
                        key := 0;
                        testmode := not testmode;
                      end
                      else if (key=ord(\'3\')) and (shift=[ssshift, ssalt, ssctrl]) then
                        groworshrinklabels30pct
                      else if (key=ord(\'p\')) and (shift=[ssshift, ssalt, ssctrl]) then
                      begin
                        if not assigned(gformarray[0]) then
                        begin
                          if not timerpopup1.enabled then
                            showallpopupmenus;
                          timerpopup1.enabled := false;
                        end;
                        showallpopupmenusasforms;
                        key := 0;
                        end
                      else if (key=ord(\'u\')) and (shift=[ssshift, ssalt, ssctrl]) then
                      begin
                        showuniformity;
                        key := 0;
                      end
                    end
                    end;",
// Sentence 222
                  "procedure tform1.checkboxreversemotionclick(sender: tobject);
                  begin
                    reversemotion.value := ord(checkboxreversemotion.checked);
                  end;",
// Sentence 223
                  "procedure tform1.setregistrationparameters(sender: tobject);
                  begin
                  end;",
// Sentence 224
                  "procedure tform1.simplex1lowerfuncval(sender: tobject);
                  begin
                  end;",
// Sentence 225
                  "procedure tform1.buttonmatchclick(sender: tobject);
                  begin
                  end;",
// Sentence 226
                  "procedure dicom_fixpatientname(patientname: string; var device: string; var haspatient: boolean);
                  begin
                  end;",
// Sentence 227
                  "procedure tform1.treereader(data: tavsfield; url: string; parameter: string);
                  var i, j: integer;
                      t, device: string;
                      ok: boolean;
                  begin
                    i := pos(\':\', patienturl);
                    if i\>0 then t := copy(patienturl, i+1, 250) else t:=\'\';
                    j := pos(\':\', url);
                    if j\>0 then url := copy(url, j+1, 500) else url := \'\';
                    j := pos(\':\', url);
                    if j\>0 then url := copy(url, j+1, 500);
                    if      importdatatype=\'pinnacle\' then read_pinnacle(data, importdatapath + t, url, parameter, t)
                    else if importdatatype=\'dicom\'    then
                    begin
                    end
                    else showmessage(reader_error + datatype);
                  end;",
// Sentence 228
                  "function tform1.treeselector(patienturl: string; itemtype: string): string;
                  var f: tavsfield;
                      i, j, depth: integer;
                      selector: tform;
                      g: tlistbox;
                      s: tstringlist;
                      b1, b2: tbutton;
                      urls:    array[1..10] of string;
                      aliases: array[1..10] of string;
                      id, name, modality, full, alias: string;
                  begin
                    j := pos(\':\', patienturl);
                    f := tavsfield.create;
                    treereader(f, copy(patienturl, j+1, 250), \'\');
                    s := tstringlist.create;
                    selector := tform.create(self);
                    selector.position := podesigned;
                      selector.borderstyle := bssizetoolwin;
                    selector.formstyle   := fsstayontop;
                    selector.caption := select_caption + itemtype;
                    selector.onclose := closeselector;
                    selector.autoscroll := false;
                    selector.keypreview := true;
                    selector.left   := 0;
                    selector.top    := 0;
                    g := tlistbox.create(selector);
                    g.parent := selector;
                    g.top    := 4;
                    g.left  := 4;
                    g.width  := 400;
                    g.height := 400;
                    depth := 1;
                    for i:=0 to f.dimensions[1]-1 do
                    begin
                      id       := f.getstring([i, 0]);
                      name     := f.getstring([i, 1]);
                      modality := f.getstring([i, 2]);
                      alias    := name;
                      j := pos(\'depth=\', id); if j\>0 then depth := strtoint(copy(id, j+6, 1));
                      j := pos(\'alias=\', id); if j\>0 then alias := copy(id, j+6, 499);
                      j := pos(\'~\', id);      if j\>0 then alias := copy(alias, 1, j-1);
                      urls[depth] := name + \'.\' + modality;
                      aliases[depth] := alias;
                      full := \'\';
                      for j:=1 to depth do
                        if urls[j]\<\>\'\' then
                          full := full + urls[j] + \'\\\';
                       full := copy(full, 1, length(full)-1);
                      alias := \'\';
                      for j:=2 to depth do
                        if aliases[j]\<\>\'\' then
                          alias := alias + aliases[j] + \'; \';
                       alias := copy(alias, 1, length(alias)-2);
                      if (itemtype=\'\') or (itemtype=modality) then
                      begin
                        g.items.add(alias);
                        s.add(full);
                      end;
                    end;
                    if itemtype=\'structure\' then
                      g.multiselect := true;
                    selector.clientwidth  := g.width + 8;
                    selector.clientheight := g.height + 20 + 6 + 40;
                    g.anchors:= [aktop, akleft, akright, akbottom];
                    b1 := tbutton.create(selector);
                    b1.parent := selector;
                    b1.top    := g.height + 20 + 6;
                    b1.left  := g.width div 2 + 4 - 110;
                    b1.anchors:= [akleft, akbottom];
                    b1.cancel := true;
                    b1.caption := cancel_caption;
                    b1.onclick := cancelclicked;
                    b2 := tbutton.create(selector);
                    b2.parent := selector;
                    b2.top    := g.height + 20 + 6;
                    b2.left  := g.width div 2 + 4 + 60;
                    b2.anchors:= [akleft, akbottom];
                    b2.default := true;
                    b2.caption := ok_caption;
                    b2.onclick := okclicked;
                    g.ondblclick := okclicked;
                    if s.count = 1 then
                    begin
                      g.selected[0] := true;
                      selector.modalresult := mrok;
                    end
                    else
                      selector.showmodal;
                    result := \'\';
                    if (selector.modalresult = mrok) then
                    for i:=0 to g.items.count-1 do
                      if g.selected[i] then
                        if itemtype\<\>\'structure\' then
                          result := patienturl + \':\' + s[i]
                        else
                        begin
                          if result=\'\' then
                            result := patienturl + \':\' + s[i]
                          else
                          begin
                            j := pos(\'structset\',s[i]);
                            if j\>0 then
                            begin
                              name := copy(s[i],j+10,500);
                              result := result + \',\' + name;
                            end;
                          end;
                        end;
                    selector.destroy;
                    f.free;
                    s.free;
                  end;",
// Sentence 229
                  "function tform1.stationselector(inifilename: string; stationname: string = \'\'): string;
                  begin
                  end;",
// Sentence 230
                  "function tform1.sectionselector(inifile: tqinifile; sectionbase: string; mode: safesettingmode; selectorcaption :string ): string;
                  begin
                  end;",
// Sentence 231
                  "procedure tform1.cancelclicked(sender: tobject);
                  begin
                    (((sender as tbutton).parent) as tform).close;
                    (((sender as tbutton).parent) as tform).modalresult := mrcancel;
                  end;",
// Sentence 232
                  "procedure tform1.okclicked(sender: tobject);
                  begin
                    (((sender as twincontrol).parent) as tform).close;
                    (((sender as twincontrol).parent) as tform).modalresult := mrok;
                  end;",
// Sentence 233
                  "procedure tform1.closeselector(sender: tobject; var action: tcloseaction);
                  begin
                  end;",
// Sentence 234
                  "procedure tform1.buttonclinicalpatientclick(sender: tobject);
                  var t, device: string;
                      i: integer;
                      inifile: tqinifile;
                      ok: boolean;
                      selector: tform;
                      g       : tlistbox;
                      b1, b2: tbutton;
                      dicomlist: tavsfield;
                  begin
                    if not selectinputdatasource then exit;
                    i := pos(\':\', patienturl);
                    if i\>0 then t := copy(patienturl, 2, i-3) else t := \'xvi\';
                    inifile := tqinifile.create(getfullinifilename(\'datasources.ini\'));
                    datasource := inifile.readstring(t, \'device\', \'\');
                    inifile.free;
                    i := pos(\':\', datasource);
                    if i\>0 then
                    begin
                      importdatatype := uppercase(copy(datasource, 1, i-1));
                      importdatapath := copy(datasource, i+1, 250);
                      importdatapath := includetrailingpathdelimiter(importdatapath);
                    end;
                    dicomlist := nil;
                    if importdatatype=\'pinnacle\' then
                    begin
                      if not selectdirectory(select_dir_dlg, importdatapath, t) then exit;
                      t := copy(t, length(importdatapath)+1, 250);
                      patienturl := \'[xvi]:\' + t;
                      referencedatachanged := true;
                    end
                    else if importdatatype=\'dicom\' then
                    begin
                      t := inputbox(\'search for\', \'patient id or name\', \'\');
                      if t=\'\' then exit;
                      dicomlist := tavsfield.create;
                      end
                    else if importdatatype\<\>\'\' then
                    begin
                    end;
                    if assigned(dicomlist) then
                    begin
                      selector := tform.create(self);
                      selector.position := podesigned;
                      selector.borderstyle := bssizetoolwin;
                      selector.formstyle   := fsstayontop;
                      selector.caption := select_caption + \'patient\';
                      selector.onclose := closeselector;
                      selector.autoscroll := false;
                      selector.keypreview := true;
                      selector.left   := 0;
                      selector.top    := 0;
                      g := tlistbox.create(selector);
                      g.parent := selector;
                      g.top    := 4;
                      g.left  := 4;
                      g.width  := 400;
                      g.height := 400;
                      for i:=1 to dicomlist.dimensions[1]-1 do
                        g.items.add(dicomlist.getstring([i,0]) + \' \' + dicomlist.getstring([i,1]));
                      selector.clientwidth  := g.width + 8;
                      selector.clientheight := g.height + 20 + 6 + 40;
                      g.anchors:= [aktop, akleft, akright, akbottom];
                      b1 := tbutton.create(selector);
                      b1.parent := selector;
                      b1.top    := g.height + 20 + 6;
                      b1.left  := g.width div 2 + 4 - 110;
                      b1.anchors:= [akleft, akbottom];
                      b1.cancel := true;
                      b1.caption := cancel_caption;
                      b1.onclick := cancelclicked;
                      b2 := tbutton.create(selector);
                      b2.parent := selector;
                      b2.top    := g.height + 20 + 6;
                      b2.left  := g.width div 2 + 4 + 60;
                      b2.anchors:= [akleft, akbottom];
                      b2.default := true;
                      b2.caption := ok_caption;
                      b2.onclick := okclicked;
                      g.ondblclick := okclicked;
                      selector.showmodal;
                      if (selector.modalresult = mrok) then
                      for i:=0 to g.items.count-1 do
                        if g.selected[i] then
                          patienturl := \'[xvi]\' + \':\' + dicomlist.getstring([i+1,0]);
                      selector.destroy;
                      referencedatachanged := true;
                      dicomlist.free;
                    end;
                  end;",
// Sentence 235
                  "function tform1.selectinputdatasource: boolean;
                  begin
                    result := false;
                    if popupmenuselectdatasource.items.count \<= 1 then
                    begin
                      result := true;
                      exit;
                    end;
                    timer1.enabled := false;
                    popupmenuselectdatasource.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                    application.processmessages;
                    if popupmenuselectdatasource.tag \<\> 0 then
                      result := true;
                    popupmenuselectdatasource.tag := 0;
                  end;",
// Sentence 236
                  "procedure tform1.setinputdatasourceclick(sender: tobject);
                  var
                    u: string;
                    i: integer;
                    rtdatasourceinifile: trtdatasourceinifile;
                  begin
                      u := striphotkey((sender as tmenuitem).caption);
                      if u\<\>\'\' then
                      begin
                        i := pos(\':\', patienturl);
                        if i\>0 then
                        begin
                          patienturl := \'[\' + u + \']:\' + copy(patienturl, i+1, length(patienturl));
                          rtdatasourceinifile := trtdatasourceinifile.create();
                          importdatatype := rtdatasourceinifile.device(u);
                          rtdatasourceinifile.free;
                        end
                        else
                          patienturl := \'[\' + u + \']:\';
                      end
                      else exit;
                      popupmenuselectdatasource.tag := 1;
                  end;",
// Sentence 237
                  "procedure tform1.buttonsetscanclick(sender: tobject);
                  var save  : tcursor;
                      t     : string;
                      f, g  : single;
                      j     : integer;
                      uid   : string;
                      begin
                    j := 1;
                    if (getkeystate(vk_lshift) and $8000)\<\>0 then j:=2;
                    if assigned(sender) then
                    begin
                      if planurl=\'fake\' then planurl := \'\';
                      if (scanurl=\'\') and (planurl=\'\') then
                      begin
                        buttonclinicalpatientclick(nil);
                      end;
                      if patienturl=\'\' then exit;
                      if (datatype=\'pinnacle\') or (datatype=\'dicom\') then
                      begin
                        t := treeselector(patienturl, \'scan\');
                        if t=\'\' then exit;
                        scanurl := t;
                      end
                      else
                        exit;
                      referencedatachanged := true;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if                 reference[1].exists(cachefilebase, treatmentuid,  \'ref\')     then uid := treatmentuid;
                    if synergymode and reference[1].exists(cachefilebase, scanseriesuid, \'ref\')     then uid := scanseriesuid;
                    if synergymode and reference[1].exists(cachefilebase, plansopuid,    \'ref\')     then uid := plansopuid;
                    if sender=nil then
                    begin
                      reference[1].load(cachefilebase, uid, \'ref\');
                      if online[1].processing.value=411 then reference[1].processing.value := 411;
                      if reference[1].topatient.empty then
                      begin
                        reference_to_patient.assign(reference_to_siddon);
                        timer1.enabled := false;
                        showmessage(orientation_warn);
                        timer1.enabled := true;
                      end;
                      if reference[1].tosiddon.empty then
                        reference[1].clear
                      else
                      begin
                        end;
                      reference[2].load(cachefilebase, uid, \'ref2\');
                    end
                    else
                    begin
                      if (datatype\<\>\'pinnacle\') and (datatype\<\>\'dicom\') and (datatype\<\>\'\') and (avlstate\<0) then
                      begin
                      end
                      else if datatype\<\>\'\' then
                      begin
                        treereader(reference[j].data     , scanurl, \'\');
                        treereader(reference[j].topatient, scanurl, \'bostonscantosiddonpatient\');
                        treereader(reference[j].tosiddon , scanurl,
                          \'bostonscantosiddonworld\');
                        treereader(reference[j].properties,scanurl, \'all\');
                      end;
                    end;
                    if onlinecube.empty then
                    begin
                      field_create(onlinecube, \'field 3d 0-vector byte\', 256, 256, 256);
                      case defaultfov of
                        76:  modify_extents(onlinecube, onlinecube, 0.2,   0.2,   0.2);
                        77:  modify_extents(onlinecube, onlinecube, 0.156, 0.156, 0.156);
                        83:  modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                        else
                        begin
                          f := abs(onlinecube.coordinate[1, 0] - onlinecube.coordinate[1, onlinecube.dimensions[1]-1]);
                          g := abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]);
                          g := max(abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]), g);
                          g := max(abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]), g);
                          f := max(f, 1);
                          g := max(g, 1);
                          modify_extents(onlinecube, onlinecube, g/f, g/f, g/f);
                        end;
                      end;
                      myzoom := 1.5 * zoomfix;
                      quirtviewerupdcoronalpanchanged(self, 0, 0);
                      quirtviewerupdsagittal.level[1].value := 1000;
                      quirtviewerupdsagittal.window[1].value := 500;
                      quirtviewerupdtransversal.level[1].maximum     := 2000;
                      quirtviewerupdtransversal.level[1].minimum     := 0;
                      quirtviewerupdtransversal.window[1].maximum     := 1000;
                      quirtviewerupdtransversal.window[1].minimum     := 0;
                    end;
                    quirtviewerupdsagittal.level[2].value := 1000;
                    quirtviewerupdsagittal.window[2].value := 500;
                    quirtviewerupdtransversal.level[2].maximum     := 2000;
                    quirtviewerupdtransversal.level[2].minimum     := 0;
                    quirtviewerupdtransversal.window[2].maximum     := 1000;
                    quirtviewerupdtransversal.window[2].minimum     := 0;
                    if planurl=\'fake\' then
                    begin
                      reference_to_siddon. makerotation(270, 0, 270);
                      reference_to_patient.makerotation(270, 0, 270);
                    end;
                    if referenceoverlaystring\<\>\'\' then
                      quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + referenceoverlaystring
                    else
                    begin
                        quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + ref_overlay + scanurl;
                    end;
                    if not reference[2].data.empty then
                    begin
                      field_overlay_lut(reference[2].externallut, \'blackbluegreenyellowred\', 0, round(reference[2].data.maximum), -1, 100, 32);
                    end;
                    screen.cursor := save;
                  end;",
// Sentence 238
                  "procedure tform1.buttonsetplanclick(sender: tobject);
                  var save:   tcursor;
                      t:      string;
                      fdum:   tavsfield;
                      i, j:   integer;
                      uid:    string;
                  begin
                    if assigned(sender) then
                    begin
                      if (scanurl=\'\') and (planurl=\'\') then
                      begin
                        buttonclinicalpatientclick(nil);
                      end;
                      if patienturl=\'\' then exit;
                      if (datatype=\'pinnacle\') or (datatype=\'dicom\') then
                      begin
                        t := treeselector(patienturl, \'beam\');
                        if t=\'\' then exit;
                        beamurl := t;
                        planurl := \'\';
                      end
                      else
                        exit;
                      referencedatachanged := true;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if planurl=\'fake\' then
                    begin
                      field_create(beamdots, \'field 1d 3-space irregular\', 1);
                      beamindex.clear;
                      machine_to_siddon.makeidentity;
                    end
                    else
                    begin
                      if fileexists(cachefilebase + treatmentuid  + \'.beams\') then uid := treatmentuid;
                      if synergymode and fileexists(cachefilebase + scanseriesuid + \'.beams\') then uid := scanseriesuid;
                      if synergymode and fileexists(cachefilebase + plansopuid    + \'.beams\') then uid := plansopuid;
                      if fileexists(cachefilebase + uid + \'.beams\') and (sender=nil) then
                        vrml_read(beamdots, beamindex, beamlut, cachefilebase + uid + \'.beams\')
                      else
                      begin
                        if (datatype\<\>\'pinnacle\') and (datatype\<\>\'dicom\') and (datatype\<\>\'\') and (avlstate\<0) and (sender \<\> nil) then
                        begin
                        end
                        else
                        begin
                          field_create(beamdots, \'field 1d 3-space irregular\', 1);
                          beamindex.clear;
                        end;
                      end;
                      field_create(beamlut, \'field 1d 256-vector byte\', 256);
                      for i:=0 to 255 do
                      begin
                        beamlut.setvalue([i,0], 255);
                        beamlut.setvalue([i,1],   0);
                        beamlut.setvalue([i,2],   0);
                        beamlut.setvalue([i,3], 255);
                      end;
                      if (not beamdots.empty) or (datatype\<\>\'quirt\') then
                      begin
                        if assigned(sender) then
                        begin
                          if (datatype=\'pinnacle\') or (datatype=\'dicom\') then
                          begin
                            treereader(machine_to_siddon, beamurl, \'\');
                            treereader(machine_to_siddon, beamurl, \'bostonscantosiddonworld\');
                          end
                          else if datatype\<\>\'\' then
                          begin
                          end;
                          for i:=0 to 2 do
                            for j:=0 to 2 do
                              if i=j then machine_to_siddon.setvalue([i,j], 1)
                              else        machine_to_siddon.setvalue([i,j], 0);
                        end;
                        if not beamdots.empty then
                        begin
                          fdum := tavsfield.create;
                          transform_math(machine_to_siddon, nil, fdum, true);
                          dotxfm(beamdots, fdum, beamdots);
                          fdum.free;
                        end;
                      end;
                    end;
                    screen.cursor := save;
                  end;",
// Sentence 239
                  "procedure tform1.buttonsetroiclick(sender: tobject);
                  begin
                    checkboxroi.checked := true;
                    showmessage(roi_message);
                  end;",
// Sentence 240
                  "procedure tform1.buttonscanclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenuscan.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;",
// Sentence 241
                  "procedure tform1.showall1click(sender: tobject);
                  begin
                    if reference[1].data.empty then exit;
                    showall1.checked := not showall1.checked;
                    quirtviewerupdcoronal.grid.forceupdate;
                    quirtviewerupdtransversal.grid.forceupdate;
                    quirtviewerupdsagittal.grid.forceupdate;
                    quirtviewerupdcoronal.grid.make;
                    quirtviewerupdtransversal.grid.make;
                    quirtviewerupdsagittal.grid.make;
                    gotoisocenterclick(self);
                    myzoom := min((quirtviewerupdcoronal.width-2) / max(quirtviewerupdcoronal.grid.dimensions[1], 1),
                                  (quirtviewerupdcoronal.height-2) / max(quirtviewerupdcoronal.grid.dimensions[0], 1));
                    quirtviewerupdcoronalpanchanged(self, 0, 0);
                  end;",
// Sentence 242
                  "procedure tform1.buttonclipbmarkersclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenuclipboxmarkers.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;",
// Sentence 243
                  "procedure tform1.buttonclipboxclick(sender: tobject);
                  var
                    i : integer;
                  begin
                    menushowunlockpresentclipbox.visible := not clipbox[2].empty;
                    clipboxlockedstatus(true);
                    for i := 1 to popupmenuclipbox.items.count - 1 do
                    begin
                      if popupmenuclipbox.items.items[i].name = \'setclipboxweights\' then
                      begin
                        popupmenuclipbox.items.items[i].visible := false ;
                        popupmenuclipbox.items.items[i].enabled := false ;
                        break;
                      end;
                    end;
                    timer1.enabled := false;
                    popupmenuclipbox.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;",
// Sentence 244
                  "procedure tform1.clipboxlockedstatus(flag : boolean);
                  var c, i : integer;
                  begin
                    if flag then
                    begin
                      c := 0;
                      for i:= 1 to nclipbox do
                        if not clipbox[i].empty then inc(c);
                    end
                    else c := 2;
                    if (c \> 1) then
                    begin
                      menushowunlockpresentclipbox.enabled := true;
                      if menuclipboxlocked.checked then
                      begin
                        if striphotkey(menushowunlockpresentclipbox.caption) = menu_menushowall_caption then
                           menushowunlockpresentclipbox.caption := menu_menuunlockpresent_caption;
                        if striphotkey(menushowunlockpresentclipbox.caption) = menu_menushowpresent_caption then
                           menushowunlockpresentclipbox.caption := menu_menuunlockpresent_caption;
                      end
                      else
                      begin
                        if striphotkey(menushowunlockpresentclipbox.caption) = menu_menulockall_caption then
                           menushowunlockpresentclipbox.caption := menu_menushowpresent_caption;
                        if striphotkey(menushowunlockpresentclipbox.caption) = menu_menuunlockpresent_caption then
                           menushowunlockpresentclipbox.caption := menu_menushowpresent_caption;
                      end;
                    end
                    else
                    begin
                      menushowunlockpresentclipbox.enabled := false;
                      if menuclipboxlocked.checked then menushowunlockpresentclipbox.caption := menu_menuunlockpresent_caption
                      else menushowunlockpresentclipbox.caption := menu_menushowpresent_caption;
                    end;
                  end;",
// Sentence 245
                  "procedure tform1.checkboxroiclick(sender: tobject);
                  begin
                    if clipbox[1].empty then
                    begin
                      field_create(clipbox[1], \'field 1d float\', 6);
                      clipbox[1].setvalue([0],-10);
                      clipbox[1].setvalue([2], 10);
                      clipbox[1].setvalue([4],-10);
                      clipbox[1].setvalue([1], 10);
                      clipbox[1].setvalue([3],-10);
                      clipbox[1].setvalue([5], 10);
                      clipbox[1].blanking := true;
                    end;
                  end;",
// Sentence 246
                  "function tform1.getdelineationurl(db: string): string;
                  begin
                    result := \'\';
                  end;",
// Sentence 247
                  "procedure tform1.getdescriptiontext(sender: tfield; var text: string;
                    displaytext: boolean);
                  begin
                    text := sender.asstring;
                  end;",
// Sentence 248
                  "procedure tform1.buttonsetdelineationclick(sender: tobject);
                  var
                    save: tcursor;
                    s, t: string;
                    i, j, r, g, b: integer;
                    busedisplaystructure: boolean;
                    uid, filename, section:   string;
                    h       : tinifiles;
                    tempdots, tempdots2, tempindex: tavsfield;
                    allblack: boolean;
                    dots, index, lut: tavsfield;
                    checkedcount: integer;
                  begin
                    if assigned(sender) then
                    begin
                      if patienturl=\'\' then exit;
                      if (datatype=\'pinnacle\') or (datatype=\'dicom\') then
                      begin
                        t := treeselector(patienturl, \'structure\');
                        if t=\'\' then exit;
                        delineationurl := t;
                      end
                      else
                        exit;
                      referencedatachanged := true;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if fileexists(cachefilebase + treatmentuid  + \'.delineation\') then uid := treatmentuid;
                    if synergymode and fileexists(cachefilebase + scanseriesuid + \'.delineation\') then uid := scanseriesuid;
                    if synergymode and fileexists(cachefilebase + plansopuid    + \'.delineation\') then uid := plansopuid;
                    if fileexists(cachefilebase + uid + \'.delineation\') and (sender=nil) then
                    begin
                      vrml_read(delineationdots, delineationindex, delineationdotslut, cachefilebase + uid + \'.delineation\');
                      if fatlines1.checked then
                      for i := 0 to delineationdotslut.dimensions[0]-1 do
                        dil_set_width(delineationdotslut, delineationdotslut, i, 20);
                      if fileexists(cachefilebase + uid + \'.delineation.orientation\') and (sender=nil) then
                      begin
                        read_xdr(delineationtransform, cachefilebase + uid + \'.delineation.orientation\');
                        transform_math(delineationtransform, machine_to_siddon, delineationtransform, false, true);
                      end
                      else
                        transform_math(reference_to_siddon, machine_to_siddon, delineationtransform, false, true);
                    end
                    else
                    begin
                      if (datatype\<\>\'pinnacle\') and (datatype\<\>\'dicom\') and (datatype\<\>\'\') and (avlstate\<0) then
                      begin
                      end
                      else if datatype\<\>\'\' then
                      begin
                        j := pos(\',\',delineationurl);
                        if j\> 0 then
                        begin
                          t := copy(delineationurl,j+1,500);
                          delineationurl := copy(delineationurl,0,j-1)
                        end;
                        tempdots := tavsfield.create;
                        treereader(delineationdots, delineationurl, \'\');
                        dots_to_line(delineationdots, delineationindex,false,2);
                        cnt_clean(delineationdots, delineationindex,delineationdots, delineationindex);
                        cnt_cicade(delineationdots, delineationindex, tempdots);
                        surf2_contours(tempdots,delineationdots, delineationindex);
                        field_to_byte(delineationdots,delineationdots);
                        tempdots.free;
                        treereader(delineationtransform, delineationurl, \'bostonscantosiddonworld\');
                        transform_math(delineationtransform, machine_to_siddon, delineationtransform, false, true);
                        field_create(delineationdotslut, \'field 1d 256-vector byte\', 256);
                        for i:=0 to 255 do
                        begin
                          delineationdotslut.setvalue([i, 0], 255);
                          delineationdotslut.setvalue([i, 1], 255);
                          delineationdotslut.setvalue([i, 2], 0);
                          delineationdotslut.setvalue([i, 3], 0);
                          delineationdotslut.setvalue([i, 4], 10);
                          delineationdotslut.setvalue([i, 5], 5);
                        end;
                        dil_set_name(delineationdotslut,delineationdotslut,0,memo_typeunknown);
                        if j\>0 then
                        begin
                          tempdots := tavsfield.create;
                          tempdots2 := tavsfield.create;
                          tempindex := tavsfield.create;
                          j := pos(\'structset\',delineationurl);
                          s := copy(delineationurl,0,j+9);
                          i := 1;
                          repeat
                            j := pos(\',\',t);
                            if j\>0 then
                            begin
                              delineationurl := s + copy(t,0,j-1);
                              t := copy(t,j+1,500);
                            end
                            else
                            begin
                              delineationurl := s+t;
                              t := \'\';
                            end;
                            treereader(tempdots, delineationurl, \'\');
                            dots_to_line(tempdots, tempindex,false,2);
                            cnt_clean(tempdots, tempindex,tempdots, tempindex);
                            cnt_cicade(tempdots, tempindex, tempdots2);
                            surf2_contours(tempdots2,tempdots, tempindex);
                            field_to_byte(tempdots,tempdots);
                            dil_add(delineationdots,delineationindex,delineationdotslut,tempdots,tempindex,delineationdotslut,delineationdots,delineationindex,delineationdotslut);
                            dil_set_name(delineationdotslut,delineationdotslut,i,memo_typeunknown+inttostr(i));
                            delineationdotslut.setvalue([i, 1], 255);
                            delineationdotslut.setvalue([i, 2], 0);
                            delineationdotslut.setvalue([i, 3], 0);
                            delineationdotslut.setvalue([i, i mod 3 + 1], 255);
                            i := i +1;
                          until t=\'\';
                          tempdots.free;
                          tempdots2.free;
                          tempindex.free;
                        end;
                      end;
                    end;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    if avlstate\>0 then filename := paramstr2
                    else               filename := adminfilebase + uid + \'.xvi\';
                    if (avlstate=3) and (sectiontoload\<\>\'none\') then
                      h := tinifiles.create([filename, filename + \'.xvi\'])
                    else
                      h := tinifiles.create([filename + \'.xvi\', filename]);
                    if (strcomp(pchar(filename),pchar(paramstr2))=0) then
                      section  := \'reference\'
                    else
                      section  := \'xvi\';
                    s := \'\';
                    busedisplaystructure := false;
                    if fileexists(cachefilebase + uid + \'.delineation\') and (sender=nil) then
                      s := h.readstring(section, \'displaystructure\'+inttostr(1), \'\');
                    if s\<\>\'\' then
                    begin
                      busedisplaystructure := true;
                      for i:=0 to delineationdotslut.dimensions[0]-1 do
                        delineationdotslut.setvalue([i, 27], 1);
                    end;
                    popupmenustructures.items.clear;
                    createmask1.clear;
                    refpointatcenterofdelineation.clear;
                    dots := tavsfield.create;
                    index := tavsfield.create;
                    lut := tavsfield.create;
                    if not delineationdots.empty then
                    begin
                      allblack := true;
                      checkedcount := 0;
                      for i:=0 to delineationdotslut.dimensions[0]-1 do
                      begin
                        dil_get_name(delineationdotslut, t, i);
                        if t\<\>\'\' then
                        begin
                          dil_get_color(delineationdotslut, j, r, g, b, i);
                          if (r+g+b)\>10 then allblack := false;
                          popupmenustructures.items.add(tmenuitem.create(self));
                          popupmenustructures.items.items[popupmenustructures.items.count-1].caption := t;
                          popupmenustructures.items.items[popupmenustructures.items.count-1].onclick := menustructuresclick;
                          if ((popupmenustructures.items.count - 1 = delineationdotslut.dimensions[0] div 2) and
                              (delineationdotslut.dimensions[0] \> 14)) then popupmenustructures.items.items[popupmenustructures.items.count-1].break := mbbarbreak;
                          dil_select(delineationdots, delineationindex, delineationdotslut,
                            dots, index, lut, i);
                          popupmenustructures.items.items[popupmenustructures.items.count-1].enabled := dots.dimensions[0]\>2;
                          createmask1.add(tmenuitem.create(self));
                          createmask1.items[createmask1.count-1].caption := t;
                          createmask1.items[createmask1.count-1].onclick := buttonsetreferencemaskclick;
                          createmask1.items[createmask1.count-1].tag := 1;
                          createmask1.items[createmask1.count-1].enabled  := dots.dimensions[0]\>2;
                          j := pos(t, maskdelineation);
                          if j\>1 then if not (ansichar(maskdelineation[j-1]) in [\'[\', \'|\']) then j:=0;
                          if j\>0 then
                          begin
                            r := j + length(t);
                            if r\<length(maskdelineation) then if maskdelineation[r]\<\>\'|\' then j:=0;
                          end;
                          if j\>0 then createmask1.items[createmask1.count-1].checked := true;
                          refpointatcenterofdelineation.add(tmenuitem.create(self));
                          refpointatcenterofdelineation.items[popupmenustructures.items.count-1].caption := t;
                          refpointatcenterofdelineation.items[popupmenustructures.items.count-1].onclick := menustructurechoiceclick;
                          if ((refpointatcenterofdelineation.count - 1 = delineationdotslut.dimensions[0] div 2) and
                              (delineationdotslut.dimensions[0] \> 14)) then refpointatcenterofdelineation.items[refpointatcenterofdelineation.count-1].break := mbbarbreak;
                          refpointatcenterofdelineation.items[popupmenustructures.items.count-1].enabled := dots.dimensions[0]\>2;
                          if busedisplaystructure then
                          begin
                            j := 1;
                            repeat
                              s := h.readstring(section, \'displaystructure\'+inttostr(j), \'\');
                              j := j + 1;
                              if s=t then
                              begin
                                inc(checkedcount);
                                delineationdotslut.setvalue([i, 27], 0);
                                break;
                              end;
                            until s = \'\';
                          end;
                          popupmenustructures.items.items[popupmenustructures.items.count-1].checked :=
                            not boolean(round(delineationdotslut.getvalue([i, 27])))
                        end;
                      end;
                      if popupmenustructures.items.count\>0 then
                      begin
                        popupmenustructures.items.add(tmenuitem.create(self));
                        popupmenustructures.items.items[popupmenustructures.items.count-1].caption := \'-\';
                        popupmenustructures.items.items[popupmenustructures.items.count-1].onclick := nil;
                        popupmenustructures.items.add(tmenuitem.create(self));
                        popupmenustructures.items.items[popupmenustructures.items.count-1].tag := -1;
                        if checkedcount\>0 then
                          popupmenustructures.items.items[popupmenustructures.items.count-1].caption := popupmenu_structures_all_off
                        else
                          popupmenustructures.items.items[popupmenustructures.items.count-1].caption := popupmenu_structures_all_on;
                        popupmenustructures.items.items[popupmenustructures.items.count-1].onclick := menustructuresclick;
                      end;
                      activesettingstolistview(h, false);
                      h.free;
                      if allblack then
                        for i:=0 to delineationdotslut.dimensions[0]-1 do
                          dil_set_color(delineationdotslut, delineationdotslut, i, 255, 255, 0, 0);
                    end;
                    dots.free;
                    index.free;
                    lut.free;
                    if not delineationdots.empty then
                    begin
                      createmask1.add(tmenuitem.create(self));
                      createmask1.items[createmask1.count-1].caption := \'-\';
                      createmask1.add(tmenuitem.create(self));
                      createmask1.items[createmask1.count-1].caption := menu_mask_allvisible;
                      createmask1.items[createmask1.count-1].onclick := buttonsetreferencemaskclick;
                      createmask1.items[createmask1.count-1].tag := 0;
                    end;
                    createmask1.add(tmenuitem.create(self));
                    createmask1.items[createmask1.count-1].caption := menu_mask_empty;
                    createmask1.items[createmask1.count-1].onclick := buttonsetreferencemaskclick;
                    createmask1.items[createmask1.count-1].tag := 2;
                    createmask1.add(tmenuitem.create(self));
                    createmask1.items[createmask1.count-1].caption := \'-\';
                    createmask1.add(tmenuitem.create(self));
                    createmask1.items[createmask1.count-1].caption := margin_menu + format(\'%0.2f cm\', [maskmargin]);
                    createmask1.items[createmask1.count-1].enabled := false;
                    createmask1.add(tmenuitem.create(self));
                    if maskedited then createmask1.items[createmask1.count-1].caption := edited_menu
                    else               createmask1.items[createmask1.count-1].caption := not_edited_menu;
                    createmask1.items[createmask1.count-1].enabled := false;
                    createmask1.add(tmenuitem.create(self));
                    createmask1.items[createmask1.count-1].caption := signature_menu + referenceapprovalby;
                    createmask1.items[createmask1.count-1].enabled := false;
                    screen.cursor := save;
                  end;",
// Sentence 249
                  "procedure tform1.buttonstructuresclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenustructures.popup(buttonstructures.clientorigin.x + buttonstructures.width div 2,buttonstructures.clientorigin.y  + buttonstructures.height div 2);
                    timer1.enabled := true;
                  end;",
// Sentence 250
                  "procedure tform1.menuclipboxlockedclick(sender: tobject);
                  var clipboxes, i :integer;
                  begin
                    clipboxes := 0;
                    for i:=1 to nclipbox do
                      if not clipbox[i].empty then inc(clipboxes) else break;
                    if clipboxes \> 1 then
                    begin
                      i := 1;
                      if activeregion.value+1 = i then
                        for i := 2 to clipboxes do
                          if not clipbox[i].empty then break;
                      clipbox[i].locked := not clipbox[i].locked;
                      menuclipboxlocked.checked := clipbox[i].locked;
                      clipboxlockedstatus(false);
                    end
                    else
                    begin
                      clipbox[1].locked := not clipbox[1].locked;
                      menuclipboxlocked.checked := clipbox[1].locked;
                    end;
                  end;",
// Sentence 251
                  "procedure tform1.menushowunlockpresentclipboxclick(sender: tobject);
                  begin
                    if menuclipboxlocked.checked then
                    begin
                      if striphotkey((sender as tmenuitem).caption) = menu_menuunlockpresent_caption then
                        (sender as tmenuitem).caption := menu_menulockall_caption
                      else (sender as tmenuitem).caption := menu_menuunlockpresent_caption
                    end
                    else
                    begin
                      if striphotkey((sender as tmenuitem).caption) = menu_menushowpresent_caption then
                        (sender as tmenuitem).caption := menu_menushowall_caption
                      else (sender as tmenuitem).caption := menu_menushowpresent_caption;
                    end;
                  end;",
// Sentence 252
                  "procedure tform1.menustructuresclick(sender: tobject);
                  var i, j: integer;
                      t, c: string;
                      allonoroff: boolean;
                      menuitem: tmenuitem;
                  begin
                    menuitem := (sender as tmenuitem);
                    c := striphotkey(menuitem.caption);
                    if abs(menuitem.tag) = 1 then
                      allonoroff := true
                    else
                    begin
                      allonoroff := false;
                      menuitem.checked := not menuitem.checked;
                    end;
                    if allonoroff then
                    begin
                      for j:=0 to popupmenustructures.items.count-1 do
                      begin
                        c := striphotkey(popupmenustructures.items[j].caption);
                        for i:=0 to delineationdotslut.dimensions[0]-1 do
                        begin
                          dil_get_name(delineationdotslut, t, i);
                          if t = c then
                          begin
                              delineationdotslut.setvalue([i, 27], ord(menuitem.tag\<\>1));
                              popupmenustructures.items.items[j].checked := menuitem.tag=1;
                              break;
                          end;
                        end;
                      end;
                      if menuitem.tag=1 then
                        menuitem.caption := popupmenu_structures_all_off
                      else
                        menuitem.caption := popupmenu_structures_all_on;
                      menuitem.tag := -menuitem.tag;
                    end
                    else
                    begin
                      for i:=0 to delineationdotslut.dimensions[0]-1 do
                      begin
                        dil_get_name(delineationdotslut, t, i);
                        if t = c then
                          delineationdotslut.setvalue([i, 27], ord(not menuitem.checked));
                      end;
                    end;
                    quirtviewerupdsagittal.make;
                    quirtviewerupdcoronal.make;
                    quirtviewerupdtransversal.make;
                    timer1.enabled := false;
                    popupmenustructures.popup(buttonstructures.clientorigin.x + buttonstructures.width div 2,buttonstructures.clientorigin.y  + buttonstructures.height div 2);
                    timer1.enabled := true;
                  end;",
// Sentence 253
                  "procedure tform1.expandcontours(sender: tobject);
                  begin
                  end;",
// Sentence 254
                  "procedure tform1.buttonsetdoseclick(sender: tobject);
                  var save:   tcursor;
                      t, uid, url: string;
                      i, j: integer;
                      machinetosiddon: tavsfield;
                  begin
                    if assigned(sender) then
                    begin
                      dosecube.clear;
                      url := patienturl;
                      if (scanurl=\'\') and (planurl=\'\') then
                      begin
                        t := patienturl;
                        buttonclinicalpatientclick(nil);
                        url := patienturl;
                        if patienturl=\'\' then exit;
                      end;
                      if (importdatatype=\'dicom\') then
                      begin
                        save := screen.cursor;
                        screen.cursor := crhourglass;
                        doseurl := \'\';
                        try
                          try
                        m := trtdatasourcemodality.create(studyurl);
                        urlset := m.selectbyname(\'dose\');
                        for i := 0 to urlset.nodecount-1 do
                        begin
                          m2 := trtdatasourcemodality.create(urlset.node[i].fullurl);
                          try
                            if (extractfilename(planurl)=m2.propertyvalue[\'referencedsopinstanceuid\']+\'.plan\') and
                                   (uppercase(m2.propertyvalue[\'dosesummationtype\'])\<\>\'beam\') and
                                   (uppercase(m2.propertyvalue[\'dosetype\'])=\'physical\') then
                            begin
                              doseurl := urlset.node[i].fullurl;
                              break;
                            end;
                          finally
                            m2.free;
                          end;
                        end;
                          except
                            doseurl := \'\';
                          end;
                        finally
                        freeandnil(urlset);
                        m.free;
                        end;
                        if (doseurl = \'\') then
                        begin
                          nfractions := 0;
                          screen.cursor := save;
                          showmessage(\'no valid dose file found\');
                          exit;
                      end
                        else
                        begin
                          m := trtdatasourcemodality.create(planurl);
                          nfractions := round(safestrtofloat(m.propertyvalue[\'numberoffractionsplanned\'], 0));
                          screen.cursor := save;
                        end;
                      end
                      else if (importdatatype=\'pinnacle\')  then
                      begin
                        t := treeselector(url, \'dose\');
                        if (t=\'\') or (t=url) then exit;
                        doseurl := t;
                      end
                      else
                        exit;
                      referencedatachanged := true;
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if onlinecube.empty then
                    begin
                      field_create(onlinecube, \'field 3d 1-vector byte\', 256, 256, 256);
                      case defaultfov of
                        76:  modify_extents(onlinecube, onlinecube, 0.2,   0.2,   0.2);
                        77:  modify_extents(onlinecube, onlinecube, 0.156, 0.156, 0.156);
                        83:  modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                        else modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                      end;
                      myzoom := 1.5 * zoomfix;
                      quirtviewerupdcoronalpanchanged(self, 0, 0);
                      quirtviewerupdsagittal.level[1].value := 1000;
                      quirtviewerupdsagittal.window[1].value := 500;
                      quirtviewerupdtransversal.level[1].maximum     := 2000;
                      quirtviewerupdtransversal.level[1].minimum     := 0;
                      quirtviewerupdtransversal.window[1].maximum     := 1000;
                      quirtviewerupdtransversal.window[1].minimum     := 0;
                    end;
                    if                 dose[1].exists(cachefilebase, treatmentuid,  \'dose\') then uid := treatmentuid;
                    if synergymode and dose[1].exists(cachefilebase, scanseriesuid, \'dose\') then uid := scanseriesuid;
                    if synergymode and dose[1].exists(cachefilebase, plansopuid,    \'dose\') then uid := plansopuid;
                    if sender=nil then
                    begin
                      dose[1].load(cachefilebase, uid, \'dose\');
                      if dose[1].tosiddon.empty then dose[1].clear;
                    end
                    else
                    begin
                      if (importdatatype\<\>\'pinnacle\') and (importdatatype\<\>\'dicom\') and (importdatatype\<\>\'\') and (avlstate\<0) then
                      begin
                      end
                      else if importdatatype\<\>\'\' then
                      begin
                        treereader(dosecube       , doseurl, \'\');
                        treereader(dose_to_siddon,  doseurl, \'worldxfm\');
                        if (scanurl=\'\') and (planurl=\'\') then
                        begin
                          doseurl := treeselector(patienturl, \'beam\');
                          if doseurl\<\>\'\' then
                          begin
                          machinetosiddon := tavsfield.create;
                            treereader(machinetosiddon, doseurl, \'\');
                          treereader(machinetosiddon, doseurl, \'worldxfm\');
                          for i:=0 to 2 do
                            for j:=0 to 2 do
                              if i=j then machinetosiddon.setvalue([i,j], 1)
                              else        machinetosiddon.setvalue([i,j], 0);
                          transform_math(dose_to_siddon, machinetosiddon, dose_to_machine, false, true);
                          transform_math(dose_to_machine, machine_to_siddon, dose_to_siddon, false, false);
                          field_overlay_lut(doselut, \'blackbluegreenyellowred\', 0, round(dosecube.maximum), -1, 100, 32);
                          checkboxdose.checked := true;
                          showmessage(message_experimentaldoseimprt);
                          machinetosiddon.free;
                        end;
                      end;
                    end;
                    end;
                    if not dosecube.empty then
                    begin
                      field_overlay_lut(doselut, \'blackbluegreenyellowred\', 0, round(dosecube.maximum), -1, 100, 32);
                      checkboxdose.checked := true;
                    end;
                    screen.cursor := save;
                  end;",
// Sentence 255
                  "procedure tform1.isodoselines1click(sender: tobject);
                  begin
                  end;",
// Sentence 256
                  "procedure tform1.vizisodoselines(sender: tobject);
                  begin
                  end;",
// Sentence 257
                  "procedure tform1.vizstructures;
                  begin
                  end;",
// Sentence 258
                  "procedure tform1.showisodoselines1click(sender: tobject);
                  begin
                  end;",
// Sentence 259
                  "procedure tform1.isodoselinesclear(sender: tobject);
                  var
                    i : integer;
                  begin
                  end;",
// Sentence 260
                  "procedure tform1.buttondoseaccumulateclick(sender: tobject);
                  var w, s, t: tavsfield;
                      x: ttransform;
                      count, total: integer;
                  begin
                    if not doseaccu.empty then
                      if messagedlg(\'reset previous accumulated dose?\', mtconfirmation, [mbyes, mbno], 0) = mryes then
                        doseaccu.clear;
                    w := tavsfield.create;
                    s := tavsfield.create;
                    t := tavsfield.create;
                    x := ttransform.create;
                    total := 1;
                    if not transform4d.empty then total := transform4d.dimensions[3];
                    for count:=0 to total-1 do
                    begin
                      x.assign(dose_to_machine);
                      if not transform4d.empty then
                      begin
                        field_slice(transform4d, t, -1, -1, nclipbox*2, 0);
                        if t.getvalue([3,3])\>0.99 then
                          transform_math(x, t, x, false, true);
                        if (comboboxcorrectionprotocol.text = correction_from_clipbox) then
                          field_slice(transform4d, t, -1, -1, 0, count)
                        else
                          field_slice(transform4d, t, -1, -1, nclipbox, count);
                        if t.getvalue([3,3])\<0.99 then continue;
                        transform_math(x, t, x);
                      end;
                    if doseaccu.empty then
                        fieldxfm(dosecube, x, onlinecube, doseaccu, 0, 0, fieldxfm_3dfield)
                      else
                      begin
                        fieldxfm(dosecube, x, onlinecube, t, 0, 0, fieldxfm_3dfield);
                        field_add(doseaccu, t, doseaccu);
                      end;
                    end;
                    field_overlay_lut(doseacculut, \'blackbluegreenyellowred\', 0, round(doseaccu.maximum), -1, 100, 32);
                    t.free;
                    w.free;
                    s.free;
                    x.free;
                  end;",
// Sentence 261
                  "procedure tform1.buttondoseclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenudose.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;",
// Sentence 262
                  "procedure tform1.clearmaskclick(sender: tobject);
                  var i: integer;
                  begin
                    if messagedlg(message_deletemask, mtconfirmation, [mbyes, mbno], 0) \<\> mryes then exit;
                    makeregistrationbackup(nclipbox, 2*nclipbox-1, 0, 9999);
                    invalidatecorrection;
                    maskedreference.clear;
                    referencemask.clear;
                    editmask.checked := false;
                    masklocked.checked := true;
                    maskid := \'\';
                    maskedited := false;
                    maskmargin := 0.0;
                    for i:=0 to createmask1.count-1 do
                      createmask1.items[i].checked := false;
                    createmask1.items[createmask1.count-3].caption := margin_menu + format(\'%0.2f cm\', [maskmargin]);
                    if maskedited then createmask1.items[createmask1.count-2].caption := edited_menu
                    else               createmask1.items[createmask1.count-2].caption := not_edited_menu;
                    createmask1.items[createmask1.count-1].caption := signature_menu + referenceapprovalby;
                  end;",
// Sentence 263
                  "procedure tform1.buttonsetreferencemaskclick(sender: tobject);
                  begin
                  end;",
// Sentence 264
                  "procedure tform1.buttonmaskclick(sender: tobject);
                  begin
                  end;",
// Sentence 265
                  "procedure tform1.editmaskclick(sender: tobject);
                  begin
                  end;",
// Sentence 266
                  "procedure tform1.updatechamferdotsreference(sender: tobject; var unchanged: boolean);
                  var dum1, dum2, dum3: tavsfield;
                      dumval, v2, m: integer;
                  begin
                    if not editmask.checked then
                    begin
                      chamferdotsreference.blanking := true;
                      exit;
                    end;
                    if (pos(match_substring_seed, comboboxmaskmatch.text)\>0) then
                    begin
                      dum1 := tavsfield.create;
                      dum2 := tavsfield.create;
                      dum3 := tavsfield.create;
                      field_findcropbox(referencemask,     dum2);
                      field_cropwithbox(reference[1].data, dum2, dum1);
                      field_cropwithbox(referencemask,     dum2, dum3);
                      field_mask(dum1, dum3, dum1);
                      m := (round(dum1.maximum));
                      field_mrthreshold(dum1, dum2, dumval, v2, dum3, -1, 11, 1, 0.2, 100, 100, false, false);
                      v2 := v2 + (m - v2) div 8;
                      createdotlist    (dum1, chamferdotsreference, v2, false, 1);
                      visboneseg(false);
                      dum1.free;
                      dum2.free;
                      dum3.free;
                    end;
                  end;",
// Sentence 267
                  "procedure tform1.readwritemask(sender: tobject);
                  begin
                  end;",
// Sentence 268
                  "procedure tform1.changebrushsize(sender: tobject);
                  var k, t: integer;
                      scale : single;
                  begin
                    t := 5;
                    if assigned(sender) then
                    begin
                      for k := 0 to paintbrushsize.count-1 do
                        paintbrushsize.items[k].checked := false;
                      (sender as tmenuitem).checked := true;
                      t := (sender as tmenuitem).tag;
                    end
                    else
                    begin
                      for k := 0 to paintbrushsize.count-1 do
                        if paintbrushsize.items[k].checked = true then
                        begin
                          t := paintbrushsize.items[k].tag;
                          break;
                        end;
                    end;
                    scale := 0.1;
                    quirtviewerupdcoronal.paintbrushsize.value        := scale * t;
                    quirtviewerupdsagittal.paintbrushsize.value       := scale * t;
                    quirtviewerupdtransversal.paintbrushsize.value    := scale * t;
                  end;",
// Sentence 269
                  "procedure tform1.strippedsavereference;
                  begin
                  end;",
// Sentence 270
                  "procedure tform1.buttonsavereferenceclick(sender: tobject);
                  var filename, initials: string;
                      i: tqinifile;
                      save: tcursor;
                      flag: boolean;
                  begin
                    if synergymode then filename := adminfilebase + plansopuid   + \'.xvi\'
                    else                filename := adminfilebase + treatmentuid + \'.xvi\';
                      if fileexists(filename) then
                      begin
                        i := tqinifile.create(filename);
                        flag := i.sectionexists(\'xvi\');
                        i.free;
                        if flag then
                          if messagedlg(replace_ref, mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                            exit;
                      end;
                    if synergymode then
                      validaterefform.dicom(true)
                    else
                      validaterefform.dicom(importdatatype = \'dicom\');
                    validaterefidentnum := planurl;
                      if validaterefform.showmodal\<\>mrok then exit;
                    if (referencecube.empty or beamdots.empty) and not (validaterefform.editdataset.text=\'ignorechecks\') then
                    begin
                      showmessage(error_nkiincompletepreset);
                      exit;
                    end;
                    initials := validaterefform.editinitials.text;
                    referencedatachanged := false;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    i := tqinifile.create(filename);
                    savesettings(i,avlref,initials, true);
                    savereferencedata(avlref);
                    i.updatefile;
                    i.free;
                    screen.cursor := save;
                    buttonloadreference.enabled := true;
                    togglebuttonloadreference() ;
                  end;",
// Sentence 271
                  "procedure tform1.savereferencedata(mode : safesettingmode);
                  var uid: string;
                      a, x: tavsfield;
                      eq : integer;
                  begin
                    if synergymode then uid := plansopuid
                    else                uid := treatmentuid;
                    if mode in [elektaref, avlref] then
                    begin
                      sysutils.forcedirectories(extractfilepath(cachefilebase));
                      dose[1].save(cachefilebase, uid, \'dose\');
                      if editmask.checked then
                        editmaskclick(self);
                      if not referencemask.empty then
                      begin
                        a := tavsfield.create;
                        field_to_short(referencemask, a);
                        write_xdr(a, cachefilebase + uid + \'.mask\',         \'\', \'\', 2);
                        write_xdr(reference_to_siddon, cachefilebase + uid + \'.mask.orientation\');
                        if maskid\<\>\'\' then
                        begin
                          write_xdr(a, cachefilebase + uid + \'.mask.\'+maskid, \'\', \'\', 2);
                          write_xdr(reference_to_siddon, cachefilebase + uid + \'.mask.orientation.\'+maskid, \'\', \'\', 2);
                        end;
                        a.free;
                      end
                      else
                      begin
                        if fileexists(cachefilebase + uid + \'.mask\') then
                          deletefile(cachefilebase + uid + \'.mask\');
                        if fileexists(cachefilebase + uid + \'.mask.orientation\') then
                          deletefile(cachefilebase + uid + \'.mask.orientation\');
                      end;
                    end;
                    if mode in [elektaalign,elektareconalign] then
                    begin
                      if editmask.checked then
                        editmaskclick(self);
                      if not referencemask.empty and fileexists(cachefilebase + uid + \'.mask\') then
                      begin
                        a := tavsfield.create;
                        x := tavsfield.create;
                        read_xdr(x, cachefilebase + uid + \'.mask\');
                        field_to_short(referencemask, a);
                        field_compare_data(a, x, eq);
                        if eq=0 then
                        begin
                          write_xdr(a, cachefilebase + uid + \'.mask.\'+maskid, \'\', \'\', 2);
                          write_xdr(reference_to_siddon, cachefilebase + uid + \'.mask.orientation.\'+maskid);
                        end;
                        a.free;
                        x.free;
                      end
                      else if not referencemask.empty then
                      begin
                        a := tavsfield.create;
                        field_to_short(referencemask, a);
                        write_xdr(a, cachefilebase + uid + \'.mask.\'+maskid, \'\', \'\', 2);
                        write_xdr(reference_to_siddon, cachefilebase + uid + \'.mask.orientation.\'+maskid);
                        a.free;
                      end;
                    end;
                  end;",
// Sentence 272
                  "function tform1.selectreferencesection(i : tinifiles; sender : tobject) : string;
                  var
                    uid, filename : string;
                  begin
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    if avlstate\>0 then filename := paramstr2
                    else               filename := adminfilebase + uid + \'.xvi\';
                    result := \'\';
                    if not i.sectionexists(\'xvi\') and not i.sectionexists(\'reference\') and not synergymode then
                    begin
                      showmessage(ref_section_error);
                      exit;
                      i.free;
                    end;
                    result := \'xvi\';
                    if i.sectionexists(\'reference\') then result := \'reference\';
                  end;",
// Sentence 273
                  "procedure tform1.buttonloadreferenceclick(sender: tobject);
                  var filename, s, section: string;
                      i       : tinifiles;
                      save    : tcursor;
                      j       : integer;
                      x, y, z : single;
                      b, dummy : boolean;
                      uid, maskstorefilebase, maskfilename, maskorientationfilename : string;
                      sr       : tsearchrec;
                      masks    : tstringlist;
                  begin
                    needloadreference := false;
                    if assigned(sf) then
                    begin
                      sl.caption := wait_loadref;
                      sl.update;
                      sf.update;
                    end;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    if avlstate\>0 then filename := paramstr2
                    else               filename := adminfilebase + uid + \'.xvi\';
                    if not fileexists(filename)  then
                    begin
                      showmessage(ref_error+ \' : \' + filename);
                      exit;
                    end;
                    if sectiontoload=\'none\' then
                      i := tinifiles.create([cachefilebase + elektatreatmentuid + \'.ini.xvi\', filename])
                    else
                    begin
                      if (avlstate=3) and (sectiontoload\<\>\'none\') then
                        i := tinifiles.create([filename, cachefilebase + elektatreatmentuid + \'.ini.xvi\', filename + \'.xvi\'])
                      else
                        i := tinifiles.create([cachefilebase + elektatreatmentuid + \'.ini.xvi\', filename + \'.xvi\', filename]);
                    end;
                    section := selectreferencesection(i, sender) ;
                    if section = \'\' then
                    begin
                      i.free ;
                      exit;
                    end;
                    if not ((filename = paramstr2) and synergymode) then
                    begin
                      patienturl     := i.readstring (section, \'patienturl\',     \'\');
                      scanurl        := i.readstring (section, \'scanurl\',        \'\');
                      planurl        := i.readstring (section, \'planurl\',        \'\');
                      beamurl        := i.readstring (section, \'beamurl\',        \'\');
                      doseurl        := i.readstring (section, \'doseurl\',        \'\');
                      delineationurl := i.readstring (section, \'delineationurl\', \'\');
                    end;
                    maskmargin     := i.readfloat  (section, \'maskmargin\',     0.0);
                    maskdelineation:= i.readstring (section, \'maskdelineation\',\'\');
                    maskbodysite   := i.readstring (section, \'maskbodysite\',   \'prostate\');
                    masklevel      := i.readinteger(section, \'masklevel\',  1000);
                    maskwindow     := i.readinteger(section, \'maskwindow\',  1000);
                    maskid         := i.readstring (section, \'maskid\',  \'\');
                    maskedited     := i.readbool   (section, \'maskedited\',  false);
                    referenceapprovalby := i.readstring (section, \'referenceapprovalby\', \'\');
                    scanurl        := i.readstring (section, \'scanpresent\',        scanurl);
                    planurl        := i.readstring (section, \'planpresent\',        planurl);
                    beamurl        := i.readstring (section, \'beampresent\',        beamurl);
                    doseurl        := i.readstring (section, \'dosepresent\',        doseurl);
                    delineationurl := i.readstring (section, \'delineationpresent\', delineationurl);
                    s := i.readstring (section, \'reconstructionprotocol\', \'\');
                    comboboxprotocol.itemindex := comboboxprotocol.items.indexof(s);
                    checkboxscan.checked          := i.readbool   (section, \'showscan\',        checkboxscan.checked);
                    showall1.checked              := i.readbool   (section, \'showallscan\',     showall1.checked);
                    checkboxplan.checked          := i.readbool   (section, \'showplan\',        checkboxplan.checked);
                    checkboxplan.checked          := i.readbool   (section, \'showbeams\',       checkboxplan.checked);
                    checkboxdose.checked          := i.readbool   (section, \'showdose\',        checkboxdose.checked);
                    checkboxdelineation.checked   := i.readbool   (section, \'showdelineation\', checkboxdelineation.checked);
                    checkboxroi.checked           := i.readbool   (section, \'showroi\',         checkboxroi.checked);
                    checkboxroi.checked           := i.readbool   (section, \'showclipbox\',     checkboxroi.checked);
                    checkboxreferencemask.checked := i.readbool   (section, \'showmask\',        checkboxreferencemask.checked);
                    checkboxenablerotation.checked   := i.readbool   (section, \'enablerotation\',  checkboxenablerotation.checked);
                    comboboxsliceaveraging.itemindex := i.readinteger(section, \'sliceaveraging\',  comboboxsliceaveraging.itemindex);
                    s := lowercase(i.readstring(section, \'displaymode\',     \'greenpurple\'));
                    if      s=\'greenpurple\'   then comboboxdisplaymode.itemindex := 0
                    else if s=\'cut\'           then comboboxdisplaymode.itemindex := 1
                    else if s=\'onlineonly\'    then comboboxdisplaymode.itemindex := 2
                    else if s=\'referenceonly\' then comboboxdisplaymode.itemindex := 3
                    else    comboboxdisplaymode.itemindex := strtointdef(s, 0);
                    s := i.readstring (section, \'registrationprotocol\', \'clipbox\');
                    appliedcorrectionprotocol := s;
                    comboboxregistrationprotocol.itemindex := comboboxregistrationprotocol.indexofmapped(s);
                    if comboboxregistrationprotocol.itemindex=-1 then comboboxregistrationprotocol.itemindex := 0;
                    comboboxregistrationprotocolchange(nil);
                    s := i.readstring (section, \'correctionfromprotocol\',  \'clipbox\');
                    appliedcorrectionfrom := s;
                    comboboxcorrectionprotocol.itemindex := comboboxcorrectionprotocol.indexofmapped(s);
                    if comboboxcorrectionprotocol.itemindex=-1 then
                    begin
                      if (comboboxcorrectionprotocol.itemindex in [0,4]) then comboboxcorrectionprotocol.itemindex := comboboxcorrectionprotocol.indexofmapped(\'clipbox\')
                      else comboboxcorrectionprotocol.itemindex := comboboxcorrectionprotocol.indexofmapped(\'mask (mean if 4d)\')
                    end;
                    s := i.readstring (section, \'correctionbyprotocol\', nameof3dsystemmappedtext);
                    comboboxcorrectionby.itemindex := comboboxcorrectionby.indexofmapped(s);
                    comboboxcorrectionbychange(self);
                    if comboboxcorrectionby.itemindex=-1 then comboboxcorrectionby.itemindex := 0;
                    appliedcorrectionby := s;
                    s := lowercase(i.readstring(section, \'matchmethod\', match_bone));
                    comboboxmatch.itemindex := comboboxmatch.items.indexof(s);
                    setregistrationparameters(comboboxmatch);
                    if      s = \'bone\'       then s:= match_bonetr
                    else if s = \'grey value\' then s:= match_greytr
                    else if s = \'manual\'     then s:= match_manual;
                    s := i.readstring (section, \'clipboxmatchmethod\', s);
                    appliedclipboxmatchmethod := s;
                    comboboxclipboxmatch.itemindex := comboboxclipboxmatch.indexofmapped(s);
                    if comboboxclipboxmatch.itemindex=-1 then comboboxclipboxmatch.itemindex := 0;
                    s := i.readstring (section, \'maskmatchmethod\', \'grey value (t + r)\');
                    appliedmaskmatchmethod := s;
                    comboboxmaskmatch.itemindex := comboboxmaskmatch.indexofmapped(s);
                    if comboboxmaskmatch.itemindex=-1 then comboboxmaskmatch.itemindex := 0;
                    b := i.readbool (section, \'clipboxtranslationlimitsidentical\', true);
                    colorstringgrid2.cellprops[1,0].box.checked := b;
                    if b then
                    begin
                      s := i.readstring (section, \'clipboxtranslationwarnlimit\', \'0.0\');
                      colorstringgrid2.cells[2,1] := s;
                    end
                    else
                    begin
                      s := i.readstring (section, \'clipboxtranslationwarnlimitright\', \'0.0\');
                      colorstringgrid2.cells[1,1] := s;
                      s := i.readstring (section, \'clipboxtranslationwarnlimitleft\', \'0.0\');
                      colorstringgrid2.cells[2,1] := s;
                      s := i.readstring (section, \'clipboxtranslationwarnlimitinf\', \'0.0\');
                      colorstringgrid2.cells[1,2] := s;
                      s := i.readstring (section, \'clipboxtranslationwarnlimitsup\', \'0.0\');
                      colorstringgrid2.cells[2,2] := s;
                      s := i.readstring (section, \'clipboxtranslationwarnlimitpost\', \'0.0\');
                      colorstringgrid2.cells[1,3] := s;
                      s := i.readstring (section, \'clipboxtranslationwarnlimitant\', \'0.0\');
                      colorstringgrid2.cells[2,3] := s;
                    end;
                    b := i.readbool (section, \'clipboxrotationlimitsidentical\', true);
                    colorstringgrid2.cellprops[1,4].box.checked := b;
                    if b then
                    begin
                      s := i.readstring (section, \'clipboxrotationwarnlimit\', \'0.0\');
                      colorstringgrid2.cells[2,5] := s;
                    end
                    else
                    begin
                      s := i.readstring (section, \'clipboxrotationwarnlimitlr_cc\', \'0.0\');
                      colorstringgrid2.cells[1,5] := s;
                      s := i.readstring (section, \'clipboxrotationwarnlimitlr_cw\', \'0.0\');
                      colorstringgrid2.cells[2,5] := s;
                      s := i.readstring (section, \'clipboxrotationwarnlimitsi_cc\', \'0.0\');
                      colorstringgrid2.cells[1,6] := s;
                      s := i.readstring (section, \'clipboxrotationwarnlimitsi_cw\', \'0.0\');
                      colorstringgrid2.cells[2,6] := s;
                      s := i.readstring (section, \'clipboxrotationwarnlimitap_cc\', \'0.0\');
                      colorstringgrid2.cells[1,7] := s;
                      s := i.readstring (section, \'clipboxrotationwarnlimitap_cw\', \'0.0\');
                      colorstringgrid2.cells[2,7] := s
                    end;
                    b := i.readbool (section, \'masktranslationlimitsidentical\', true);
                    colorstringgrid3.cellprops[1,0].box.checked := b;
                    if b then
                    begin
                      s := i.readstring (section, \'masktranslationwarnlimit\', \'0.0\');
                      colorstringgrid3.cells[2,1] := s;
                    end
                    else
                    begin
                      s := i.readstring (section, \'masktranslationwarnlimitright\', \'0.0\');
                      colorstringgrid3.cells[1,1] := s;
                      s := i.readstring (section, \'masktranslationwarnlimitleft\', \'0.0\');
                      colorstringgrid3.cells[2,1] := s;
                      s := i.readstring (section, \'masktranslationwarnlimitinf\', \'0.0\');
                      colorstringgrid3.cells[1,2] := s;
                      s := i.readstring (section, \'masktranslationwarnlimitsup\', \'0.0\');
                      colorstringgrid3.cells[2,2] := s;
                      s := i.readstring (section, \'masktranslationwarnlimitpost\', \'0.0\');
                      colorstringgrid3.cells[1,3] := s;
                      s := i.readstring (section, \'masktranslationwarnlimitant\', \'0.0\');
                      colorstringgrid3.cells[2,3] := s;
                    end;
                    b := i.readbool (section, \'maskrotationlimitsidentical\', true);
                    colorstringgrid3.cellprops[1,4].box.checked := b;
                    if b then
                    begin
                      s := i.readstring (section, \'maskrotationwarnlimit\', \'0.0\');
                      colorstringgrid3.cells[2,5] := s;
                    end
                    else
                    begin
                      s := i.readstring (section, \'maskrotationwarnlimitlr_cc\', \'0.0\');
                      colorstringgrid3.cells[1,5] := s;
                      s := i.readstring (section, \'maskrotationwarnlimitlr_cw\', \'0.0\');
                      colorstringgrid3.cells[2,5] := s;
                      s := i.readstring (section, \'maskrotationwarnlimitsi_cc\', \'0.0\');
                      colorstringgrid3.cells[1,6] := s;
                      s := i.readstring (section, \'maskrotationwarnlimitsi_cw\', \'0.0\');
                      colorstringgrid3.cells[2,6] := s;
                      s := i.readstring (section, \'maskrotationwarnlimitap_cc\', \'0.0\');
                      colorstringgrid3.cells[1,7] := s;
                      s := i.readstring (section, \'maskrotationwarnlimitap_cw\', \'0.0\');
                      colorstringgrid3.cells[2,7] := s
                    end;
                    boxclick(colorstringgrid2.cellprops[1,0].box);
                    boxclick(colorstringgrid3.cellprops[1,0].box);
                    loadclipboxes(i, section, clipbox, cbnames, cbweights);
                    updateviewernamelabels() ;
                    x := i.readfloat(section, \'isocx\', -9999);
                    y := i.readfloat(section, \'isocy\', -9999);
                    z := i.readfloat(section, \'isocz\', -9999);
                    if (x\<-9990) or (y\<-9990) or (z\<-9990) then
                    begin
                      showmessage(isoc_error);
                      if avlstate\>0 then
                      begin
                        application.terminate;
                        exit;
                      end;
                    end;
                    if synergymode and buttonsavereference.visible then
                      if (abs(x - strtofloat(syn_isox)) \> 0.01) or
                         (abs(y - strtofloat(syn_isoy)) \> 0.01) or
                         (abs(z - strtofloat(syn_isoz)) \> 0.01) then
                         showmessage(error_nkiisocerror);
                    try
                      machine_to_siddon.maketranslation(x, y, z);
                    except
                      showmessage(isoc_error);
                      if avlstate\>0 then
                      begin
                        application.terminate;
                        exit;
                      end;
                    end;
                    if i.readbool(section,\'markerset\',false) then
                    begin
                      field_create(quirtviewerupdcoronal.markerdots[1], \'field 1d 3-space irregular 20-vector byte\', 1);
                      quirtviewerupdcoronal.markerdots[1].coordinate[0,0] := i.readfloat(section, \'markerx\', 0);
                      quirtviewerupdcoronal.markerdots[1].coordinate[1,0] := i.readfloat(section, \'markery\', 0);
                      quirtviewerupdcoronal.markerdots[1].coordinate[2,0] := i.readfloat(section, \'markerz\', 0);
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 0], ord(\'c\'));
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 1], 255);
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 2], 0);
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 3], 0);
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 4], ord(\'s\'));
                      quirtviewerupdcoronal.markerdots[1].setvalue([0, 5], ord(\'+\'));
                      quirtviewerupdcoronal.markerdots[1].ischangedby := nil;
                    end
                    else
                      quirtviewerupdcoronal.markerdots[1].clear;
                    x := i.readfloat(section, \'correctionreferencepointx\', -9999);
                    y := i.readfloat(section, \'correctionreferencepointy\', -9999);
                    z := i.readfloat(section, \'correctionreferencepointz\', -9999);
                    correctionreferencepointstructure := i.readstring (section, \'correctionreferencepointstructure\', \'\');
                    correctionreferencepoint.debugname := inttostr(i.readinteger(section, \'correctionreferencepointmode\', 0));
                    if (x\<-9990) or (y\<-9990) or (z\<-9990) then
                    begin
                      if not synergymode then
                      begin
                        showmessage(cor_ref_error);
                        if avlstate\>1 then
                          application.terminate;
                      end
                      else
                      begin
                        x := syn_crpx / 10;
                        y := syn_crpy / 10;
                        z := syn_crpz / 10;
                        if syn_crpm=\'isocenter\' then correctionreferencepoint.debugname := \'0\';
                        if syn_crpm=\'clipbox\'   then correctionreferencepoint.debugname := \'1\';
                        if syn_crpm=\'marker\'    then correctionreferencepoint.debugname := \'2\';
                        if syn_crpm=\'center of structures\' then correctionreferencepoint.debugname := \'3\';
                        if syn_crpm=\'mask\' then correctionreferencepoint.debugname := \'4\';
                      end;
                    end;
                    correctionreferencepoint.coordinate[0,0] := x;
                    correctionreferencepoint.coordinate[1,0] := y;
                    correctionreferencepoint.coordinate[2,0] := z;
                    b := true;
                    updatecorrectionreferencepoint(nil, b);
                    s := lowercase(inifile.readstring(section, \'fov\', \'small\'));
                    if s=\'small\'  then defaultfov := 83;
                    if s=\'medium\' then defaultfov := 77;
                    if s=\'large\'  then defaultfov := 76;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if (avlstate\>0) then
                    begin
                      if (scanurl\<\>\'0\')                   then buttonsetscanclick(nil);
                      if (planurl\<\>\'0\') or (beamurl\<\>\'0\') then buttonsetplanclick(nil);
                      if (delineationurl\<\>\'0\')            then buttonsetdelineationclick(nil);
                      if (doseurl\<\>\'0\')                   then buttonsetdoseclick(nil);
                    end
                    else if (synergymode) then
                    begin
                      buttonsetscanclick(nil);
                      if (planurl\<\>\'0\') or (beamurl\<\>\'0\') then buttonsetplanclick(nil);
                      buttonsetdelineationclick(nil);
                      buttonsetdoseclick(nil);
                    end
                    else
                    begin
                      if (scanurl\<\>\'\')                  then buttonsetscanclick(nil);
                      if (planurl\<\>\'\') or (beamurl\<\>\'\') then buttonsetplanclick(nil);
                      if (doseurl\<\>\'\')                  then buttonsetdoseclick(nil);
                      if (delineationurl\<\>\'\')           then buttonsetdelineationclick(nil);
                    end;
                    comboboxregistrationprotocolchange(nil);
                    for j:=1 to high(online) do
                    begin
                      online[j].level.maximum  := 2000;
                      online[j].level.minimum  := 0;
                      online[j].window.maximum := 1000;
                      online[j].window.minimum := 0;
                      online[j].level.value  := i.readinteger  (section, \'online\'+inttostr(j)+\'.level\',  round(online[j].level.value));
                      online[j].window.value := i.readinteger  (section, \'online\'+inttostr(j)+\'.window\', round(online[j].window.value));
                    end;
                    online[1].level.value  := i.readinteger  (section, \'onlinelevel\',   round(online[1].level.value));
                    online[1].window.value := i.readinteger  (section, \'onlinewindow\',  round(online[1].window.value));
                    for j:=1 to high(reference) do
                    begin
                      reference[j].level.maximum  := 2000;
                      reference[j].level.minimum  := 0;
                      reference[j].window.maximum := 1000;
                      reference[j].window.minimum := 0;
                      reference[j].level.value  := i.readinteger  (section, \'reference\'+inttostr(j)+\'.level\',  round(reference[j].level.value));
                      reference[j].window.value := i.readinteger  (section, \'reference\'+inttostr(j)+\'.window\', round(reference[j].window.value));
                    end;
                    reference[1].level.value := i.readinteger  (section, \'referencelevel\',   round(reference[1].level.value));
                    reference[1].window.value := i.readinteger  (section, \'referencewindow\', round(reference[1].window.value));
                    restore1.checked := true;
                    levels[0] := online[1].level.value;
                    levels[1] := online[1].window.value;
                    levels[2] := reference[1].level.value;
                    levels[3] := reference[1].window.value;
                    restore1.enabled := true;
                    myzoom := i.readfloat  (section, \'zoom\', 1.5 * zoomfix);
                    quirtviewerupdtransversal.grid.make;
                    myzoom :=
                      myzoom * abs(quirtviewerupdtransversal.grid.coordinate[0, 1] - quirtviewerupdtransversal.grid.coordinate[0, 0]) / 0.1;
                      quirtviewerupdcoronalpanchanged(self, 0, 0);
                    field_create(quirtviewerupdcoronal.markerdots[3], \'field 1d 3-space irregular 20-vector byte\', 1);
                    quirtviewerupdcoronal.markerdots[3].coordinate[0,0] := i.readfloat(section, \'viewpointx\', 0);
                    quirtviewerupdcoronal.markerdots[3].coordinate[1,0] := i.readfloat(section, \'viewpointy\', 0);
                    quirtviewerupdcoronal.markerdots[3].coordinate[2,0] := i.readfloat(section, \'viewpointz\', 0);
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 0], ord(\'c\'));
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 1], 0);
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 2], 0);
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 3], 0);
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 4], ord(\'y\'));
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 5], 1);
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 6], ord(\'s\'));
                    quirtviewerupdcoronal.markerdots[3].setvalue([0, 7], ord(\'.\'));
                    quirtviewerupdcoronal.markerdots[3].ischangedby := self;
                    activesettingstolistview(i, false);
                    i.free;
                    if fileexists(cachefilebase + treatmentuid  + \'.mask\') then uid := treatmentuid;
                    if synergymode and fileexists(cachefilebase + scanseriesuid + \'.mask\') then uid := scanseriesuid;
                    if synergymode and fileexists(cachefilebase + plansopuid    + \'.mask\') then uid := plansopuid;
                    maskstorefilebase := cachefilebase;
                    maskfilename := maskstorefilebase + uid + \'.mask\';
                    maskorientationfilename := maskfilename + \'.orientation\';
                    if sectiontoload\<\>\'none\' then
                      if fileexists(maskfilename + \'.\' + maskid) then
                      begin
                        maskfilename := maskstorefilebase + uid + \'.mask.\' + maskid;
                        maskorientationfilename := maskstorefilebase + uid + \'.mask\' + \'.orientation.\' +maskid;
                      end;
                    begin
                      if fileexists(maskfilename) then
                        read_xdr(referencemask, maskfilename)
                      else
                      begin
                        maskid:=\'0\';
                        maskedreference.clear;
                        referencemask.clear;
                        maskedreferencelut.clear;
                      end;
                      if fileexists(maskorientationfilename) then
                      begin
                        read_xdr(maskedreferencetransform, maskorientationfilename);
                        transform_math(maskedreferencetransform, machine_to_siddon, maskedreferencetransform, false, true);
                      end
                      else
                        transform_math(reference_to_siddon, machine_to_siddon, maskedreferencetransform, false, true);
                      if (avlstate=1) and (maskid\<\>\'\') then
                      begin
                        masks := tstringlist.create;
                        if findfirst(maskstorefilebase + uid + \'.mask.\'+\'*.*\', 0, sr) = 0 then
                        begin
                          if (length(sr.name) \> length(uid + \'.mask\')) and (pos(\'orientation\', sr.name)=0) then masks.add(sr.name);
                          while findnext(sr) = 0 do
                            if (length(sr.name) \> length(uid + \'.mask\')) and (pos(\'orientation\', sr.name)=0) then masks.add(sr.name);
                          findclose(sr);
                        end;
                        masks.sort;
                        if masks.count\>0 then
                          if copy(masks[masks.count-1], length(masks[masks.count-1])-14, 15)\>maskid then
                          begin
                            timer1.enabled := false;
                            if messagedlg(format(message_reviewmask, [copy(masks[masks.count-1], length(masks[masks.count-1])-14, 15)]), mtconfirmation, [mbyes, mbno], 0) = mryes then
                            begin
                              read_xdr(referencemask, maskstorefilebase + masks[masks.count-1]);
                              if fileexists(maskstorefilebase + masks[masks.count-1]+\'.orientation\') then
                              begin
                                read_xdr(maskedreferencetransform, maskstorefilebase + masks[masks.count-1]+\'.orientation\');
                                transform_math(maskedreferencetransform, machine_to_siddon, maskedreferencetransform, false, true);
                              end
                              else
                                transform_math(reference_to_siddon, machine_to_siddon, maskedreferencetransform, false, true);
                              maskid := copy(masks[masks.count-1], length(masks[masks.count-1])-14, 15);
                            end
                            else
                              if maskid=\'0\' then maskid := \'\';
                            timer1.enabled := true;
                          end;
                        masks.free;
                      end;
                      if not referencemask.empty then
                      begin
                        if referencemask.datatype =avs_type_byte then
                        begin
                          maskedreference.assign(referencecube);
                          field_mask(maskedreference, referencemask, maskedreference);
                          field_autocrop(maskedreference, maskedreference, 2);
                        end
                        else if round(referencemask.maximum)=255 then
                        begin
                          maskedreference.assign(referencecube);
                          field_to_byte(referencemask, referencemask);
                          field_mask(maskedreference, referencemask, maskedreference);
                          field_autocrop(maskedreference, maskedreference, 2);
                        end
                        else
                        begin
                          field_eqsc(referencemask,referencemask,0);
                          field_not(referencemask,referencemask);
                          field_addc(referencemask,referencemask,256);
                          maskedreference.assign(referencecube);
                          field_setc(maskedreference,maskedreference,0);
                          field_insertc(maskedreference,referencemask,referencemask);
                          field_to_byte(referencemask,referencemask);
                          read_xdr(maskedreference, maskstorefilebase + uid + \'.mask\');
                        end;
                      end;
                      if maskwindow\<1 then maskwindow := 1;
                      if masklevel-maskwindow\<0 then masklevel := maskwindow;
                      fillmaskedreferencelut;
                    end;
                    eulerxfm(machine_to_machineadjust);
                    transformdisplaymode.value := 0;
                    machine_to_machineadjust.ischangedby := sender;
                    lastmatchresult := \'\';
                    onlinetoreftransformmatched := \'\';
                    matchadjusted   := false;
                    matchrotation   := true;
                    if not quirtviewerupdcoronal.clipbox[1].empty then
                      quirtviewerupdcoronal.activeclipbox.value := 1;
                    referencedatachanged := false;
                    screen.cursor := save;
                  end;",
// Sentence 274
                  "procedure tform1.loadclipboxes(i: tinifiles; section : string; var cbs: array of tavsfield; var namelist : tstringlist; var weightlist: array of single) ;
                  var
                    stringlist : tstringlist;
                    t1         : ttransform ;
                    s, jstr    : string  ;
                    j, jlow, jhigh : integer ;
                  begin
                    namelist.clear ;
                    for j := low(weightlist) to high(weightlist) do
                      weightlist[j] := 1 ;
                    s := i.readstring (section, \'clip1\', \'\');
                    jlow := low(cbs);
                    jhigh:= high(cbs) ;
                    if (s \<\> \'\') and (valuefromstr(s, 5, 0)\<\>valuefromstr(s, 6, 0)) then
                    begin
                      field_create(cbs[jlow], \'field 1d float\', 6);
                      cbs[jlow].setvalue([0], valuefromstr(s, 1, -10));
                      cbs[jlow].setvalue([1], valuefromstr(s, 2,  10));
                      cbs[jlow].setvalue([2], valuefromstr(s, 3, -10));
                      cbs[jlow].setvalue([3], valuefromstr(s, 4,  10));
                      cbs[jlow].setvalue([4], valuefromstr(s, 5, -10));
                      cbs[jlow].setvalue([5], valuefromstr(s, 6,  10));
                      cbs[jlow].locked     := i.readbool   (section, \'clip1locked\', false);
                      menuclipboxlocked.checked := cbs[jlow].locked;
                    end
                    else
                    begin
                      if i.readfloat  (section, \'clipboxx1\', -9999) \< -9998 then
                      begin
                        if i.readfloat  (section, \'clip1x1\', -9999) \< -9998 then
                        begin
                          if not synergymode then cbs[jlow].clear;
                        end
                        else
                        begin
                          field_create(cbs[jlow], \'field 1d float\', 6);
                          cbs[jlow].setvalue([0], i.readfloat  (section, \'clip1x1\', -10));
                          cbs[jlow].setvalue([1], i.readfloat  (section, \'clip1x2\',  10));
                          cbs[jlow].setvalue([2], i.readfloat  (section, \'clip1y1\', -10));
                          cbs[jlow].setvalue([3], i.readfloat  (section, \'clip1y2\',  10));
                          cbs[jlow].setvalue([4], i.readfloat  (section, \'clip1z1\', -10));
                          cbs[jlow].setvalue([5], i.readfloat  (section, \'clip1z2\',  10));
                          cbs[jlow].locked     := i.readbool   (section, \'clip1locked\', false);
                          menuclipboxlocked.checked := cbs[jlow].locked;
                        end;
                      end
                      else
                      begin
                        field_create(cbs[jlow], \'field 1d float\', 6);
                        cbs[jlow].setvalue([0], i.readfloat  (section, \'clipboxx1\', -10));
                        cbs[jlow].setvalue([1], i.readfloat  (section, \'clipboxx2\',  10));
                        cbs[jlow].setvalue([2], i.readfloat  (section, \'clipboxy1\', -10));
                        cbs[jlow].setvalue([3], i.readfloat  (section, \'clipboxy2\',  10));
                        cbs[jlow].setvalue([4], i.readfloat  (section, \'clipboxz1\', -10));
                        cbs[jlow].setvalue([5], i.readfloat  (section, \'clipboxz2\',  10));
                        t1 := ttransform.create;
                        t1.makerotation(270, 0, 270);
                        cropbox_transform(cbs[jlow], t1, cbs[jlow]);
                        t1.free;
                        cbs[jlow].locked     := i.readbool   (section, \'clipboxlocked\', false);
                        menuclipboxlocked.checked := cbs[jlow].locked;
                      end;
                      namelist.add(\'clipbox1\') ;
                      weightlist[low(weightlist)] := 1.0 ;
                    end;
                  end;",
// Sentence 275
                  "procedure tform1.updateviewernamelabels() ;
                  var
                    j  : integer ;
                    newname: string ;
                  begin
                    if clipbox[2].empty then
                    begin
                      if quirtviewerupdcoronal.clipboxtext[1].value \<\>  (#27+chr(255)+#1+#1+\' \'+#10+\' \') then
                      begin
                        quirtviewerupdcoronal.clipboxtext[1].locked := false;
                        quirtviewerupdcoronal.clipboxtext[1].value :=  #27+chr(255)+#1+#1+\' \'+#10+\' \';
                        quirtviewerupdcoronal.clipboxtext[1].locked := true;
                      end;
                    end
                    else
                    begin
                      for j := 1 to cbnames.count do
                      begin
                        if cbnames[j-1]=\'\' then
                          cbnames[j-1]:=\' \';
                        newname :=  #27+chr(255)+#1+#1 + cbnames[j-1] + #10 + floattostrf(cbweights[j], fffixed, 5, 2);
                        if quirtviewerupdcoronal.clipboxtext[j].value \<\> newname then
                        begin
                          quirtviewerupdcoronal.clipboxtext[j].locked := false;
                          quirtviewerupdcoronal.clipboxtext[j].value := newname;
                          quirtviewerupdcoronal.clipboxtext[j].locked := true;
                        end;
                      end;
                    end;
                  end;",
// Sentence 276
                  "procedure tform1.buttonclearreferenceclick(sender: tobject);
                  var i:integer;
                  begin
                    for i:=1 to nclipbox do
                    begin
                      quirtviewerupdcoronal.clipboxtext[i].locked :=  false ;
                      quirtviewerupdcoronal.clipboxtext[i].value := \'\' ;
                      clipbox[i].clear;
                      quirtviewerupdcoronal.clipboxtext[i].locked :=  true ;
                      cbweights[i] :=1 ;
                    end;
                    cbnames.clear ;
                    reference[1].clear;
                    dose[1].clear;
                    delineationdots.clear;
                    delineationindex.clear;
                    delineationindex.clear;
                    beamdots.clear;
                    beamindex.clear;
                    maskedreference.clear;
                    referencemask.clear;
                    maskedreferencelut.clear;
                    machine_to_siddon.makeidentity;
                    eulerxfm(machine_to_machineadjust);
                    transformdisplaymode.value := 0;
                    quirtviewerupdcoronal.warp[1].clear;
                    quirtviewerupdcoronal.warp[6].clear;
                    quirtviewerupdcoronal.viewwarp.clear;
                    quirtviewerupdcoronal.markerdots[3].clear;
                    field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                    correctionreferencepoint.debugname := \'0\';
                    correctionreferencepointstructure := \'\';
                    quirtviewerupdcoronal.text[3].value := \'\';
                    quirtviewerupdtransversal.text[4].value := \'\';
                    scanurl := \'\';
                    studyurl:= \'\';
                    planurl := \'\';
                    beamurl := \'\';
                    doseurl := \'\';
                    delineationurl := \'\';
                    maskmargin := 0;
                    maskdelineation := \'\';
                    comboboxprotocol.itemindex := 0;
                    referencedatachanged := true;
                    quirtviewerupdcoronal.markerdots[1].clear;
                    machine_to_machineadjust.ischangedby := sender;
                    lastmatchresult := \'\';
                    onlinetoreftransformmatched := \'\';
                    matchadjusted   := false;
                    matchrotation   := true;
                  end;",
// Sentence 277
                  "procedure tform1.buttonclearonlineclick(sender: tobject);
                  var f, g  : single;
                  begin
                    online[1].clear;
                    field_create(onlinecube, \'field 3d 0-vector byte\', 256, 256, 256);
                    case defaultfov of
                      76:  modify_extents(onlinecube, onlinecube, 0.2,   0.2,   0.2);
                      77:  modify_extents(onlinecube, onlinecube, 0.156, 0.156, 0.156);
                      83:  modify_extents(onlinecube, onlinecube, 0.1,   0.1,   0.1);
                      else
                      begin
                        f := abs(onlinecube.coordinate[1, 0] - onlinecube.coordinate[1, onlinecube.dimensions[1]-1]);
                        g := abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]);
                        g := max(abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]), g);
                        g := max(abs(referencecube.coordinate[0, 0] - referencecube.coordinate[0, referencecube.dimensions[0]-1]), g);
                        f := max(f, 1);
                        g := max(g, 1);
                        modify_extents(onlinecube, onlinecube, g/f, g/f, g/f);
                      end;
                    end;
                    if online[1].tomachine.empty then
                       online[1].tomachine.makerotation(270, 0, 270);
                    myzoom := 1.5 * zoomfix;
                    phase.clear;
                    phasehist.clear;
                    transform4d.clear;
                    makeregistrationbackup(0, 9999, 0, 9999);
                    vistransform4d.clear;
                    vistransform4d2.clear;
                    quirtviewerupdcoronal.warp[1].clear;
                    quirtviewerupdcoronal.warp[6].clear;
                    quirtviewerupdcoronal.viewwarp.clear;
                    buttonresetmatchclick(self);
                    matchprerotate := false;
                    matchrotmark   := false;
                    match4dsingleframe := false;
                  end;",
// Sentence 278
                  "procedure tform1.buttontoreferenceclick(sender: tobject);
                  var
                    crp2, clpbx2 : tavsfield;
                    refempty : boolean;
                  begin
                    if (getkeystate(vk_lshift) and $8000)\<\>0 then
                    begin
                      if referencecube.empty then
                        exit;
                      online_to_machine.assign(reference_to_machine);
                      field_to_uniform(referencecube,onlinecube);
                      online[1].connectviewer(quirtviewerupdsagittal, 1);
                      online[1].connectviewer(quirtviewerupdtransversal, 1);
                      online[1].connectviewer(quirtviewerupdcoronal, 1);
                      onlineurl := scanurl;
                      showmessage(nki_copiedreftoonline);
                      exit;
                    end;
                    crp2   := tavsfield.create;
                    clpbx2 := tavsfield.create;
                    if not referencecube.empty then
                    begin
                      field_copy(correctionreferencepoint, crp2);
                      field_copy(clipbox[1], clpbx2);
                      refempty := false;
                    end
                    else
                    begin
                      crp2.assign(correctionreferencepoint);
                      clpbx2.assign(clipbox[1]);
                      refempty := true;
                    end;
                    buttonclearreferenceclick(self);
                    referencedatachanged := true;
                    checkboxroi.checked := true;
                    menuclipboxlocked.checked := false;
                    if (onlinecube.ndim = 4) and ((getkeystate(vk_control) and $8000)\<\>0) then
                    begin
                      if quirtviewerupdcoronal.frame.value \<\> -1 then
                        field_slice(onlinecube, referencecube, -1, -1, -1, quirtviewerupdcoronal.frame.value)
                      else
                      begin
                        if not phasehist.empty then
                          field_ortho_wghtsum(onlinecube, phasehist, referencecube, field_ortho_wghtsum_udirection)
                        else
                          field_ortho_average(onlinecube, referencecube, field_ortho_average_udirection);
                      end;
                    end
                    else
                      referencecube.assign(onlinecube);
                    reference_to_siddon.assign(online_to_machine);
                    reference_to_patient.assign(online_to_machine);
                    dosecube.clear;
                    doseaccu.clear;
                    dose_to_siddon.clear;
                    dose_to_machine.clear;
                    quirtviewerupdsagittal.level[2].value := quirtviewerupdsagittal.level[1].value-100;
                    quirtviewerupdsagittal.window[2].value := quirtviewerupdsagittal.window[1].value;
                    field_create(beamdots, \'field 1d 3-space irregular\', 1);
                    beamindex.clear;
                    if not refempty then
                    begin
                      field_copy(crp2, correctionreferencepoint);
                      field_copy(clpbx2, clipbox[1]);
                    end
                    else
                    begin
                      correctionreferencepoint.assign(crp2);
                      clipbox[1].assign(clpbx2);
                    end;
                    crp2.clear;
                    clpbx2.clear;
                    buttonresetmatchclick(self);
                    if (comboboxregistrationprotocol.itemindex\<0) then
                      comboboxregistrationprotocol.itemindex:=0;
                    comboboxregistrationprotocolchange(nil);
                    if not fileexists(reconfilebase + scanuid + \'.scan\') then
                      showmessage(toref_warn1)
                    else
                      showmessage(toref_warn2);
                    if exportedscan = \'\' then
                      scanurl := \'xdr:\' + reconfilebase + scanuid + \'.scan\'
                    else
                      scanurl := exportedscan;
                    planurl := \'fake\';
                    beamurl := \'\';
                    doseurl := \'\';
                    if referenceoverlaystring\<\>\'\' then
                      quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + referenceoverlaystring
                    else
                      quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + ref_overlay + scandate;
                  end;",
// Sentence 279
                  "procedure tform1.copyrefclick(sender: tobject);
                  begin
                  end;",
// Sentence 280
                  "procedure tform1.buttonexportclick(sender: tobject);
                  begin
                  end;",
// Sentence 281
                  "procedure tform1.timericomtimer(sender: tobject);
                  begin
                  end;",
// Sentence 282
                  "procedure tform1.buttonzerocouchclick(sender: tobject);
                  begin
                  end;",
// Sentence 283
                  "procedure tform1.updown1update;
                  var filename: string;
                  begin
                    updown1.hint := format(updown_hint, [updown1.position+1, updown1.max+1]);
                    queryscans.locate(\'dbid\', scanlist[max(0,updown1.position)], []);
                    filename := reconfilebase + scanuid + \'.scan\';
                    if prevfile = filename then exit;
                    if online[1].exists(reconfilebase, scanuid, \'scan\') or
                       online[1].exists(reconfilebase, scanuid, \'image1\') then
                      needloadscan := true;
                      needloadmatch := true;
                    prevfile := filename;
                  end;",
// Sentence 284
                  "procedure tform1.updown1mousedown(sender: tobject; button: tmousebutton;
                    shift: tshiftstate; x, y: integer);
                  begin
                    if (ssshift in shift) and (x \< updown1.width div 2) then updown1.position := 0;
                    if (ssshift in shift) and (x \> updown1.width div 2) then updown1.position := updown1.max;
                    if (ssshift in shift) then updown1update;
                  end;",
// Sentence 285
                  "procedure tform1.updown1mouseup(sender: tobject; button: tmousebutton;
                    shift: tshiftstate; x, y: integer);
                  begin
                    updown1update;
                  end;",
// Sentence 286
                  "procedure tform1.updownplanselectionchangingex(sender: tobject;
                    var allowchange: boolean; newvalue: smallint; direction: tupdowndirection);
                  begin
                  end;",
// Sentence 287
                  "procedure tform1.timer4dtimer(sender: tobject);
                  var
                    nf : integer;
                  begin
                    if not timer1.enabled then exit;
                    if form1timer1enabled\>0 then exit;
                    if (not panelcontrol4d.visible) then
                    begin
                      bitbtnaverage4dclick(self);
                      exit;
                    end;
                    if (onlinecube.ndim\<\>4) and (referencecube.ndim\<\>4) then exit;
                    nf := onlinecube.dimensions[3];
                    if nf \< 1 then exit;
                    quirtviewerupdcoronal.frame.value    := (quirtviewerupdcoronal.frame.value + 1) mod nf;
                    if onlinecube.ndim = 4 then
                    begin
                      if phasehist.empty then
                        timer4d.interval := timer4d.tag
                      else
                        timer4d.interval := round(timer4d.tag*phasehist.getvalue([quirtviewerupdcoronal.frame.value])*phasehist.dimensions[0]);
                      if timer4d.interval \< 1 then timer4d.interval := 1;
                    end;
                    timer1timer(self);
                  end;",
// Sentence 288
                  "procedure tform1.buttonplay4dclick(sender: tobject);
                  var prevrev: integer;
                  begin
                    if (onlinecube.ndim\<\>4) and (referencecube.ndim\<\>4) then exit;
                    prevrev := reversemotion.value;
                    reversemotion.value := ord((sender as tbitbtn)=bitbtnplaygreen);
                    if (timer4d.enabled = false) and (timer4d.tag \<\> 0) then
                    begin
                      timer4d.enabled := true;
                      timer4d.interval := timer4d.tag;
                      exit;
                    end;
                    timer4d.enabled := true;
                    if (reversemotion.value\<\>prevrev) or
                    (((getkeystate(vk_lshift) or getkeystate(vk_rshift)) and $8000)\<\>0) then exit;
                    if onlinecube.ndim = 4 then
                    begin
                      case timer4d.tag of
                        0: timer4d.tag := 400;
                        400:  timer4d.tag := 150;
                        150:  timer4d.tag :=  50;
                        else  timer4d.tag :=  400;
                      end;
                      timer4d.interval := timer4d.tag;
                    end
                  end;",
// Sentence 289
                  "procedure tform1.bitbtnplaypurplemousedown(sender: tobject;
                    button: tmousebutton; shift: tshiftstate; x, y: integer);
                  begin
                  end;",
// Sentence 290
                  "procedure tform1.bitbtnplaypurplemouseup(sender: tobject; button: tmousebutton;
                    shift: tshiftstate; x, y: integer);
                  begin
                  end;",
// Sentence 291
                  "procedure tform1.bitbtnstop4dclick(sender: tobject);
                  var average : boolean;
                  begin
                    reversemotion.value := 0;
                    if ((getkeystate(vk_lshift) or getkeystate(vk_rshift)) and $8000)\<\>0 then
                      average := true
                    else
                      average := false;
                    if average then
                    begin
                      if onlinecube.ndim = 4 then
                        timer4d.tag :=  0
                      else
                        timer4d.interval :=  9999;
                      if timer4d.enabled = true then timer4d.enabled := false;
                      quirtviewerupdcoronal.frame.value    := -1;
                    end
                    else
                      if timer4d.enabled then timer4d.enabled := false;
                  end;",
// Sentence 292
                  "procedure tform1.bitbtnfwd4dclick(sender: tobject);
                  var
                    nf : integer;
                  begin
                    reversemotion.value := 0;
                    if timer4d.enabled = true then timer4d.enabled := false;
                    if (onlinecube.ndim\<\>4) and (referencecube.ndim\<\>4) then exit;
                    nf := onlinecube.dimensions[3];
                    if nf \< 1 then exit;
                    if radiobuttoncurrentframe.checked and (quirtviewerupdcoronal.frame.value = nf-1) then exit;
                   quirtviewerupdcoronal.frame.value := (quirtviewerupdcoronal.frame.value + 1) mod nf;
                  end;",
// Sentence 293
                  "procedure tform1.bitbtnback4dclick(sender: tobject);
                  var
                    nf : integer;
                    i : integer;
                  begin
                    reversemotion.value := 0;
                    if timer4d.enabled = true then timer4d.enabled := false;
                    if (onlinecube.ndim\<\>4) and (referencecube.ndim\<\>4) then exit;
                    nf := onlinecube.dimensions[3];
                    if nf \< 1 then exit;
                    if (quirtviewerupdcoronal.frame.value \<= 0) then i := 9
                    else i := (quirtviewerupdcoronal.frame.value - 1) mod nf;
                    quirtviewerupdcoronal.frame.value    := i;
                  end;",
// Sentence 294
                  "procedure tform1.bitbtnaverage4dclick(sender: tobject);
                  begin
                    quirtviewerupdcoronal.frame.value := -1;
                    timer4d.enabled := false;
                  end;",
// Sentence 295
                  "procedure tform1.buttonstopstep4dclick(sender: tobject);
                  var average : boolean;
                  begin
                    if ((getkeystate(vk_lshift) or getkeystate(vk_rshift)) and $8000)\<\>0 then
                      average := true
                    else
                      average := false;
                    stopstep4d(average);
                  end;",
// Sentence 296
                  "procedure tform1.stopstep4d(average : boolean = false);
                  begin
                    if average then
                    begin
                      if onlinecube.ndim = 4 then
                        timer4d.tag :=  0
                      else
                        timer4d.interval :=  9999;
                      if timer4d.enabled = true then timer4d.enabled := false;
                      quirtviewerupdcoronal.frame.value    := -1;
                    end
                    else if timer4d.enabled then timer4d.enabled := false
                    else                    timer4dtimer(self);
                  end;",
// Sentence 297
                  "procedure tform1.buttonreconstructmousedown(sender: tobject;
                    button: tmousebutton; shift: tshiftstate; x, y: integer);
                  begin
                  end;",
// Sentence 298
                  "procedure tform1.batchrecon(sender: tobject);
                  begin
                  end;",
// Sentence 299
                  "procedure tform1.batchmatch(sender: tobject);
                  begin
                  end;",
// Sentence 300
                  "function tform1.simplex2functionevaluation(sender: tobject;
                    evalpoint: array of double): double;
                  begin
                   result := 0;
                  end;",
// Sentence 301
                  "procedure tform1.checkboxrecordformclick(sender: tobject);
                  var s : tsavedialog;
                      avifps: integer;
                      formimage: tbitmap;
                      pixmap: tavsfield;
                      i: integer;
                  begin
                    if checkboxrecordform.checked then
                    begin
                      avihandle := -1;
                      s := tsavedialog.create(self);
                      s.filter := saveasfilter_movie;
                      s.options := [ofoverwriteprompt, ofnochangedir];
                      s.defaultext := \'avi\';
                      if s.execute then
                      begin
                        avifps := strtointdef(inputbox(\'frame rate\', \'fps\', inttostr(5)), 5);
                        formimage := getformimage;
                        formimage.pixelformat := pf24bit;
                        pixmap := tavsfield.createas(\'field 2d 3-vector byte\', [formimage.width, formimage.height]);
                        for i := 0 to formimage.height - 1 do
                          move( formimage.scanline[i]^,
                            pchar(cardinal(pixmap.data)+ cardinal(i * formimage.width * 3))^, formimage.width * 3);
                        formimage.free;
                        avi_creat(pixmap, avihandle, s.filename, avifps, \'mp42\');
                        pixmap.free;
                        avicount := 1;
                      end
                      else
                        checkboxrecordform.checked := false;
                    end
                    else
                    begin
                      if avihandle\>=0 then avi_close(avihandle);
                      avihandle := -1;
                    end;
                  end;",
// Sentence 302
                  "procedure tform1.buttonsetcorrectionreferencepointclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenucorrectionreferencepoint.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;",
// Sentence 303
                  "procedure tform1.updatecorrectionreferencepoint(sender: tobject;
                    var unchanged: boolean);
                  var x, y, z: single;
                      s: string;
                      i: integer;
                      dots, index, lut: tavsfield;
                  begin
                    case strtoint(correctionreferencepoint.debugname) of
                      0: begin
                         field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                           correctionreferencepoint.coordinate[0,0] := 0;
                           correctionreferencepoint.coordinate[1,0] := 0;
                           correctionreferencepoint.coordinate[2,0] := 0;
                           refpointatisocenter1.checked := true;
                           refpointatcenterofclipbox1.checked := false;
                           refpointatcenterofmask1.checked := false;
                           refpointatmarker.checked := false;
                           refpointatcenterofdelineation.checked := false;
                           correctionreferencepointstructure := \'\';
                           s := corr_ref_isoc;
                         end;
                      1: begin
                           if not unchanged then
                           begin
                             if clipbox[1].empty then exit;
                             field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                             correctionreferencepoint.coordinate[0,0] := (clipbox[1].getvalue([0]) + clipbox[1].getvalue([1]))/2;
                             correctionreferencepoint.coordinate[1,0] := (clipbox[1].getvalue([2]) + clipbox[1].getvalue([3]))/2;
                             correctionreferencepoint.coordinate[2,0] := (clipbox[1].getvalue([4]) + clipbox[1].getvalue([5]))/2;
                           end;
                           refpointatisocenter1.checked := false;
                           refpointatcenterofclipbox1.checked := true;
                           refpointatcenterofmask1.checked := false;
                           refpointatmarker.checked := false;
                           refpointatcenterofdelineation.checked := false;
                           correctionreferencepointstructure := \'\';
                           s := corr_ref_clipbox;
                         end;
                      2: begin
                           if not unchanged then
                           begin
                             field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                             if quirtviewerupdcoronal.markerdots[1].empty then
                             begin
                               correctionreferencepoint.coordinate[0,0] := 0;
                               correctionreferencepoint.coordinate[1,0] := 0;
                               correctionreferencepoint.coordinate[2,0] := 0;
                               s := corr_ref_marker_ns;
                             end
                             else
                             begin
                               correctionreferencepoint.coordinate[0,0] := quirtviewerupdcoronal.markerdots[1].coordinate[0,0];
                               correctionreferencepoint.coordinate[1,0] := quirtviewerupdcoronal.markerdots[1].coordinate[1,0];
                               correctionreferencepoint.coordinate[2,0] := quirtviewerupdcoronal.markerdots[1].coordinate[2,0];
                               s := corr_ref_marker;
                             end;
                           end
                           else
                           begin
                             x := correctionreferencepoint.coordinate[0,0];
                             y := correctionreferencepoint.coordinate[1,0];
                             z := correctionreferencepoint.coordinate[2,0];
                             if quirtviewerupdcoronal.markerdots[1].empty then s := corr_ref_marker_ns
                             else if (x = quirtviewerupdcoronal.markerdots[1].coordinate[0,0]) and
                                (y = quirtviewerupdcoronal.markerdots[1].coordinate[1,0]) and
                                (z = quirtviewerupdcoronal.markerdots[1].coordinate[2,0]) then
                                 s := corr_ref_marker
                             else s := corr_ref_marker_ch
                           end;
                           refpointatisocenter1.checked := false;
                           refpointatcenterofclipbox1.checked := false;
                           refpointatcenterofmask1.checked := false;
                           refpointatmarker.checked := true;
                           refpointatcenterofdelineation.checked := false;
                           correctionreferencepointstructure := \'\';
                         end;
                      3: begin
                           if not unchanged then
                           begin
                             dots  := tavsfield.create;
                             index := tavsfield.create;
                             lut   := tavsfield.create;
                             if not delineationdotslut.empty and (correctionreferencepointstructure\<\>\'\')then
                             for i:=0 to delineationdotslut.dimensions[0]-1 do
                             begin
                               dil_get_name(delineationdotslut, s, i);
                               if s=correctionreferencepointstructure then
                                 dil_select(delineationdots, delineationindex, delineationdotslut, dots, index, lut, i);
                             end;
                             x := 0; y:=0; z:=0;
                             field_center(dots, x, y, z, s);
                             correctionreferencepoint.coordinate[0,0] := x;
                             correctionreferencepoint.coordinate[1,0] := y;
                             correctionreferencepoint.coordinate[2,0] := z;
                             if dots.empty then
                             begin
                               showmessage(delineation_warning);
                               refpointatisocenter1.checked := true;
                               refpointatcenterofdelineation.checked := false;
                             end
                             else
                             begin
                               refpointatcenterofdelineation.checked := true;
                               dotxfm(correctionreferencepoint, reference_to_machine, correctionreferencepoint);
                             end;
                             dots.free;
                             index.free;
                             lut.free;
                           end
                           else
                             refpointatcenterofdelineation.checked := true;
                           s := corr_ref_delinea;
                           refpointatisocenter1.checked := false;
                           refpointatcenterofclipbox1.checked := false;
                           refpointatcenterofmask1.checked := false;
                           refpointatmarker.checked := false;
                         end;
                      4: begin
                           if not unchanged then
                           begin
                             mask_cog[1].make;
                             if mask_cog[1].coordinate[0,0]\<-9998 then exit;
                             field_create(correctionreferencepoint, \'field 1d 3-space irregular 10-vector byte\', 1);
                             correctionreferencepoint.coordinate[0,0] := mask_cog[1].coordinate[0,0];
                             correctionreferencepoint.coordinate[1,0] := mask_cog[1].coordinate[1,0];
                             correctionreferencepoint.coordinate[2,0] := mask_cog[1].coordinate[2,0];
                           end;
                           refpointatisocenter1.checked := false;
                           refpointatcenterofclipbox1.checked := false;
                           refpointatcenterofmask1.checked := true;
                           refpointatmarker.checked := false;
                           refpointatcenterofdelineation.checked := false;
                           correctionreferencepointstructure := \'\';
                           s := corr_ref_mask;
                         end;
                    end;
                    correctionreferencepoint.setvalue([0, 0], ord(\'c\'));
                    correctionreferencepoint.setvalue([0, 1], 0);
                    correctionreferencepoint.setvalue([0, 2], 255);
                    correctionreferencepoint.setvalue([0, 3], 255);
                    correctionreferencepoint.setvalue([0, 4], ord(\'y\'));
                    correctionreferencepoint.setvalue([0, 5],  50);
                    correctionreferencepoint.setvalue([0, 6], ord(\'s\'));
                    correctionreferencepoint.setvalue([0, 7], ord(\'*\'));
                    quirtviewerupdcoronal.text[3].value := #27+#1+chr(255)+chr(255)+s;
                      if unchanged then
                        correctionreferencepoint.ischangedby := nil
                      else
                        correctionreferencepoint.ischangedby := self;
                    unchanged := true;
                  end;",
// Sentence 304
                  "procedure tform1.refpointatisocenter1click(sender: tobject);
                  var b:boolean;
                  begin
                    correctionreferencepoint.debugname := \'0\';
                    b := false;
                    updatecorrectionreferencepoint(nil, b);
                    referencedatachanged := true;
                  end;",
// Sentence 305
                  "procedure tform1.refpointatcenterofclipbox1click(sender: tobject);
                  var b:boolean;
                  begin
                    correctionreferencepoint.debugname := \'1\';
                    b := false;
                    updatecorrectionreferencepoint(nil, b);
                    referencedatachanged := true;
                  end;",
// Sentence 306
                  "procedure tform1.refpointatcenterofmaskclick(sender: tobject);
                  var b:boolean;
                  begin
                    correctionreferencepoint.debugname := \'4\';
                    b := false;
                    updatecorrectionreferencepoint(nil, b);
                    referencedatachanged := true;
                  end;",
// Sentence 307
                  "procedure tform1.refpointatmarkerclick(sender: tobject);
                  var b:boolean;
                  begin
                    correctionreferencepoint.debugname := \'2\';
                    b := false;
                    updatecorrectionreferencepoint(nil, b);
                    referencedatachanged := true;
                  end;",
// Sentence 308
                  "procedure tform1.refpointatcenterofdelineationclick(sender: tobject);
                  begin
                  end;",
// Sentence 309
                  "procedure tform1.menustructurechoiceclick(sender: tobject);
                  var b:boolean;
                  begin
                    correctionreferencepointstructure := striphotkey((sender as tmenuitem).caption);
                    correctionreferencepoint.debugname := \'3\';
                    b := false;
                    updatecorrectionreferencepoint(nil, b);
                    referencedatachanged := true;
                  end;",
// Sentence 310
                  "procedure tform1.buttonconverttocorrectionclick(sender: tobject);
                  begin
                  end;",
// Sentence 311
                  "procedure tform1.buttonelektadismissclick(sender: tobject);
                  var i:  tqinifile;
                      initials : string;
                      outfile: string;
                      save: tcursor;
                  begin
                    if reconstructing then
                    begin
                      stopreconstructing := true;
                      exit;
                    end;
                    if match2inprogress then
                    begin
                      if assigned(m) then m.stop;
                      match2inprogress := false;
                      exit;
                    end;
                    if (avlstate in [3, 4]) and (sender=buttonelektaaccept) and (not correctionbyhexapod) then
                    begin
                      if (editrotationlr.text \<\> \'0.0\') or
                         (editrotationcc.text \<\> \'0.0\') or
                         (editrotationap.text \<\> \'0.0\') or
                         (labelcomputedlat2.caption = \'-\') then
                      begin
                        showmessage(unacceptable_corr);
                        exit;
                      end;
                    end;
                    if (avlstate in [1]) and (sender=buttonelektaaccept) and (comboboxregistrationprotocol.itemindex in [ 2, 3, 4]) then
                    begin
                      if (safestrtofloat(colorstringgrid2.cells[1,1]) \>= safestrtofloat(colorstringgrid2.cells[2,1])) or
                         (safestrtofloat(colorstringgrid2.cells[1,2]) \>= safestrtofloat(colorstringgrid2.cells[2,2])) or
                         (safestrtofloat(colorstringgrid2.cells[1,3]) \>= safestrtofloat(colorstringgrid2.cells[2,3])) or
                         (safestrtofloat(colorstringgrid2.cells[1,5]) \>= safestrtofloat(colorstringgrid2.cells[2,5])) or
                         (safestrtofloat(colorstringgrid2.cells[1,6]) \>= safestrtofloat(colorstringgrid2.cells[2,6])) or
                         (safestrtofloat(colorstringgrid2.cells[1,7]) \>= safestrtofloat(colorstringgrid2.cells[2,7])) then
                      begin
                        if messagedlg(unacceptable_clipboxlimits, mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                          exit;
                      end;
                    end;
                    if (avlstate in [1]) and (sender=buttonelektaaccept) and (comboboxregistrationprotocol.itemindex in [ 2, 3, 5]) then
                    begin
                      if (safestrtofloat(colorstringgrid3.cells[1,1]) \>= safestrtofloat(colorstringgrid3.cells[2,1])) or
                         (safestrtofloat(colorstringgrid3.cells[1,2]) \>= safestrtofloat(colorstringgrid3.cells[2,2])) or
                         (safestrtofloat(colorstringgrid3.cells[1,3]) \>= safestrtofloat(colorstringgrid3.cells[2,3])) or
                         (safestrtofloat(colorstringgrid3.cells[1,5]) \>= safestrtofloat(colorstringgrid3.cells[2,5])) or
                         (safestrtofloat(colorstringgrid3.cells[1,6]) \>= safestrtofloat(colorstringgrid3.cells[2,6])) or
                         (safestrtofloat(colorstringgrid3.cells[1,7]) \>= safestrtofloat(colorstringgrid3.cells[2,7])) then
                      begin
                        if messagedlg(unacceptable_masklimits, mtconfirmation, [mbyes, mbno], 0) \<\> mryes then
                          exit;
                      end;
                    end;
                    if (avlstate in [3, 4]) and (sender=buttonelektaaccept) and (correctionbyhexapod) and (not b6dofsystemhascrp) then
                    begin
                      if correctionreferencepoint.coordinate[0, 0]*correctionreferencepoint.coordinate[0, 0] +
                         correctionreferencepoint.coordinate[1, 0]*correctionreferencepoint.coordinate[1, 0] +
                         correctionreferencepoint.coordinate[2, 0]*correctionreferencepoint.coordinate[2, 0] \> 0.1 then
                      begin
                        if messagedlg(format(warning_hexapodisoc, [nameof6dofsystem]), mtconfirmation, [mbok, mbcancel], 0) \<\> mrok then
                          exit;
                      end;
                    end;
                    if (avlstate in [1]) and (sender=buttonelektaaccept) and (correctionbyhexapod) and (not b6dofsystemhascrp) then
                    begin
                      if correctionreferencepoint.coordinate[0, 0]*correctionreferencepoint.coordinate[0, 0] +
                         correctionreferencepoint.coordinate[1, 0]*correctionreferencepoint.coordinate[1, 0] +
                         correctionreferencepoint.coordinate[2, 0]*correctionreferencepoint.coordinate[2, 0] \> 0.1 then
                      begin
                        showmessage(format(error_hexapodisoc, [nameof6dofsystem]));
                        exit;
                      end;
                    end;
                    if ((avlstate = -1) or (avlstate in [1, 3, 4])) and referencemask.empty and (comboboxregistrationprotocol.itemindex in [1,2,3,5]) and (sender=buttonelektaaccept) then
                    begin
                      showmessage(unacceptable_emptymask);
                      exit;
                    end;
                    if (sender=buttonelektaaccept)and
                       (strcomp(pchar(confirm_caption),pchar(buttonelektaaccept.caption))\<\>0) and
                       (quirtviewerupdcoronal.text[2].value \<\> #27 + #1 + chr(255) + #1 + text_noprevious)
                       and (avlstate in [0, 3, 4])then
                      begin
                        if messagedlg(warning_regoverwrite  + copy(quirtviewerupdcoronal.text[2].value, 5, 99),
                                      mtconfirmation, [mbok, mbcancel], 0) \<\> mrok then
                        exit;
                      end;
                     if (sender=buttonelektaaccept)and
                       (referenceapprovalby \<\> \'\')
                       and (avlstate in [1])then
                      begin
                        if messagedlg(warning_refoverwrite  + referenceapprovalby,
                                      mtconfirmation, [mbok, mbcancel], 0) \<\> mrok then
                        exit;
                      end;
                      if (sender=buttonelektaaccept) and (avlstate in [1,3,4]) and (not synergymode) then
                    begin
                      if not inputquery(signature_dlg, initials_dlg, initials) then
                        exit
                      else if (initials=\'\') or (initials[1]=\'\'\'\') or (initials[1]=\'\"\') then
                      begin
                        repeat
                          if not inputquery(signature_dlg, initials_dlg, initials) then
                            exit
                        until (initials\<\>\'\') and (initials[1]\<\>\'\'\'\') and (initials[1]\<\>\'\"\');
                      end;
                    end;
                    if (avlstate in [3, 4]) and (sender=buttonelektaaccept) and (correctionbyhexapod) and (b6dofsystemhascrp) then
                    begin
                      showmessage(format(\'copy this data to hexapod: %s %s %s %s %s %s %.2f %.2f %.2f\',
                                  [edittranslationlr.text,edittranslationcc.text,edittranslationap.text,
                                   editrotationlr.text,editrotationcc.text,editrotationap.text,
                                   correctionreferencepoint.coordinate[0, 0], correctionreferencepoint.coordinate[1, 0], correctionreferencepoint.coordinate[2, 0]]));
                    end;
                    save := screen.cursor;
                    screen.cursor := crhourglass;
                    if (avlstate in [1,3,4]) and (sender=buttonelektaaccept) then
                    begin
                       case avlstate of
                       1: savereferencedata(elektaref);
                       3: savereferencedata(elektaalign);
                       4: savereferencedata(elektareconalign);
                       end;
                    end;
                    screen.cursor := save;
                    outfile := paramstr2 + \'.xvi\';
                    try
                      if fileexists(outfile) then
                        setfileattributes(pchar(outfile), file_attribute_normal);
                      i := tqinifile.create(outfile);
                    except
                       showmessage(\'except_exit_message\');
                       application.terminate;
                       exit;
                    end;
                    if sender\<\>buttonelektaaccept then
                    begin
                      i.writebool(\'status\', \'completionstatus\', true);
                      i.writebool(\'status\', \'approvalstatus\', sender\<\>buttonelektadismiss);
                      if avlstate in [0, 1] then
                      begin
                        try
                          application.terminate;
                        except
                        end;
                        i.free;
                        exit;
                      end;
                      if avlstate in [0, 3, 4] then
                      begin
                        try
                        except
                        end;
                        i.free;
                        application.terminate;
                        exit;
                      end;
                      if avlstate in [5] then
                      begin
                        i.free;
                        application.terminate;
                        exit;
                      end;
                    end;
                   case avlstate of
                      1: savesettings(i, elektaref, initials,true);
                      2: savesettings(i, elektarecon, initials,true);
                      3: savesettings(i, elektaalign, initials, true);
                      4: savesettings(i, elektareconalign, initials, true);
                      6: savesettings(i, elektarecon, initials, true);
                      else labelelektamode.caption := mode_unknown;
                    end;
                    writematchresultlogfile(initials);
                    i.writebool(\'status\', \'completionstatus\', true);
                    i.writebool(\'status\', \'approvalstatus\', sender\<\>buttonelektadismiss);
                    i.free;
                    application.terminate;
                    exit;
                  end;",
// Sentence 312
                  "procedure tform1.writematchresultlogfile(signature: string);
                  var f: textfile;
                      x0, y0, z0 : real;
                      sx, sy, sz : real;
                      activeclipbox : integer;
                  begin
                    if matchresultlogfile=\'\' then exit;
                    activeclipbox := 1;
                    x0 := (clipbox[activeclipbox].getvalue([0])+clipbox[activeclipbox].getvalue([1]))/2;
                    y0 := (clipbox[activeclipbox].getvalue([2])+clipbox[activeclipbox].getvalue([3]))/2;
                    z0 := (clipbox[activeclipbox].getvalue([4])+clipbox[activeclipbox].getvalue([5]))/2;
                      sx := abs(clipbox[activeclipbox].getvalue([0])-clipbox[activeclipbox].getvalue([1]));
                    sy := abs(clipbox[activeclipbox].getvalue([2])-clipbox[activeclipbox].getvalue([3]));
                    sz := abs(clipbox[activeclipbox].getvalue([4])-clipbox[activeclipbox].getvalue([5]));
                    if not fileexists(matchresultlogfile) then
                    begin
                      sysutils.forcedirectories(extractfilepath(matchresultlogfile));
                      assignfile(f, matchresultlogfile);
                      rewrite(f);
                      writeln(f, \'patientid\', #9,
                                 \'treatmentuid\', #9,
                                 \'scanuid\', #9,
                                 \'scandate\', #9,
                                 \'signature\', #9,
                                 \'correctiontranslationlr\', #9,
                                 \'correctiontranslationcc\', #9,
                                 \'correctiontranslationap\', #9,
                                 \'correctionrotationlr\', #9,
                                 \'correctionrotationcc\', #9,
                                 \'correctionrotationap\', #9,
                                 \'alignmenttranslationlr\', #9,
                                 \'alignmenttranslationcc\', #9,
                                 \'alignmenttranslationap\', #9,
                                 \'alignmentrotationlr\', #9,
                                 \'alignmentrotationcc\', #9,
                                 \'alignmentrotationap\', #9,
                                 \'correctionmethod\', #9,
                                 \'couchshiftlat\', #9,
                                 \'couchshiftlong\', #9,
                                 \'couchshiftheight\', #9
                                 , \'correctionrefpointpositionlr\', #9
                                 , \'correctionrefpointpositioncc\', #9
                                 , \'correctionrefpointpositionap\', #9
                                 ,\'clipbox_nr\', #9
                                 ,\'clipboxpositionlr_(ref)\', #9
                                 ,\'clipboxpositioncc_(ref)\', #9
                                 ,\'clipboxpositionap_(ref)\', #9
                                 ,\'clipboxsizelr_(ref)\', #9
                                 ,\'clipboxsizecc_(ref)\', #9
                                 ,\'clipboxsizeap_(ref)\', #9
                                 ,\'match_date_time\', #9
                                 ,\'scantime\', #9
                                );
                    end
                    else
                    begin
                      assignfile(f, matchresultlogfile);
                      append(f);
                    end;
                      writeln(f, patientid, #9,
                                 treatmentuid, #9,
                                 scanuid, #9,
                                 scandate, #9,
                                 signature, #9,
                                 edittranslationlr.text, #9,
                                 edittranslationcc.text, #9,
                                 edittranslationap.text, #9,
                                 editrotationlr.text, #9,
                                 editrotationcc.text, #9,
                                 editrotationap.text, #9,
                                 edittranslationlr.imename, #9,
                                 edittranslationcc.imename, #9,
                                 edittranslationap.imename, #9,
                                 editrotationlr.imename, #9,
                                 editrotationcc.imename, #9,
                                 editrotationap.imename, #9,
                                 \'couchshift\', #9,
                                 labelcomputedlat2.caption, #9,
                                 labelcomputedlong2.caption, #9,
                                 labelcomputedheight2.caption, #9
                                 , format(\'%.3f\',[correctionreferencepoint.coordinate[0,0]]), #9
                                 , format(\'%.3f\',[correctionreferencepoint.coordinate[1,0]]), #9
                                 , format(\'%.3f\',[correctionreferencepoint.coordinate[2,0]]), #9
                                 , format(\'%d\',[activeclipbox]), #9
                                 , format(\'%.4f\',[x0]), #9
                                 , format(\'%.4f\',[y0]), #9
                                 , format(\'%.4f\',[z0]), #9
                                 , format(\'%.4f\',[sx]), #9
                                 , format(\'%.4f\',[sy]), #9
                                 , format(\'%.4f\',[sz]), #9
                                 , datetimetostr(now), #9
                              );
                    closefile(f);
                  end;",
// Sentence 313
                  "procedure tform1.convertmatchclick(sender: tobject);
                  begin
                  end;",
// Sentence 314
                  "procedure tform1.button3d2dclick(sender: tobject);
                  var
                    str1  : string;
                  begin
                    if not assigned(m) then
                      m := tmatch.create(self);
                    if m.active then
                    begin
                      button3d2d.caption := caption_nki3d2d;
                      m.stop;
                      exit;
                    end;
                    button3d2d.caption := caption_nkistop;
                    str1 := caption;
                    quirtviewerupdcoronal.interpolate.value := 0;
                    quirtviewerupdsagittal.interpolate.value := 0;
                    quirtviewerupdtransversal.interpolate.value := 0;
                    if online[1].data.ndim=2 then
                    begin
                      m.fixscan2 := true;
                      m.postprocess := true;
                      m.scan1 := reference[1].data;
                      m.transform1 := reference[1].tomachine;
                      online[1].clipbox[1].make;
                      field_cropwithbox(online[1].data, online[1].clipbox[1], m.scan2);
                      m.transform2 := online[1].tomachine;
                      online[2].clipbox[1].make;
                      field_cropwithbox(online[2].data, online[2].clipbox[1], m.scan3);
                      m.transform3 := online[2].tomachine;
                    end
                    else
                    begin
                      m.fixscan2 := false;
                      m.postprocess := false;
                      reference[1].clipbox[1].make;
                      field_cropwithbox(reference[1].data, reference[1].clipbox[1], m.scan1);
                      m.transform1 := reference[1].tomachine;
                      m.scan2      := online[1].data;
                      m.transform2 := online[1].tomachine;
                    end;
                    m.adjust2 := machine_to_machineadjust;
                    m.onlowerfuncval := matchlowerfuncval;
                    if (radiogroupmatchoptions.itemindex = 0) then m.transformtype := shift_rot
                    else if (radiogroupmatchoptions.itemindex = 2) then m.transformtype := shift_xz
                    else m.transformtype := shift;
                    m.start;
                    if not (m.state = finished_ok) then
                      showmessage(m.information);
                    progressbar3.position := 0;
                    caption := str1;
                    button3d2d.caption := caption_nki3d2d;
                    m.free;
                    m := nil;
                  end;",
// Sentence 315
                  "procedure tform1.matchlowerfuncval(sender: tobject);
                  begin
                    if assigned(m) then
                    begin
                      progressbar3.position := round (progressoffset + progressscale * progressbar3.max*(m.progress/100));
                        caption := m.information;
                      countmakes := 0;
                      quirtviewerupdsagittal.make;
                      quirtviewerupdcoronal.make;
                      quirtviewerupdtransversal.make;
                      timer1timer(timer1);
                      timer1.enabled := false;
                      timer1.enabled := true;
                      application.processmessages;
                    end;
                  end;",
// Sentence 316
                  "procedure tform1.visboneseg(online : boolean);
                  var n: integer;
                  begin
                    if ((pos(match_substring_seed, comboboxmaskmatch.text)\>0) and editmask.checked) then
                      n := 3
                    else
                      n := 1;
                    if online then
                    begin
                      chamferdotslutonline.setvalue([0, 0], 255);
                      chamferdotslutonline.setvalue([0, 1], 0);
                      chamferdotslutonline.setvalue([0, 2], 255);
                      chamferdotslutonline.setvalue([0, 3], 0);
                      chamferdotslutonline.setvalue([0, 4], 15);
                      quirtviewerupdcoronal.polydots[5] := chamferdotsonline;
                      quirtviewerupdsagittal.polydots[5] := chamferdotsonline;
                      quirtviewerupdtransversal.polydots[5] := chamferdotsonline;
                      quirtviewerupdcoronal.polylut[5] := chamferdotslutonline;
                      quirtviewerupdsagittal.polylut[5] := chamferdotslutonline;
                      quirtviewerupdtransversal.polylut[5] := chamferdotslutonline;
                    end
                    else
                    begin
                      chamferdotslutreference.setvalue([0, 0], 255);
                      chamferdotslutreference.setvalue([0, 1], 255 div n);
                      chamferdotslutreference.setvalue([0, 2],   0);
                      chamferdotslutreference.setvalue([0, 3], 255 div n);
                      chamferdotslutreference.setvalue([0, 4], 15);
                      quirtviewerupdcoronal.polydots[9] := chamferdotsreference;
                      quirtviewerupdsagittal.polydots[9] := chamferdotsreference;
                      quirtviewerupdtransversal.polydots[9] := chamferdotsreference;
                      quirtviewerupdcoronal.polylut[9] := chamferdotslutreference;
                      quirtviewerupdsagittal.polylut[9] := chamferdotslutreference;
                      quirtviewerupdtransversal.polylut[9] := chamferdotslutreference;
                    end;
                    if online then
                    begin
                      quirtviewerupdcoronal.polytransform[5] := online_to_machine;
                      quirtviewerupdsagittal.polytransform[5] := online_to_machine;
                      quirtviewerupdtransversal.polytransform[5] := online_to_machine;
                      quirtviewerupdcoronal.polyadjust[5] := machine_to_machineadjust;
                      quirtviewerupdsagittal.polyadjust[5] := machine_to_machineadjust;
                      quirtviewerupdtransversal.polyadjust[5] := machine_to_machineadjust;
                    end
                    else
                    begin
                      quirtviewerupdcoronal.polytransform[9] := reference_to_machine;
                      quirtviewerupdsagittal.polytransform[9] := reference_to_machine;
                      quirtviewerupdtransversal.polytransform[9] := reference_to_machine;
                      quirtviewerupdcoronal.polyadjust[9] := nil;
                      quirtviewerupdsagittal.polyadjust[9] := nil;
                      quirtviewerupdtransversal.polyadjust[9] := nil;
                    end;
                  end;",
// Sentence 317
                  "procedure tform1.matchclassbuttonclick(sender: tobject);
                  begin
                  end;",
// Sentence 318
                  "procedure tform1.acceptsingleframematch(sender: tobject);
                  var dummy  : tavsfield;
                      r, f      : integer;
                  begin
                    r := quirtviewerupdcoronal.activeclipbox.value-1;
                    f := quirtviewerupdcoronal.frame.value;
                    if r\<0 then r := 0;
                    if r\>=transform4d.dimensions[2] then exit;
                    if f\<0 then f := 0;
                    if f\>=transform4d.dimensions[3] then exit;
                    dummy := tavsfield.create;
                    field_inc_ndim(machine_to_machineadjust, dummy);
                    field_inc_ndim(dummy, dummy);
                    field_insert2(transform4d, dummy, transform4d, 0, 0, r, f);
                    dummy.free;
                    showmessage(format(message_nkimatchupdroi, [r+1, f]));
                  end;",
// Sentence 319
                  "procedure tform1.externalmatch(region: integer; frame: integer; matchmode: tmatchmode; style: integer);
                  var
                    v2, eq, i, j:  integer;
                    f, g, rp, dum1, dum2 : tavsfield;
                    s, str1 : string;
                    save_cursor: tcursor;
                    tprerot,toldadjust, tbestadjust, t1 : ttransform;
                    k, dumval : integer;
                    endcfvalue         : double;
                    segmenterror : boolean;
                    fl: textfile;
                    clipboxmask: tavsfield;
                    clipboxxfm: tavsfield;
                  begin
                    if not assigned(m) then
                      m := tmatch.create(self);
                    if (avlstate=1003) and enabletestmode then
                    begin
                      m.optimizer := plotcf;
                      if fileexists(getfullinifilename(\'plotcf.dat\')) then
                      begin
                        field_create(m.plotpoints, \'field 1d 6-vector double\', 10000);
                        assignfile(fl, getfullinifilename(\'plotcf.dat\'));
                        reset(fl);
                        i := 0;
                        while not eof(fl) do
                        begin
                          readln(fl, s);
                          for j:=0 to m.plotpoints.veclen-1 do
                            m.plotpoints.setvalue([i, j], valuefromstr(s, j+1, -1));
                          inc(i);
                        end;
                        field_crop(m.plotpoints, m.plotpoints, 0, i-1);
                        closefile(fl);
                      end
                      else
                      begin
                        field_create(m.plotpoints, \'field 1d 6-vector double\', 600);
                        for i:=0 to 99 do
                        begin
                          m.plotpoints.setvalue([i,     0], (i-50)/25);
                          m.plotpoints.setvalue([i+100, 1], (i-50)/25);
                          m.plotpoints.setvalue([i+200, 2], (i-50)/25);
                          m.plotpoints.setvalue([i+300, 3], (i-50)/2.5);
                          m.plotpoints.setvalue([i+400, 4], (i-50)/2.5);
                          m.plotpoints.setvalue([i+500, 5], (i-50)/2.5);
                        end;
                      end;
                    end;
                    segmenterror := false;
                    if m.active then
                    begin
                      matchclassbutton.caption := caption_nkimatchclass;
                      buttonmatch.caption := startmatch_caption;
                      m.stop;
                      matchinprogress := false;
                      exit;
                    end;
                    if ( (region\>=nclipbox) and maskedreference.empty ) then
                    begin
                      showmessage(mask_error);
                      exit;
                    end;
                    if region\<nclipbox then
                      if clipbox[region+1].empty then
                    begin
                      showmessage(clipbox_error);
                      exit;
                    end;
                    save_cursor := screen.cursor;
                    screen.cursor := crhourglass;
                    matchclassbutton.caption := caption_nkistop;
                    buttonmatch.caption := stopmatch_caption;
                    str1 :=   caption;
                    matchinprogress := true;
                    f := tavsfield.create;
                    g := tavsfield.create;
                    rp := tavsfield.createas(\'field 1d irregular 3-space\', [1]);
                    m.transform1 := reference[1].tomachine;
                    m.transform2 := online[1].tomachine;
                    m.adjust2    := machine_to_machineadjust;
                    m.onlowerfuncval := matchlowerfuncval;
                    m.excludezeros          := true;
                    m.forcefastinterpolator := true;
                    m.fixscan2              := false;
                    if style in [0] then
                    begin
                      m.transformtype := shift;
                      m.param1 := 0.001;
                    end
                    else if style in [1,2] then
                      m.transformtype := shift_rot
                    else if style in [3] then
                    begin
                      m.transformtype := rotate;
                      m.param1 := 0.001;
                      if not quirtviewerupdcoronal.markerdots[1].empty then
                      begin
                        rp.coordinate[0,0] := quirtviewerupdcoronal.markerdots[1].coordinate[0,0];
                        rp.coordinate[1,0] := quirtviewerupdcoronal.markerdots[1].coordinate[1,0];
                        rp.coordinate[2,0] := quirtviewerupdcoronal.markerdots[1].coordinate[2,0];
                      end
                      else
                      begin
                        rp.coordinate[0,0] := correctionreferencepoint.coordinate[0,0];
                        rp.coordinate[1,0] := correctionreferencepoint.coordinate[1,0];
                        rp.coordinate[2,0] := correctionreferencepoint.coordinate[2,0];
                      end;
                      m.rotationpoint1 := rp;
                    end
                    else
                    begin
                      f.free;
                      g.free;
                      exit;
                    end;
                    if online[1].data.ndim=4 then
                    begin
                      if frame\>=0 then
                        field_slice(online[1].data, g, -1, -1, -1, frame)
                      else
                      begin
                        if not phasehist.empty then
                          field_ortho_wghtsum(online[1].data, phasehist, g, field_ortho_wghtsum_udirection)
                        else
                          field_ortho_average(online[1].data, g, field_ortho_average_udirection);
                        field_to_short(g, g);
                      end;
                    end
                    else
                      field_copy(online[1].data, g);
                    if region\<nclipbox then s := comboboxclipboxmatch.text
                    else s := comboboxmaskmatch.text;
                    if region\<nclipbox then
                    begin
                      reference[1].clipbox[region+1].make;
                      field_cropwithbox(reference[1].data, reference[1].clipbox[region+1], f, 0);
                      online[1].clipbox[region+1].make;
                      field_cropwithbox(g, online[1].clipbox[region+1], g, 1);
                    end
                    else if region = nclipbox then
                    begin
                      maskedreference.make;
                      field_copy(maskedreference, f);
                      clipboxmask := tavsfield.create;
                      clipboxxfm := tavsfield.create;
                      field_findcropbox(maskedreference, clipboxmask);
                      cropbox_to_coords(clipboxmask, maskedreference, clipboxmask);
                      transform_math(maskedreferencetransform, machine_to_machineadjust, clipboxxfm, false, true);
                      transform_math(clipboxxfm, online[1].tomachine, clipboxxfm, false, true);
                      cropbox_transform(clipboxmask, clipboxxfm, clipboxmask);
                      field_cropwithbox(g, clipboxmask, g, 1);
                      clipboxmask.free;
                      clipboxxfm.free;
                    end;
                    if f.ndim=4 then
                    begin
                      field_ortho_average(f, f, field_ortho_average_udirection);
                      field_to_short(f, f);
                    end;
                    if matchmode=mmchamfer then
                    begin
                      if region\<nclipbox then s := comboboxclipboxmatch.text
                      else s := comboboxmaskmatch.text;
                      if (pos(match_substring_seed, s)\>0) then
                      begin
                        dum1 := tavsfield.create;
                        dum2 := tavsfield.create;
                        field_mrthreshold(f, dum1, dumval, v2, dum2, -1, 11, 1, 0.2, 100, 100, false, false);
                        dum1.free;
                        dum2.free;
                        v2 := v2 + (round(f.maximum) - v2) div 8;
                        createdotlist    (f, m.scan1, v2, false, 1);
                        if (m.scan1.dimensions[0]\<1) or (v2\<600) then segmenterror := true;
                        m.chamferrms := true;
                      end
                      else
                      begin
                        dum1 := tavsfield.create;
                        dum2 := tavsfield.create;
                        field_mrthreshold(f, dum1, dumval, v2, dum2, -1, 11, 1, 0.2, 100, 115, false, false);
                        dum1.free;
                        dum2.free;
                        createdotlist    (f, m.scan1, v2, false);
                        if (m.scan1.dimensions[0]\<1) or (v2\<600) then segmenterror := true;
                      end;
                      githreshold1 := v2;
                      if visualizebonesegmentation1.checked then
                      begin
                        chamferdotsreference.assign(m.scan1);
                        visboneseg(false);
                      end;
                      dum1 := tavsfield.create;
                      dum2 := tavsfield.create;
                      if (pos(match_substring_seed, s)\>0) then
                      begin
                        field_mrthreshold(g, dum1, dumval, v2, dum2, -1, 11, 1, 0.2, 100, 100, false, false);
                        v2 := v2 + (round(g.maximum) - v2) div 8;
                      end
                      else
                      begin
                        field_mrthreshold(g, dum1, dumval, v2, dum2, -1, 11, 1, 0.2, 100, 115, false, false);
                      end;
                      githreshold2 := v2;
                      dum1.free;
                      dum2.free;
                      if (v2 \>= g.maximum) or (v2\<600) then segmenterror := true;
                      createdistancemap(g, m.scan2, v2, false);
                      if visualizebonesegmentation1.checked then
                      begin
                        field_gtec(g, chamferdotsonline, v2);
                        fieldtrace(chamferdotsonline, chamferdotsonline, 1);
                        visboneseg(true);
                      end;
                      m.fixscan2 := true;
                    end
                    else
                    begin
                      field_resize(f, f, f.dimensions[0] div 70, f.dimensions[1] div 70, f.dimensions[2] div 70);
                      preprocessscan(f, m.scan1);
                      preprocessscan(g, m.scan2);
                    end;
                    if transform4d.empty then
                    begin
                      field_create(transform4d, \'field 4d float\', 4, 4, nclipbox*3, max(onlinecube.dimensions[3], 1));
                      field_setc(transform4d, transform4d, -1);
                      field_copy(transform4d, backuptransform4d);
                    end;
                    toldadjust  := ttransform.create;
                    toldadjust.assign(machine_to_machineadjust);
                    if not segmenterror then
                    begin
                      if style in [0,1,3] then
                        m.start
                      else
                      begin
                        tprerot     := ttransform.create;
                        tbestadjust := ttransform.create;
                        t1 := ttransform.create;
                        field_copy(machine_to_machineadjust, toldadjust);
                        endcfvalue := 0;
                        for k := -1 to 1 do
                        begin
                          if strcomp(pchar(matchclassbutton.caption), \'matchclass\')=0 then
                            break;
                          tprerot.makerotation(k*5, 0, 0);
                          if matchrotmark then
                          begin
                            t1.maketranslation(quirtviewerupdcoronal.markerdots[1].coordinate[0,0], quirtviewerupdcoronal.markerdots[1].coordinate[1,0], quirtviewerupdcoronal.markerdots[1].coordinate[2,0]);
                            tprerot.premultiply(t1);
                            t1.invert;
                            tprerot.postmultiply(t1);
                          end;
                          machine_to_machineadjust.assign(toldadjust);
                          machine_to_machineadjust.premultiply(tprerot);
                          m.start;
                          if m.endcfvalue \< endcfvalue then
                          begin
                            endcfvalue := m.endcfvalue;
                            tbestadjust.assign(machine_to_machineadjust);
                          end;
                        end;
                        machine_to_machineadjust.assign(tbestadjust);
                        tprerot.free;
                        tbestadjust.free;
                        t1.free;
                      end;
                    end;
                    if (matchmode=mmchamfer) and not segmenterror then
                    begin
                      if ((pos(match_substring_seed, s)\>0)  and (m.endcfvalue \> seedmatchdoubtthreshold)) or
                         ((pos(match_substring_seed, s)\<=0) and (m.endcfvalue \> bonematchdoubtthreshold)) then
                      begin
                        if showmatchresultsdetailsbone then
                        begin
                          if messagedlg(match_doubt1 + #13 + #13 + m.information + #13 + #13 + match_accept,
                            mtwarning, [mbyes, mbno], 0) \<\> mryes then
                          begin
                            machine_to_machineadjust.assign(toldadjust);
                            invalidatecorrection;
                          end
                        end
                        else
                          if messagedlg(match_doubt2 + #13 + match_accept, mtwarning, [mbyes, mbno], 0) \<\> mryes then
                          begin
                            machine_to_machineadjust.assign(toldadjust);
                            invalidatecorrection;
                            match2inprogress := false;
                          end;
                      end;
                    end;
                    field_compare_data(machine_to_machineadjust,toldadjust,eq);
                    if (eq\<\>1) then
                      externalmanualmatchto4d(frame, region);
                    if online[1].data.ndim\<\>4 then progressbar3.position := 0;
                    caption := str1;
                    matchclassbutton.caption := caption_nkimatchclass;
                    buttonmatch.caption := startmatch_caption;
                    if region\<nclipbox then
                      lastclipboxmatchresult := m.information
                    else
                      lastmaskmatchresult := m.information;
                    if (avlstate=1003) and enabletestmode then
                    begin
                      assignfile(fl, extractfilepath(application.exename)+scanuid+\'.res\');
                      if fileexists(extractfilepath(application.exename)+scanuid+\'.res\') then append(fl) else rewrite(fl);
                      writeln(fl, formatdatetime(\'yyyymmdd hh:mm:ss\', now), #9, region, #9, frame, #9, ord(matchmode), #9, style);
                      for i:=0 to m.plotpoints.dimensions[0]-1 do
                        writeln(fl, m.plotpoints.getvalue([i, 0]), #9,
                                    m.plotpoints.getvalue([i, 1]), #9,
                                    m.plotpoints.getvalue([i, 2]), #9,
                                    m.plotpoints.getvalue([i, 3]), #9,
                                    m.plotpoints.getvalue([i, 4]), #9,
                                    m.plotpoints.getvalue([i, 5]), #9,
                                    m.plotdata.getvalue([i]));
                      closefile(fl);
                    end;
                    m.free;
                    m := nil;
                    f.free;
                    g.free;
                    toldadjust.free;
                    rp.free;
                    matchinprogress := false;
                    screen.cursor  := save_cursor;
                    if segmenterror then
                    begin
                      if (pos(match_substring_seed, s)\>0) then str1 := segment_error_seed
                      else                                     str1 := segment_error_bone;
                      if region\>=nclipbox then str1 := format(str1, [segment_error_mask, segment_error_mask])
                      else                     str1 := format(str1, [segment_error_clipbox, segment_error_clipbox]);
                      showmessage(str1);
                      exit;
                    end;
                  end;",
// Sentence 320
                  "procedure tform1.tr2t(t: ttransform; crp: tavsfield);
                  var
                      p : tavsfield;
                      x, y, z : double;
                  begin
                      p := tavsfield.create;
                      t.invert;
                      dotxfm(crp, t, p);
                      x := p.coordinate[0,0] - crp.coordinate[0,0];
                      y := p.coordinate[1,0] - crp.coordinate[1,0];
                      z := p.coordinate[2,0] - crp.coordinate[2,0];
                      t.makeidentity;
                      t.maketranslation(x,y,z);
                      p.free;
                  end;",
// Sentence 321
                  "procedure tform1.externalconverttocorrection;
                  var t: ttransform;
                      p, crp: tavsfield;
                      x, y, z, v, w: double;
                      i, j, i1, i2: integer;
                      s: string;
                      nexhale: integer;
                      multiclip : boolean;
                  begin
                    x := 0;
                    y := 0;
                    z := 0;
                    w := 0;
                    clipboxlist.make;
                    multiclip := false;
                    if not clipbox[2].empty then
                    begin
                      v := 0;
                      for i :=1 to nclipbox do
                        if (clipboxlist.getvalue([i-1, 6])\<\>0) then v := v +1;
                      if v \> 1 then
                        multiclip := true;
                    end;
                    if alignmentmode.value=2 then begin i1:=2*nclipbox+1; i2:=2*nclipbox+1 end
                    else if (comboboxcorrectionprotocol.text = correction_from_clipbox) then begin i1:=1; i2:=nclipbox end
                    else begin i1:=nclipbox+1; i2:=2*nclipbox end;
                    if not ((alignmentmode.value in [0..2])) then
                      exit;
                    t := ttransform.create;
                    p := tavsfield.create;
                    crp := tavsfield.create;
                    for i:=i1 to i2 do
                      for j:=0 to max(onlinecube.dimensions[3]-1, 0) do
                    begin
                      if transform4d.empty then
                        t.assign(machine_to_machineadjust)
                      else
                      begin
                        if i-1 \>= transform4d.dimensions[2] then continue;
                        if j   \>= transform4d.dimensions[3] then continue;
                        field_slice(transform4d, t, -1, -1, i-1, j);
                      end;
                      field_copy(correctionreferencepoint, crp);
                      if ( ((comboboxcorrectionprotocol.text = correction_from_clipbox) and multiclip) or
                            (comboboxcorrectionprotocol.text \<\> correction_from_clipbox))  and (i\<=nclipbox) then
                      begin
                        if (not clipbox[i].empty) then
                        begin
                          crp.coordinate[0,0] := (clipbox[i].getvalue([0]) + clipbox[i].getvalue([1]))/2;
                          crp.coordinate[1,0] := (clipbox[i].getvalue([2]) + clipbox[i].getvalue([3]))/2;
                          crp.coordinate[2,0] := (clipbox[i].getvalue([4]) + clipbox[i].getvalue([5]))/2;
                        end;
                      end
                      else if (comboboxcorrectionprotocol.text = correction_from_clipbox) and (i=(nclipbox+1)) then
                      begin
                        mask_cog[1].make;
                        if mask_cog[1].coordinate[0,0] \> -9998 then
                        begin
                          crp.coordinate[0,0] := mask_cog[1].coordinate[0,0];
                          crp.coordinate[1,0] := mask_cog[1].coordinate[1,0];
                          crp.coordinate[2,0] := mask_cog[1].coordinate[2,0];
                        end;
                      end;
                      if correctionbyhexapod then
                        field_setc(crp, crp, 0, true);
                      nexhale := onlinecube.dimensions[3] div 8;
                      if (comboboxcorrectionprotocol.text = correction_from_mask_exh) then
                        if (j\>nexhale) and (j\<onlinecube.dimensions[3]-nexhale) then continue;
                      if t.getvalue([3,3])\<0 then continue;
                      t.invert;
                      dotxfm(crp, t, p);
                      p.coordinate[0,0] := p.coordinate[0,0] - crp.coordinate[0,0];
                      p.coordinate[1,0] := p.coordinate[1,0] - crp.coordinate[1,0];
                      p.coordinate[2,0] := p.coordinate[2,0] - crp.coordinate[2,0];
                      if i\<=nclipbox then v := clipboxlist.getvalue([i-1, 6])
                      else                v := 1;
                      if not phasehist.empty then v := v * phasehist.getvalue([j]);
                      x := x + v * p.coordinate[0,0];
                      y := y + v * p.coordinate[1,0];
                      z := z + v * p.coordinate[2,0];
                      w := w + v;
                      if transform4d.empty then break;
                    end;
                    if w\<\>0 then
                    begin
                      x := x/w;
                      y := y/w;
                      z := z/w;
                    end;
                    edittranslationlr.text := floattostrf(x, fffixed, 5, 2);
                    edittranslationcc.text := floattostrf(y, fffixed, 5, 2);
                    edittranslationap.text := floattostrf(z, fffixed, 5, 2);
                    if not correctionbyhexapod then
                    begin
                      editrotationlr.text := \'0.0\';
                      editrotationcc.text := \'0.0\';
                      editrotationap.text := \'0.0\';
                    end;
                    labelcomputedlat2.caption   := floattostrf(-x, fffixed, 5, complabprec);
                    labelcomputedlong2.caption  := floattostrf(-y, fffixed, 5, complabprec);
                    if iec_linear_convention in [0, 1, 3] then
                      labelcomputedheight2.caption:= floattostrf( z, fffixed, 5, complabprec)
                    else
                      labelcomputedheight2.caption:= floattostrf(-z, fffixed, 5, complabprec);
                    labelcomputedlat2.enabled := true;
                    labelcomputedlong2.enabled := true;
                    labelcomputedheight2.enabled := true;
                    if safestrtofloat(labelcomputedlat2.caption)\>0    then labelcomputedlat2.hint    := hint_right else labelcomputedlat2.hint    := hint_left;
                    if safestrtofloat(labelcomputedlong2.caption)\>0   then labelcomputedlong2.hint   := hint_in    else labelcomputedlong2.hint   := hint_out;
                    if iec_linear_convention in [0, 1, 3] then
                      if safestrtofloat(labelcomputedheight2.caption)\<0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down
                    else
                      if safestrtofloat(labelcomputedheight2.caption)\>0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down;
                    t.assign(online_to_machine);
                    t.premultiply(machine_to_machineadjust);
                    transform_math(t, reference_to_machine, t, false, true, false);
                    s := t.asstring;
                    for j:=1 to length(s) do
                    begin
                      if s[j]=#10 then s[j] := \' \';
                      if s[j]=#13 then s[j] := \' \';
                    end;
                    onlinetoreftransformmatched := s;
                    t.free;
                    p.free;
                    crp.free;
                    externalmanualmatchto4d(-1, nclipbox*2);
                    if ( (unpackregistration(-4, -1, s, s, s, s, s, s, s, false, true, false)\>0) and (comboboxregistrationprotocol.itemindex in [0,2,3,5]) ) or
                       ( (unpackregistration(nclipbox, -5, s, s, s, s, s, s, s, false, true, false)\>0) and (comboboxregistrationprotocol.itemindex in [1,2,3,5]) ) then
                    begin
                      alignmentmode.value := 2;
                      correctionapprovalby := \'\';
                    end
                    else
                    begin
                        alignmentmode.value := 3;
                      correctionapprovalby := \'*\';
                    end;
                    appliedcorrectionprotocol := comboboxregistrationprotocol.mappedtext;
                    appliedcorrectionfrom     := comboboxcorrectionprotocol.mappedtext;
                    appliedcorrectionby       := comboboxcorrectionby.mappedtext;
                    manualmatchactive := false;
                  end;",
// Sentence 322
                  "procedure tform1.weightedconverttocorrection(weight: single);
                  var t: ttransform;
                      p, crp: tavsfield;
                      x, y, z, v, w: double;
                      rx, ry, rz: double;
                      rrx, rry, rrz: single;
                      i, j, i1, i2: integer;
                      s: string;
                      nexhale: integer;
                      multiclip : boolean;
                  begin
                    x := 0;
                    y := 0;
                    z := 0;
                    w := 0;
                    rx:= 0;
                    ry:= 0;
                    rz:= 0;
                    clipboxlist.make;
                    i1:=1; i2:=nclipbox+1;
                    multiclip := false;
                    if not clipbox[2].empty then
                    begin
                      v := 0;
                      for i :=1 to nclipbox do
                        if (clipboxlist.getvalue([i-1, 6])\<\>0) then v := v +1;
                      if v \> 1 then
                        multiclip := true;
                    end;
                    t := ttransform.create;
                    p := tavsfield.create;
                    crp := tavsfield.create;
                    for i:=i1 to i2 do
                      for j:=0 to max(onlinecube.dimensions[3]-1, 0) do
                    begin
                      if transform4d.empty then
                        t.assign(machine_to_machineadjust)
                      else
                      begin
                        if i-1 \>= transform4d.dimensions[2] then continue;
                        if j   \>= transform4d.dimensions[3] then continue;
                        field_slice(transform4d, t, -1, -1, i-1, j);
                      end;
                      field_copy(correctionreferencepoint, crp);
                      if ((comboboxcorrectionprotocol.text \<\> correction_from_clipbox) or multiclip) and (i\<=nclipbox) then
                      begin
                        if (not clipbox[i].empty) then
                        begin
                          crp.coordinate[0,0] := (clipbox[i].getvalue([0]) + clipbox[i].getvalue([1]))/2;
                          crp.coordinate[1,0] := (clipbox[i].getvalue([2]) + clipbox[i].getvalue([3]))/2;
                          crp.coordinate[2,0] := (clipbox[i].getvalue([4]) + clipbox[i].getvalue([5]))/2;
                        end;
                      end
                      else if (comboboxcorrectionprotocol.text = correction_from_clipbox) and (i=(nclipbox+1)) then
                      begin
                        mask_cog[1].make;
                        if mask_cog[1].coordinate[0,0] \> -9998 then
                        begin
                          crp.coordinate[0,0] := mask_cog[1].coordinate[0,0];
                          crp.coordinate[1,0] := mask_cog[1].coordinate[1,0];
                          crp.coordinate[2,0] := mask_cog[1].coordinate[2,0];
                        end;
                      end;
                      if correctionbyhexapod then
                        field_setc(crp, crp, 0, true);
                      nexhale := onlinecube.dimensions[3] div 8;
                      if (comboboxcorrectionprotocol.text = correction_from_mask_exh) then
                        if (j\>nexhale) and (j\<onlinecube.dimensions[3]-nexhale) then continue;
                      if t.getvalue([3,3])\<0 then continue;
                      t.invert;
                      dotxfm(crp, t, p);
                      t.getrotationafterscaling(rrx, rry, rrz);
                      rrx := -rrx;
                      rry := -rry;
                      rrz := -rrz;
                      p.coordinate[0,0] := p.coordinate[0,0] - crp.coordinate[0,0];
                      p.coordinate[1,0] := p.coordinate[1,0] - crp.coordinate[1,0];
                      p.coordinate[2,0] := p.coordinate[2,0] - crp.coordinate[2,0];
                      if i\<=nclipbox then v := clipboxlist.getvalue([i-1, 6]) * (1-weight)
                      else                v := 1                              * weight;
                      if not phasehist.empty then v := v * phasehist.getvalue([j]);
                      x := x + v * p.coordinate[0,0];
                      y := y + v * p.coordinate[1,0];
                      z := z + v * p.coordinate[2,0];
                      rx := rx + v * rrx;
                      ry := ry + v * rry;
                      rz := rz + v * rrz;
                      w := w + v;
                      if transform4d.empty then break;
                    end;
                    if w\<\>0 then
                    begin
                      x := x/w;
                      y := y/w;
                      z := z/w;
                      rx := rx/w;
                      ry := ry/w;
                      rz := rz/w;
                    end;
                    if colorstringgrid1.cellprops[3,1].box.checked then edittranslationlr.text := floattostrf(x, fffixed, 5, 2);
                    if colorstringgrid1.cellprops[3,2].box.checked then edittranslationcc.text := floattostrf(y, fffixed, 5, 2);
                    if colorstringgrid1.cellprops[3,3].box.checked then edittranslationap.text := floattostrf(z, fffixed, 5, 2);
                    if correctionbyhexapod then
                    begin
                      editrotationlr.text := \'0.0\';
                      editrotationcc.text := \'0.0\';
                      editrotationap.text := \'0.0\';
                    end
                    else
                    begin
                      if not iec_angle_convention then
                      begin
                        if colorstringgrid1.cellprops[3,4].box.checked then editrotationlr.text := floattostrf( rx, fffixed, 5, 1);
                        if colorstringgrid1.cellprops[3,5].box.checked then editrotationcc.text := floattostrf(-ry, fffixed, 5, 1);
                        if colorstringgrid1.cellprops[3,6].box.checked then editrotationap.text := floattostrf( rz, fffixed, 5, 1);
                      end
                      else
                      begin
                        if colorstringgrid1.cellprops[3,4].box.checked then
                        begin
                          if rx\>-0.05 then
                            editrotationlr.text := floattostrf( rx, fffixed, 5, 1)
                          else
                            editrotationlr.text := floattostrf( rx + 360, fffixed, 5, 1);
                        end;
                        if colorstringgrid1.cellprops[3,5].box.checked then
                        begin
                          if ry\<0.05 then
                            editrotationcc.text := floattostrf(-ry, fffixed, 5, 1)
                          else
                            editrotationcc.text := floattostrf(-ry + 360, fffixed, 5, 1);
                        end;
                        if colorstringgrid1.cellprops[3,6].box.checked then
                        begin
                          if rz\>-0.05 then
                            editrotationap.text := floattostrf( rz, fffixed, 5, 1)
                          else
                            editrotationap.text := floattostrf( rz + 360, fffixed, 5, 1);
                        end;
                      end;
                    end;
                    machine_to_machineadjust.make;
                    if colorstringgrid1.cellprops[3,1].box.checked then
                      labelcomputedlat2.caption   := floattostrf(-x, fffixed, 5, complabprec);
                    if colorstringgrid1.cellprops[3,2].box.checked then
                      labelcomputedlong2.caption  := floattostrf(-y, fffixed, 5, complabprec);
                    if colorstringgrid1.cellprops[3,3].box.checked then
                    begin
                      if iec_linear_convention in [0, 1, 3] then
                        labelcomputedheight2.caption:= floattostrf( z, fffixed, 5, complabprec)
                      else
                        labelcomputedheight2.caption:= floattostrf(-z, fffixed, 5, complabprec);
                    end;
                    if safestrtofloat(labelcomputedlat2.caption)\>0    then labelcomputedlat2.hint    := hint_right else labelcomputedlat2.hint    := hint_left;
                    if safestrtofloat(labelcomputedlong2.caption)\>0   then labelcomputedlong2.hint   := hint_in    else labelcomputedlong2.hint   := hint_out;
                    if iec_linear_convention in [0, 1, 3] then
                      if safestrtofloat(labelcomputedheight2.caption)\<0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down
                    else
                      if safestrtofloat(labelcomputedheight2.caption)\>0 then labelcomputedheight2.hint := hint_up    else labelcomputedheight2.hint := hint_down;
                    t.assign(online_to_machine);
                    t.premultiply(machine_to_machineadjust);
                    transform_math(t, reference_to_machine, t, false, true, false);
                    s := t.asstring;
                    for j:=1 to length(s) do
                    begin
                      if s[j]=#10 then s[j] := \' \';
                      if s[j]=#13 then s[j] := \' \';
                    end;
                    onlinetoreftransformmatched := s;
                    t.free;
                    p.free;
                    crp.free;
                    externalmanualmatchto4d(-1, nclipbox*2);
                  end;",
// Sentence 323
                  "procedure tform1.externalmanualmatchto4d(frame, region: integer);
                  var f: tavsfield;
                      f1, f2, i: integer;
                  begin
                    if transform4d.empty then
                    begin
                      field_create(transform4d, \'field 4d float\', 4, 4, 3*nclipbox, max(onlinecube.dimensions[3], 1));
                      field_setc(transform4d, transform4d, -1);
                      field_copy(transform4d, backuptransform4d);
                    end;
                    f1 := frame;
                    f2 := f1;
                    if f1\<0 then begin f1 := 0; f2:=max(transform4d.dimensions[3]-1, 0); end;
                    f := tavsfield.create;
                    field_inc_ndim(machine_to_machineadjust, f);
                    field_inc_ndim(f, f);
                    for i := f1 to f2 do field_insert2(transform4d, f, transform4d, 0, 0, region, i);
                    f.free;
                  end;",
// Sentence 324
                  "function tform1.compareregistrationbackup(low, high: integer): boolean;
                  var f, g: tavsfield;
                      eq: integer;
                  begin
                    result := false;
                    if backuptransform4d.empty and transform4d.empty then result := true;
                    if backuptransform4d.empty then exit;
                    if transform4d.empty then exit;
                    f := tavsfield.create;
                    g := tavsfield.create;
                    field_crop(transform4d,       f, 0, 9999, 0, 9999, low, high, 0, 9999);
                    field_crop(backuptransform4d, g, 0, 9999, 0, 9999, low, high, 0, 9999);
                    field_compare_data(f, g, eq);
                    result := eq\<\>0;
                    f.free;
                    g.free;
                    exit;
                  end;",
// Sentence 325
                  "function tform1.compareregistrationbackuppartial(low, high: integer): integer;
                  var f, g: tavsfield;
                      eq, i, r, neq: integer;
                  begin
                     result := 0;
                     if backuptransform4d.empty and transform4d.empty then result := 100;
                     if backuptransform4d.empty then exit;
                     if transform4d.empty then exit;
                     f := tavsfield.create;
                     g := tavsfield.create;
                     neq := 0;
                     for i:=low to high do
                       for r:=0 to transform4d.dimensions[3]-1 do
                     begin
                       field_crop(transform4d,       f, 0, 9999, 0, 9999, i, i, r, r);
                       field_crop(backuptransform4d, g, 0, 9999, 0, 9999, i, i, r, r);
                       field_compare_data(f, g, eq);
                       neq := neq + eq;
                     end;
                     result := neq;
                     f.free;
                     g.free;
                     exit;
                  end;",
// Sentence 326
                  "procedure tform1.makeregistrationbackup(low, high, phaselow, phasehigh: integer);
                  var f: tavsfield;
                  begin
                    if transform4d.empty then
                    begin
                      backuptransform4d.clear;
                      exit;
                    end;
                    if backuptransform4d.empty then
                    begin
                      field_copy(transform4d, backuptransform4d);
                      field_setc(backuptransform4d, backuptransform4d, -1);
                    end;
                    f := tavsfield.create;
                    field_crop(transform4d,       f, 0, 9999, 0, 9999, low, high, phaselow, phasehigh);
                    field_insert2(backuptransform4d, f, backuptransform4d, 0, 0, low, phaselow, 0);
                    f.free;
                  end;",
// Sentence 327
                  "procedure tform1.invalidateregistrationbackup(low, high: integer);
                  var f: tavsfield;
                  begin
                    if transform4d.empty then
                    begin
                      backuptransform4d.clear;
                      exit;
                    end;
                    if backuptransform4d.empty then
                    begin
                      field_copy(transform4d, backuptransform4d);
                      field_setc(backuptransform4d, backuptransform4d, -1);
                    end;
                    f := tavsfield.create;
                    field_crop(transform4d,       f, 0, 9999, 0, 9999, low, high, 0, 9999);
                    field_setc(f, f, -9999);
                    field_insert2(backuptransform4d, f, backuptransform4d, 0, 0, low, 0, 0);
                    f.free;
                  end;",
// Sentence 328
                  "procedure tform1.readini;
                  var i, j: integer;
                      s: string;
                      h: tqinifile;
                  begin
                    inifile := tinifiles.create([paramstr2]);
                    if avlstate\<\>inifile.readinteger(\'xvi\', \'avlstate\', -1) then
                    begin
                      if avlstate=6 then reconterminate(false, error_inifile)
                      else
                      begin
                        showmessage(error_inifile);
                        application.terminate;
                      end;
                    end;
                    if inifile.readbool(\'xvi\', \'profile\', false) then
                    begin
                      appstarttime := now;
                      quirtavstrace(\'\');
                    end;
                    readonly := inifile.readbool(\'xvi\', \'readonly\', false);
                    buttonelektaaccept.enabled := not readonly;
                    exitaccept1.enabled := buttonelektaaccept.enabled;
                    avlflexmapmode := (inifile.readbool(\'xvi\', \'avlflexmapmode\',false));
                    projectionscalibrated := inifile.readinteger(\'reconstruction\', \'projectionscalibrated\', 0);
                    offsetfilename     := inifile.readstring(\'reconstruction\', \'offsetfile\',    \'\');
                    gainfilename       := inifile.readstring(\'reconstruction\', \'gainfile\',      \'\');
                    gainfilename       := inifile.readstring(\'reconstruction\', \'gainfileopen\', gainfilename);
                    gainbowtiefilename := inifile.readstring(\'reconstruction\', \'gainfilebowtie\',\'\');
                    badmapfilename     := inifile.readstring(\'reconstruction\', \'badmapfile\',    \'\');
                    readcorrectionimages(gain, offset, bad, bowtie);
                    checkboxmultithread.checked := inifile.readbool(\'xvi\', \'multithreaded\', true) and checkboxmultithread.enabled;
                    checkboxmedian.checked      := inifile.readbool(\'xvi\', \'medianfilter\', false);
                    skipcolumnsleft             := inifile.readinteger(\'xvi\', \'skipcolumnsleft\',  0);
                    skipcolumnsright            := inifile.readinteger(\'xvi\', \'skipcolumnsright\', 0);
                    skiprowstop                 := inifile.readinteger(\'xvi\', \'skiprowstop\',  0);
                    skiprowsbottom              := inifile.readinteger(\'xvi\', \'skiprowsbottum\', 0);
                    skiprowsbottom              := inifile.readinteger(\'xvi\', \'skiprowsbottom\', skiprowsbottom);
                    fastcorrectimage            := inifile.readbool   (\'xvi\', \'fastcorrectimage\', false);
                    fastcorrectimagescale       := inifile.readinteger(\'xvi\', \'fastcorrectimagescale\', 4);
                    correctfor0xffffpixelbug    := inifile.readbool   (\'xvi\', \'correctfor0xffffpixelbug\', false);
                    editfp0.text      := format(\'%.2f\', [inifile.readfloat(\'xvi\', \'fp0\', 0.7)]);
                    editfp1.text      := format(\'%.2f\', [inifile.readfloat(\'xvi\', \'fp1\', 90)]);
                    inplanerotationcorrectionangle :=
                      inifile.readfloat(\'xvi\', \'inplanerotationcorrectionangle\', 0);
                    iec_angle_convention := inifile.readbool(\'xvi\', \'iecangleconvention\', false);
                    iec_linear_convention := inifile.readinteger(\'xvi\', \'ieclinearconvention\', 1);
                    application.hinthidepause := inifile.readinteger(\'xvi\', \'hinthidepauselength\', 2500);
                    pagecontrol1.activepageindex := 2;
                    statusbar1.panels[0].text := inifile.readstring(\'xvi\', \'statuslinetext\', \'\');
                    showmatchresultsdetailsgreyvalue := inifile.readbool(\'xvi\', \'showmatchresultsdetailsgreyvalue\', true);
                    showmatchresultsdetailsbone := inifile.readbool(\'xvi\', \'showmatchresultsdetailsbone\', true);
                    if (avlstate\<=0) and not pagecontrol1.pages[1].tabvisible then
                    begin
                      pagecontrol1.tabheight := 1;
                      pagecontrol1.tabwidth  := 1;
                    end;
                    if avlstate\>0 then
                    begin
                      patientid          := inifile.readstring(\'identification\', \'patientid\', \'\');
                      patientname        := inifile.readstring(\'identification\', \'lastname\', \'\') + \', \' +
                                            inifile.readstring(\'identification\', \'firstname\', \'\');
                      treatmentid        := inifile.readstring(\'identification\', \'treatmentid\', \'\');
                      plansopuid         := inifile.readstring(\'identification\', \'referenceuid\', \'\');
                      treatmentuid       := inifile.readstring(\'identification\', \'referenceuid\', \'\');
                      scanuid            := inifile.readstring(\'identification\', \'scanuid\', \'\');
                      titlebarstring         := inifile.readstring(\'identification\', \'titlebarstring\', \'\');
                      referenceoverlaystring := inifile.readstring(\'identification\', \'referenceoverlaystring\', \'\');
                      onlineoverlaystring    := inifile.readstring(\'identification\', \'onlineoverlaystring\', \'\');
                      dob                    := inifile.readstring(\'identification\', \'dob\', \'\');
                      reconfilebase      := inifile.readstring(\'xvi\', \'reconstructedscansdirectory\', \'\');
                      adminfilebase      := inifile.readstring(\'xvi\', \'administrativefilesdirectory\', \'\');
                      substituteparms(adminfilebase);
                    end;
                    if not readonly then
                      sysutils.forcedirectories(extractfilepath(adminfilebase));
                    cachefilebase      := inifile.readstring(\'xvi\', \'referencecachedirectory\', \'\');
                    if avlstate in [2, 6] then
                      cachefilebase := cachefilebase + plansopuid + \'\\\';
                    projectionfilebase := inifile.readstring(\'xvi\', \'projectiondirectory\', \'\');
                    anglefilebase      := inifile.readstring(\'xvi\', \'administrativefilesdirectory\', \'\') +
                                          inifile.readstring(\'reconstruction\', \'projectionanglefile\', \'\');
                    if avlstate in [2, 4, 6] then
                    begin
                      if useonlinereconstruction then
                        numframes:=9000
                      else
                      begin
                        for i:=0 to 9000 do
                        begin
                          s := format(anglefilebase, [i]);
                          for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                          if fileexists(s) then numframes := i+1 else break;
                        end;
                      end;
                      frameid   := 0;
                      if useonlinereconstruction then
                        projdim := inifile.readinteger(\'reconstruction\', \'camerawidth\', 512)
                      else
                      begin
                        s := format(anglefilebase, [frameid]);
                        for j:=pos(\'%\', anglefilebase) to length(s) do if s[j]=\' \' then s[j] := \'0\';
                        h :=tqinifile.create(s);
                        s := format(\'%.4d\', [frameid]);
                        s := projectionfilebase + h.readstring(s, \'projectiondatafile\', \'\');
                        read_heimann_his(f, s);
                        projdim := f.dimensions[0];
                        h.free;
                      end;
                      prepad := 0;
                      case projdim of
                        960, 480, 240, 120, 60:
                          begin
                            detectorsize := 43.0;
                            fdd          := 153.2;
                          end;
                        780, 390, 195:
                          begin
                            detectorsize := 28.7;
                            fdd          := 153.6;
                          end;
                        1024, 512, 256, 128, 64:
                          begin
                            detectorsize := 40.96;
                            fdd          := 153.6;
                          end;
                        else
                          begin
                            showmessage(\'unsupported detector\');
                            detectorsize := 10.0;
                            fdd          := 153.6;
                          end;
                      end;
                      detectorsize := inifile.readfloat(\'xvi\', \'detectorsize\', detectorsize);
                      fdd := inifile.readfloat(\'xvi\', \'focusdetectordistance\', fdd);
                      fid := inifile.readfloat(\'xvi\', \'focusisocdistance\', 100.00);
                    end;
                    matchresultlogfile := inifile.readstring(\'xvi\', \'matchresultlogfile\', \'\');
                    flexmapfilename := inifile.readstring(\'reconstruction\', \'flexmap\', \'\');
                    useonlinereconstruction := inifile.readbool(\'reconstruction\', \'useonlinereconstruction\', false);
                    projectiontimeout := inifile.readinteger(\'reconstruction\', \'projectiontimeout\', 10);
                    zoomfix := inifile.readfloat(\'xvi\', \'zoomfix\', 1);
                    quirtviewerupdtransversal.interpolatedzoom.value := ord(inifile.readbool(\'xvi\', \'interpolatedzoom\', true));
                    reversemotion.value := inifile.readinteger(\'xvi\', \'planningstationary\', 0);
                    i := inifile.readinteger(\'xvi\', \'guirefreshinterval\', 20);
                    if i=0 then
                      timer1.enabled := false
                    else
                      timer1.interval:= i;
                  end;",
// Sentence 329
                  "procedure tform1.formresize(sender: tobject);
                  begin
                    if not xviischildwindow then exit;
                    progressbar3.height := height;
                    progressbar3.left := width - 15;
                    if screenlayoutmode=0 then
                    begin
                      quirtviewerupdcoronal.top := 0;
                      quirtviewerupdcoronal.left := 0;
                      quirtviewerupdcoronal.height := round(height * screenlayoutratio2);
                      quirtviewerupdcoronal.width  := round(width  * screenlayoutratio1);
                      quirtviewerupdsagittal.top := 0;
                      quirtviewerupdsagittal.height := quirtviewerupdcoronal.height;
                      quirtviewerupdsagittal.left   := quirtviewerupdcoronal.left + quirtviewerupdcoronal.width + 3;
                      quirtviewerupdsagittal.width  := width - quirtviewerupdcoronal.width - 15 - 6;
                      quirtviewerupdtransversal.left := quirtviewerupdcoronal.left;
                      quirtviewerupdtransversal.top    := quirtviewerupdcoronal.top + quirtviewerupdcoronal.height + 3;
                      quirtviewerupdtransversal.height := height - quirtviewerupdcoronal.height - 3;
                      quirtviewerupdtransversal.width  := quirtviewerupdcoronal.width;
                    end
                    else if screenlayoutmode=1 then
                    begin
                      quirtviewerupdtransversal.top := 0;
                      quirtviewerupdtransversal.left := 0;
                      quirtviewerupdtransversal.height := height;
                      quirtviewerupdtransversal.width  := round((width - 15 - 6) * screenlayoutratio1);
                      quirtviewerupdcoronal.top := 0;
                      quirtviewerupdcoronal.height := height;
                      quirtviewerupdcoronal.width  := round((width - 15 - 6) * screenlayoutratio2);
                      quirtviewerupdcoronal.left   := quirtviewerupdtransversal.left + quirtviewerupdtransversal.width + 3;
                      if quirtviewerupdcoronal.left=3 then quirtviewerupdcoronal.left := 0;
                      quirtviewerupdsagittal.top    := 0;
                      quirtviewerupdsagittal.height := height;
                      if screenlayoutratio1+screenlayoutratio2 = 0 then
                        quirtviewerupdsagittal.width  := width - quirtviewerupdtransversal.width - quirtviewerupdcoronal.width - 15 - 3
                      else
                        quirtviewerupdsagittal.width  := width - quirtviewerupdtransversal.width - quirtviewerupdcoronal.width - 15 - 9;
                      quirtviewerupdsagittal.left := quirtviewerupdcoronal.left + quirtviewerupdcoronal.width + 3;
                      if quirtviewerupdsagittal.left=3 then quirtviewerupdsagittal.left := 0;
                      if quirtviewerupdtransversal.width\<10 then  quirtviewerupdtransversal.width := 10;
                      if quirtviewerupdcoronal.width\<10 then      quirtviewerupdcoronal.width := 10;
                      if quirtviewerupdsagittal.width\<10 then     quirtviewerupdsagittal.width := 10;
                    end
                    else if screenlayoutmode=2 then
                    begin
                      quirtviewerupdtransversal.left := 0;
                      quirtviewerupdtransversal.top    := 0;
                      quirtviewerupdtransversal.height := round(height * screenlayoutratio2);
                      quirtviewerupdtransversal.width  := round(width  * screenlayoutratio1);
                      quirtviewerupdcoronal.top := quirtviewerupdtransversal.top + quirtviewerupdtransversal.height + 3;
                      quirtviewerupdcoronal.left := quirtviewerupdtransversal.left;
                      quirtviewerupdcoronal.height := height - quirtviewerupdtransversal.height - 3;
                      quirtviewerupdcoronal.width  := quirtviewerupdtransversal.width;
                      quirtviewerupdsagittal.top := quirtviewerupdcoronal.top;
                      quirtviewerupdsagittal.height := quirtviewerupdcoronal.height;
                      quirtviewerupdsagittal.left   := quirtviewerupdcoronal.left + quirtviewerupdcoronal.width + 3;
                      quirtviewerupdsagittal.width  := width - quirtviewerupdcoronal.width - 15 - 6;
                    end
                    else if screenlayoutmode=3 then
                    begin
                      quirtviewerupdtransversal.left := 0;
                      quirtviewerupdtransversal.top    := 0;
                      quirtviewerupdtransversal.height := height;
                      quirtviewerupdtransversal.width  := round(width  * screenlayoutratio1);
                      quirtviewerupdcoronal.top := 0;
                      quirtviewerupdcoronal.left := quirtviewerupdtransversal.left + quirtviewerupdtransversal.width + 3;
                      quirtviewerupdcoronal.height := round(height * screenlayoutratio2);
                      quirtviewerupdcoronal.width  := width - quirtviewerupdtransversal.width - 15 - 6;
                      quirtviewerupdsagittal.top := quirtviewerupdcoronal.top + quirtviewerupdcoronal.height + 3;
                      quirtviewerupdsagittal.height := height - quirtviewerupdcoronal.height - 3;
                      quirtviewerupdsagittal.left   := quirtviewerupdtransversal.left + quirtviewerupdtransversal.width + 3;
                      quirtviewerupdsagittal.width  := width - quirtviewerupdtransversal.width - 15 - 6;
                    end
                    else if screenlayoutmode=4 then
                    begin
                      quirtviewerupdcoronal.left := 0;
                      quirtviewerupdcoronal.top    := 0;
                      quirtviewerupdcoronal.height := height;
                      quirtviewerupdcoronal.width  := round(width  * screenlayoutratio1);
                      quirtviewerupdtransversal.top := 0;
                      quirtviewerupdtransversal.left := quirtviewerupdcoronal.left + quirtviewerupdcoronal.width + 3;
                      quirtviewerupdtransversal.height := round(height * screenlayoutratio2);
                      quirtviewerupdtransversal.width  := width - quirtviewerupdcoronal.width - 15 - 6;
                      quirtviewerupdsagittal.top := quirtviewerupdtransversal.top + quirtviewerupdtransversal.height + 3;
                      quirtviewerupdsagittal.height := height - quirtviewerupdtransversal.height - 3;
                      quirtviewerupdsagittal.left   := quirtviewerupdcoronal.left + quirtviewerupdcoronal.width + 3;
                      quirtviewerupdsagittal.width  := width - quirtviewerupdcoronal.width - 15 - 6;
                    end
                    else if screenlayoutmode=5 then
                    begin
                      quirtviewerupdsagittal.left := 0;
                      quirtviewerupdsagittal.top    := 0;
                      quirtviewerupdsagittal.height := height;
                      quirtviewerupdsagittal.width  := round(width  * screenlayoutratio1);
                      quirtviewerupdtransversal.top := 0;
                      quirtviewerupdtransversal.left := quirtviewerupdsagittal.left + quirtviewerupdsagittal.width + 3;
                      quirtviewerupdtransversal.height := round(height * screenlayoutratio2);
                      quirtviewerupdtransversal.width  := width - quirtviewerupdsagittal.width - 15 - 6;
                      quirtviewerupdcoronal.top := quirtviewerupdtransversal.top + quirtviewerupdtransversal.height + 3;
                      quirtviewerupdcoronal.height := height - quirtviewerupdtransversal.height - 3;
                      quirtviewerupdcoronal.left   := quirtviewerupdsagittal.left + quirtviewerupdsagittal.width + 3;
                      quirtviewerupdcoronal.width  := width - quirtviewerupdsagittal.width - 15 - 6;
                    end;
                    quirtviewerupdcoronal.visible     := (quirtviewerupdcoronal.width\>10) and (quirtviewerupdcoronal.height\>10);
                    quirtviewerupdsagittal.visible    := (quirtviewerupdsagittal.width\>10) and (quirtviewerupdsagittal.height\>10);
                    quirtviewerupdtransversal.visible := (quirtviewerupdtransversal.width\>10) and (quirtviewerupdtransversal.height\>10);
                    quirtviewerupdcoronalpanchanged(self, 0, 0);
                  end;",
// Sentence 330
                  "procedure tform1.formshow(sender: tobject);
                  var
                    i: integer;
                    activepageindex: integer;
                  begin
                    activepageindex := pagecontrol1.activepageindex;
                    for i := pagecontrol1.pagecount-1 downto 0 do
                      pagecontrol1.activepage := pagecontrol1.pages[i];
                    pagecontrol1.activepageindex := activepageindex;
                  end;",
// Sentence 331
                  "procedure tform1.buttonsummarizeclipclick(sender: tobject);
                  begin
                  end;",
// Sentence 332
                  "procedure tform1.buttontestclick(sender: tobject);
                  begin
                  end;",
// Sentence 333
                  "procedure tform1.freeall;
                  var i:integer;
                  begin
                    timer1.enabled := false;
                    if assigned(gquerylist) then
                    begin
                      for i:=0 to gquerylist.count-1 do
                        gquerylist.objects[i].free;
                      gquerylist.free;
                    end;
                    inifile.free;
                    caldirlist.free;
                    machine_to_machineadjust.free;
                    prevmachine_to_machineadjust.free;
                    machine_to_siddon.free;
                    cbctonline.free;
                    dtsonline.free;
                    cbctreference.free;
                    dtsreference.free;
                    for i:=1 to high(online)    do online[i].free;
                    for i:=1 to high(reference) do reference[i].free;
                    for i:=1 to high(dose)      do dose[i].free;
                    filteredrecords.free;
                    scanlist.free;
                    queryscanswhere.free;
                    vistransform4d2.free;
                    bonetumormatchlist.free;
                    convertcorexcllist.free;
                    for i := 1 to nclipbox do
                    begin
                      quirtviewerupdcoronal.clipboxtext[i].free;
                      quirtviewerupdcoronal.clipbox[i].free;
                    end;
                    cbnames.free;
                    m.free;
                    bad.free;
                    freeandnil(tabledbid);
                    freeandnil(tablepatients);
                    freeandnil(tableports);
                    freeandnil(tableprocedure);
                    freeandnil(tabletreatments);
                    freeandnil(queryscans);
                    freeandnil(queryframes);
                    freeandnil(queryoffsets);
                    freeandnil(queryscandetails);
                    freeandnil(queryframedetails);
                    freeandnil(queryoffsetframes);
                    freeandnil(queryimages);
                    end;",
// Sentence 334
                  "procedure tform1.copytoclipboard1click(sender: tobject);
                  begin
                  end;",
// Sentence 335
                  "procedure tform1.buttonmeasureinsertsclick(sender: tobject);
                  const
                    densarr: array[0..15] of integer = (-4, -3, -2, -1, 1, 2, 800, 900, 965, 1096, 1097, 1098, 1099, 1120, 1340, 1990);
                  var
                    tmpf: tavsfield;
                    tmpf2: tavsfield;
                    tmpf3: tavsfield;
                    cbct: tavsfield;
                    _mean, _mean2: single;
                    sres: string;
                    t, tcbct: ttransform;
                    i: integer;
                    fres: tavsfield;
                  begin
                    t := ttransform.create;
                    tcbct := ttransform.create;
                    tmpf := tavsfield.create;
                    tmpf2 := tavsfield.create;
                    tmpf3 := tavsfield.create;
                    cbct := tavsfield.create;
                    fres := tavsfield.create;
                    eulerxfm(t);
                    transform_math(t, reference_to_machine, t);
                    field_to_short(quirtviewerupdtransversal.field[2], tmpf);
                    field_to_short(quirtviewerupdtransversal.field[1], cbct);
                    t.invert;
                    eulerxfm(tcbct);
                    transform_math(tcbct, online_to_machine, tcbct);
                    transform_math(tcbct, machine_to_machineadjust, tcbct);
                    transform_math(tcbct, t, t);
                    fieldxfm(cbct, t, quirtviewerupdtransversal.field[2], cbct, 0, 0, fieldxfm_3dfield);
                    if queryscans.active then
                      sres := queryscans.fieldbyname(\'dbid\').asstring + #9 + memo1.lines[1] + #13#10;
                    field_create(fres, \'field 1d rectilinear double\', high(densarr)+1);
                    for i:=0 to high(densarr) do
                    begin
                      field_threshold(tmpf, tmpf3, densarr[i], densarr[i]);
                      field_autocrop(tmpf3, tmpf3);
                      field_ops(tmpf3, tmpf3, 3, field_ops_localmin);
                      _mean2 := tmpf3.mean;
                      field_croptogrid(cbct, tmpf3, tmpf2);
                      field_mask(tmpf2, tmpf3, tmpf2);
                      _mean := tmpf2.mean * 255.0 / _mean2;
                      sres := sres+ inttostr(i) + #9 + inttostr(densarr[i]) + #9 + floattostr(_mean) + #13#10;
                      fres.coordinate[0, i] := densarr[i];
                      fres.setvalue([i], _mean);
                    end;
                    nstats(fres, tmpf, nstats_regression, 0, 1);
                    sres := sres+ \'regression\' + #9 + floattostr(tmpf.getvalue([0,0])) + #9 + floattostr(tmpf.getvalue([0,1])) + #9 + floattostr(tmpf.getvalue([0,2])) + #13#10;
                    t.free;
                    tcbct.free;
                    tmpf.free;
                    tmpf2.free;
                    tmpf3.free;
                    cbct.free;
                    fres.free;
                    sres :=
                      format(\'%d ma, %d ms, %d kv\',
                      [
                        form1.scanma,
                        form1.scanms,
                        form1.scankv
                      ]) +  #13#10 + sres;
                    clipboard.astext := sres;
                    showmessage(message_copiedtexttoclpbrd + #13#10 + sres);
                  end;",
// Sentence 336
                  "procedure tform1.buttonidealcatphanasrefclick(sender: tobject);
                  var
                    i: integer;
                    ellipse: tavsfield;
                  begin
                    buttonclearreferenceclick(self);
                    referencedatachanged := true;
                    checkboxroi.checked := true;
                    menuclipboxlocked.checked := false;
                    referencecube.assign(onlinecube);
                    ellipse := tavsfield.create;
                    for i:=0 to referencecube.dimensions[0]-1 do
                    begin
                      field_slice(referencecube, ellipse, 0, -1, -1);
                      field_setc(ellipse, ellipse, 0);
                      if inrange(referencecube.coordinate[0, i], -9, 9) then
                        paint_elipse(ellipse, nil, ellipse, 0, 0, 0, 7.5, 7.5, 1, 1000);
                      if inrange(referencecube.coordinate[0, i], -3-1.25+0.05, -3+1.25-0.05) then
                      begin
                        paint_elipse(ellipse, nil, ellipse, 0,  5.8, 0, 0.6, 0.6, 1, 1);
                        paint_elipse(ellipse, nil, ellipse, 0, -5.8, 0, 0.6, 0.6, 1, 2);
                        paint_elipse(ellipse, nil, ellipse, -8,  8, 0, 0.6, 0.6, 1, -1);
                        paint_elipse(ellipse, nil, ellipse, -8, -8, 0, 0.6, 0.6, 1, -2);
                        paint_elipse(ellipse, nil, ellipse,  8, -8, 0, 0.6, 0.6, 1, -3);
                        paint_elipse(ellipse, nil, ellipse,  8,  8, 0, 0.6, 0.6, 1, -4);
                        paint_elipse(ellipse, nil, ellipse, -5.02294734,  2.9, 0, 0.6, 0.6, 1, 1096);
                        paint_elipse(ellipse, nil, ellipse, -5.02294734, -2.9, 0, 0.6, 0.6, 1, 1097);
                        paint_elipse(ellipse, nil, ellipse,  5.02294734,  2.9, 0, 0.6, 0.6, 1, 1098);
                        paint_elipse(ellipse, nil, ellipse,  5.02294734, -2.9, 0, 0.6, 0.6, 1, 1099);
                        paint_elipse(ellipse, nil, ellipse, -5.8, 0, 0, 0.6, 0.6, 1, 1340);
                        paint_elipse(ellipse, nil, ellipse,  5.8, 0, 0, 0.6, 0.6, 1, 900);
                        paint_elipse(ellipse, nil, ellipse,  2.9 , -5.02294734 , 0, 0.6, 0.6, 1, 965);
                        paint_elipse(ellipse, nil, ellipse,  2.9,  5.02294734, 0, 0.6, 0.6, 1, 800);
                        paint_elipse(ellipse, nil, ellipse, -2.9, -5.02294734, 0, 0.6, 0.6, 1, 1120);
                        paint_elipse(ellipse, nil, ellipse, -2.9,  5.02294734, 0, 0.6, 0.6, 1, 1990);
                      end;
                      field_inc_ndim(ellipse, ellipse);
                      field_transpose(ellipse, ellipse, 2);
                      field_insert(referencecube, ellipse, referencecube, i, 0, 0);
                    end;
                    reference_to_siddon.assign(online_to_machine);
                    reference_to_patient.assign(online_to_machine);
                    dosecube.clear;
                    doseaccu.clear;
                    dose_to_siddon.clear;
                    dose_to_machine.clear;
                    quirtviewerupdsagittal.level[2].value := quirtviewerupdsagittal.level[1].value-100;
                    quirtviewerupdsagittal.window[2].value := quirtviewerupdsagittal.window[1].value;
                    field_create(beamdots, \'field 1d 3-space irregular\', 1);
                    if synergymode then plansopuid := \'fake_\' + scanuid else treatmentuid := \'fake_\' + scanuid;
                    beamindex.clear;
                    buttonresetmatchclick(self);
                    if exportedscan = \'\' then
                      scanurl := \'xdr:\' + reconfilebase + scanuid + \'.scan\'
                    else
                      scanurl := exportedscan;
                    planurl := \'fake\';
                    beamurl := \'\';
                    doseurl := \'\';
                    clipbox[1].setvalue([0],-7.5);
                    clipbox[1].setvalue([1], 7.5);
                    clipbox[1].setvalue([2], 1.5);
                    clipbox[1].setvalue([3], 4.5);
                    clipbox[1].setvalue([4],-7.5);
                    clipbox[1].setvalue([5], 7.5);
                    if referenceoverlaystring\<\>\'\' then
                      quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + referenceoverlaystring
                    else
                      quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + ref_overlay + scandate;
                    eulerxfm(ellipse, 0, 0, 0, 0, -4, 0);
                    eulerxfm(machine_to_machineadjust, -180, 0, -180);
                    transform_math(ellipse, machine_to_machineadjust, machine_to_machineadjust);
                    ellipse.free;
                  end;",
// Sentence 337
                  "procedure tform1.button2click(sender: tobject);
                  var i:integer;
                  begin
                    i := 1;
                    if quirtviewerupdcoronal.toolbar[i].empty then
                    begin
                      field_create(quirtviewerupdcoronal.toolbar[i], \'field 2d 3-vector byte\', quirtviewerupdcoronal.width-2, 40);
                      field_setc(quirtviewerupdcoronal.toolbar[i], quirtviewerupdcoronal.toolbar[i], 128);
                      field_text(quirtviewerupdcoronal.toolbar[i], nil, quirtviewerupdcoronal.toolbar[i], \'hallo\');
                      field_setc(quirtviewerupdcoronal.toolbarsel[i], quirtviewerupdcoronal.toolbarsel[i], -4);
                      quirtviewerupdcoronal.toolbarsel[i].locked := true;
                          quirtviewerupdcoronal.interpolatedzoom.value := 0;
                    end
                    else
                    begin
                      quirtviewerupdcoronal.toolbar[i].clear;
                      quirtviewerupdcoronal.toolbarsel[i].clear;
                    end;
                  end;",
// Sentence 338
                  "procedure tform1.bitbtngreenpurplecutclick(sender: tobject);
                  begin
                    if comboboxdisplaymode.itemindex=0 then comboboxdisplaymode.itemindex := 1
                    else comboboxdisplaymode.itemindex := 0;
                    checkboxscan.checked := true;
                    end;",
// Sentence 339
                  "procedure tform1.bitbtnreflocclick(sender: tobject);
                  begin
                    if comboboxdisplaymode.itemindex=2 then comboboxdisplaymode.itemindex := 3
                    else comboboxdisplaymode.itemindex := 2;
                    checkboxscan.checked := true;
                    end;",
// Sentence 340
                  "procedure tform1.bitbtnpresetlevelwindowsclick(sender: tobject);
                  begin
                    popupmenu2.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                  end;",
// Sentence 341
                  "procedure tform1.changelevelorwindow(sender: tobject);
                  var i: integer;
                  begin
                    for i:=0 to popupmenu2.items.count-1 do
                      popupmenu2.items[i].checked := false;
                  end;",
// Sentence 342
                  "procedure tform1.restore1click(sender: tobject);
                  var l, h:integer;
                      brecall: boolean;
                  begin
                    l := 0;
                    h := 0;
                    brecall := false;
                    quirtviewerupdcoronal.level[1].onchanged := changelevelorwindow;
                    quirtviewerupdcoronal.window[1].onchanged := changelevelorwindow;
                    quirtviewerupdcoronal.level[2].onchanged := changelevelorwindow;
                    quirtviewerupdcoronal.window[2].onchanged := changelevelorwindow;
                    case (sender as tmenuitem).menuindex of
                      0:  begin l:=0;   h:=0;   end;
                      1:  begin l:=30;  h:=170; end;
                      2:  begin l:=60;  h:=140; end;
                      3:  begin l:=80;  h:=120; end;
                      4:  begin l:=0;   h:=140; end;
                      6:  begin
                            online[1].window.maximum := 2000;
                            online[1].window.minimum := 0;
                            reference[1].window.maximum := 2000;
                            reference[1].window.minimum := 0;
                            online[1].level.maximum := 2000;
                            online[1].level.minimum := -2000;
                            reference[1].level.maximum := 2000;
                            reference[1].level.minimum := -2000;
                            online[1].level.value := levels[0];
                            online[1].window.value := levels[1];
                            reference[1].level.value := levels[2];
                            reference[1].window.value := levels[3];
                            brecall := true;
                           end;
                    end;
                    if not brecall then
                    begin
                      quirtviewerupdcoronal.blw(1, l, h);
                      quirtviewerupdcoronal.blw(2, l, h);
                      timer1timer(self);
                    end;
                    (sender as tmenuitem).checked := true;
                    popupmenu2.popup(
                      thackpopupmenu(popupmenu2).popuppoint.x,
                      thackpopupmenu(popupmenu2).popuppoint.y);
                  end;",
// Sentence 343
                  "procedure tform1.copyclipbox1;
                  var t: tavsfield;
                  begin
                    t := tavsfield.create;
                    if transform4d.empty then
                      externalmanualmatchto4d(-1, 0);
                    field_slice(transform4d, t, -1, -1, 0, 0);
                    if t.getvalue([3,3])\>0.99 then
                    begin
                      field_copy(t, machine_to_machineadjust);
                      externalmanualmatchto4d(-1, nclipbox);
                    end;
                    t.free;
                  end;",
// Sentence 344
                  "procedure tform1.tabcontrol1change(sender: tobject);
                  begin
                    if assigned(activecontrol) and assigned(activecontrol.parent) and
                      ((activecontrol.parent=paneltranslation) or
                       (activecontrol.parent=panelrotation)) then
                    begin
                      activecontrol := nil;
                      timer1timer(nil);
                    end;
                    reversemotion.value := 0;
                      case 10 * comboboxregistrationprotocol.itemindex + tabcontrol1.tabindex of
                         0: alignmentmode.value := 0;
                                1:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                         2: alignmentmode.value := 4;
                        10: alignmentmode.value := 1;
                        11:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                        12: alignmentmode.value := 4;
                        20: alignmentmode.value := 0;
                        21: alignmentmode.value := 1;
                        22:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                        23: alignmentmode.value := 4;
                        30: alignmentmode.value := 0;
                        31: alignmentmode.value := 1;
                        32:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                        33: alignmentmode.value := 4;
                        40: alignmentmode.value := 0;
                        41:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                        42: alignmentmode.value := 4;
                        50: alignmentmode.value := 1;
                        51:
                            if ( (correctionapprovalby=\'\')) and (labelcomputedlat2.caption\<\>\'-\') then
                              alignmentmode.value := 2 else alignmentmode.value := 3;
                        52: alignmentmode.value := 4;
                      end;
                    if (alignmentmode.value=4) and assigned(colorstringgridsummaryupd) then
                      colorstringgridsummaryupd.forceupdate;
                    memomaskclipboxdifference.lines.text := memo_nkidoubleclick;
                    manualmatchactive := false;
                    if not quirtviewerupdcoronal.toolbar[1].empty then
                    begin
                      buttonlimitinformationclick(self);
                      buttonlimitinformationclick(self);
                    end;
                    comboboxsummarytype.items.clear;
                    comboboxsummarytype.items.add(summary_current);
                    if online[1].data.ndim\>3 then comboboxsummarytype.items.add(summary_details);
                    comboboxsummarytype.items.add(summary_residuals);
                    if comboboxregistrationprotocol.itemindex\>1 then comboboxsummarytype.items.add(summary_limits);
                    comboboxsummarytype.itemindex := 0;
                  end;",
// Sentence 345
                  "procedure tform1.tabcontrol1changing(sender: tobject;
                    var allowchange: boolean);
                  begin
                    allowchange := true;
                    if matchinprogress then allowchange := false;
                    if match2inprogress then allowchange := false;
                  end;",
// Sentence 346
                  "procedure tform1.buttonnextstepclick(sender: tobject);
                  var tx1, ty1, tz1, tx2, ty2, tz2, rx1, ry1, rz1, rx2, ry2, rz2, dum: string;
                  var limits1, limits2: integer;
                  var i: integer;
                  begin
                    manualmatchactive := false;
                    reversemotion.value := 0;
                    if (alignmentmode.value=0) and
                       ((comboboxregistrationprotocol.itemindex=2) or (comboboxregistrationprotocol.itemindex=3)) then
                      centerofmask1click(self)
                    else if (alignmentmode.value=2) then
                    begin
                      if inputquery(signature_dlg, initials_dlg, dum) then
                      begin
                        if (dum=\'\') or (dum[1]=\'\'\'\') or (dum[1]=\'\"\')then
                        begin
                          repeat
                            if not inputquery(signature_dlg, initials_dlg, dum) then
                            begin
                              reversemotion.value := 0;
                              exit;
                            end;
                          until (dum\<\>\'\') and (dum[1]\<\>\'\'\'\') and (dum[1]\<\>\'\"\');
                        end;
                        if not compareregistrationbackup(2*nclipbox, 3*nclipbox-1) or transform4d.empty then
                          externalconverttocorrection;
                        alignmentmode.value := 3;
                        if (correctionapprovalby = \'\') or (correctionapprovalby = \'*\') then
                          correctionapprovalby := dum
                        else
                          correctionapprovalby := correctionapprovalby + \' + \' + dum;
                        makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999);
                      reversemotion.value := 0;
                      end;
                      for i:=1 to 6 do
                        colorstringgrid1.cellprops[3,i].box.checked := false;
                      exit;
                    end;
                    case 10 * comboboxregistrationprotocol.itemindex + tabcontrol1.tabindex of
                         0: begin tabcontrol1.tabindex := 1; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                        10: begin tabcontrol1.tabindex := 1; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                        20: begin tabcontrol1.tabindex := 1; alignmentmode.value := 1; copyclipbox1; makeregistrationbackup(nclipbox, 2*nclipbox-1, 0, 9999); invalidatecorrection; end;
                        21: begin tabcontrol1.tabindex := 2; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                    30: begin tabcontrol1.tabindex := 2; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                    40: begin tabcontrol1.tabindex := 1; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                        50: begin tabcontrol1.tabindex := 1; externalconverttocorrection; makeregistrationbackup(2*nclipbox, 3*nclipbox-1, 0, 9999); end;
                      end;
                    if alignmentmode.value=2 then
                    begin
                      showmessage(warning_reviewcorrection);
                      if (comboboxcorrectionprotocol.text = correction_from_clipbox) then trackbarweight.position := 0
                      else trackbarweight.position := 10;
                      limits1 := unpackregistration(-4,        -1, tx1, ty1, tz1, rx1, ry1, rz1, dum, false, true, false);
                      limits2 := unpackregistration(nclipbox, -5, tx2, ty2, tz2, rx2, ry2, rz2, dum, false, true, false);
                      colorstringgrid1.cellprops[3,1].box.checked :=
                             ((limits1 and $003) or (limits2 and $003))\<\>0;
                      colorstringgrid1.cellprops[3,2].box.checked :=
                             ((limits1 and $00c) or (limits2 and $00c))\<\>0;
                      colorstringgrid1.cellprops[3,3].box.checked :=
                             ((limits1 and $030) or (limits2 and $030))\<\>0;
                      if correctionbyhexapod then
                      begin
                        colorstringgrid1.cellprops[3,4].box.checked :=
                             ((limits1 and $0c0) or (limits2 and $0c0))\<\>0;
                        colorstringgrid1.cellprops[3,5].box.checked :=
                             ((limits1 and $300) or (limits2 and $300))\<\>0;
                        colorstringgrid1.cellprops[3,6].box.checked :=
                             ((limits1 and $c00) or (limits2 and $c00))\<\>0;
                      end
                      else
                      begin
                        colorstringgrid1.cellprops[3,4].box.checked := false;
                        colorstringgrid1.cellprops[3,5].box.checked := false;
                        colorstringgrid1.cellprops[3,6].box.checked := false;
                      end;
                    end;
                    reversemotion.value := 0;
                    end;",
// Sentence 347
                  "procedure tform1.bitbtndismisscorrectionclick(sender: tobject);
                  begin
                    alignmentmode.value := 2;
                    correctionapprovalby := \'\';
                  end;",
// Sentence 348
                  "procedure tform1.comboboxregistrationprotocolchange(sender: tobject);
                  var x: tavsfield;
                      i: integer;
                  begin
                         if (comboboxregistrationprotocol.itemindex=0) and (alignmentmode.value=1) then alignmentmode.value:=0
                    else if (comboboxregistrationprotocol.itemindex=1) and (alignmentmode.value=0) then alignmentmode.value:=1
                    else if (comboboxregistrationprotocol.itemindex=2) and (alignmentmode.value=1) then alignmentmode.value:=0
                    else if (comboboxregistrationprotocol.itemindex=3) and (alignmentmode.value=1) then alignmentmode.value:=0
                    else if (comboboxregistrationprotocol.itemindex=4) and (alignmentmode.value=1) then alignmentmode.value:=0
                    else if (comboboxregistrationprotocol.itemindex=5) and (alignmentmode.value=0) then alignmentmode.value:=1;
                    preparetabs(sender) ;
                    i := comboboxcorrectionprotocol.itemindex;
                    comboboxcorrectionprotocol.clear;
                    if (comboboxregistrationprotocol.itemindex in [0,3,4]) then
                      comboboxcorrectionprotocol.add(correction_from_clipbox, [\'clipbox\', \'clipbox registration\']);
                    if (comboboxregistrationprotocol.itemindex in [1,2,5]) then
                    begin
                      comboboxcorrectionprotocol.add(correction_from_mask_mean, [\'mask (mean if 4d)\']);
                      if not reference[1].data.empty then
                      begin
                        x := tavsfield.create;
                        transform_math(reference[1].topatient, reference[1].tosiddon, x, true);
                        if x.getvalue([1,1])\>0 then
                        begin
                          comboboxcorrectionprotocol.add(correction_from_mask_exh, [\'mask (exhale if 4d)\']);
                          comboboxcorrectionprotocol.hint :=
                            combobox_comboboxcorrectionprotocol_hint;
                        end
                        else
                          comboboxcorrectionprotocol.hint :=
                            combobox_comboboxcorrectionprotocol_hint + #10 +
                            combobox_comboboxcorrectionprotocol_hint2;
                        x.free;
                      end
                      else
                        comboboxcorrectionprotocol.add(correction_from_mask_exh, [\'mask (exhale if 4d)\']);
                    end;
                    if (i\>=0) and (i\<comboboxcorrectionprotocol.items.count) then
                      comboboxcorrectionprotocol.itemindex := i
                    else
                      comboboxcorrectionprotocol.itemindex := 0;
                    tabcontrol1change(self);
                    buttonresetmatchclick(self);
                    referencedatachanged := true;
                    if assigned(sender) then
                    begin
                      if comboboxregistrationprotocol.itemindex \<\> 1 then
                        checkboxroi.checked := true;
                      if comboboxregistrationprotocol.itemindex \<\> 0 then
                        checkboxreferencemask.checked := true;
                      if comboboxregistrationprotocol.itemindex = 1 then
                        checkboxroi.checked := false;
                      if comboboxregistrationprotocol.itemindex = 0 then
                        checkboxreferencemask.checked := false;
                    end;
                  end;",
// Sentence 349
                  "procedure tform1.comboboxcorrectionprotocolchange(sender: tobject);
                  begin
                    invalidatecorrection;
                   if assigned(colorstringgridsummaryupd) then colorstringgridsummaryupd.forceupdate;
                  end;",
// Sentence 350
                  "procedure tform1.comboboxcorrectionbychange(sender: tobject);
                  begin
                    invalidatecorrection;
                    correctionbyhexapod := comboboxcorrectionby.itemindex =
                      comboboxcorrectionby.indexofmapped(nameof6dsystemmappedtext);
                    preparetabs(sender);
                  end;",
// Sentence 351
                  "procedure tform1.preparetabs(sender: tobject) ;
                  begin
                      if onlinecube.empty or (onlinecube.veclen=0) then
                      begin
                        case comboboxregistrationprotocol.itemindex of
                          0: tabcontrol1.tabs.commatext := tab_regclip;
                          1: tabcontrol1.tabs.commatext := tab_regmask;
                          2: tabcontrol1.tabs.commatext := tab_regclip+\',\'+tab_regmask;
                          3: tabcontrol1.tabs.commatext := tab_regclip+\',\'+tab_regmask;
                          4: tabcontrol1.tabs.commatext := tab_regclip;
                          5: tabcontrol1.tabs.commatext := tab_regmask;
                        end;
                      end
                      else
                      begin
                        tabcontrol1.tabwidth := 120 ;
                        case comboboxregistrationprotocol.itemindex of
                          0: tabcontrol1.tabs.commatext := tab_regclip+\',\'+tab_correction+\',\'+tab_overview;
                          1: tabcontrol1.tabs.commatext := tab_regmask+\',\'+tab_correction+\',\'+tab_overview;
                          2, 3: tabcontrol1.tabs.commatext := tab_regclip+\',\'+tab_regmask+\',\'+tab_correction+\',\'+tab_overview;
                          4: tabcontrol1.tabs.commatext := tab_regclip+\',\'+tab_correction+\',\'+tab_overview;
                          5: tabcontrol1.tabs.commatext := tab_regmask+\',\'+tab_correction+\',\'+tab_overview;
                        end;
                      end;
                      tabcontrol1change(sender);
                        end;",
// Sentence 352
                  "procedure tform1.updownroismouseup(sender: tobject; button: tmousebutton;
                    shift: tshiftstate; x, y: integer);
                  begin
                    updownroisupdate;
                  end;",
// Sentence 353
                  "procedure tform1.updownroisupdate;
                  var
                    save : boolean;
                  begin
                    save := quirtviewerupdcoronal.activeclipbox.locked;
                    quirtviewerupdcoronal.activeclipbox.locked := save;
                  end;",
// Sentence 354
                  "procedure tform1.buttonmatch2click(sender: tobject);
                  var style, r, r1, r2, f, f1, f2: integer;
                      s: string;
                      save: tavsfield;
                      id : ttransform;
                      matchmode: tmatchmode;
                  begin
                    timer4d.enabled := false;
                    reversemotion.value := 0;
                    if match2inprogress then
                    begin
                      if assigned(m) then m.stop;
                      match2inprogress := false;
                      exit;
                    end;
                    save := tavsfield.create;
                    field_copy(machine_to_machineadjust, save);
                    if alignmentmode.value=0 then
                    begin
                      if radiobuttonallrois.checked then
                      begin
                        r1 := 0;
                        r2 := nclipbox-1;
                        activeregion.value := 0;
                      end
                      else
                      begin
                        r1 := activeregion.value;
                        r2 := activeregion.value;
                        activeregion.value := 0;
                      end;
                      s := comboboxclipboxmatch.mappedtext;
                      end
                    else
                    begin
                          if maskedreference.empty then
                      begin
                        showmessage(mask_error);
                        save.free;
                        exit;
                      end;
                      s := comboboxmaskmatch.mappedtext;
                      r1 := nclipbox;
                      r2 := nclipbox;
                      if editmask.checked then editmaskclick(self);
                      id := ttransform.create;
                      id.makeidentity;
                      if machine_to_machineadjust.equals(id) then
                      begin
                        centerofmask1click(self);
                        timer1timer(self);
                      end;
                      id.free;
                    end;
                    if (pos(match_substring_4d, s)\>0) and (onlinecube.ndim=3) then
                    begin
                      showmessage(warning_4dtoolon3ddata);
                    end;
                    buttonmatch2.caption := stopmatch_caption;
                    match2inprogress := true;
                    invalidatecorrection;
                    panelcontrol4d.enabled := false;
                    page1.enabled := false;
                    screen.cursor := crhourglass;
                    id := ttransform.create;
                    id.makeidentity;
                    for r:=r1 to r2 do
                    begin
                      if r\<nclipbox then
                      begin
                        if clipbox[r+1].empty then continue;
                        quirtviewerupdcoronal.activeclipbox.value := r+1;
                        updownrois.position := r;
                        activeregion.value := r;
                        labelrois.caption := \'\';
                        field_copy(save, machine_to_machineadjust);
                        if machine_to_machineadjust.equals(id) then
                          centerofclipbox1click(self);
                      end;
                      if alignmentmode.value=0 then
                        s := comboboxclipboxmatch.mappedtext
                      else
                        s := comboboxmaskmatch.mappedtext;
                        if radiobuttonallframes.checked and (pos(match_substring_4d, s)\>0) then
                      begin
                        f1 := 0;
                        f2 := max(online[1].data.dimensions[3]-1, 0);
                      end
                      else if pos(match_substring_4d, s)\>0 then
                      begin
                        f1 := quirtviewerupdcoronal.frame.value;
                        f2 := quirtviewerupdcoronal.frame.value;
                      end
                      else
                      begin
                        f1 := -1;
                        f2 := -1;
                      end;
                      if pos(match_substring_t , s)\>0 then
                        style := 0
                      else if pos(match_substring_prerot, s)\>0 then
                        style := 2
                      else if pos(match_substring_r , s)\>0 then
                        style := 3
                      else
                       style := 1;
                      if (pos(match_substring_bone, s)\>0) or
                         (pos(match_substring_seed, s)\>0) then
                        matchmode := mmchamfer
                      else
                        matchmode := mmgreyvalue;
                      progressbar3.position := 0;
                      for f:=f1 to f2 do
                      begin
                        progressoffset := (f-f1) * progressbar3.max / (1+f2-f1);
                        progressscale := 1 / (1+f2-f1);
                        quirtviewerupdcoronal.frame.value := f;
                        externalmatch(r, f, matchmode, style);
                        if not match2inprogress then break;
                      end;
                      if not match2inprogress then break;
                    end;
                    id.free;
                    screen.cursor := crdefault;
                    progressoffset := 0;
                    progressscale := 1;
                    progressbar3.position := 0;
                    buttonmatch2.caption := startmatch_caption;
                    match2inprogress := false;
                    panelcontrol4d.enabled := true;
                    page1.enabled := true;
                    if alignmentmode.value=0 then
                      appliedclipboxmatchmethod := s
                    else if alignmentmode.value=1 then
                      appliedmaskmatchmethod := s;
                    if radiobuttonallrois.checked then
                    begin
                      activeregion.value := 0;
                      updownrois.position := 0;
                    end;
                    if pos(match_substring_4d, s)\>0 then
                    begin
                      if alignmentmode.value=0 then
                        centerofclipbox1click(nil)
                      else
                        visitcenterofmask;
                      buttonplay4dclick(bitbtnplaygreen);
                    end;
                    save.free;
                  end;",
// Sentence 355
                  "procedure tform1.buttonmarkersclick(sender: tobject);
                  begin
                    timer1.enabled := false;
                    popupmenumarkers.popup(mouse.cursorpos.x, mouse.cursorpos.y);
                    timer1.enabled := true;
                  end;",
// Sentence 356
                  "procedure tform1.showmarkertoolclick(sender: tobject);
                  begin
                    showmarkertool.checked := not showmarkertool.checked;
                  end;",
// Sentence 357
                  "procedure tform1.savereferencemarkerlistclick(sender: tobject);
                  var
                    dir               : string;
                  begin
                    if quirtviewerupdcoronal.polydots[6].empty then exit;
                    if quirtviewerupdcoronal.polydots[6].dimensions[0]=0 then exit;
                    dir := cachefilebase;
                  end;",
// Sentence 358
                  "procedure tform1.loadreferencemarkersclick(sender: tobject);
                  var
                   dir, filename, uid : string;
                  begin
                    dir := cachefilebase;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    filename := dir + \'\\\' +uid + \'.xvi\';
                    if not fileexists(filename) then
                    begin
                      showmessage(\'cannot find xvi inifile...\');
                      exit;
                    end;
                  end;",
// Sentence 359
                  "procedure tform1.saveonlinemarkersclick(sender: tobject);
                  var
                   dir             : string;
                  begin
                    if quirtviewerupdcoronal.polydots[7].empty then exit;
                    if quirtviewerupdcoronal.polydots[7].dimensions[0]=0 then exit;
                    dir := cachefilebase;
                  end;",
// Sentence 360
                  "procedure tform1.loadonlinemarkersclick(sender: tobject);
                  var
                   dir, filename, uid : string;
                  begin
                   dir := cachefilebase;
                    if synergymode then uid := plansopuid else uid := treatmentuid;
                    filename := dir + \'\\\' +uid + \'.xvi\';
                    if not fileexists(filename) then
                    begin
                      showmessage(\'cannot find xvi inifile...\');
                      exit;
                    end;
                  end;",
// Sentence 361
                  "procedure tform1.formdestroy(sender: tobject);
                  begin
                    destroyhintlist;
                    freeall;
                  end;",
// Sentence 362
                  "procedure tform1.memomaskclipboxdifferencedblclick(sender: tobject);
                  begin
                    if memomaskclipboxdifference.lines[0]=memodiff_double then
                      memomaskclipboxdifference.lines.text := \'\'
                    else
                      memomaskclipboxdifference.lines.text := memodiff_info;
                  end;",
// Sentence 363
                  "procedure tform1.trackbarweightchange(sender: tobject);
                  begin
                    weightedconverttocorrection(trackbarweight.position / trackbarweight.max);
                  end;",
// Sentence 364
                  "procedure tform1.bitbtnunlockprotocolclick(sender: tobject);
                  begin
                    if bitbtnunlockprotocol.tag=0 then
                    begin
                      bitbtnunlockprotocol.glyph := bitbtnunlock.glyph;
                      bitbtnunlockprotocol.tag := 1;
                    end
                    else
                    begin
                      bitbtnunlockprotocol.glyph := bitbtnlock.glyph;
                      bitbtnunlockprotocol.tag := 0;
                      referencedatachanged := false;
                    end;
                  end;",
// Sentence 365
                  "procedure tform1.importdose1click(sender: tobject);
                  begin
                    buttonsetdoseclick(buttonsetdose);
                  end;",
// Sentence 366
                  "procedure tform1.exportraw3d1click(sender: tobject);
                  begin
                    quirtviewerupdcoronal.frame.value := -1;
                    buttonexportclick(self);
                  end;",
// Sentence 367
                  "procedure tform1.exportraw4d1click(sender: tobject);
                  begin
                    quirtviewerupdcoronal.frame.value := 0;
                    buttonexportclick(self);
                  end;",
// Sentence 368
                  "procedure tform1.shiftscan1click(sender: tobject);
                  var s: string;
                      x: single;
                  begin
                    s := inputbox(\'enter longitudonal shift\', \'shift (cm)\', \'0\');
                    x := safestrtofloat(s);
                    if x\<\>0 then
                    begin
                      field_shift(onlinecube, x, 0, 0);
                      onlinecube.hasnewvalue;
                    end;
                  end;",
// Sentence 369
                  "procedure tform1.copy1click(sender: tobject);
                  begin
                    write_xdr(onlinecube, cachefilebase + treatmentuid + \'.clipboard\', \'\', \'\', 2);
                    showmessage(message_copiedscantoclipbrd);
                  end;",
// Sentence 370
                  "procedure tform1.pasteasreference1click(sender: tobject);
                  begin
                    if not fileexists(cachefilebase + treatmentuid + \'.clipboard\') then
                    begin
                      showmessage(warning_nothingtopaste);
                      exit;
                    end;
                    buttonclearreferenceclick(self);
                    referencedatachanged := true;
                    checkboxroi.checked := true;
                    menuclipboxlocked.checked := false;
                    read_xdr(referencecube, cachefilebase + treatmentuid + \'.clipboard\');
                    reference_to_siddon.assign(online_to_machine);
                    reference_to_patient.assign(online_to_machine);
                    dosecube.clear;
                    doseaccu.clear;
                    dose_to_siddon.clear;
                    dose_to_machine.clear;
                    quirtviewerupdsagittal.level[2].value := quirtviewerupdsagittal.level[1].value-100;
                    quirtviewerupdsagittal.window[2].value := quirtviewerupdsagittal.window[1].value;
                    field_create(beamdots, \'field 1d 3-space irregular\', 1);
                    if synergymode then plansopuid := \'fake_\' + scanuid else treatmentuid := \'fake_\' + scanuid;
                    beamindex.clear;
                    buttonresetmatchclick(self);
                    showmessage(toref_warn2);
                    scanurl := research_clipurl;
                    planurl := \'fake\';
                    beamurl := \'\';
                    doseurl := \'\';
                    referenceoverlaystring := research_clipurl;
                    quirtviewerupdtransversal.text[4].value := #27 + chr(255) + #1 + chr(255) + referenceoverlaystring;
                  end;",
// Sentence 371
                  "procedure tform1.pastetostitch1click(sender: tobject);
                  var s, t: tavsfield;
                  begin
                    if not fileexists(cachefilebase + treatmentuid + \'.clipboard\') then
                    begin
                      showmessage(warning_nothingtopaste);
                      exit;
                    end;
                    s := tavsfield.create;
                    t := tavsfield.create;
                    read_xdr(s, cachefilebase + treatmentuid + \'.clipboard\');
                    if (s.ndim=4) or (onlinecube.ndim=4) then
                    begin
                      showmessage(error_no4dstitch);
                    end
                    else
                    begin
                      extents_grid2(onlinecube, s, nil, nil, t, onlinecube.coordinate[0, 1]-onlinecube.coordinate[0, 0]);
                      fieldxfm(s, nil, t, s, 0, 0, fieldxfm_3dfield);
                      fieldxfm(onlinecube, nil, t, onlinecube, 0, 0, fieldxfm_3dfield);
                      field_max(s, onlinecube, onlinecube);
                    end;
                    s.free;
                    t.free;
                  end;",
// Sentence 372
                  "procedure tform1.exit1click(sender: tobject);
                  begin
                    buttonelektadismissclick(buttonelektadismiss);
                  end;",
// Sentence 373
                  "procedure tform1.imageguidance1click(sender: tobject);
                  begin
                    pagecontrol1.activepageindex := 2;
                    pagecontrol1change(self);
                  end;",
// Sentence 374
                  "procedure tform1.dbase1click(sender: tobject);
                  begin
                    pagecontrol1.activepageindex := 0;
                    pagecontrol1change(self);
                  end;",
// Sentence 375
                  "procedure tform1.imageselection1click(sender: tobject);
                  begin
                    pagecontrol1.activepageindex := 1;
                    pagecontrol1change(self);
                  end;",
// Sentence 376
                  "procedure tform1.clipbox1click(sender: tobject);
                  begin
                    tabcontrol1.tabindex := 0;
                    tabcontrol1change(self);
                  end;",
// Sentence 377
                  "procedure tform1.clipbox2refmark1click(sender: tobject);
                  begin
                  end;",
// Sentence 378
                  "procedure tform1.reg2onlinemark1click(sender: tobject);
                  begin
                  end;",
// Sentence 379
                  "procedure tform1.mask1click(sender: tobject);
                  begin
                    if comboboxregistrationprotocol.itemindex=2 then
                      tabcontrol1.tabindex := 1
                    else
                      tabcontrol1.tabindex := 0;
                    tabcontrol1change(self);
                  end;",
// Sentence 380
                  "procedure tform1.correction1click(sender: tobject);
                  begin
                    if comboboxregistrationprotocol.itemindex in [2,3] then
                      tabcontrol1.tabindex := 2
                    else
                      tabcontrol1.tabindex := 1;
                    tabcontrol1change(self);
                  end;",
// Sentence 381
                  "procedure tform1.overview1click(sender: tobject);
                  begin
                    if comboboxregistrationprotocol.itemindex in [2,3] then
                      tabcontrol1.tabindex := 3
                    else
                      tabcontrol1.tabindex := 2;
                    tabcontrol1change(self);
                  end;",
// Sentence 382
                  "procedure writescan(f: tavsfield; dir, name, patid: string);
                  var xfm: tavsfield;
                  begin
                    xfm := tavsfield.create;
                    eulerxfm(xfm);
                    if form1.datatype=\'dicom\' then
                    else if form1.datatype=\'pinnacle\' then
                      write_pin_scan(f, dir, patid + \' \' + name, \'hfs\', strtointdef(name, 9999));
                    xfm.free;
                  end;",
// Sentence 383
                  "procedure tform1.exportmatched3d1click(sender: tobject);
                  begin
                    quirtviewerupdcoronal.frame.value := -1;
                    exportmatched4d1click(nil);
                  end;",
// Sentence 384
                  "procedure tform1.exportmatched4d1click(sender: tobject);
                  var url, t, filename, f, name, patid: string;
                      i, j, k: integer;
                      machinetosiddon, x, tmp: tavsfield;
                      ini: tinifile;
                  begin
                    if assigned(sender) then
                      quirtviewerupdcoronal.frame.value := 0;
                    if datatype\<\>\'dicom\' then
                    begin
                      if doseurl=\'\' then
                      begin
                        buttonclinicalpatientclick(nil);
                        url := patienturl;
                        url := treeselector(url, \'beam\');
                        if url=\'\' then exit;
                      end
                      else
                        url := doseurl;
                      patienturl := copy(url, 1, pos(\'.patient\', url)+8);
                      j := 0;
                      for i:=1 to length(patienturl) do
                        if patienturl[i]=\':\' then j:=i;
                      patienturl := copy(patienturl,1,j-1);
                      if (pos(\'.scan\', url)\>=1) and not reference[1].properties.empty then
                        t := copy(url, 1, pos(\'.scan\', url)+4)
                      else
                        t := treeselector(patienturl, \'scan\');
                      if t=\'\' then exit;
                    end;
                    filename := datapath + copy(patienturl, 7, 250);
                    if datatype\<\>\'dicom\' then
                    begin
                      if not sysutils.directoryexists(filename) then
                      begin
                        showmessage(clinical_warning);
                        exit;
                      end;
                      f    := filename;
                      name := \'\';
                      if not inputquery(pinname_query, scan_prompt, name) then exit;
                      if length(name)=0 then exit;
                    end
                    else
                    begin
                      name := tempdir+\'test%04d\';
                      if not inputquery(\'dicom file name base\', \'scan: \', name) then exit;
                      if length(name)=0 then exit;
                    end;
                    ini := tqinifile.create(getfullinifilename(\'datasources.ini\'));
                    datasource := ini.readstring(\'xvi\', \'device\', \'\');
                    ini.free;
                    i := pos(\':\', datasource);
                    if i\>0 then
                    begin
                      datatype := uppercase(copy(datasource, 1, i-1));
                      datapath := copy(datasource, i+1, 250);
                      if datapath[length(datapath)]\<\>\'\\\' then datapath := datapath + \'\\\';
                    end;
                    if datatype\<\>\'dicom\' then
                    begin
                      treereader(online[4].data, t, \'\');
                      treereader(online[4].tosiddon,  t, \'worldxfm\');
                      treereader(online[4].properties, t, \'all\');
                      if pos(\'.dose\', url)\>0 then
                      begin
                        j := 0;
                        for i:=1 to length(url) do
                          if url[i]=\'\\\' then j:=i;
                        url := copy(url,1,j)+\'1.beam\';
                      end;
                    machinetosiddon := tavsfield.create;
                      treereader(machinetosiddon, url, \'worldxfm\');
                      for i:=0 to 2 do
                        for j:=0 to 2 do
                          if i=j then machinetosiddon.setvalue([i,j], 1)
                          else        machinetosiddon.setvalue([i,j], 0);
                      transform_math(online[4].tosiddon, machinetosiddon, online[4].tomachine, false, true);
                      transform_math(online[4].tomachine, machine_to_siddon, online[4].tosiddon, false, false);
                      machinetosiddon.free;
                    end;
                    x := tavsfield.create;
                    tmp := tavsfield.create;
                    if transform4d.empty then
                      field_copy(machine_to_machineadjust, x)
                    else
                      field_slice(transform4d, x, -1, -1, nclipbox*2, 0);
                    if x.getvalue([3,3])\<0.95 then eulerxfm(x);
                    transform_math(online_to_machine, x, x);
                    if datatype\<\>\'dicom\' then
                      transform_math(x, online[4].tomachine, x, false, true)
                    else
                      transform_math(x, reference[1].tomachine, x, false, true);
                    if (onlinecube.ndim=4) and (sender\<\>nil) then
                    begin
                      for k:=0 to onlinecube.dimensions[3]-1 do
                      begin
                        field_slice(onlinecube, tmp, -1, -1, -1, k);
                        if datatype\<\>\'dicom\' then
                        begin
                          fieldxfm(tmp, x, online[4].data, tmp, 0, 0, fieldxfm_3dfield);
                          yzx_to_xyz(tmp, tmp);
                        end
                        else
                        begin
                          fieldxfm(tmp, x, reference[1].data, tmp, 0, 0, fieldxfm_3dfield);
                          field_resize(tmp, tmp, 2, 2);
                          if tmp.coordinate[0,0]\<tmp.coordinate[0,1] then modify_extents(tmp, tmp, -1);
                          if tmp.coordinate[1,0]\>tmp.coordinate[1,1] then modify_extents(tmp, tmp, 1, -1);
                        end;
                        if tmp.datasize\<\>2 then field_to_short(tmp, tmp);
                        field_maxc(tmp, tmp, 0);
                        j := pos(\':\', patienturl);
                        patid := copy(patienturl, j+1, 250);
                        writescan(tmp, f, name + \'.\' + inttostr(k), patid);
                        if datatype\<\>\'dicom\' then
                          name := inttostr(strtointdef(name, 9999)+1);
                      end
                    end
                    else
                    begin
                      if (onlinecube.ndim=4) and (sender=nil) then
                      begin
                        field_ortho_average(onlinecube, tmp, field_ortho_average_udirection);
                        showmessage(scan_saved_avg);
                      end;
                      if datatype\<\>\'dicom\' then
                      begin
                        fieldxfm(tmp, x, online[4].data, tmp, 0, 0, fieldxfm_3dfield);
                        yzx_to_xyz(tmp, tmp);
                      end
                      else
                      begin
                        fieldxfm(tmp, x, reference[1].data, tmp, 0, 0, fieldxfm_3dfield);
                        if tmp.coordinate[0,0]\<tmp.coordinate[0,1] then modify_extents(tmp, tmp, -1);
                        if tmp.coordinate[1,0]\>tmp.coordinate[1,1] then modify_extents(tmp, tmp, 1, -1);
                      end;
                      if tmp.datasize\<\>2 then field_to_short(tmp, tmp);
                      field_maxc(tmp, tmp, 0);
                      j := pos(\':\', patienturl);
                      patid := copy(patienturl, j+1, 250);
                      writescan(tmp, f, name, patid);
                      showmessage(scan_saved_pin + name);
                    end;
                    x.free;
                    tmp.free;
                    online[4].clear;
                  end;",
// Sentence 385
                  "procedure tform1.colorstringgrid3setedittext(sender: tobject; acol,
                    arow: integer; const value: string);
                  var g: tcolorstringgrid;
                  begin
                    g := sender as tcolorstringgrid;
                    boxclick(g.cellprops[1,0].box);
                  end;",
// Sentence 386
                  "procedure tform1.colorstringgrid3exit(sender: tobject);
                  var g: tcolorstringgrid;
                      arow : integer;
                  begin
                    g := sender as tcolorstringgrid;
                    for arow := 1 to 3 do
                    begin
                      g.cells[1,arow] := format(\'%.1f\', [-abs(0.001+safestrtofloat(g.cells[1,arow]))]);
                      g.cells[2,arow] := format(\'%.1f\', [abs(0.001+safestrtofloat(g.cells[2,arow]))]);
                    end;
                    for arow := 5 to 7 do
                    begin
                      g.cells[1,arow] := format(\'%.1f\', [-min(abs(0.001+safestrtofloat(g.cells[1,arow])),180)]);
                      g.cells[2,arow] := format(\'%.1f\', [min(abs(0.001+safestrtofloat(g.cells[2,arow])),180)]);
                    end;
                  end;",
// Sentence 387
                  "procedure tform1.colorstringgrid3enter(sender: tobject);
                  var g: tcolorstringgrid;
                  begin
                    g := sender as tcolorstringgrid;
                    g.onselectcell := nil;
                    g.row := 1;
                    if g.cellprops[1,0].box.checked then g.col := 2 else g.col := 1;
                    g.onselectcell := colorstringgrid3selectcell;
                  end;",
// Sentence 388
                  "procedure tform1.colorstringgrid3selectcell(sender: tobject; acol,
                    arow: integer; var canselect: boolean);
                  var g: tcolorstringgrid;
                  begin
                     g := sender as tcolorstringgrid;
                     if arow in [0, 4] then g.options := g.options - [goediting];
                     if (arow in [1, 5]) and (acol in [2]) then
                       g.options := g.options + [goediting]
                     else
                     begin
                       g.options := g.options - [goediting];
                       if not g.cellprops[1,0].box.checked then
                         if (arow in [1,2,3]) and (acol in [1,2]) then g.options := g.options + [goediting];
                       if not g.cellprops[1,4].box.checked then
                         if (arow in [5,6,7]) and (acol in [1,2]) then g.options := g.options + [goediting];
                    end;
                    if not (goediting in g.options) then
                      canselect := false;
                    if (arow=2) and (acol=1) and not (goediting in g.options) then
                    begin
                      g.row := 5;
                      g.col := 1 + ord(g.cellprops[1,4].box.checked);
                    end;
                    if (arow=6) and (acol=1) and not (goediting in g.options) then
                    begin
                      if g.cellprops[1,4].box.checked then
                      begin
                        g.row := 1;
                        g.col := 1 + ord(g.cellprops[1,0].box.checked);
                      end;
                    end;
                    if (arow=4) and (acol=1) and not (goediting in g.options) then
                    begin
                      g.row := 5;
                      g.col := 1 + ord(g.cellprops[1,4].box.checked);
                    end;
                    if (arow=0) and (acol=1) and not (goediting in g.options) then
                    begin
                      g.row := 1;
                      g.col := 1 + ord(g.cellprops[1,4].box.checked);
                    end;
                  end;",
// Sentence 389
                  "procedure tform1.boxclick(sender: tobject);
                  var g: tcolorstringgrid;
                      i: integer;
                  begin
                    g := ((sender as tcheckbox).parent) as tcolorstringgrid;
                    if g.cellprops[1,0].box.checked then
                    begin
                      g.cells[1,1] := format(\'%.1f\', [-abs(0.001+safestrtofloat(g.cells[2,1]))]);
                      for i:=2 to 3 do g.cells[1,i] := g.cells[1,1];
                      g.cells[2,2] := format(\'%.1f\', [abs(0.001+safestrtofloat(g.cells[2,1]))]);
                      g.cells[2,3] := g.cells[2,2];
                      for i:=1 to 3 do g.cellprops[1,i].color := clgray;
                      for i:=2 to 3 do g.cellprops[2,i].color := clgray;
                      for i:=1 to 3 do g.cellprops[1,i].style := [];
                      for i:=2 to 3 do g.cellprops[2,i].style := [];
                      for i:=1 to 1 do g.cellprops[2,i].color := clblack;
                      for i:=1 to 1 do g.cellprops[2,i].style := [fsbold];
                    end
                    else
                    begin
                      for i:=1 to 3 do g.cellprops[1,i].color := clblack;
                      for i:=2 to 3 do g.cellprops[2,i].color := clblack;
                      for i:=1 to 3 do g.cellprops[1,i].style := [fsbold];
                      for i:=2 to 3 do g.cellprops[2,i].style := [fsbold];
                    end;
                    if g.cellprops[1,4].box.checked then
                    begin
                      g.cells[1,5] := format(\'%.1f\', [-abs(0.001+safestrtofloat(g.cells[2,5]))]);
                      for i:=6 to 7 do g.cells[1,i] := g.cells[1,5];
                      g.cells[2,6] := format(\'%.1f\', [abs(0.001+safestrtofloat(g.cells[2,5]))]);
                      g.cells[2,7] := g.cells[2,6];
                      for i:=5 to 7 do g.cellprops[1,i].color := clgray;
                      for i:=6 to 7 do g.cellprops[2,i].color := clgray;
                      for i:=5 to 7 do g.cellprops[1,i].style := [];
                      for i:=6 to 7 do g.cellprops[2,i].style := [];
                      for i:=5 to 5 do g.cellprops[2,i].color := clblack;
                      for i:=5 to 5 do g.cellprops[2,i].style := [fsbold];
                    end
                    else
                    begin
                      for i:=5 to 7 do g.cellprops[1,i].color := clblack;
                      for i:=5 to 7 do g.cellprops[2,i].color := clblack;
                      for i:=5 to 7 do g.cellprops[1,i].style := [fsbold];
                      for i:=5 to 7 do g.cellprops[2,i].style := [fsbold];
                    end;
                    g.invalidate;
                  end;",
// Sentence 390
                  "procedure tform1.btnlockplanselectclick(sender: tobject);
                  begin
                  end;",
// Sentence 391
                  "procedure tform1.buttonstatclick(sender: tobject);
                  var
                    ix, iy, t: single;
                    g: tavsfield;
                    mean, sdev, min, fmax: single;
                    npoints: integer;
                    text: string;
                  begin
                    if not assigned(quirtviewer1.clipbox[1]) or (quirtviewer1.clipbox[1].empty) then
                    begin
                      field_create(quirtviewer1.clipbox[1], \'field 1d float\', 4);
                    ix := 0;
                      iy := 0;
                      t := 2;
                      quirtviewer1.clipbox[1].setvalue([0],ix-t);
                      quirtviewer1.clipbox[1].setvalue([1],ix+t);
                      quirtviewer1.clipbox[1].setvalue([2],iy-t);
                      quirtviewer1.clipbox[1].setvalue([3],iy+t);
                    end;
                    g := tavsfield.create;
                    field_cropwithbox(quirtviewer1.field[1], quirtviewer1.clipbox[1] , g);
                    field_stat(g, mean, sdev, min, fmax, npoints, 0, 0, text);
                    memo1.lines.add(floattostr(mean));
                    g.free;
                    end;",
// Sentence 392
                  "procedure tform1.trackbar1change(sender: tobject);
                  var
                    icomplpos: integer;
                  begin
                    if not queryframes.active then
                      exit;
                    icomplpos := trackbar1.max+1-trackbar1.position;
                    if icomplpos\<\>strtointdef(queryframes.fieldbyname(\'seq_num\').asstring, 1) then
                    begin
                      queryframes.locate(\'seq_num\',inttostr(icomplpos), [locaseinsensitive]);
                      setgantry();
                      movieloop(self);
                    end
                  end;",
// Sentence 393
                  "procedure tform1.makematchinactiveclick(sender: tobject);
                  begin
                  end;",
// Sentence 394
                  "procedure tform1.clinicalmodeclick(sender: tobject);
                  begin
                  end;",
// Sentence 395
                  "procedure tform1.buttoncopytohexapodclick(sender: tobject);
                  begin
                    if runprogramblocking(runtableshift, extractfilepath(runtableshift),
                                  [edittranslationlr.text,edittranslationcc.text,edittranslationap.text,
                                   editrotationlr.text,editrotationcc.text,editrotationap.text,
                                   floattostr(correctionreferencepoint.coordinate[0, 0]),
                                   floattostr(correctionreferencepoint.coordinate[1, 0]),
                                   floattostr(correctionreferencepoint.coordinate[2, 0])])=-1 then
                      showmessage(format(\'copy this data to hexapod: %s %s %s %s %s %s %s %s %s\',
                                  [edittranslationlr.text,edittranslationcc.text,edittranslationap.text,
                                   editrotationlr.text,editrotationcc.text,editrotationap.text,
                                   floattostr(correctionreferencepoint.coordinate[0, 0]),
                                   floattostr(correctionreferencepoint.coordinate[1, 0]),
                                   floattostr(correctionreferencepoint.coordinate[2, 0])]));
                  end;",
// Sentence 396
                  "procedure tform1.warpformcreate(sender: tobject);
                  begin
                  end;",
// Sentence 397
                  "procedure tform1.checkboxdoseclick(sender: tobject);
                  begin
                  end;",
// Sentence 398
                  "procedure tform1.checkboxdoseaccuclick(sender: tobject);
                  begin
                    if checkboxdoseaccu.checked then
                      checkboxdose.checked := false;
                  end;",
// Sentence 399
                  "procedure tform1.buttonlimitinformationclick(sender: tobject);
                  begin
                    if quirtviewerupdcoronal.toolbar[1].empty and (alignmentmode.value=0) then
                    begin
                      read_xdr(quirtviewerupdcoronal.toolbar[1], getfullinifilename(\'limits_coronal_clipbox.xdr\'));
                      read_xdr(quirtviewerupdsagittal.toolbar[1], getfullinifilename(\'limits_sagittal_clipbox.xdr\'));
                      read_xdr(quirtviewerupdtransversal.toolbar[1], getfullinifilename(\'limits_transverse_clipbox.xdr\'));
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_clipbox, 10, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_limits,  10, 4, 255, 255, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_clipbox, 10, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_limits,  10, 4, 255, 255, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_clipbox, 10, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_limits,  10, 4, 255, 255, 0, 0);
                    end
                    else if quirtviewerupdcoronal.toolbar[1].empty and (alignmentmode.value=1) then
                    begin
                      read_xdr(quirtviewerupdcoronal.toolbar[1], getfullinifilename(\'limits_coronal_mask.xdr\'));
                      read_xdr(quirtviewerupdsagittal.toolbar[1], getfullinifilename(\'limits_sagittal_mask.xdr\'));
                      read_xdr(quirtviewerupdtransversal.toolbar[1], getfullinifilename(\'limits_transverse_mask.xdr\'));
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_mask, 25, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdcoronal.toolbar[1], nil, quirtviewerupdcoronal.toolbar[1], text_limits,  25, 4, 255, 255, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_mask, 25, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdsagittal.toolbar[1], nil, quirtviewerupdsagittal.toolbar[1], text_limits,  25, 4, 255, 255, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_anatomy, 54, 78, 255, 0, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_mask, 25, 154, 255, 0, 0, 0);
                      field_text(quirtviewerupdtransversal.toolbar[1], nil, quirtviewerupdtransversal.toolbar[1], text_limits,  25, 4, 255, 255, 0, 0);
                    end
                    else
                    begin
                      quirtviewerupdcoronal.toolbar[1].clear;
                      quirtviewerupdsagittal.toolbar[1].clear;
                      quirtviewerupdtransversal.toolbar[1].clear;
                    end;
                  end;",
// Sentence 400
                  "procedure tform1.exitaccept1click(sender: tobject);
                  begin
                    buttonelektadismissclick(buttonelektaaccept);
                  end;",
// Sentence 401
                  "procedure tform1.recordvideo1click(sender: tobject);
                  begin
                    recordvideo1.checked := not recordvideo1.checked;
                    checkboxrecordform.checked := recordvideo1.checked;
                  end;",
// Sentence 402
                  "procedure tform1.bitbtnaverage4dtransformclick(sender: tobject);
                  begin
                  end;",
// Sentence 403
                  "procedure tform1.bitbtnaverage4dtransformmousedown(sender: tobject;
                    button: tmousebutton; shift: tshiftstate; x, y: integer);
                  begin
                    radiobuttonaverageframes.checked := true;
                    radiobuttoneachframe.checked := false;
                  end;",
// Sentence 404
                  "procedure tform1.bitbtnaverage4dtransformmouseup(sender: tobject;
                    button: tmousebutton; shift: tshiftstate; x, y: integer);
                  begin
                    radiobuttonaverageframes.checked := false;
                    radiobuttoneachframe.checked := true;
                  end;",
// Sentence 405
                  "procedure tform1.label74click(sender: tobject);
                  begin
                  end;",
// Sentence 406
                  "procedure tform1.linac1newpatient(const apatientid: string;
                    aworkset: tmercworkset; aevent: tmercevent; aicompacket: tmercicompacket);
                  begin
                  end;",
// Sentence 407
                  "procedure tform1.linac1newtreatment(const atreatname: string;
                    aworkset: tmercworkset; aevent: tmercevent; aicompacket: tmercicompacket);
                  begin
                  end;",
// Sentence 408
                  "procedure tform1.linkmark2clip1click(sender: tobject);
                  begin
                    linkmark2clip1.checked := not linkmark2clip1.checked;
                  end;",
// Sentence 409
                  "procedure tform1.bitbtnwarpclick(sender: tobject);
                  begin
                    if radiobuttonwarpallrois.checked then radiobuttoneachroi.checked := true
                    else radiobuttonwarpallrois.checked := true;
                  end;",
// Sentence 410
                  "procedure tform1.creategeometryclick(sender: tobject);
                  var
                   dir, ifname : string;
                  begin
                    dir := reconfilebase;
                    ifname := dir + treatmentuid  +\'.reference.markers\';
                    if fileexists(ifname) = false then
                       ifname := dir + scanuid + \'.\' + scandate + \'.\' + scantime + \'.online.markers\';
                    if fileexists(ifname) then
                    begin
                    end
                    else
                      showmessage(error_nkinoonlinemarkerfile + #10 + ifname);
                  end;",
// Sentence 411
                  "procedure tform1.createmultianglegainfile1click(sender: tobject);
                  begin
                  end;",
// Sentence 412
                  "procedure tform1.visualizebonesegmentation1click(sender: tobject);
                  begin
                     visualizebonesegmentation1.checked := not visualizebonesegmentation1.checked;
                  end;",
// Sentence 413
                  "procedure tform1.buttonloadtestdataclick(sender: tobject);
                  var f: textfile;
                      s, t: string;
                      i: integer;
                  begin
                    if not opendialog1.execute then exit;
                    assignfile(f, opendialog1.filename);
                    reset(f);
                    readln(f, s);
                    readln(f, s);
                    for i:=0 to max(onlinecube.dimensions[3]-1, 0) do
                    begin
                      readln(f, s);
                      if onlinecube.dimensions[3]\>0 then
                        phasehist.setvalue([i], valuefromstr(s, 2, -1));
                      if comboboxregistrationprotocol.itemindex \<\> comboboxregistrationprotocol.indexofmapped(\'mask\') then
                      begin
                        t := format(\'%g,%g,%g,%g,%g,%g\',
                          [valuefromstr(s, 3, -1), valuefromstr(s, 4, -1),
                           valuefromstr(s, 5, -1), valuefromstr(s, 6, -1),
                           valuefromstr(s, 7, -1), valuefromstr(s, 8, -1)]);
                        packregistration(nil, t, i, 0);
                      end;
                      if comboboxregistrationprotocol.itemindex \<\> comboboxregistrationprotocol.indexofmapped(\'clipbox\') then
                      begin
                        t := format(\'%g,%g,%g,%g,%g,%g\',
                          [valuefromstr(s, 9, -1), valuefromstr(s, 10, -1),
                           valuefromstr(s, 11, -1), valuefromstr(s, 12, -1),
                           valuefromstr(s, 13, -1), valuefromstr(s, 14, -1)]);
                        packregistration(nil, t, i, nclipbox);
                      end;
                      t := format(\'%g,%g,%g,%g,%g,%g\',
                        [valuefromstr(s, 15, -1), valuefromstr(s, 16, -1),
                         valuefromstr(s, 17, -1), valuefromstr(s, 18, -1),
                         valuefromstr(s, 19, -1), valuefromstr(s, 20, -1)]);
                      packregistration(nil, t, i, 2*nclipbox);
                    end;
                    closefile(f);
                  end;",
// Sentence 414
                  "procedure tform1.checkboxshowsegmentationclick(sender: tobject);
                  begin
                    visualizebonesegmentation1.checked := checkboxshowsegmentation.checked;
                  end;",
// Sentence 415
                  "procedure tform1.colorstringgrid3keydown(sender: tobject; var key: word;
                    shift: tshiftstate);
                  begin
                    timeracceptlimits.enabled := false;
                    timeracceptlimits.enabled := true;
                  end;",
// Sentence 416
                  "procedure tform1.timeracceptlimitstimer(sender: tobject);
                  begin
                    colorstringgrid2.onexit(colorstringgrid2);
                    colorstringgrid3.onexit(colorstringgrid3);
                    timeracceptlimits.enabled := false;
                  end;",
// Sentence 417
                  "function getbuilddate(const afilename: string): string;
                  var
                    filename: string;
                    infosize, wnd: dword;
                    verbuf: pointer;
                    fi: pchar;
                    versize: dword;
                  begin
                    result := \'\';
                    try
                      filename := afilename;
                      uniquestring(filename);
                      infosize := getfileversioninfosize(pchar(filename), wnd);
                      if infosize \<\> 0 then
                      begin
                        getmem(verbuf, infosize);
                        try
                          if getfileversioninfo(pchar(filename), wnd, infosize, verbuf) then
                            if verqueryvalue(verbuf, \'\\stringfileinfo\\040904e4\\build date\',
                              pointer(fi), versize) then
                              result := fi;
                        finally
                          freemem(verbuf);
                        end;
                      end;
                    except
                      end;
                  end;",
// Sentence 418
                  "procedure tform1.loaddvf1click(sender: tobject);
                  begin
                  end;"
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..419])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::MethodImplementation, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::MethodImplementation, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::MethodImplementation, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_MethodImplementation2_000()
{
    return parse(#DelphiGrammar::MethodImplementation, "function crc16(s: string): uint16;
                  var
                    m_crctable: array[0..255] of word;
                  
                    procedure ccrcinit();
                    var
                      counter: integer;
                      c: shortint; // signed 8-bit integer
                    begin
                      for counter := 0 to 256-1 do
                      begin
                        c := shortint(counter xor (counter shl 4));
                        m_crctable[counter] := word((integer(c) shl 8) xor (integer(c) shl 3) xor (integer(c) shr 4));
                      end;
                    end;
                  
                    procedure ccrcupdatecrc(buffer: pbyte; var crc: word);
                    begin
                      crc := (crc shr 8) xor m_crctable[buffer^ xor (crc and 255)];
                    end;
                  
                    function ccrccomputecrc(buffer: pbyte; length: dword): word;
                    var
                      crc: word;      // unsigned 16-bit integer
                      counter: dword; // unsigned 32-bit integer
                    begin
                      crc := 0;
                  
                      for counter := 0 to length-1 do
                      begin
                        ccrcupdatecrc(buffer, crc);
                        inc(buffer);
                      end;
                  
                      result := crc;
                    end;
                  
                  var
                    ansi: ansistring;
                  begin
                    ccrcinit;
                    ansi := ansistring(s);
                    result := ccrccomputecrc(pbyte(pansichar(ansi)), length(ansi))
                  end;");
}

test bool Test_TestCases_1_MethodImplementation2()
{
    print("Running 1 tests for construction \'MethodImplementation2\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "function crc16(s: string): uint16;
                  var
                    m_crctable: array[0..255] of word;
                  
                    procedure ccrcinit();
                    var
                      counter: integer;
                      c: shortint; // signed 8-bit integer
                    begin
                      for counter := 0 to 256-1 do
                      begin
                        c := shortint(counter xor (counter shl 4));
                        m_crctable[counter] := word((integer(c) shl 8) xor (integer(c) shl 3) xor (integer(c) shr 4));
                      end;
                    end;
                  
                    procedure ccrcupdatecrc(buffer: pbyte; var crc: word);
                    begin
                      crc := (crc shr 8) xor m_crctable[buffer^ xor (crc and 255)];
                    end;
                  
                    function ccrccomputecrc(buffer: pbyte; length: dword): word;
                    var
                      crc: word;      // unsigned 16-bit integer
                      counter: dword; // unsigned 32-bit integer
                    begin
                      crc := 0;
                  
                      for counter := 0 to length-1 do
                      begin
                        ccrcupdatecrc(buffer, crc);
                        inc(buffer);
                      end;
                  
                      result := crc;
                    end;
                  
                  var
                    ansi: ansistring;
                  begin
                    ccrcinit;
                    ansi := ansistring(s);
                    result := ccrccomputecrc(pbyte(pansichar(ansi)), length(ansi))
                  end;"
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..1])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::MethodImplementation, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::MethodImplementation, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::MethodImplementation, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Program_000()
{
    return parse(#DelphiGrammar::Program, "program testprogram(wudde); 
                               uses a,b,c,d;
                               
                               const
                                  a : integer = 10;
                                  b = 15;
                               
                               type
                                  tb = record
                                          a,b: integer;
                                          c : string;end;
                               
                               var 
                                  a : integer;
                               
                               procedure a(); 
                               var 
                                  a: integer; 
                               begin 
                                  a:=a+1; 
                               end; 
                               
                               begin 
                                  a(b*3+2,c); 
                               end.");
}

test bool Test_TestCases_1_Program()
{
    print("Running 1 tests for construction \'Program\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "program testprogram(wudde); 
                               uses a,b,c,d;
                               
                               const
                                  a : integer = 10;
                                  b = 15;
                               
                               type
                                  tb = record
                                          a,b: integer;
                                          c : string;end;
                               
                               var 
                                  a : integer;
                               
                               procedure a(); 
                               var 
                                  a: integer; 
                               begin 
                                  a:=a+1; 
                               end; 
                               
                               begin 
                                  a(b*3+2,c); 
                               end."
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..1])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::Program, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::Program, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::Program, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_RecordType_000()
{
    return parse(#DelphiGrammar::RecordType, "record public a : integer; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_RecordType_001()
{
    return parse(#DelphiGrammar::RecordType, "record a : integer; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_RecordType_002()
{
    return parse(#DelphiGrammar::RecordType, "record public end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_RecordType_003()
{
    return parse(#DelphiGrammar::RecordType, "record end");
}

test bool Test_TestCases_1_RecordType()
{
    print("Running 4 tests for construction \'RecordType\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "record public a : integer; end",
// Sentence 001
                  "record a : integer; end",
// Sentence 002
                  "record public end",
// Sentence 003
                  "record end"
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..4])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::RecordType, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::RecordType, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::RecordType, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Statement_000()
{
    return parse(#DelphiGrammar::Statement, "try blah(); except on exception do begin blah2(); end; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Statement_001()
{
    return parse(#DelphiGrammar::Statement, "try blah() except on exception do begin blah2(); end; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Statement_002()
{
    return parse(#DelphiGrammar::Statement, "if a=4 then if b=4 then a:=5");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Statement_003()
{
    return parse(#DelphiGrammar::Statement, "if a=1 then 
                  			if b=1 then 
                  				for i:=1 to 10 do 
                  					if a=3 then 
                  						a:=4 
                  					else 
                  						b:=2 
                  			else 
                  				c:=3 
                  		else 
                  			d:=4");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Statement_004()
{
    return parse(#DelphiGrammar::Statement, "if a=1 then
                  			if b=1 then
                  				b:=1
                  			else
                  				c:=1");
}

test bool Test_TestCases_1_Statement()
{
    print("Running 5 tests for construction \'Statement\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "try blah(); except on exception do begin blah2(); end; end",
// Sentence 001
                  "try blah() except on exception do begin blah2(); end; end",
// Sentence 002
                  "if a=4 then if b=4 then a:=5",
// Sentence 003
                  "if a=1 then 
                  			if b=1 then 
                  				for i:=1 to 10 do 
                  					if a=3 then 
                  						a:=4 
                  					else 
                  						b:=2 
                  			else 
                  				c:=3 
                  		else 
                  			d:=4",
// Sentence 004
                  "if a=1 then
                  			if b=1 then
                  				b:=1
                  			else
                  				c:=1"
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..5])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::Statement, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::Statement, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::Statement, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_000()
{
    return parse(#DelphiGrammar::StatementBody, "3*5");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_001()
{
    return parse(#DelphiGrammar::StatementBody, "3*5+2");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_002()
{
    return parse(#DelphiGrammar::StatementBody, "begin            {blabla}        end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_003()
{
    return parse(#DelphiGrammar::StatementBody, "begin a:=a+5; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_004()
{
    return parse(#DelphiGrammar::StatementBody, "begin end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_005()
{
    return parse(#DelphiGrammar::StatementBody, "begin{blabla}end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_006()
{
    return parse(#DelphiGrammar::StatementBody, "case a          of 3:          a:=a + 1;      end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_007()
{
    return parse(#DelphiGrammar::StatementBody, "case a          of 3:          a:=a + 1;  else          end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_008()
{
    return parse(#DelphiGrammar::StatementBody, "case a          of 3:          a:=a + 1;  else      end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_009()
{
    return parse(#DelphiGrammar::StatementBody, "case a          of 3:          a:=a + 1;  else   b:=b+1;       end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_010()
{
    return parse(#DelphiGrammar::StatementBody, "case a          of 3:          a:=a + 1;  else b:=b+1;    end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_011()
{
    return parse(#DelphiGrammar::StatementBody, "case a          of 3:          a:=a + 1;  else end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_012()
{
    return parse(#DelphiGrammar::StatementBody, "case a          of 3:          a:=a + 1;  end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_013()
{
    return parse(#DelphiGrammar::StatementBody, "case a          of 3:          a:=a+1;end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_014()
{
    return parse(#DelphiGrammar::StatementBody, "case a of 3..4,5: a:=a+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_015()
{
    return parse(#DelphiGrammar::StatementBody, "case a of 3:          a:=a+1;        end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_016()
{
    return parse(#DelphiGrammar::StatementBody, "case a of 3:          a:=a+1;end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_017()
{
    return parse(#DelphiGrammar::StatementBody, "case a of 3: a:=a+1 end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_018()
{
    return parse(#DelphiGrammar::StatementBody, "case a of 3: a:=a+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_019()
{
    return parse(#DelphiGrammar::StatementBody, "case a of 3:a:=a+1;end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_020()
{
    return parse(#DelphiGrammar::StatementBody, "for a in b do begin a:=a+1; b:=b+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_021()
{
    return parse(#DelphiGrammar::StatementBody, "for i:=1 downto 100 do a:=a+1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_022()
{
    return parse(#DelphiGrammar::StatementBody, "for i:=1 downto 100 do begin a:=a+1; b:=b+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_023()
{
    return parse(#DelphiGrammar::StatementBody, "for i:=1 to 100 do a:=a+1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_024()
{
    return parse(#DelphiGrammar::StatementBody, "goto 20");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_025()
{
    return parse(#DelphiGrammar::StatementBody, "if a=4 then a:=4 else b:=5");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_026()
{
    return parse(#DelphiGrammar::StatementBody, "if a=5 then a:=a+5");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_027()
{
    return parse(#DelphiGrammar::StatementBody, "if a=5 then begin a:=a+5; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_028()
{
    return parse(#DelphiGrammar::StatementBody, "inherited");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_029()
{
    return parse(#DelphiGrammar::StatementBody, "raise cexception at testa at testb");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_030()
{
    return parse(#DelphiGrammar::StatementBody, "raise cexception");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_031()
{
    return parse(#DelphiGrammar::StatementBody, "repeat a:=a+1; b:b+1; {comment} until a=b");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_032()
{
    return parse(#DelphiGrammar::StatementBody, "repeat until a=b");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_033()
{
    return parse(#DelphiGrammar::StatementBody, "try a:=a+1; finally b:=b+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_034()
{
    return parse(#DelphiGrammar::StatementBody, "try begin a:=a+1; end; begin b:=b+1; end; except b:=b+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_035()
{
    return parse(#DelphiGrammar::StatementBody, "try begin a:=a+1; end; begin b:=b+1; end; except on e : texception.exception do a:=a+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_036()
{
    return parse(#DelphiGrammar::StatementBody, "try begin a:=a+1; end; begin b:=b+1; end; except on e : texception.exception do begin a:=a+1; end; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_037()
{
    return parse(#DelphiGrammar::StatementBody, "try begin a:=a+1; end; begin b:=b+1; end; except on e : texception.exception do begin a:=a+1; end; on e : texception.exception do begin a:=a+1; end; else begin a:=a+1; end; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_038()
{
    return parse(#DelphiGrammar::StatementBody, "try begin a:=a+1; end; begin b:=b+1; end; except on e : texception.exception do begin a:=a+1; end; on e : texception.exception do begin a:=a+1; end; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_039()
{
    return parse(#DelphiGrammar::StatementBody, "try begin a:=a+1; end; begin b:=b+1; end; finally b:=b+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_040()
{
    return parse(#DelphiGrammar::StatementBody, "try begin a:=a+1; end; finally b:=b+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_041()
{
    return parse(#DelphiGrammar::StatementBody, "while a=3 do a:=a+1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_042()
{
    return parse(#DelphiGrammar::StatementBody, "while a=3 do begin a:=a+1; b:=b+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_043()
{
    return parse(#DelphiGrammar::StatementBody, "with a,b,c do a:=a+1");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_044()
{
    return parse(#DelphiGrammar::StatementBody, "with a,b,c do begin a:=a+1; end");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_045()
{
    return parse(#DelphiGrammar::StatementBody, "testvar := 3*5+2");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementBody_046()
{
    return parse(#DelphiGrammar::StatementBody, "begin case a.b of 1: begin end; 2: a:=a+1; else b:=b+1;  end; end");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_StatementBody_000()
{
    return parse(#DelphjiGrammar::StatementBody, "beginend");
}

Tree Test_CreateTree_ShouldFail_TestCases_1_StatementBody_001()
{
    return parse(#DelphjiGrammar::StatementBody, "if a=5 then a:=a+5;");
}

test bool Test_TestCases_1_StatementBody()
{
    print("Running 49 tests for construction \'StatementBody\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "3*5",
// Sentence 001
                  "3*5+2",
// Sentence 002
                  "begin            {blabla}        end",
// Sentence 003
                  "begin a:=a+5; end",
// Sentence 004
                  "begin end",
// Sentence 005
                  "begin{blabla}end",
// Sentence 006
                  "case a          of 3:          a:=a + 1;      end",
// Sentence 007
                  "case a          of 3:          a:=a + 1;  else          end",
// Sentence 008
                  "case a          of 3:          a:=a + 1;  else      end",
// Sentence 009
                  "case a          of 3:          a:=a + 1;  else   b:=b+1;       end",
// Sentence 010
                  "case a          of 3:          a:=a + 1;  else b:=b+1;    end",
// Sentence 011
                  "case a          of 3:          a:=a + 1;  else end",
// Sentence 012
                  "case a          of 3:          a:=a + 1;  end",
// Sentence 013
                  "case a          of 3:          a:=a+1;end",
// Sentence 014
                  "case a of 3..4,5: a:=a+1; end",
// Sentence 015
                  "case a of 3:          a:=a+1;        end",
// Sentence 016
                  "case a of 3:          a:=a+1;end",
// Sentence 017
                  "case a of 3: a:=a+1 end",
// Sentence 018
                  "case a of 3: a:=a+1; end",
// Sentence 019
                  "case a of 3:a:=a+1;end",
// Sentence 020
                  "for a in b do begin a:=a+1; b:=b+1; end",
// Sentence 021
                  "for i:=1 downto 100 do a:=a+1",
// Sentence 022
                  "for i:=1 downto 100 do begin a:=a+1; b:=b+1; end",
// Sentence 023
                  "for i:=1 to 100 do a:=a+1",
// Sentence 024
                  "goto 20",
// Sentence 025
                  "if a=4 then a:=4 else b:=5",
// Sentence 026
                  "if a=5 then a:=a+5",
// Sentence 027
                  "if a=5 then begin a:=a+5; end",
// Sentence 028
                  "inherited",
// Sentence 029
                  "raise cexception at testa at testb",
// Sentence 030
                  "raise cexception",
// Sentence 031
                  "repeat a:=a+1; b:b+1; {comment} until a=b",
// Sentence 032
                  "repeat until a=b",
// Sentence 033
                  "try a:=a+1; finally b:=b+1; end",
// Sentence 034
                  "try begin a:=a+1; end; begin b:=b+1; end; except b:=b+1; end",
// Sentence 035
                  "try begin a:=a+1; end; begin b:=b+1; end; except on e : texception.exception do a:=a+1; end",
// Sentence 036
                  "try begin a:=a+1; end; begin b:=b+1; end; except on e : texception.exception do begin a:=a+1; end; end",
// Sentence 037
                  "try begin a:=a+1; end; begin b:=b+1; end; except on e : texception.exception do begin a:=a+1; end; on e : texception.exception do begin a:=a+1; end; else begin a:=a+1; end; end",
// Sentence 038
                  "try begin a:=a+1; end; begin b:=b+1; end; except on e : texception.exception do begin a:=a+1; end; on e : texception.exception do begin a:=a+1; end; end",
// Sentence 039
                  "try begin a:=a+1; end; begin b:=b+1; end; finally b:=b+1; end",
// Sentence 040
                  "try begin a:=a+1; end; finally b:=b+1; end",
// Sentence 041
                  "while a=3 do a:=a+1",
// Sentence 042
                  "while a=3 do begin a:=a+1; b:=b+1; end",
// Sentence 043
                  "with a,b,c do a:=a+1",
// Sentence 044
                  "with a,b,c do begin a:=a+1; end",
// Sentence 045
                  "testvar := 3*5+2",
// Sentence 046
                  "begin case a.b of 1: begin end; 2: a:=a+1; else b:=b+1;  end; end"
                 ];

    // Patterns that must fail
    failSet = [
// Sentence 000
                  "beginend",
// Sentence 001
                  "if a=5 then a:=a+5;"
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..47])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::StatementBody, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::StatementBody, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..2])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::StatementBody, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementList_000()
{
    return parse(#DelphiGrammar::StatementList, "try except end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementList_001()
{
    return parse(#DelphiGrammar::StatementList, "try a:=a+1; except end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementList_002()
{
    return parse(#DelphiGrammar::StatementList, "try a:=a+1; except a:=a+1; end;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_StatementList_003()
{
    return parse(#DelphiGrammar::StatementList, "if a=4 then if b=5 then a:=5;");
}

test bool Test_TestCases_1_StatementList()
{
    print("Running 4 tests for construction \'StatementList\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "try except end;",
// Sentence 001
                  "try a:=a+1; except end;",
// Sentence 002
                  "try a:=a+1; except a:=a+1; end;",
// Sentence 003
                  "if a=4 then if b=5 then a:=5;"
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..4])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::StatementList, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::StatementList, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::StatementList, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Unit_000()
{
    return parse(#DelphiGrammar::Unit, "
                  unit mainform;
                  
                  interface
                  
                  uses
                    winapi.windows, winapi.messages, system.sysutils, system.variants, system.classes, vcl.graphics,
                    vcl.controls, vcl.forms, vcl.dialogs, vcl.stdctrls, serialmanager, serialprotocol,
                    vcl.extctrls, vcl.comctrls, settingsform, inifiles, vcl.menus, math;
                  
                  const
                    gcisocoperatingmodenone                   = 0;
                  
                    gcisocoperatingmodefindmaincubeisoc       = 1;
                    gcisocoperatingmodefindattachedcubeisoc   = 2;
                    gcisocoperatingmodecalibration            = 3;
                  
                  
                    gcisocmaincubeprogressgantry_0_collimator_0   = 1;
                    gcisocmaincubeprogressgantry_0_collimator_180 = 2;
                    gcisocmaincubeprogressshowresults             = 3;
                  
                    gcisocattachedcubeprogressgantry_0_collimator_0     = 1;
                    gcisocattachedcubeprogressgantry_0_collimator_180   = 2;
                  
                    gcisocattachedcubeprogressgantry_l90_collimator_0   = 3;
                    gcisocattachedcubeprogressgantry_l90_collimator_180 = 4;
                  
                    gcisocattachedcubeprogressgantry_180_collimator_0   = 5;
                    gcisocattachedcubeprogressgantry_180_collimator_180 = 6;
                  
                    gcisocattachedcubeprogressgantry_r90_collimator_0   = 7;
                    gcisocattachedcubeprogressgantry_r90_collimator_180 = 8;
                  
                    gcisocattachedcubeprogressshowresults               = 9;
                  
                    gcisoccalibrationneeded                             = 1;
                    gcisoccalibrationcompleted                          = 2;
                    gcisoccalibrationbusy                                                                         = 3;
                  
                    gcsweepplaneattachedtop     = 0;
                    gcsweepplaneattachedbottom  = 1;
                    gcsweepplaneattachedleft    = 2;
                    gcsweepplaneattachedright   = 3;
                    gcsweepplanemaintop         = 4;
                  
                    gccollimatorangle_0   = 0;
                    gccollimatorangle_180 = 1;
                  
                    gcinvalidisocvalue    : longint = $f0000000;
                  
                  type
                    tgsensorreading = record
                      x, y, z : single;
                    end;
                  
                    tisoccube       = record
                      xl, xr  : longint;
                      yf, yb  : longint;
                      zt, zb  : longint;
                    end;
                  
                    tisocplane    = record
                      collimatorangle : array[0..1] of tisoccube;
                    end;
                  
                    tisocmeasurements = record
                      plane : array[0..4] of tisocplane;
                    end;
                  
                    tform1 = class(tform)
                      timer_serialmaintenance: ttimer;
                      memoconsole: tmemo;
                      statusbar1: tstatusbar;
                      mainmenu1: tmainmenu;
                      isocfinder1: tmenuitem;
                      connect1: tmenuitem;
                      settings1: tmenuitem;
                      serialsettings1: tmenuitem;
                      disconnect1: tmenuitem;
                      n1: tmenuitem;
                      exit1: tmenuitem;
                      help1: tmenuitem;
                      about1: tmenuitem;
                      pagecontrol1: tpagecontrol;
                      tabsheet1: ttabsheet;
                      tabsheet2: ttabsheet;
                      button_test_getversion: tbutton;
                      button_test_sweep: tbutton;
                      button_test_sweepcompleted: tbutton;
                      button_test_resetisoccube: tbutton;
                      button_test_getisoccube: tbutton;
                      button_test_requestcalibration: tbutton;
                      button_test_iscalibrationcomplete: tbutton;
                      general: ttabsheet;
                      button_test_ismotorbusy: tbutton;
                      button_test_getcubeposition: tbutton;
                      button_test_setcubeposition: tbutton;
                      edit_x: tedit;
                      edit_y: tedit;
                      edit_z: tedit;
                      label1: tlabel;
                      label2: tlabel;
                      label3: tlabel;
                      button_test_setminusposition: tbutton;
                      button_test_setzeroposition: tbutton;
                      button_test_setplusposition: tbutton;
                      button_test_gsensor: tbutton;
                      tabsheetgsensor: ttabsheet;
                      gsensorimage: timage;
                      panel1: tpanel;
                      groupbox1: tgroupbox;
                      gsensormainxedit: tedit;
                      gsensormainyedit: tedit;
                      gsensormainzedit: tedit;
                      label4: tlabel;
                      label5: tlabel;
                      label6: tlabel;
                      timer_gsensor: ttimer;
                      panel2: tpanel;
                      button_maincubeisoc_restart: tbutton;
                      button_maincubeisoc_nextstep: tbutton;
                      button_maincubeisoc_sweep: tbutton;
                      button_maincubeisoc_center: tbutton;
                      label_maincubeisoc_0_0: tlabel;
                      label_maincubeisoc_0_180: tlabel;
                      label_maincubeisoc_results: tlabel;
                      panel3: tpanel;
                      label_calibrationrequired: tlabel;
                      label_calibrationcompleted: tlabel;
                      button_calibrate_start: tbutton;
                      timer_operation: ttimer;
                      findisocmaincubememo: tmemo;
                      tabsheet3: ttabsheet;
                      panel4: tpanel;
                      label_attachedcubeisoc_0_0: tlabel;
                      label_attachedcubeisoc_0_180: tlabel;
                      label_attachedcubeisoc_results: tlabel;
                      button_findattachedcube_start: tbutton;
                      button_findattachedcube_nextstep: tbutton;
                      button_findattachedcube_sweep: tbutton;
                      button_findattachedcube_centercube: tbutton;
                      findisocattachedcubememo: tmemo;
                      label_attachedcubeisoc_90_0: tlabel;
                      label_attachedcubeisoc_90_180: tlabel;
                      label_attachedcubeisoc_180_0: tlabel;
                      label_attachedcubeisoc_180_180: tlabel;
                      label_attachedcubeisoc_m90_0: tlabel;
                      label_attachedcubeisoc_m90_180: tlabel;
                      button_findattachedcube_prevstep: tbutton;
                      button_maincubeisoc_prevstep: tbutton;
                      procedure formcreate(sender: tobject);
                      procedure formdestroy(sender: tobject);
                      procedure timer_serialmaintenancetimer(sender: tobject);
                      procedure button_test_getversionclick(sender: tobject);
                      procedure button_test_sweepclick(sender: tobject);
                      procedure button_test_sweepcompletedclick(sender: tobject);
                      procedure button_test_resetisoccubeclick(sender: tobject);
                      procedure button_test_getisoccubeclick(sender: tobject);
                      procedure button_test_requestcalibrationclick(sender: tobject);
                      procedure button_test_iscalibrationcompleteclick(sender: tobject);
                      procedure formclose(sender: tobject; var action: tcloseaction);
                      procedure connect1click(sender: tobject);
                      procedure disconnect1click(sender: tobject);
                      procedure serialsettings1click(sender: tobject);
                      procedure exit1click(sender: tobject);
                      procedure button_test_ismotorbusyclick(sender: tobject);
                      procedure button_test_getcubepositionclick(sender: tobject);
                      procedure button_test_setcubepositionclick(sender: tobject);
                      procedure button_test_setminuspositionclick(sender: tobject);
                      procedure button_test_setzeropositionclick(sender: tobject);
                      procedure button_test_setpluspositionclick(sender: tobject);
                      procedure button_test_gsensorclick(sender: tobject);
                      procedure tabsheetgsensorshow(sender: tobject);
                      procedure tabsheetgsensorhide(sender: tobject);
                      procedure formresize(sender: tobject);
                      procedure timer_gsensortimer(sender: tobject);
                      procedure button_calibrate_startclick(sender: tobject);
                      procedure timer_operationtimer(sender: tobject);
                      procedure button_maincubeisoc_restartclick(sender: tobject);
                      procedure button_maincubeisoc_sweepclick(sender: tobject);
                      procedure button_maincubeisoc_nextstepclick(sender: tobject);
                      procedure button_findattachedcube_startclick(sender: tobject);
                      procedure button_findattachedcube_sweepclick(sender: tobject);
                      procedure button_findattachedcube_nextstepclick(sender: tobject);
                      procedure button_maincubeisoc_centerclick(sender: tobject);
                      procedure button_findattachedcube_centercubeclick(sender: tobject);
                      procedure button_findattachedcube_prevstepclick(sender: tobject);
                      procedure button_maincubeisoc_prevstepclick(sender: tobject);
                  
                    private
                      fserialmanager  : tserialmanager;
                  
                      fcommport             : string;
                      fcommconnectionstring : string;
                  
                      fserialconnectiononline : boolean;
                  
                      fgsensorreadingmaincube : tgsensorreading;
                  
                      fisocoperatingmodeprogressmaincube      : integer;
                      fisocoperatingmodeprogressattachedcube  : integer;
                      fisocoperatingmodeprogresscalibration   : integer;
                  
                      fisocoperatingmode              : integer;
                  
                      fisocmeasurements               : tisocmeasurements;
                  
                      faxissweepinprogress            : boolean;
                  
                      fattachedcubecomputedisoccube   : tisoccube;
                      fmaincubecomputedisoccube       : tisoccube;
                  
                      function issystembusywithoperationifsoprintonconsole(wantedoperationmode : integer) : boolean;
                  
                  
                      class procedure callbackversion(version : byte); static;
                      class procedure callbacksweepplane(); static;
                      class procedure callbacksweepplanecompleted(busy, completed : byte); static;
                      class procedure callbackresetisoccube(); static;
                      class procedure callbackgetisoccube(plane : byte;
                                                          xl, xr, yf, yb,
                                                          zt, zb : integer); static;
                      class procedure callbackrequestcalibrate(); static;
                      class procedure callbackcalibrationiscompleted(busy,
                                                                     completed : byte); static;
                  
                      class procedure callbacksetcubeposition(); static;
                      class procedure callbackgetcubeposition(x, y, z : longint); static;
                      class procedure callbackismotorbusy(motorisbusy : boolean); static;
                  
                      class procedure callbackgetgsensorinput(x, y, z : single); static;
                  
                    private
                      procedure showmaincubeisocpositiondata();
                      procedure showattachedcubeisocpositiondata();
                  
                      function printisocvalue(value : longint) : string;
                      procedure printisocreadings(memo : tmemo; isoc : tisoccube; avginsteadofdiff : boolean);
                  
                      procedure computeisocmaincube(var isoccube : tisoccube);
                      procedure computeisocattachedcube(var isoccube : tisoccube);
                  
                      procedure unionisoccubes(var isoccube : tisoccube; unioncube : tisoccube);
                  
                      procedure getxyzfromisoccube(angle : tisoccube; var x, y, z : longint);
                      procedure getisocfromisoccube(angle : tisoccube; var isoc : tisoccube);
                      procedure mergeisocsizefromisoccube(angle : tisoccube; var isoc : tisoccube);
                  
                      function formatresult(val : longint) : string;
                  
                      procedure eraseisocmeasurements();
                      procedure eraseisoccube(var cube : tisoccube);
                  
                    public
                  
                      procedure setgsensorinputmaincube(x, y, z : single);
                      procedure repaintgsensorbox();
                  
                      procedure updatecalibrationlabels();
                      procedure updatemaincubelabels();
                      procedure updateattachedcubelabels();
                  
                    public
                      procedure setcalibrationcompleted();
                      procedure getisoccube();
                      procedure setsweepcompleted();
                      procedure storesweepresult(plane : byte; xl, xr, yf, yb, zt, zb : longint);
                    end;
                  
                  implementation
                  end.");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Unit_001()
{
    return parse(#DelphiGrammar::Unit, "
                  unit mainform;
                  
                  interface
                  
                  uses
                    winapi.windows, winapi.messages, system.sysutils, system.variants, system.classes, vcl.graphics,
                    vcl.controls, vcl.forms, vcl.dialogs, vcl.stdctrls, serialmanager, serialprotocol,
                    vcl.extctrls, vcl.comctrls, settingsform, inifiles, vcl.menus, math;
                  
                  const
                    gcisocoperatingmodenone                   = 0;
                  
                    gcisocoperatingmodefindmaincubeisoc       = 1;
                    gcisocoperatingmodefindattachedcubeisoc   = 2;
                    gcisocoperatingmodecalibration            = 3;
                  
                  
                    gcisocmaincubeprogressgantry_0_collimator_0   = 1;
                    gcisocmaincubeprogressgantry_0_collimator_180 = 2;
                    gcisocmaincubeprogressshowresults             = 3;
                  
                    gcisocattachedcubeprogressgantry_0_collimator_0     = 1;
                    gcisocattachedcubeprogressgantry_0_collimator_180   = 2;
                  
                    gcisocattachedcubeprogressgantry_l90_collimator_0   = 3;
                    gcisocattachedcubeprogressgantry_l90_collimator_180 = 4;
                  
                    gcisocattachedcubeprogressgantry_180_collimator_0   = 5;
                    gcisocattachedcubeprogressgantry_180_collimator_180 = 6;
                  
                    gcisocattachedcubeprogressgantry_r90_collimator_0   = 7;
                    gcisocattachedcubeprogressgantry_r90_collimator_180 = 8;
                  
                    gcisocattachedcubeprogressshowresults               = 9;
                  
                    gcisoccalibrationneeded                             = 1;
                    gcisoccalibrationcompleted                          = 2;
                    gcisoccalibrationbusy								                = 3;
                  
                    gcsweepplaneattachedtop     = 0;
                    gcsweepplaneattachedbottom  = 1;
                    gcsweepplaneattachedleft    = 2;
                    gcsweepplaneattachedright   = 3;
                    gcsweepplanemaintop         = 4;
                  
                    gccollimatorangle_0   = 0;
                    gccollimatorangle_180 = 1;
                  
                    gcinvalidisocvalue    : longint = $f0000000;
                  
                  type
                    tgsensorreading = record
                      x, y, z : single;
                    end;
                  
                    tisoccube       = record
                      xl, xr  : longint;
                      yf, yb  : longint;
                      zt, zb  : longint;
                    end;
                  
                    tisocplane    = record
                      collimatorangle : array[0..1] of tisoccube;
                    end;
                  
                    tisocmeasurements = record
                      plane : array[0..4] of tisocplane;
                    end;
                  
                    tform1 = class(tform)
                      timer_serialmaintenance: ttimer;
                      memoconsole: tmemo;
                      statusbar1: tstatusbar;
                      mainmenu1: tmainmenu;
                      isocfinder1: tmenuitem;
                      connect1: tmenuitem;
                      settings1: tmenuitem;
                      serialsettings1: tmenuitem;
                      disconnect1: tmenuitem;
                      n1: tmenuitem;
                      exit1: tmenuitem;
                      help1: tmenuitem;
                      about1: tmenuitem;
                      pagecontrol1: tpagecontrol;
                      tabsheet1: ttabsheet;
                      tabsheet2: ttabsheet;
                      button_test_getversion: tbutton;
                      button_test_sweep: tbutton;
                      button_test_sweepcompleted: tbutton;
                      button_test_resetisoccube: tbutton;
                      button_test_getisoccube: tbutton;
                      button_test_requestcalibration: tbutton;
                      button_test_iscalibrationcomplete: tbutton;
                      general: ttabsheet;
                      button_test_ismotorbusy: tbutton;
                      button_test_getcubeposition: tbutton;
                      button_test_setcubeposition: tbutton;
                      edit_x: tedit;
                      edit_y: tedit;
                      edit_z: tedit;
                      label1: tlabel;
                      label2: tlabel;
                      label3: tlabel;
                      button_test_setminusposition: tbutton;
                      button_test_setzeroposition: tbutton;
                      button_test_setplusposition: tbutton;
                      button_test_gsensor: tbutton;
                      tabsheetgsensor: ttabsheet;
                      gsensorimage: timage;
                      panel1: tpanel;
                      groupbox1: tgroupbox;
                      gsensormainxedit: tedit;
                      gsensormainyedit: tedit;
                      gsensormainzedit: tedit;
                      label4: tlabel;
                      label5: tlabel;
                      label6: tlabel;
                      timer_gsensor: ttimer;
                      panel2: tpanel;
                      button_maincubeisoc_restart: tbutton;
                      button_maincubeisoc_nextstep: tbutton;
                      button_maincubeisoc_sweep: tbutton;
                      button_maincubeisoc_center: tbutton;
                      label_maincubeisoc_0_0: tlabel;
                      label_maincubeisoc_0_180: tlabel;
                      label_maincubeisoc_results: tlabel;
                      panel3: tpanel;
                      label_calibrationrequired: tlabel;
                      label_calibrationcompleted: tlabel;
                      button_calibrate_start: tbutton;
                      timer_operation: ttimer;
                      findisocmaincubememo: tmemo;
                      tabsheet3: ttabsheet;
                      panel4: tpanel;
                      label_attachedcubeisoc_0_0: tlabel;
                      label_attachedcubeisoc_0_180: tlabel;
                      label_attachedcubeisoc_results: tlabel;
                      button_findattachedcube_start: tbutton;
                      button_findattachedcube_nextstep: tbutton;
                      button_findattachedcube_sweep: tbutton;
                      button_findattachedcube_centercube: tbutton;
                      findisocattachedcubememo: tmemo;
                      label_attachedcubeisoc_90_0: tlabel;
                      label_attachedcubeisoc_90_180: tlabel;
                      label_attachedcubeisoc_180_0: tlabel;
                      label_attachedcubeisoc_180_180: tlabel;
                      label_attachedcubeisoc_m90_0: tlabel;
                      label_attachedcubeisoc_m90_180: tlabel;
                      button_findattachedcube_prevstep: tbutton;
                      button_maincubeisoc_prevstep: tbutton;
                      procedure formcreate(sender: tobject);
                      procedure formdestroy(sender: tobject);
                      procedure timer_serialmaintenancetimer(sender: tobject);
                      procedure button_test_getversionclick(sender: tobject);
                      procedure button_test_sweepclick(sender: tobject);
                      procedure button_test_sweepcompletedclick(sender: tobject);
                      procedure button_test_resetisoccubeclick(sender: tobject);
                      procedure button_test_getisoccubeclick(sender: tobject);
                      procedure button_test_requestcalibrationclick(sender: tobject);
                      procedure button_test_iscalibrationcompleteclick(sender: tobject);
                      procedure formclose(sender: tobject; var action: tcloseaction);
                      procedure connect1click(sender: tobject);
                      procedure disconnect1click(sender: tobject);
                      procedure serialsettings1click(sender: tobject);
                      procedure exit1click(sender: tobject);
                      procedure button_test_ismotorbusyclick(sender: tobject);
                      procedure button_test_getcubepositionclick(sender: tobject);
                      procedure button_test_setcubepositionclick(sender: tobject);
                      procedure button_test_setminuspositionclick(sender: tobject);
                      procedure button_test_setzeropositionclick(sender: tobject);
                      procedure button_test_setpluspositionclick(sender: tobject);
                      procedure button_test_gsensorclick(sender: tobject);
                      procedure tabsheetgsensorshow(sender: tobject);
                      procedure tabsheetgsensorhide(sender: tobject);
                      procedure formresize(sender: tobject);
                      procedure timer_gsensortimer(sender: tobject);
                      procedure button_calibrate_startclick(sender: tobject);
                      procedure timer_operationtimer(sender: tobject);
                      procedure button_maincubeisoc_restartclick(sender: tobject);
                      procedure button_maincubeisoc_sweepclick(sender: tobject);
                      procedure button_maincubeisoc_nextstepclick(sender: tobject);
                      procedure button_findattachedcube_startclick(sender: tobject);
                      procedure button_findattachedcube_sweepclick(sender: tobject);
                      procedure button_findattachedcube_nextstepclick(sender: tobject);
                      procedure button_maincubeisoc_centerclick(sender: tobject);
                      procedure button_findattachedcube_centercubeclick(sender: tobject);
                      procedure button_findattachedcube_prevstepclick(sender: tobject);
                      procedure button_maincubeisoc_prevstepclick(sender: tobject);
                  
                    private
                      fserialmanager  : tserialmanager;
                  
                      fcommport             : string;
                      fcommconnectionstring : string;
                  
                      fserialconnectiononline : boolean;
                  
                      fgsensorreadingmaincube : tgsensorreading;
                  
                      fisocoperatingmodeprogressmaincube      : integer;
                      fisocoperatingmodeprogressattachedcube  : integer;
                      fisocoperatingmodeprogresscalibration   : integer;
                  
                      fisocoperatingmode              : integer;
                  
                      fisocmeasurements               : tisocmeasurements;
                  
                      faxissweepinprogress            : boolean;
                  
                      fattachedcubecomputedisoccube   : tisoccube;
                      fmaincubecomputedisoccube       : tisoccube;
                  
                      function issystembusywithoperationifsoprintonconsole(wantedoperationmode : integer) : boolean;
                  
                  
                      class procedure callbackversion(version : byte); static;
                      class procedure callbacksweepplane(); static;
                      class procedure callbacksweepplanecompleted(busy, completed : byte); static;
                      class procedure callbackresetisoccube(); static;
                      class procedure callbackgetisoccube(plane : byte;
                                                          xl, xr, yf, yb,
                                                          zt, zb : integer); static;
                      class procedure callbackrequestcalibrate(); static;
                      class procedure callbackcalibrationiscompleted(busy,
                                                                     completed : byte); static;
                  
                      class procedure callbacksetcubeposition(); static;
                      class procedure callbackgetcubeposition(x, y, z : longint); static;
                      class procedure callbackismotorbusy(motorisbusy : boolean); static;
                  
                      class procedure callbackgetgsensorinput(x, y, z : single); static;
                  
                    private
                      procedure showmaincubeisocpositiondata();
                      procedure showattachedcubeisocpositiondata();
                  
                      function printisocvalue(value : longint) : string;
                      procedure printisocreadings(memo : tmemo; isoc : tisoccube; avginsteadofdiff : boolean);
                  
                      procedure computeisocmaincube(var isoccube : tisoccube);
                      procedure computeisocattachedcube(var isoccube : tisoccube);
                  
                      procedure unionisoccubes(var isoccube : tisoccube; unioncube : tisoccube);
                  
                      procedure getxyzfromisoccube(angle : tisoccube; var x, y, z : longint);
                      procedure getisocfromisoccube(angle : tisoccube; var isoc : tisoccube);
                      procedure mergeisocsizefromisoccube(angle : tisoccube; var isoc : tisoccube);
                  
                      function formatresult(val : longint) : string;
                  
                      procedure eraseisocmeasurements();
                      procedure eraseisoccube(var cube : tisoccube);
                  
                    public
                  
                      procedure setgsensorinputmaincube(x, y, z : single);
                      procedure repaintgsensorbox();
                  
                      procedure updatecalibrationlabels();
                      procedure updatemaincubelabels();
                      procedure updateattachedcubelabels();
                  
                    public
                      procedure setcalibrationcompleted();
                      procedure getisoccube();
                      procedure setsweepcompleted();
                      procedure storesweepresult(plane : byte; xl, xr, yf, yb, zt, zb : longint);
                    end;
                  
                  var
                    form1: tform1;
                  
                  implementation
                  
                  {$r *.dfm}
                  
                  
                  procedure tform1.eraseisoccube(var cube : tisoccube);
                  var
                    counterinner, counterouter : cardinal;
                  begin
                    with cube do
                    begin
                      xl := gcinvalidisocvalue;
                      xr := gcinvalidisocvalue;
                  
                      yf := gcinvalidisocvalue;
                      yb := gcinvalidisocvalue;
                  
                      zt := gcinvalidisocvalue;
                      zb := gcinvalidisocvalue;
                    end;
                  end;
                  
                  procedure tform1.eraseisocmeasurements();
                  var
                    counterinner, counterouter : cardinal;
                  begin
                    for counterouter := 0 to 4 do
                    begin
                      for counterinner := 0 to 1 do
                      begin
                        eraseisoccube(fisocmeasurements.plane[counterouter].collimatorangle[counterinner]);
                      end;
                    end;
                  end;
                  
                  class procedure tform1.callbackversion(version : byte);
                  begin
                    form1.memoconsole.lines.add(\'isoc finder version: \' + inttostr(version div 100) +
                                                \'.\' + inttostr(version mod 100) + \' found.\');
                  end;
                  
                  procedure tform1.connect1click(sender: tobject);
                  begin
                    if (fserialmanager.init(fcommport, fcommconnectionstring) = true) then
                    begin
                      memoconsole.lines.add(\'connected to port \'\'\' + fcommport + \'\'\' with string: \'\'\' +
                                            fcommconnectionstring + \'\'\'\');
                  
                      fserialmanager.setcallback_getversion(callbackversion);
                      fserialmanager.setcallback_sweepplane(callbacksweepplane);
                      fserialmanager.setcallback_issweepcompleted(callbacksweepplanecompleted);
                      fserialmanager.setcallback_resetisoccube(callbackresetisoccube);
                      fserialmanager.setcallback_getisoccube(callbackgetisoccube);
                      fserialmanager.setcallback_requestcalibrate(callbackrequestcalibrate);
                      fserialmanager.setcallback_iscalibrationcompleted(callbackcalibrationiscompleted);
                  
                      fserialmanager.setcallback_setcubeposition(callbacksetcubeposition);
                      fserialmanager.setcallback_getcubeposition(callbackgetcubeposition);
                      fserialmanager.setcallback_ismotorbusy(callbackismotorbusy);
                  
                      fserialmanager.setcallback_getgsensorinput(callbackgetgsensorinput);
                  
                      fserialmanager.getversion();
                  
                      fserialconnectiononline := true;
                    end
                    else
                    begin
                      memoconsole.lines.add(\'failed to connect to port \' + fcommport + \' with string: \'\'\' +
                                            fcommconnectionstring + \'\'\'\');
                      fserialconnectiononline := false;
                    end;
                  end;
                  
                  procedure tform1.disconnect1click(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                    begin
                      fserialmanager.exit;
                  
                      memoconsole.lines.add(\'disconnected from isoc finder\');
                    end;
                  end;
                  
                  procedure tform1.exit1click(sender: tobject);
                  begin
                    self.close();
                  end;
                  
                  class procedure tform1.callbacksweepplane();
                  begin
                  end;
                  
                  class procedure tform1.callbacksweepplanecompleted(busy, completed : byte);
                  begin
                    if (completed \<\> 0) then
                    begin
                      form1.setsweepcompleted();
                      form1.getisoccube();
                      form1.memoconsole.lines.add(\'sweep completed, retrieving isoc numbers\');
                    end;
                  end;
                  
                  class procedure tform1.callbackresetisoccube();
                  begin
                    form1.memoconsole.lines.add(\'callbackresetisoccube: \');
                  end;
                  
                  class procedure tform1.callbackgetisoccube(plane : byte;
                                                             xl, xr, yf,yb, zt,zb : integer);
                  begin
                    case plane of
                      gcserialmanager_sweepplane_main_top:
                        plane := gcsweepplanemaintop;
                      gcserialmanager_sweepplane_cube_top:
                        plane := gcsweepplaneattachedtop;
                      gcserialmanager_sweepplane_cube_bottom:
                        plane := gcsweepplaneattachedbottom;
                      gcserialmanager_sweepplane_cube_left:
                        plane := gcsweepplaneattachedleft;
                      gcserialmanager_sweepplane_cube_right:
                        plane := gcsweepplaneattachedright;
                    end;
                  
                    form1.storesweepresult(plane, xl, xr, yf, yb, zt, zb);
                  end;
                  
                  class procedure tform1.callbackrequestcalibrate();
                  begin
                    form1.memoconsole.lines.add(\'calibration requested\');
                  end;
                  
                  class procedure tform1.callbackcalibrationiscompleted(busy, completed : byte);
                  var
                    resultstring : string;
                  begin
                    if (boolean(completed) = true) then
                    begin
                      form1.setcalibrationcompleted();
                      form1.memoconsole.lines.add(\'calibration is completed\');
                    end;
                  end;
                  
                  class procedure tform1.callbacksetcubeposition();
                  begin
                    form1.memoconsole.lines.add(\'cube position set\');
                  end;
                  
                  class procedure tform1.callbackgetcubeposition(x, y, z : longint);
                  var
                    tempstring : string;
                  begin
                    tempstring := \'callbackgetcubeposition: x = \' + inttostr(x) + \' y = \' +
                                  inttostr(y) + \' z = \' + inttostr(z);
                  
                    form1.memoconsole.lines.add(tempstring);
                  end;
                  
                  class procedure tform1.callbackgetgsensorinput(x, y, z : single);
                  var
                    tempstring : string;
                  begin
                    form1.setgsensorinputmaincube(x, y, z);
                  
                    form1.gsensormainxedit.text := format(\'%.2f\', [x]);
                    form1.gsensormainyedit.text := format(\'%.2f\', [y]);
                    form1.gsensormainzedit.text := format(\'%.2f\', [z]);
                  end;
                  
                  class procedure tform1.callbackismotorbusy(motorisbusy : boolean);
                  begin
                    if (motorisbusy = true) then
                    begin
                      form1.memoconsole.lines.add(\'callbackismotorbusy: true\');
                    end
                    else
                      form1.memoconsole.lines.add(\'callbackismotorbusy: false\');
                  end;
                  
                  
                  procedure tform1.button_test_setcubepositionclick(sender: tobject);
                  var
                    x, y, z : longint;
                  begin
                    if (assigned(fserialmanager)) then
                    begin
                      x := strtoint(edit_x.text);
                      y := strtoint(edit_y.text);
                      z := strtoint(edit_z.text);
                  
                      fserialmanager.setcubeposition(x, y, z);
                  
                    end;
                  end;
                  
                  procedure tform1.button_test_setminuspositionclick(sender: tobject);
                  begin
                      fserialmanager.setcubeposition(-10000, -10000, -10000);
                  end;
                  
                  procedure tform1.button_test_setzeropositionclick(sender: tobject);
                  begin
                      fserialmanager.setcubeposition(0, 0, 0);
                  end;
                  
                  procedure tform1.button_test_setpluspositionclick(sender: tobject);
                  begin
                      fserialmanager.setcubeposition(10000, 10000, 10000);
                  end;
                  
                  procedure tform1.button_test_gsensorclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.getgsensorinput();
                  end;
                  
                  procedure tform1.button_findattachedcube_startclick(sender: tobject);
                  begin
                    fisocoperatingmode := gcisocoperatingmodefindattachedcubeisoc;
                    fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_r90_collimator_0;
                    //zeromemory(@fisocmeasurements, sizeof(tisocmeasurements));
                    eraseisocmeasurements();
                  
                    memoconsole.lines.add(\'\>\> start attached cube isoc search\');
                  end;
                  
                  procedure tform1.button_findattachedcube_nextstepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindattachedcubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    case fisocoperatingmodeprogressattachedcube of
                      gcisocattachedcubeprogressgantry_r90_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_r90_collimator_180;
                      gcisocattachedcubeprogressgantry_r90_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_0_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_0_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_0_collimator_180;
                      gcisocattachedcubeprogressgantry_0_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_l90_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_l90_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_l90_collimator_180;
                      gcisocattachedcubeprogressgantry_l90_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_180_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_180_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_180_collimator_180;
                      gcisocattachedcubeprogressgantry_180_collimator_180:
                        begin
                          fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressshowresults;
                          showattachedcubeisocpositiondata();
                        end;
                  
                      gcisocattachedcubeprogressshowresults:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressshowresults;
                    else
                      fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_r90_collimator_0;
                    end;
                  end;
                  
                  procedure tform1.button_findattachedcube_sweepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindattachedcubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    fisocoperatingmode := gcisocoperatingmodefindattachedcubeisoc;
                  
                    if (assigned(fserialmanager)) then
                    begin
                      case fisocoperatingmodeprogressattachedcube of
                        gcisocattachedcubeprogressgantry_0_collimator_0,
                        gcisocattachedcubeprogressgantry_0_collimator_180:
                        begin
                          fserialmanager.sweepplane(gcserialmanager_sweepplane_cube_top);
                          button_maincubeisoc_sweep.enabled := false;
                          faxissweepinprogress := true;
                        end;
                  
                        gcisocattachedcubeprogressgantry_l90_collimator_0,
                        gcisocattachedcubeprogressgantry_l90_collimator_180:
                        begin
                          fserialmanager.sweepplane(gcserialmanager_sweepplane_cube_left);
                          button_maincubeisoc_sweep.enabled := false;
                          faxissweepinprogress := true;
                        end;
                  
                        gcisocattachedcubeprogressgantry_180_collimator_0,
                        gcisocattachedcubeprogressgantry_180_collimator_180:
                        begin
                          fserialmanager.sweepplane(gcserialmanager_sweepplane_cube_bottom);
                          button_maincubeisoc_sweep.enabled := false;
                          faxissweepinprogress := true;
                        end;
                  
                        gcisocattachedcubeprogressgantry_r90_collimator_0,
                        gcisocattachedcubeprogressgantry_r90_collimator_180:
                        begin
                          fserialmanager.sweepplane(gcserialmanager_sweepplane_cube_right);
                          button_maincubeisoc_sweep.enabled := false;
                          faxissweepinprogress := true;
                        end;
                      end;
                    end;
                  end;
                  
                  procedure tform1.button_findattachedcube_centercubeclick(sender: tobject);
                  var
                    x, y, z : longint;
                    divider : cardinal;
                  begin
                    if (not assigned(fserialmanager)) then
                    begin
                      system.exit;
                    end;
                  
                    x       := 0;
                    divider := 0;
                    if (fattachedcubecomputedisoccube.xl \<\> gcinvalidisocvalue) then
                    begin
                      inc(x, fattachedcubecomputedisoccube.xl);
                      inc(divider);
                    end;
                    if (fattachedcubecomputedisoccube.xr \<\> gcinvalidisocvalue) then
                    begin
                      inc(x, fattachedcubecomputedisoccube.xr);
                      inc(divider);
                    end;
                    if (divider \<\> 0) and (divider \<\> 1) then
                    begin
                      x := x div divider;
                    end;
                  
                    y       := 0;
                    divider := 0;
                    if (fattachedcubecomputedisoccube.yf \<\> gcinvalidisocvalue) then
                    begin
                      inc(y, fattachedcubecomputedisoccube.yf);
                      inc(divider);
                    end;
                    if (fattachedcubecomputedisoccube.yb \<\> gcinvalidisocvalue) then
                    begin
                      inc(y, fattachedcubecomputedisoccube.yb);
                      inc(divider);
                    end;
                    if (divider \<\> 0) and (divider \<\> 1) then
                    begin
                      y := y div divider;
                    end;
                  
                    z       := 0;
                    divider := 0;
                    if (fattachedcubecomputedisoccube.zt \<\> gcinvalidisocvalue) then
                    begin
                      inc(z, fattachedcubecomputedisoccube.zt);
                      inc(divider);
                    end;
                    if (fattachedcubecomputedisoccube.zb \<\> gcinvalidisocvalue) then
                    begin
                      inc(z, fattachedcubecomputedisoccube.zb);
                      inc(divider);
                    end;
                    if (divider \<\> 0) and (divider \<\> 1) then
                    begin
                      z := z div divider;
                    end;
                  
                    fserialmanager.setcubeposition(x, y, z);
                  
                  end;
                  
                  procedure tform1.button_findattachedcube_prevstepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindattachedcubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    case fisocoperatingmodeprogressattachedcube of
                      gcisocattachedcubeprogressgantry_r90_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_r90_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_0_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_r90_collimator_180;
                      gcisocattachedcubeprogressgantry_0_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_0_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_l90_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_0_collimator_180;
                      gcisocattachedcubeprogressgantry_l90_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_l90_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_180_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_l90_collimator_180;
                      gcisocattachedcubeprogressgantry_180_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_180_collimator_0;
                      gcisocattachedcubeprogressshowresults:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_180_collimator_180;
                    end;
                  end;
                  
                  function tform1.issystembusywithoperationifsoprintonconsole(wantedoperationmode : integer) : boolean;
                  begin
                    if (fisocoperatingmode = wantedoperationmode) then
                    begin
                      result := false;
                      system.exit();
                    end;
                  
                    if (fisocoperatingmode \<\> gcisocoperatingmodenone) then
                    begin
                      case fisocoperatingmode of
                        gcisocoperatingmodefindmaincubeisoc:
                          memoconsole.lines.add(\'!!! main cube isoc center search still in progress.\');
                        gcisocoperatingmodefindattachedcubeisoc:
                          memoconsole.lines.add(\'!!!attached cube isoc center search still in progress.\');
                        gcisocoperatingmodecalibration:
                          memoconsole.lines.add(\'!!! calibration still in progress.\');
                        else
                          memoconsole.lines.add(\'!!! unknown operation still in progress.\');
                      end;
                      result := true;
                      system.exit();
                    end;
                    result := false;
                  end;
                  
                  procedure tform1.button_calibrate_startclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodecalibration) = true) then
                    begin
                      system.exit();
                    end;
                  
                    fisocoperatingmodeprogresscalibration := gcisoccalibrationneeded;
                  
                    if (assigned(fserialmanager)) then
                    begin
                      fisocoperatingmode := gcisocoperatingmodecalibration;
                      fisocoperatingmodeprogresscalibration := gcisoccalibrationbusy;
                  
                      // first calibrate, then set position of cube to 0, 0, 0
                      fserialmanager.requestcalibration();
                  
                      button_calibrate_start.enabled := false;
                    end;
                  end;
                  
                  procedure tform1.button_maincubeisoc_centerclick(sender: tobject);
                  var
                    x, y, z : longint;
                  begin
                    if (not assigned(fserialmanager)) then
                    begin
                      system.exit;
                    end;
                  
                    x := (fmaincubecomputedisoccube.xl + fmaincubecomputedisoccube.xr) div 2;
                    y := (fmaincubecomputedisoccube.yf + fmaincubecomputedisoccube.yb) div 2;
                    z := (fmaincubecomputedisoccube.zt + fmaincubecomputedisoccube.zb) div 2;
                  
                    fserialmanager.setcubeposition(x, y, z);
                  end;
                  
                  procedure tform1.button_maincubeisoc_nextstepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindmaincubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    case fisocoperatingmodeprogressmaincube of
                      gcisocmaincubeprogressgantry_0_collimator_0:
                        fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressgantry_0_collimator_180;
                      gcisocmaincubeprogressgantry_0_collimator_180:
                      begin
                        fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressshowresults;
                        showmaincubeisocpositiondata();
                      end;
                      gcisocmaincubeprogressshowresults:
                      begin
                        fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressshowresults;
                        fisocoperatingmode := gcisocoperatingmodenone;
                      end;
                    else
                      fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressgantry_0_collimator_0;
                    end;
                  end;
                  
                  procedure tform1.button_maincubeisoc_restartclick(sender: tobject);
                  begin
                    fisocoperatingmode := gcisocoperatingmodefindmaincubeisoc;
                    fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressgantry_0_collimator_0;
                  
                    eraseisocmeasurements();
                  
                    memoconsole.lines.add(\'\>\> start main cube isoc search\');
                  end;
                  
                  procedure tform1.button_maincubeisoc_sweepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindmaincubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    fisocoperatingmode := gcisocoperatingmodefindmaincubeisoc;
                  
                    if (assigned(fserialmanager)) then
                    begin
                      fserialmanager.sweepplane(gcserialmanager_sweepplane_main_top);
                      button_maincubeisoc_sweep.enabled := false;
                      faxissweepinprogress := true;
                    end;
                  end;
                  
                  procedure tform1.button_test_ismotorbusyclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.ismotorbusy();
                  end;
                  
                  procedure tform1.button_maincubeisoc_prevstepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindmaincubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    case fisocoperatingmodeprogressmaincube of
                      gcisocmaincubeprogressgantry_0_collimator_180:
                        fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressgantry_0_collimator_0;
                      gcisocmaincubeprogressshowresults:
                        fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressgantry_0_collimator_180;
                    end;
                  end;
                  
                  procedure tform1.button_test_getcubepositionclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.getcubeposition();
                  end;
                  
                  procedure tform1.button_test_getversionclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.getversion();
                  end;
                  
                  procedure tform1.button_test_sweepclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.sweepplane(gcserial_protocol_plane_main_top);
                  end;
                  
                  procedure tform1.button_test_sweepcompletedclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.issweepcompleted();
                  end;
                  
                  procedure tform1.button_test_resetisoccubeclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.resetisoccube();
                  end;
                  
                  procedure tform1.button_test_getisoccubeclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.getisoccube(gcserial_protocol_plane_main_top);
                  end;
                  
                  procedure tform1.button_test_requestcalibrationclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.requestcalibration();
                  end;
                  
                  procedure tform1.button_test_iscalibrationcompleteclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.iscalibrationcomplete();
                  end;
                  
                  procedure tform1.formclose(sender: tobject; var action: tcloseaction);
                  begin
                    timer_serialmaintenance.enabled := false;
                    fserialmanager.exit;
                  end;
                  
                  procedure tform1.formcreate(sender: tobject);
                  var
                    inifile     : tinifile;
                    inifilename : string;
                  
                    tempstring  : string;
                  begin
                    fserialmanager := tserialmanager.create;
                  
                    inifilename := changefileext(application.exename, \'.ini\');
                    inifile := tinifile.create(inifilename);
                  
                    fcommport := \'\';
                    fcommconnectionstring := \'\';
                  
                    if (assigned(inifile)) then
                    begin
                      fcommport := inifile.readstring(\'comportsettings\', \'port\', \'\');
                      fcommconnectionstring := inifile.readstring(\'comportsettings\', \'connectionstring\', \'\');
                  
                      freeandnil(inifile);
                    end;
                  
                    repaintgsensorbox();
                  
                    fisocoperatingmodeprogressmaincube      := gcisocmaincubeprogressgantry_0_collimator_0;
                    fisocoperatingmodeprogressattachedcube  := gcisocattachedcubeprogressgantry_r90_collimator_0;
                    fisocoperatingmodeprogresscalibration   := gcisoccalibrationneeded;
                  
                    fisocoperatingmode              := gcisocoperatingmodenone;
                  
                    faxissweepinprogress            := false;
                  
                    updatecalibrationlabels();
                    updatemaincubelabels();
                    updateattachedcubelabels();
                  
                  //  zeromemory(@fattachedcubecomputedisoccube, sizeof(tisoccube));
                  //  zeromemory(@fmaincubecomputedisoccube, sizeof(tisoccube));
                  
                    eraseisoccube(fattachedcubecomputedisoccube);
                    eraseisoccube(fmaincubecomputedisoccube);
                  end;
                  
                  procedure tform1.formdestroy(sender: tobject);
                  begin
                    freeandnil(fserialmanager);
                  end;
                  
                  procedure tform1.formresize(sender: tobject);
                  begin
                    gsensorimage.picture.bitmap.width := gsensorimage.width;
                    gsensorimage.picture.bitmap.height := gsensorimage.height;
                  end;
                  
                  procedure tform1.serialsettings1click(sender: tobject);
                  begin
                    serialsettingsform.initform(fcommport, fcommconnectionstring);
                    if (serialsettingsform.showmodal = mrok) then
                    begin
                      fcommport := serialsettingsform.getselectedcomport();
                      fcommconnectionstring := serialsettingsform.getselectedconnectionstring();
                    end;
                  end;
                  
                  procedure tform1.tabsheetgsensorhide(sender: tobject);
                  begin
                    timer_gsensor.enabled := false;
                  end;
                  
                  procedure tform1.tabsheetgsensorshow(sender: tobject);
                  begin
                    timer_gsensor.enabled := true;
                  end;
                  
                  procedure tform1.timer_serialmaintenancetimer(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                    begin
                      fserialmanager.maintenancefunction();
                    end;
                  end;
                  
                  procedure tform1.timer_gsensortimer(sender: tobject);
                  begin
                    if (fserialconnectiononline = false) then
                      system.exit;
                  
                    // only update g sensor if looking at g sensor tabsheet.
                    if (pagecontrol1.tabindex \<\> 3) then
                      system.exit;
                  
                    fserialmanager.getgsensorinput();
                    repaintgsensorbox();
                  end;
                  
                  procedure tform1.timer_operationtimer(sender: tobject);
                  begin
                    updateattachedcubelabels();
                    updatemaincubelabels();
                    updatecalibrationlabels();
                  
                    case fisocoperatingmode of
                      gcisocoperatingmodenone:
                        begin
                          system.exit;
                        end;
                      gcisocoperatingmodefindmaincubeisoc:
                        begin
                          if (faxissweepinprogress = true) then
                          begin
                            if (assigned(fserialmanager)) then
                            begin
                              fserialmanager.issweepcompleted();
                            end;
                          end;
                        end;
                      gcisocoperatingmodefindattachedcubeisoc:
                        begin
                          if (faxissweepinprogress = true) then
                          begin
                            if (assigned(fserialmanager)) then
                            begin
                              fserialmanager.issweepcompleted();
                            end;
                          end;
                        end;
                      gcisocoperatingmodecalibration:
                        begin
                          if (fisocoperatingmodeprogresscalibration = gcisoccalibrationbusy) then
                          begin
                            if (assigned(fserialmanager)) then
                            begin
                              fserialmanager.iscalibrationcomplete();
                            end;
                          end;
                        end;
                    else
                      fisocoperatingmode := gcisocoperatingmodenone;
                      system.exit();
                    end;
                  end;
                  
                  procedure tform1.setgsensorinputmaincube(x, y, z : single);
                  begin
                    fgsensorreadingmaincube.x := x;
                    fgsensorreadingmaincube.y := y;
                    fgsensorreadingmaincube.z := z;
                  end;
                  
                  procedure tform1.repaintgsensorbox();
                  var
                    rect      : trect;
                    textrect  : trect;
                    counter   : cardinal;
                  
                    spacerx : single;
                    spacery : single;
                  
                    systemstring : system.string;
                    axisvalue    : single;
                  
                    center        : tpoint;
                  
                    savedalignment : word;
                  
                    readingpointpositionx, readingpointpositiony : single;
                  
                  begin
                    // calc some sizes
                    rect.left := 0;
                    rect.top  := 0;
                    rect.right := gsensorimage.width;
                    rect.bottom := gsensorimage.height;
                  
                    center.x := gsensorimage.width div 2;
                    center.y := gsensorimage.height div 2;
                  
                    spacerx := rect.width / 20;
                    spacery := rect.height / 20;
                  
                    // draw main rectangle
                  
                    gsensorimage.canvas.rectangle(rect);
                  
                    // draw position of main cube reading in red
                  
                    readingpointpositionx := gsensorimage.width;
                    readingpointpositionx := readingpointpositionx / 2 +
                                             (readingpointpositionx / 2) * fgsensorreadingmaincube.x;
                  
                    readingpointpositiony := gsensorimage.height;
                    readingpointpositiony := readingpointpositiony / 2 +
                                             (readingpointpositiony / 2) * fgsensorreadingmaincube.y * -1;
                  
                  
                    gsensorimage.canvas.brush.color := clred;
                  
                    gsensorimage.canvas.ellipse(round(readingpointpositionx - 5),
                                                round(readingpointpositiony - 5),
                                                round(readingpointpositionx + 5),
                                                round(readingpointpositiony + 5));
                  
                    // draw main rectangle and axis
                  
                    gsensorimage.canvas.brush.color := clwhite;
                  
                    gsensorimage.canvas.moveto(center.x, 0);
                    gsensorimage.canvas.lineto(center.x, rect.bottom);
                  
                    gsensorimage.canvas.moveto(0, center.y);
                    gsensorimage.canvas.lineto(rect.width, center.y);
                  
                    // set axis font size
                  
                    gsensorimage.canvas.font.size := 6;
                  
                    // draw axis lines & values for x axis
                  
                    for counter := 1 to 19 do
                    begin
                      textrect.left   := round(spacerx * counter) - 10;
                      textrect.right  := round(spacerx * counter) + 10;
                      textrect.top    := center.y + 5;
                      textrect.bottom := center.y + 20;
                  
                      if (counter \<\> 10) then
                      begin
                        axisvalue := counter;
                        axisvalue := (axisvalue - 10) / 10;
                        systemstring := format(\'%.1f\', [axisvalue]);
                        gsensorimage.canvas.textrect(textrect, systemstring,
                                                     [tfcenter, tfverticalcenter, tfsingleline]);
                  
                        gsensorimage.canvas.moveto(round(spacerx * counter), center.y - 5);
                        gsensorimage.canvas.lineto(round(spacerx * counter), center.y + 5);
                      end;
                    end;
                  
                    // draw axis lines & values for y axis
                  
                    for counter := 1 to 19 do
                    begin
                      textrect.left   := center.x - 5;
                      textrect.right  := center.x - 20;
                      textrect.top    := round(spacery * counter) - 10;
                      textrect.bottom := round(spacery * counter) + 10;
                  
                      if (counter \<\> 10) then
                      begin
                        axisvalue := counter;
                        axisvalue := (axisvalue - 10) / 10;
                        systemstring := format(\'%.1f\', [axisvalue]);
                        gsensorimage.canvas.textrect(textrect, systemstring,
                                                     [tfcenter, tfverticalcenter, tfsingleline]);
                  
                        gsensorimage.canvas.moveto(center.x - 5, round(spacery * counter));
                        gsensorimage.canvas.lineto(center.x + 5, round(spacery * counter));
                      end;
                    end;
                  end;
                  
                  procedure tform1.updatecalibrationlabels();
                  begin
                    if (fisocoperatingmodeprogresscalibration = gcisoccalibrationneeded) then
                    begin
                    	label_calibrationrequired.font.color := clred;
                    	label_calibrationcompleted.font.color := clblack;
                    end
                    else if (fisocoperatingmodeprogresscalibration = gcisoccalibrationcompleted) then
                    begin
                    	label_calibrationrequired.font.color := clgreen;
                    	label_calibrationcompleted.font.color := clgreen;
                    end;
                  end;
                  
                  procedure tform1.updatemaincubelabels();
                  begin
                    if (fisocoperatingmodeprogressmaincube = gcisocmaincubeprogressgantry_0_collimator_0) then
                    begin
                      label_maincubeisoc_0_0.font.color := clred;
                      label_maincubeisoc_0_180.font.color := clblack;
                      label_maincubeisoc_results.font.color := clblack;
                    end
                    else if (fisocoperatingmodeprogressmaincube = gcisocmaincubeprogressgantry_0_collimator_180) then
                    begin
                      label_maincubeisoc_0_0.font.color := clgreen;
                      label_maincubeisoc_0_180.font.color := clred;
                      label_maincubeisoc_results.font.color := clblack;
                    end
                    else if (fisocoperatingmodeprogressmaincube = gcisocmaincubeprogressshowresults) then
                    begin
                      label_maincubeisoc_0_0.font.color := clgreen;
                      label_maincubeisoc_0_180.font.color := clgreen;
                      label_maincubeisoc_results.font.color := clgreen;
                    end
                    else
                    begin
                  
                    end;
                  end;
                  
                  procedure tform1.updateattachedcubelabels();
                  var
                    labelarray  : array[0..8] of tlabel;
                    counter     : cardinal;
                    currentindex: cardinal;
                  begin
                  
                  
                    labelarray[0] := label_attachedcubeisoc_90_0;
                    labelarray[1] := label_attachedcubeisoc_90_180;
                  
                    labelarray[2] := label_attachedcubeisoc_0_0;
                    labelarray[3] := label_attachedcubeisoc_0_180;
                  
                    labelarray[4] := label_attachedcubeisoc_m90_0;
                    labelarray[5] := label_attachedcubeisoc_m90_180;
                  
                    labelarray[6] := label_attachedcubeisoc_180_0;
                    labelarray[7] := label_attachedcubeisoc_180_180;
                  
                  
                    labelarray[8] := label_attachedcubeisoc_results;
                  
                    case fisocoperatingmodeprogressattachedcube of
                      gcisocattachedcubeprogressgantry_r90_collimator_0:
                        currentindex := 0;
                      gcisocattachedcubeprogressgantry_r90_collimator_180:
                        currentindex := 1;
                      gcisocattachedcubeprogressgantry_0_collimator_0:
                        currentindex := 2;
                      gcisocattachedcubeprogressgantry_0_collimator_180:
                        currentindex := 3;
                      gcisocattachedcubeprogressgantry_l90_collimator_0:
                        currentindex := 4;
                      gcisocattachedcubeprogressgantry_l90_collimator_180:
                        currentindex := 5;
                      gcisocattachedcubeprogressgantry_180_collimator_0:
                        currentindex := 6;
                      gcisocattachedcubeprogressgantry_180_collimator_180:
                        currentindex := 7;
                  
                      gcisocattachedcubeprogressshowresults:
                        currentindex := 8;
                    end;
                  
                    if (currentindex \<\> 8) then
                    begin
                      labelarray[currentindex].font.color := clred;
                    end
                    else
                    begin
                      labelarray[currentindex].font.color := clgreen;
                    end;
                  
                    if (currentindex \> 0) then
                    begin
                      for counter := 0 to currentindex - 1 do
                      begin
                        labelarray[counter].font.color := clgreen;
                      end;
                    end;
                  
                    if (currentindex \< 8) then
                    begin
                      for counter := 8 downto currentindex + 1 do
                      begin
                        labelarray[counter].font.color := clblack;
                      end;
                    end;
                  end;
                  
                  procedure tform1.setcalibrationcompleted();
                  begin
                    fisocoperatingmodeprogresscalibration := gcisoccalibrationcompleted;
                    fisocoperatingmode                    := gcisocoperatingmodenone;
                  
                    // center cube afterwards.
                    if (assigned(fserialmanager)) then
                    begin
                      fserialmanager.setcubeposition(0, 0, 0);
                    end;
                  
                    button_calibrate_start.enabled := true;
                  end;
                  
                  procedure tform1.setsweepcompleted();
                  begin
                    faxissweepinprogress := false;
                    button_maincubeisoc_sweep.enabled := true;
                  end;
                  
                  
                  procedure tform1.getisoccube();
                  begin
                    if (not assigned(fserialmanager)) then
                    begin
                      system.exit();
                    end;
                  
                    case fisocoperatingmode of
                      gcisocoperatingmodefindmaincubeisoc:
                      begin
                        fserialmanager.getisoccube(gcserialmanager_sweepplane_main_top);
                      end;
                      gcisocoperatingmodefindattachedcubeisoc:
                      begin
                        case fisocoperatingmodeprogressattachedcube of
                          gcisocattachedcubeprogressgantry_0_collimator_0,
                          gcisocattachedcubeprogressgantry_0_collimator_180:
                            fserialmanager.getisoccube(gcserialmanager_sweepplane_cube_top);
                  
                          gcisocattachedcubeprogressgantry_l90_collimator_0,
                          gcisocattachedcubeprogressgantry_l90_collimator_180:
                            fserialmanager.getisoccube(gcserialmanager_sweepplane_cube_left);
                  
                          gcisocattachedcubeprogressgantry_180_collimator_0,
                          gcisocattachedcubeprogressgantry_180_collimator_180:
                            fserialmanager.getisoccube(gcserialmanager_sweepplane_cube_bottom);
                  
                          gcisocattachedcubeprogressgantry_r90_collimator_0,
                          gcisocattachedcubeprogressgantry_r90_collimator_180:
                            fserialmanager.getisoccube(gcserialmanager_sweepplane_cube_right);
                  
                        end;
                      end;
                    end;
                  end;
                  
                  function tform1.formatresult(val : longint) : string;
                  begin
                    if (val = gcinvalidisocvalue) then
                    begin
                      result := \'n/a\';
                    end
                    else
                    begin
                      result := format(\'%d\', [val]);
                    end;
                  end;
                  
                  procedure tform1.storesweepresult(plane : byte; xl, xr, yf, yb, zt, zb : longint);
                  var
                    isoccubeptr : ^tisoccube;
                    cubestored  : boolean;
                  
                    resultstring : string;
                  begin
                    cubestored := false;
                  
                    case fisocoperatingmode of
                      gcisocoperatingmodefindmaincubeisoc:
                      begin
                        case fisocoperatingmodeprogressmaincube of
                          gcisocmaincubeprogressgantry_0_collimator_0:
                            begin
                              if (plane = gcsweepplanemaintop) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_0]);
                                cubestored := true;
                              end;
                            end;
                          gcisocmaincubeprogressgantry_0_collimator_180:
                            begin
                              if (plane = gcsweepplanemaintop) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_180]);
                                cubestored := true;
                              end;
                            end;
                          gcisocmaincubeprogressshowresults:
                          begin
                          end;
                        end;
                      end;
                      gcisocoperatingmodefindattachedcubeisoc:
                      begin
                        case fisocoperatingmodeprogressattachedcube of
                          gcisocattachedcubeprogressgantry_0_collimator_0:
                            begin
                              if (plane = gcsweepplaneattachedtop) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_0]);
                                cubestored := true;
                              end;
                            end;
                          gcisocattachedcubeprogressgantry_0_collimator_180:
                            begin
                              if (plane = gcsweepplaneattachedtop) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_180]);
                                cubestored := true;
                              end;
                            end;
                  
                          gcisocattachedcubeprogressgantry_l90_collimator_0:
                            begin
                              if (plane = gcsweepplaneattachedleft) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_0]);
                                cubestored := true;
                              end;
                            end;
                          gcisocattachedcubeprogressgantry_l90_collimator_180:
                            begin
                              if (plane = gcsweepplaneattachedleft) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_180]);
                                cubestored := true;
                              end;
                            end;
                  
                          gcisocattachedcubeprogressgantry_180_collimator_0:
                            begin
                              if (plane = gcsweepplaneattachedbottom) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_0]);
                                cubestored := true;
                              end;
                            end;
                  
                          gcisocattachedcubeprogressgantry_180_collimator_180:
                            begin
                              if (plane = gcsweepplaneattachedbottom) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_180]);
                                cubestored := true;
                              end;
                            end;
                  
                          gcisocattachedcubeprogressgantry_r90_collimator_0:
                            begin
                              if (plane = gcsweepplaneattachedright) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_0]);
                                cubestored := true;
                              end;
                            end;
                  
                          gcisocattachedcubeprogressgantry_r90_collimator_180:
                            begin
                              if (plane = gcsweepplaneattachedright) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_180]);
                                cubestored := true;
                              end;
                            end;
                        end;
                      end;
                    end;
                  
                    if (cubestored = false) then
                    begin
                      memoconsole.lines.add(\'cube not stored...\');
                    end
                    else
                    begin
                      memoconsole.lines.add(\'cube downloaded and stored...\');
                  
                      resultstring := format(\'%u | \', [plane]);
                  
                      resultstring := resultstring + formatresult(xl) + \' \';
                      resultstring := resultstring + formatresult(xr) + \' | \';
                  
                      resultstring := resultstring + formatresult(yf) + \' \';
                      resultstring := resultstring + formatresult(yb) + \' | \';
                  
                      resultstring := resultstring + formatresult(zt) + \' \';
                      resultstring := resultstring + formatresult(zb) + \' | \';
                  
                      memoconsole.lines.add(resultstring);
                  
                      isoccubeptr^.xl := xl;
                      isoccubeptr^.xr := xr;
                  
                      isoccubeptr^.yf := yf;
                      isoccubeptr^.yb := yb;
                  
                      isoccubeptr^.zt := zt;
                      isoccubeptr^.zb := zb;
                    end;
                  end;
                  
                  procedure tform1.showmaincubeisocpositiondata();
                  var
                    isoccube : tisoccube;
                  begin
                    findisocmaincubememo.lines.add(\'isoc readings.\');
                  
                    findisocattachedcubememo.lines.add(\'raw position measurements: -------------------\');
                    findisocattachedcubememo.lines.add(\'per sensor position and average\');
                  
                  
                    findisocmaincubememo.lines.add(\'collimator 0 degrees\');
                    printisocreadings(findisocmaincubememo,
                                fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_0], true);
                    findisocmaincubememo.lines.add(\'collimator 180 degrees\');
                    printisocreadings(findisocmaincubememo,
                                fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_180], true);
                  
                    computeisocmaincube(isoccube);
                  
                    findisocattachedcubememo.lines.add(\'isoc size measurements: -------------------\');
                    findisocattachedcubememo.lines.add(\'(min and max average position found per axis followed by size\');
                  
                    printisocreadings(findisocmaincubememo, isoccube, false);
                  
                    fmaincubecomputedisoccube := isoccube;
                  
                    findisocmaincubememo.lines.add(\'\');
                  end;
                  
                  procedure tform1.showattachedcubeisocpositiondata();
                  var
                    isoccube : tisoccube;
                  begin
                    findisocattachedcubememo.lines.add(\'isoc readings.\');
                  
                    findisocattachedcubememo.lines.add(\'raw position measurements: -------------------\');
                    findisocattachedcubememo.lines.add(\'per sensor position and average\');
                  
                  
                    findisocattachedcubememo.lines.add(\'gantry 0 degrees collimator 0 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_0], true);
                    findisocattachedcubememo.lines.add(\'gantry 0 degrees collimator 180 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_180], true);
                  
                    findisocattachedcubememo.lines.add(\'gantry 90 degrees collimator 0 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_0], true);
                    findisocattachedcubememo.lines.add(\'gantry 90 degrees collimator 180 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_180], true);
                  
                    findisocattachedcubememo.lines.add(\'gantry 180 degrees collimator 0 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_0], true);
                    findisocattachedcubememo.lines.add(\'gantry 180 degrees collimator 180 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_180], true);
                  
                    findisocattachedcubememo.lines.add(\'gantry -90 degrees collimator 0 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_0], true);
                    findisocattachedcubememo.lines.add(\'gantry -90 degrees collimator 180 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_180], true);
                  
                  
                    findisocattachedcubememo.lines.add(\'isoc size measurements: -------------------\');
                    findisocattachedcubememo.lines.add(\'(min and max average position found per axis followed by size\');
                  
                    computeisocattachedcube(isoccube);
                  
                    findisocattachedcubememo.lines.add(\'isoc size attached cube\');
                    printisocreadings(findisocattachedcubememo, isoccube, false);
                  
                    fattachedcubecomputedisoccube := isoccube;
                  
                    findisocattachedcubememo.lines.add(\'\');
                  
                  end;
                  
                  function tform1.printisocvalue(value : longint) : string;
                  begin
                    if (value = gcinvalidisocvalue) then
                    begin
                      result := \'n/a\';
                    end
                    else
                    begin
                      result := format(\'%d\', [value]);
                    end;
                  end;
                  
                  procedure tform1.printisocreadings(memo : tmemo; isoc : tisoccube; avginsteadofdiff : boolean);
                  var
                    resultstringx, resultstringy, resultstringz : string;
                  begin
                    resultstringx := \'\';
                    resultstringx := resultstringx + \'x1: \' + printisocvalue(isoc.xl) + \'  \';
                    resultstringx := resultstringx + \'x2: \' + printisocvalue(isoc.xr) + \'  \';
                    if (avginsteadofdiff = true) then
                    begin
                      resultstringx := resultstringx + \'avg: \';
                    end
                    else
                    begin
                      resultstringx := resultstringx + \'diff: \';
                    end;
                  
                    if (isoc.xl = gcinvalidisocvalue) or (isoc.xr = gcinvalidisocvalue) then
                    begin
                      if (isoc.xl \<\> gcinvalidisocvalue) then
                      begin
                        resultstringx := resultstringx + printisocvalue(isoc.xl);
                      end
                      else if (isoc.xr \<\> gcinvalidisocvalue) then
                      begin
                        resultstringx := resultstringx + printisocvalue(isoc.xr);
                      end
                      else
                      begin
                        resultstringx := resultstringx + \'n/a\';
                      end;
                    end
                    else
                    begin
                      if (avginsteadofdiff) then
                      begin
                        resultstringx := resultstringx + printisocvalue((isoc.xl + isoc.xr) div 2);
                      end
                      else
                      begin
                        resultstringx := resultstringx + printisocvalue(isoc.xr - isoc.xl);
                      end;
                  
                    end;
                  
                    resultstringy := \'\';
                    resultstringy := resultstringy + \'y1: \' + printisocvalue(isoc.yf) + \'  \';
                    resultstringy := resultstringy + \'y2: \' + printisocvalue(isoc.yb) + \'  \';
                    if (avginsteadofdiff = true) then
                    begin
                      resultstringy := resultstringy + \'avg: \';
                    end
                    else
                    begin
                      resultstringy := resultstringy + \'diff: \';
                    end;
                  
                  
                    if (isoc.yf = gcinvalidisocvalue) or (isoc.yb = gcinvalidisocvalue) then
                    begin
                      if (isoc.yf \<\> gcinvalidisocvalue) then
                      begin
                        resultstringy := resultstringy + printisocvalue(isoc.yf);
                      end
                      else if (isoc.yb \<\> gcinvalidisocvalue) then
                      begin
                        resultstringy := resultstringy + printisocvalue(isoc.yb);
                      end
                      else
                      begin
                        resultstringy := resultstringy + \'n/a\';
                      end;
                    end
                    else
                    begin
                      if (avginsteadofdiff) then
                      begin
                        resultstringy := resultstringy + printisocvalue((isoc.yf + isoc.yb) div 2);
                      end
                      else
                      begin
                        resultstringy := resultstringy + printisocvalue(isoc.yb - isoc.yf);
                      end;
                    end;
                  
                  
                    resultstringz := \'\';
                    resultstringz := resultstringz + \'z1: \' + printisocvalue(isoc.zt) + \'  \';
                    resultstringz := resultstringz + \'z2: \' + printisocvalue(isoc.zb) + \'  \';
                    if (avginsteadofdiff = true) then
                    begin
                      resultstringz := resultstringz + \'avg: \';
                    end
                    else
                    begin
                      resultstringz := resultstringz + \'diff: \';
                    end;
                  
                  
                    if (isoc.zt = gcinvalidisocvalue) or (isoc.zb = gcinvalidisocvalue) then
                    begin
                      if (isoc.zt \<\> gcinvalidisocvalue) then
                      begin
                        resultstringz := resultstringz + printisocvalue(isoc.zt);
                      end
                      else if (isoc.zb \<\> gcinvalidisocvalue) then
                      begin
                        resultstringz := resultstringz + printisocvalue(isoc.zb);
                      end
                      else
                      begin
                        resultstringz := resultstringz + \'n/a\';
                      end;
                    end
                    else
                    begin
                      if (avginsteadofdiff) then
                      begin
                        resultstringz := resultstringz + printisocvalue((isoc.zt + isoc.zb) div 2);
                      end
                      else
                      begin
                        resultstringz := resultstringz + printisocvalue(isoc.zb - isoc.zt);
                      end;
                    end;
                  
                  
                    memo.lines.add(resultstringx);
                    memo.lines.add(resultstringy);
                    memo.lines.add(resultstringz);
                  end;
                  
                  procedure tform1.getxyzfromisoccube(angle : tisoccube; var x, y, z : longint);
                  var
                    counter : cardinal;
                  begin
                    x := 0;
                    y := 0;
                    z := 0;
                  
                    // x
                    counter := 0;
                    if (angle.xl \<\> gcinvalidisocvalue) then
                    begin
                      x := x + angle.xl;
                      inc(counter);
                    end;
                    if (angle.xr \<\> gcinvalidisocvalue) then
                    begin
                      x := x + angle.xr;
                      inc(counter);
                    end;
                  
                    if (counter \<\> 0) then
                    begin
                      x:= x div counter;
                    end
                    else
                    begin
                      x := gcinvalidisocvalue;
                    end;
                  
                    // y
                    counter := 0;
                    if (angle.yf \<\> gcinvalidisocvalue) then
                    begin
                      y := y + angle.yf;
                      inc(counter);
                    end;
                    if (angle.yb \<\> gcinvalidisocvalue) then
                    begin
                      y := y + angle.yb;
                      inc(counter);
                    end;
                  
                    if (counter \<\> 0) then
                    begin
                      y:= y div counter;
                    end
                    else
                    begin
                      y := gcinvalidisocvalue;
                    end;
                  
                    // z
                    counter := 0;
                    if (angle.zt \<\> gcinvalidisocvalue) then
                    begin
                      z := z + angle.zt;
                      inc(counter);
                    end;
                    if (angle.zb \<\> gcinvalidisocvalue) then
                    begin
                      z := z + angle.zb;
                      inc(counter);
                    end;
                  
                    if (counter \<\> 0) then
                    begin
                      z := z div counter;
                    end
                    else
                    begin
                      z := gcinvalidisocvalue;
                    end;
                  end;
                  
                  procedure tform1.getisocfromisoccube(angle : tisoccube; var isoc : tisoccube);
                  var
                    x, y, z : longint;
                  begin
                    // get averaged line measurements. (two measurement bottom and top are
                    // added and averaged to get one single position per plane axis
                  
                    getxyzfromisoccube(angle, x, y, z);
                  
                    isoc.xl := x;
                    isoc.xr := x;
                  
                    isoc.yf := y;
                    isoc.yb := y;
                  
                    isoc.zt := z;
                    isoc.zb := z;
                  end;
                  
                  procedure tform1.mergeisocsizefromisoccube(angle : tisoccube; var isoc : tisoccube);
                  var
                    x, y, z : longint;
                  begin
                    // get averaged line measurements. (two measurement bottom and top are
                    // added and averaged to get one single position per plane axis
                  
                    // merge them with existing cube. if no value is available, do nothing.
                  
                    getxyzfromisoccube(angle, x, y, z);
                  
                    if (x \<\> gcinvalidisocvalue) then
                    begin
                      if (isoc.xl = gcinvalidisocvalue) then
                      begin
                        isoc.xl := x;
                      end
                      else
                      begin
                        isoc.xl := min(isoc.xl, x);
                      end;
                  
                      if (isoc.xr = gcinvalidisocvalue) then
                      begin
                        isoc.xr := x;
                      end
                      else
                      begin
                        isoc.xr := max(isoc.xr, x);
                      end;
                    end;
                  
                    if (y \<\> gcinvalidisocvalue) then
                    begin
                      if (isoc.yf = gcinvalidisocvalue) then
                      begin
                        isoc.yf := y;
                      end
                      else
                      begin
                        isoc.yf := min(isoc.yf, y);
                      end;
                  
                      if (isoc.yb = gcinvalidisocvalue) then
                      begin
                        isoc.yb := y;
                      end
                      else
                      begin
                        isoc.yb := max(isoc.yb, y);
                      end;
                    end;
                  
                    if (z \<\> gcinvalidisocvalue) then
                    begin
                      if (isoc.zt = gcinvalidisocvalue) then
                      begin
                        isoc.zt := z;
                      end
                      else
                      begin
                        isoc.zt := min(isoc.zt, z);
                      end;
                  
                      if (isoc.zb = gcinvalidisocvalue) then
                      begin
                        isoc.zb := z;
                      end
                      else
                      begin
                        isoc.zb := max(isoc.zb, z);
                      end;
                    end;
                  end;
                  
                  procedure tform1.computeisocmaincube(var isoccube : tisoccube);
                  var
                    angle0ptr   : ^tisoccube;
                    angle180ptr : ^tisoccube;
                  
                    x, y, z     : longint;
                  begin
                  //  zeromemory(@isoccube, sizeof(tisoccube));
                    eraseisoccube(isoccube);
                  
                    angle0ptr   := addr(fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_0]);
                    angle180ptr := addr(fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_180]);
                  
                    getisocfromisoccube(angle0ptr^, isoccube);
                    mergeisocsizefromisoccube(angle180ptr^, isoccube);
                  end;
                  
                  procedure tform1.computeisocattachedcube(var isoccube : tisoccube);
                  var
                    angle0ptr   : ^tisoccube;
                    angle180ptr : ^tisoccube;
                  begin
                  //  zeromemory(@isoccube, sizeof(tisoccube));
                    eraseisoccube(isoccube);
                  
                    angle0ptr   := addr(fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_0]);
                    getisocfromisoccube(angle0ptr^, isoccube);
                    angle180ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_180]);
                    mergeisocsizefromisoccube(angle180ptr^, isoccube);
                  
                    angle0ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_0]);
                    mergeisocsizefromisoccube(angle0ptr^, isoccube);
                    angle180ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_180]);
                    mergeisocsizefromisoccube(angle180ptr^, isoccube);
                  
                    angle0ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_0]);
                    mergeisocsizefromisoccube(angle0ptr^, isoccube);
                    angle180ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_180]);
                    mergeisocsizefromisoccube(angle180ptr^, isoccube);
                  
                    angle0ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_0]);
                    mergeisocsizefromisoccube(angle0ptr^, isoccube);
                    angle180ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_180]);
                    mergeisocsizefromisoccube(angle180ptr^, isoccube);
                  end;
                  
                  procedure tform1.unionisoccubes(var isoccube : tisoccube; unioncube : tisoccube);
                  begin
                    if (unioncube.xl \< isoccube.xl) then
                      isoccube.xl := unioncube.xl;
                    if (unioncube.xr \> isoccube.xr) then
                      isoccube.xr := unioncube.xr;
                  
                    if (unioncube.yf \< isoccube.yf) then
                      isoccube.yf := unioncube.yf;
                    if (unioncube.yb \> isoccube.yb) then
                      isoccube.yb := unioncube.yb;
                  
                    if (unioncube.zt \< isoccube.zt) then
                      isoccube.zt := unioncube.zt;
                    if (unioncube.zb \> isoccube.zb) then
                      isoccube.zb := unioncube.zb;
                  end;
                  
                  
                  end.
                  ");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_Unit_002()
{
    return parse(#DelphiGrammar::Unit, "
                 TEST SENTENCE CLEARED HERE BECAUSE IT IS CLOSED SOURCE 
                  ");
}

test bool Test_TestCases_1_Unit()
{
    print("Running 3 tests for construction \'Unit\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "
                  unit mainform;
                  
                  interface
                  
                  uses
                    winapi.windows, winapi.messages, system.sysutils, system.variants, system.classes, vcl.graphics,
                    vcl.controls, vcl.forms, vcl.dialogs, vcl.stdctrls, serialmanager, serialprotocol,
                    vcl.extctrls, vcl.comctrls, settingsform, inifiles, vcl.menus, math;
                  
                  const
                    gcisocoperatingmodenone                   = 0;
                  
                    gcisocoperatingmodefindmaincubeisoc       = 1;
                    gcisocoperatingmodefindattachedcubeisoc   = 2;
                    gcisocoperatingmodecalibration            = 3;
                  
                  
                    gcisocmaincubeprogressgantry_0_collimator_0   = 1;
                    gcisocmaincubeprogressgantry_0_collimator_180 = 2;
                    gcisocmaincubeprogressshowresults             = 3;
                  
                    gcisocattachedcubeprogressgantry_0_collimator_0     = 1;
                    gcisocattachedcubeprogressgantry_0_collimator_180   = 2;
                  
                    gcisocattachedcubeprogressgantry_l90_collimator_0   = 3;
                    gcisocattachedcubeprogressgantry_l90_collimator_180 = 4;
                  
                    gcisocattachedcubeprogressgantry_180_collimator_0   = 5;
                    gcisocattachedcubeprogressgantry_180_collimator_180 = 6;
                  
                    gcisocattachedcubeprogressgantry_r90_collimator_0   = 7;
                    gcisocattachedcubeprogressgantry_r90_collimator_180 = 8;
                  
                    gcisocattachedcubeprogressshowresults               = 9;
                  
                    gcisoccalibrationneeded                             = 1;
                    gcisoccalibrationcompleted                          = 2;
                    gcisoccalibrationbusy                                                                         = 3;
                  
                    gcsweepplaneattachedtop     = 0;
                    gcsweepplaneattachedbottom  = 1;
                    gcsweepplaneattachedleft    = 2;
                    gcsweepplaneattachedright   = 3;
                    gcsweepplanemaintop         = 4;
                  
                    gccollimatorangle_0   = 0;
                    gccollimatorangle_180 = 1;
                  
                    gcinvalidisocvalue    : longint = $f0000000;
                  
                  type
                    tgsensorreading = record
                      x, y, z : single;
                    end;
                  
                    tisoccube       = record
                      xl, xr  : longint;
                      yf, yb  : longint;
                      zt, zb  : longint;
                    end;
                  
                    tisocplane    = record
                      collimatorangle : array[0..1] of tisoccube;
                    end;
                  
                    tisocmeasurements = record
                      plane : array[0..4] of tisocplane;
                    end;
                  
                    tform1 = class(tform)
                      timer_serialmaintenance: ttimer;
                      memoconsole: tmemo;
                      statusbar1: tstatusbar;
                      mainmenu1: tmainmenu;
                      isocfinder1: tmenuitem;
                      connect1: tmenuitem;
                      settings1: tmenuitem;
                      serialsettings1: tmenuitem;
                      disconnect1: tmenuitem;
                      n1: tmenuitem;
                      exit1: tmenuitem;
                      help1: tmenuitem;
                      about1: tmenuitem;
                      pagecontrol1: tpagecontrol;
                      tabsheet1: ttabsheet;
                      tabsheet2: ttabsheet;
                      button_test_getversion: tbutton;
                      button_test_sweep: tbutton;
                      button_test_sweepcompleted: tbutton;
                      button_test_resetisoccube: tbutton;
                      button_test_getisoccube: tbutton;
                      button_test_requestcalibration: tbutton;
                      button_test_iscalibrationcomplete: tbutton;
                      general: ttabsheet;
                      button_test_ismotorbusy: tbutton;
                      button_test_getcubeposition: tbutton;
                      button_test_setcubeposition: tbutton;
                      edit_x: tedit;
                      edit_y: tedit;
                      edit_z: tedit;
                      label1: tlabel;
                      label2: tlabel;
                      label3: tlabel;
                      button_test_setminusposition: tbutton;
                      button_test_setzeroposition: tbutton;
                      button_test_setplusposition: tbutton;
                      button_test_gsensor: tbutton;
                      tabsheetgsensor: ttabsheet;
                      gsensorimage: timage;
                      panel1: tpanel;
                      groupbox1: tgroupbox;
                      gsensormainxedit: tedit;
                      gsensormainyedit: tedit;
                      gsensormainzedit: tedit;
                      label4: tlabel;
                      label5: tlabel;
                      label6: tlabel;
                      timer_gsensor: ttimer;
                      panel2: tpanel;
                      button_maincubeisoc_restart: tbutton;
                      button_maincubeisoc_nextstep: tbutton;
                      button_maincubeisoc_sweep: tbutton;
                      button_maincubeisoc_center: tbutton;
                      label_maincubeisoc_0_0: tlabel;
                      label_maincubeisoc_0_180: tlabel;
                      label_maincubeisoc_results: tlabel;
                      panel3: tpanel;
                      label_calibrationrequired: tlabel;
                      label_calibrationcompleted: tlabel;
                      button_calibrate_start: tbutton;
                      timer_operation: ttimer;
                      findisocmaincubememo: tmemo;
                      tabsheet3: ttabsheet;
                      panel4: tpanel;
                      label_attachedcubeisoc_0_0: tlabel;
                      label_attachedcubeisoc_0_180: tlabel;
                      label_attachedcubeisoc_results: tlabel;
                      button_findattachedcube_start: tbutton;
                      button_findattachedcube_nextstep: tbutton;
                      button_findattachedcube_sweep: tbutton;
                      button_findattachedcube_centercube: tbutton;
                      findisocattachedcubememo: tmemo;
                      label_attachedcubeisoc_90_0: tlabel;
                      label_attachedcubeisoc_90_180: tlabel;
                      label_attachedcubeisoc_180_0: tlabel;
                      label_attachedcubeisoc_180_180: tlabel;
                      label_attachedcubeisoc_m90_0: tlabel;
                      label_attachedcubeisoc_m90_180: tlabel;
                      button_findattachedcube_prevstep: tbutton;
                      button_maincubeisoc_prevstep: tbutton;
                      procedure formcreate(sender: tobject);
                      procedure formdestroy(sender: tobject);
                      procedure timer_serialmaintenancetimer(sender: tobject);
                      procedure button_test_getversionclick(sender: tobject);
                      procedure button_test_sweepclick(sender: tobject);
                      procedure button_test_sweepcompletedclick(sender: tobject);
                      procedure button_test_resetisoccubeclick(sender: tobject);
                      procedure button_test_getisoccubeclick(sender: tobject);
                      procedure button_test_requestcalibrationclick(sender: tobject);
                      procedure button_test_iscalibrationcompleteclick(sender: tobject);
                      procedure formclose(sender: tobject; var action: tcloseaction);
                      procedure connect1click(sender: tobject);
                      procedure disconnect1click(sender: tobject);
                      procedure serialsettings1click(sender: tobject);
                      procedure exit1click(sender: tobject);
                      procedure button_test_ismotorbusyclick(sender: tobject);
                      procedure button_test_getcubepositionclick(sender: tobject);
                      procedure button_test_setcubepositionclick(sender: tobject);
                      procedure button_test_setminuspositionclick(sender: tobject);
                      procedure button_test_setzeropositionclick(sender: tobject);
                      procedure button_test_setpluspositionclick(sender: tobject);
                      procedure button_test_gsensorclick(sender: tobject);
                      procedure tabsheetgsensorshow(sender: tobject);
                      procedure tabsheetgsensorhide(sender: tobject);
                      procedure formresize(sender: tobject);
                      procedure timer_gsensortimer(sender: tobject);
                      procedure button_calibrate_startclick(sender: tobject);
                      procedure timer_operationtimer(sender: tobject);
                      procedure button_maincubeisoc_restartclick(sender: tobject);
                      procedure button_maincubeisoc_sweepclick(sender: tobject);
                      procedure button_maincubeisoc_nextstepclick(sender: tobject);
                      procedure button_findattachedcube_startclick(sender: tobject);
                      procedure button_findattachedcube_sweepclick(sender: tobject);
                      procedure button_findattachedcube_nextstepclick(sender: tobject);
                      procedure button_maincubeisoc_centerclick(sender: tobject);
                      procedure button_findattachedcube_centercubeclick(sender: tobject);
                      procedure button_findattachedcube_prevstepclick(sender: tobject);
                      procedure button_maincubeisoc_prevstepclick(sender: tobject);
                  
                    private
                      fserialmanager  : tserialmanager;
                  
                      fcommport             : string;
                      fcommconnectionstring : string;
                  
                      fserialconnectiononline : boolean;
                  
                      fgsensorreadingmaincube : tgsensorreading;
                  
                      fisocoperatingmodeprogressmaincube      : integer;
                      fisocoperatingmodeprogressattachedcube  : integer;
                      fisocoperatingmodeprogresscalibration   : integer;
                  
                      fisocoperatingmode              : integer;
                  
                      fisocmeasurements               : tisocmeasurements;
                  
                      faxissweepinprogress            : boolean;
                  
                      fattachedcubecomputedisoccube   : tisoccube;
                      fmaincubecomputedisoccube       : tisoccube;
                  
                      function issystembusywithoperationifsoprintonconsole(wantedoperationmode : integer) : boolean;
                  
                  
                      class procedure callbackversion(version : byte); static;
                      class procedure callbacksweepplane(); static;
                      class procedure callbacksweepplanecompleted(busy, completed : byte); static;
                      class procedure callbackresetisoccube(); static;
                      class procedure callbackgetisoccube(plane : byte;
                                                          xl, xr, yf, yb,
                                                          zt, zb : integer); static;
                      class procedure callbackrequestcalibrate(); static;
                      class procedure callbackcalibrationiscompleted(busy,
                                                                     completed : byte); static;
                  
                      class procedure callbacksetcubeposition(); static;
                      class procedure callbackgetcubeposition(x, y, z : longint); static;
                      class procedure callbackismotorbusy(motorisbusy : boolean); static;
                  
                      class procedure callbackgetgsensorinput(x, y, z : single); static;
                  
                    private
                      procedure showmaincubeisocpositiondata();
                      procedure showattachedcubeisocpositiondata();
                  
                      function printisocvalue(value : longint) : string;
                      procedure printisocreadings(memo : tmemo; isoc : tisoccube; avginsteadofdiff : boolean);
                  
                      procedure computeisocmaincube(var isoccube : tisoccube);
                      procedure computeisocattachedcube(var isoccube : tisoccube);
                  
                      procedure unionisoccubes(var isoccube : tisoccube; unioncube : tisoccube);
                  
                      procedure getxyzfromisoccube(angle : tisoccube; var x, y, z : longint);
                      procedure getisocfromisoccube(angle : tisoccube; var isoc : tisoccube);
                      procedure mergeisocsizefromisoccube(angle : tisoccube; var isoc : tisoccube);
                  
                      function formatresult(val : longint) : string;
                  
                      procedure eraseisocmeasurements();
                      procedure eraseisoccube(var cube : tisoccube);
                  
                    public
                  
                      procedure setgsensorinputmaincube(x, y, z : single);
                      procedure repaintgsensorbox();
                  
                      procedure updatecalibrationlabels();
                      procedure updatemaincubelabels();
                      procedure updateattachedcubelabels();
                  
                    public
                      procedure setcalibrationcompleted();
                      procedure getisoccube();
                      procedure setsweepcompleted();
                      procedure storesweepresult(plane : byte; xl, xr, yf, yb, zt, zb : longint);
                    end;
                  
                  implementation
                  end.",
// Sentence 001
                  "
                  unit mainform;
                  
                  interface
                  
                  uses
                    winapi.windows, winapi.messages, system.sysutils, system.variants, system.classes, vcl.graphics,
                    vcl.controls, vcl.forms, vcl.dialogs, vcl.stdctrls, serialmanager, serialprotocol,
                    vcl.extctrls, vcl.comctrls, settingsform, inifiles, vcl.menus, math;
                  
                  const
                    gcisocoperatingmodenone                   = 0;
                  
                    gcisocoperatingmodefindmaincubeisoc       = 1;
                    gcisocoperatingmodefindattachedcubeisoc   = 2;
                    gcisocoperatingmodecalibration            = 3;
                  
                  
                    gcisocmaincubeprogressgantry_0_collimator_0   = 1;
                    gcisocmaincubeprogressgantry_0_collimator_180 = 2;
                    gcisocmaincubeprogressshowresults             = 3;
                  
                    gcisocattachedcubeprogressgantry_0_collimator_0     = 1;
                    gcisocattachedcubeprogressgantry_0_collimator_180   = 2;
                  
                    gcisocattachedcubeprogressgantry_l90_collimator_0   = 3;
                    gcisocattachedcubeprogressgantry_l90_collimator_180 = 4;
                  
                    gcisocattachedcubeprogressgantry_180_collimator_0   = 5;
                    gcisocattachedcubeprogressgantry_180_collimator_180 = 6;
                  
                    gcisocattachedcubeprogressgantry_r90_collimator_0   = 7;
                    gcisocattachedcubeprogressgantry_r90_collimator_180 = 8;
                  
                    gcisocattachedcubeprogressshowresults               = 9;
                  
                    gcisoccalibrationneeded                             = 1;
                    gcisoccalibrationcompleted                          = 2;
                    gcisoccalibrationbusy								                = 3;
                  
                    gcsweepplaneattachedtop     = 0;
                    gcsweepplaneattachedbottom  = 1;
                    gcsweepplaneattachedleft    = 2;
                    gcsweepplaneattachedright   = 3;
                    gcsweepplanemaintop         = 4;
                  
                    gccollimatorangle_0   = 0;
                    gccollimatorangle_180 = 1;
                  
                    gcinvalidisocvalue    : longint = $f0000000;
                  
                  type
                    tgsensorreading = record
                      x, y, z : single;
                    end;
                  
                    tisoccube       = record
                      xl, xr  : longint;
                      yf, yb  : longint;
                      zt, zb  : longint;
                    end;
                  
                    tisocplane    = record
                      collimatorangle : array[0..1] of tisoccube;
                    end;
                  
                    tisocmeasurements = record
                      plane : array[0..4] of tisocplane;
                    end;
                  
                    tform1 = class(tform)
                      timer_serialmaintenance: ttimer;
                      memoconsole: tmemo;
                      statusbar1: tstatusbar;
                      mainmenu1: tmainmenu;
                      isocfinder1: tmenuitem;
                      connect1: tmenuitem;
                      settings1: tmenuitem;
                      serialsettings1: tmenuitem;
                      disconnect1: tmenuitem;
                      n1: tmenuitem;
                      exit1: tmenuitem;
                      help1: tmenuitem;
                      about1: tmenuitem;
                      pagecontrol1: tpagecontrol;
                      tabsheet1: ttabsheet;
                      tabsheet2: ttabsheet;
                      button_test_getversion: tbutton;
                      button_test_sweep: tbutton;
                      button_test_sweepcompleted: tbutton;
                      button_test_resetisoccube: tbutton;
                      button_test_getisoccube: tbutton;
                      button_test_requestcalibration: tbutton;
                      button_test_iscalibrationcomplete: tbutton;
                      general: ttabsheet;
                      button_test_ismotorbusy: tbutton;
                      button_test_getcubeposition: tbutton;
                      button_test_setcubeposition: tbutton;
                      edit_x: tedit;
                      edit_y: tedit;
                      edit_z: tedit;
                      label1: tlabel;
                      label2: tlabel;
                      label3: tlabel;
                      button_test_setminusposition: tbutton;
                      button_test_setzeroposition: tbutton;
                      button_test_setplusposition: tbutton;
                      button_test_gsensor: tbutton;
                      tabsheetgsensor: ttabsheet;
                      gsensorimage: timage;
                      panel1: tpanel;
                      groupbox1: tgroupbox;
                      gsensormainxedit: tedit;
                      gsensormainyedit: tedit;
                      gsensormainzedit: tedit;
                      label4: tlabel;
                      label5: tlabel;
                      label6: tlabel;
                      timer_gsensor: ttimer;
                      panel2: tpanel;
                      button_maincubeisoc_restart: tbutton;
                      button_maincubeisoc_nextstep: tbutton;
                      button_maincubeisoc_sweep: tbutton;
                      button_maincubeisoc_center: tbutton;
                      label_maincubeisoc_0_0: tlabel;
                      label_maincubeisoc_0_180: tlabel;
                      label_maincubeisoc_results: tlabel;
                      panel3: tpanel;
                      label_calibrationrequired: tlabel;
                      label_calibrationcompleted: tlabel;
                      button_calibrate_start: tbutton;
                      timer_operation: ttimer;
                      findisocmaincubememo: tmemo;
                      tabsheet3: ttabsheet;
                      panel4: tpanel;
                      label_attachedcubeisoc_0_0: tlabel;
                      label_attachedcubeisoc_0_180: tlabel;
                      label_attachedcubeisoc_results: tlabel;
                      button_findattachedcube_start: tbutton;
                      button_findattachedcube_nextstep: tbutton;
                      button_findattachedcube_sweep: tbutton;
                      button_findattachedcube_centercube: tbutton;
                      findisocattachedcubememo: tmemo;
                      label_attachedcubeisoc_90_0: tlabel;
                      label_attachedcubeisoc_90_180: tlabel;
                      label_attachedcubeisoc_180_0: tlabel;
                      label_attachedcubeisoc_180_180: tlabel;
                      label_attachedcubeisoc_m90_0: tlabel;
                      label_attachedcubeisoc_m90_180: tlabel;
                      button_findattachedcube_prevstep: tbutton;
                      button_maincubeisoc_prevstep: tbutton;
                      procedure formcreate(sender: tobject);
                      procedure formdestroy(sender: tobject);
                      procedure timer_serialmaintenancetimer(sender: tobject);
                      procedure button_test_getversionclick(sender: tobject);
                      procedure button_test_sweepclick(sender: tobject);
                      procedure button_test_sweepcompletedclick(sender: tobject);
                      procedure button_test_resetisoccubeclick(sender: tobject);
                      procedure button_test_getisoccubeclick(sender: tobject);
                      procedure button_test_requestcalibrationclick(sender: tobject);
                      procedure button_test_iscalibrationcompleteclick(sender: tobject);
                      procedure formclose(sender: tobject; var action: tcloseaction);
                      procedure connect1click(sender: tobject);
                      procedure disconnect1click(sender: tobject);
                      procedure serialsettings1click(sender: tobject);
                      procedure exit1click(sender: tobject);
                      procedure button_test_ismotorbusyclick(sender: tobject);
                      procedure button_test_getcubepositionclick(sender: tobject);
                      procedure button_test_setcubepositionclick(sender: tobject);
                      procedure button_test_setminuspositionclick(sender: tobject);
                      procedure button_test_setzeropositionclick(sender: tobject);
                      procedure button_test_setpluspositionclick(sender: tobject);
                      procedure button_test_gsensorclick(sender: tobject);
                      procedure tabsheetgsensorshow(sender: tobject);
                      procedure tabsheetgsensorhide(sender: tobject);
                      procedure formresize(sender: tobject);
                      procedure timer_gsensortimer(sender: tobject);
                      procedure button_calibrate_startclick(sender: tobject);
                      procedure timer_operationtimer(sender: tobject);
                      procedure button_maincubeisoc_restartclick(sender: tobject);
                      procedure button_maincubeisoc_sweepclick(sender: tobject);
                      procedure button_maincubeisoc_nextstepclick(sender: tobject);
                      procedure button_findattachedcube_startclick(sender: tobject);
                      procedure button_findattachedcube_sweepclick(sender: tobject);
                      procedure button_findattachedcube_nextstepclick(sender: tobject);
                      procedure button_maincubeisoc_centerclick(sender: tobject);
                      procedure button_findattachedcube_centercubeclick(sender: tobject);
                      procedure button_findattachedcube_prevstepclick(sender: tobject);
                      procedure button_maincubeisoc_prevstepclick(sender: tobject);
                  
                    private
                      fserialmanager  : tserialmanager;
                  
                      fcommport             : string;
                      fcommconnectionstring : string;
                  
                      fserialconnectiononline : boolean;
                  
                      fgsensorreadingmaincube : tgsensorreading;
                  
                      fisocoperatingmodeprogressmaincube      : integer;
                      fisocoperatingmodeprogressattachedcube  : integer;
                      fisocoperatingmodeprogresscalibration   : integer;
                  
                      fisocoperatingmode              : integer;
                  
                      fisocmeasurements               : tisocmeasurements;
                  
                      faxissweepinprogress            : boolean;
                  
                      fattachedcubecomputedisoccube   : tisoccube;
                      fmaincubecomputedisoccube       : tisoccube;
                  
                      function issystembusywithoperationifsoprintonconsole(wantedoperationmode : integer) : boolean;
                  
                  
                      class procedure callbackversion(version : byte); static;
                      class procedure callbacksweepplane(); static;
                      class procedure callbacksweepplanecompleted(busy, completed : byte); static;
                      class procedure callbackresetisoccube(); static;
                      class procedure callbackgetisoccube(plane : byte;
                                                          xl, xr, yf, yb,
                                                          zt, zb : integer); static;
                      class procedure callbackrequestcalibrate(); static;
                      class procedure callbackcalibrationiscompleted(busy,
                                                                     completed : byte); static;
                  
                      class procedure callbacksetcubeposition(); static;
                      class procedure callbackgetcubeposition(x, y, z : longint); static;
                      class procedure callbackismotorbusy(motorisbusy : boolean); static;
                  
                      class procedure callbackgetgsensorinput(x, y, z : single); static;
                  
                    private
                      procedure showmaincubeisocpositiondata();
                      procedure showattachedcubeisocpositiondata();
                  
                      function printisocvalue(value : longint) : string;
                      procedure printisocreadings(memo : tmemo; isoc : tisoccube; avginsteadofdiff : boolean);
                  
                      procedure computeisocmaincube(var isoccube : tisoccube);
                      procedure computeisocattachedcube(var isoccube : tisoccube);
                  
                      procedure unionisoccubes(var isoccube : tisoccube; unioncube : tisoccube);
                  
                      procedure getxyzfromisoccube(angle : tisoccube; var x, y, z : longint);
                      procedure getisocfromisoccube(angle : tisoccube; var isoc : tisoccube);
                      procedure mergeisocsizefromisoccube(angle : tisoccube; var isoc : tisoccube);
                  
                      function formatresult(val : longint) : string;
                  
                      procedure eraseisocmeasurements();
                      procedure eraseisoccube(var cube : tisoccube);
                  
                    public
                  
                      procedure setgsensorinputmaincube(x, y, z : single);
                      procedure repaintgsensorbox();
                  
                      procedure updatecalibrationlabels();
                      procedure updatemaincubelabels();
                      procedure updateattachedcubelabels();
                  
                    public
                      procedure setcalibrationcompleted();
                      procedure getisoccube();
                      procedure setsweepcompleted();
                      procedure storesweepresult(plane : byte; xl, xr, yf, yb, zt, zb : longint);
                    end;
                  
                  var
                    form1: tform1;
                  
                  implementation
                  
                  {$r *.dfm}
                  
                  
                  procedure tform1.eraseisoccube(var cube : tisoccube);
                  var
                    counterinner, counterouter : cardinal;
                  begin
                    with cube do
                    begin
                      xl := gcinvalidisocvalue;
                      xr := gcinvalidisocvalue;
                  
                      yf := gcinvalidisocvalue;
                      yb := gcinvalidisocvalue;
                  
                      zt := gcinvalidisocvalue;
                      zb := gcinvalidisocvalue;
                    end;
                  end;
                  
                  procedure tform1.eraseisocmeasurements();
                  var
                    counterinner, counterouter : cardinal;
                  begin
                    for counterouter := 0 to 4 do
                    begin
                      for counterinner := 0 to 1 do
                      begin
                        eraseisoccube(fisocmeasurements.plane[counterouter].collimatorangle[counterinner]);
                      end;
                    end;
                  end;
                  
                  class procedure tform1.callbackversion(version : byte);
                  begin
                    form1.memoconsole.lines.add(\'isoc finder version: \' + inttostr(version div 100) +
                                                \'.\' + inttostr(version mod 100) + \' found.\');
                  end;
                  
                  procedure tform1.connect1click(sender: tobject);
                  begin
                    if (fserialmanager.init(fcommport, fcommconnectionstring) = true) then
                    begin
                      memoconsole.lines.add(\'connected to port \'\'\' + fcommport + \'\'\' with string: \'\'\' +
                                            fcommconnectionstring + \'\'\'\');
                  
                      fserialmanager.setcallback_getversion(callbackversion);
                      fserialmanager.setcallback_sweepplane(callbacksweepplane);
                      fserialmanager.setcallback_issweepcompleted(callbacksweepplanecompleted);
                      fserialmanager.setcallback_resetisoccube(callbackresetisoccube);
                      fserialmanager.setcallback_getisoccube(callbackgetisoccube);
                      fserialmanager.setcallback_requestcalibrate(callbackrequestcalibrate);
                      fserialmanager.setcallback_iscalibrationcompleted(callbackcalibrationiscompleted);
                  
                      fserialmanager.setcallback_setcubeposition(callbacksetcubeposition);
                      fserialmanager.setcallback_getcubeposition(callbackgetcubeposition);
                      fserialmanager.setcallback_ismotorbusy(callbackismotorbusy);
                  
                      fserialmanager.setcallback_getgsensorinput(callbackgetgsensorinput);
                  
                      fserialmanager.getversion();
                  
                      fserialconnectiononline := true;
                    end
                    else
                    begin
                      memoconsole.lines.add(\'failed to connect to port \' + fcommport + \' with string: \'\'\' +
                                            fcommconnectionstring + \'\'\'\');
                      fserialconnectiononline := false;
                    end;
                  end;
                  
                  procedure tform1.disconnect1click(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                    begin
                      fserialmanager.exit;
                  
                      memoconsole.lines.add(\'disconnected from isoc finder\');
                    end;
                  end;
                  
                  procedure tform1.exit1click(sender: tobject);
                  begin
                    self.close();
                  end;
                  
                  class procedure tform1.callbacksweepplane();
                  begin
                  end;
                  
                  class procedure tform1.callbacksweepplanecompleted(busy, completed : byte);
                  begin
                    if (completed \<\> 0) then
                    begin
                      form1.setsweepcompleted();
                      form1.getisoccube();
                      form1.memoconsole.lines.add(\'sweep completed, retrieving isoc numbers\');
                    end;
                  end;
                  
                  class procedure tform1.callbackresetisoccube();
                  begin
                    form1.memoconsole.lines.add(\'callbackresetisoccube: \');
                  end;
                  
                  class procedure tform1.callbackgetisoccube(plane : byte;
                                                             xl, xr, yf,yb, zt,zb : integer);
                  begin
                    case plane of
                      gcserialmanager_sweepplane_main_top:
                        plane := gcsweepplanemaintop;
                      gcserialmanager_sweepplane_cube_top:
                        plane := gcsweepplaneattachedtop;
                      gcserialmanager_sweepplane_cube_bottom:
                        plane := gcsweepplaneattachedbottom;
                      gcserialmanager_sweepplane_cube_left:
                        plane := gcsweepplaneattachedleft;
                      gcserialmanager_sweepplane_cube_right:
                        plane := gcsweepplaneattachedright;
                    end;
                  
                    form1.storesweepresult(plane, xl, xr, yf, yb, zt, zb);
                  end;
                  
                  class procedure tform1.callbackrequestcalibrate();
                  begin
                    form1.memoconsole.lines.add(\'calibration requested\');
                  end;
                  
                  class procedure tform1.callbackcalibrationiscompleted(busy, completed : byte);
                  var
                    resultstring : string;
                  begin
                    if (boolean(completed) = true) then
                    begin
                      form1.setcalibrationcompleted();
                      form1.memoconsole.lines.add(\'calibration is completed\');
                    end;
                  end;
                  
                  class procedure tform1.callbacksetcubeposition();
                  begin
                    form1.memoconsole.lines.add(\'cube position set\');
                  end;
                  
                  class procedure tform1.callbackgetcubeposition(x, y, z : longint);
                  var
                    tempstring : string;
                  begin
                    tempstring := \'callbackgetcubeposition: x = \' + inttostr(x) + \' y = \' +
                                  inttostr(y) + \' z = \' + inttostr(z);
                  
                    form1.memoconsole.lines.add(tempstring);
                  end;
                  
                  class procedure tform1.callbackgetgsensorinput(x, y, z : single);
                  var
                    tempstring : string;
                  begin
                    form1.setgsensorinputmaincube(x, y, z);
                  
                    form1.gsensormainxedit.text := format(\'%.2f\', [x]);
                    form1.gsensormainyedit.text := format(\'%.2f\', [y]);
                    form1.gsensormainzedit.text := format(\'%.2f\', [z]);
                  end;
                  
                  class procedure tform1.callbackismotorbusy(motorisbusy : boolean);
                  begin
                    if (motorisbusy = true) then
                    begin
                      form1.memoconsole.lines.add(\'callbackismotorbusy: true\');
                    end
                    else
                      form1.memoconsole.lines.add(\'callbackismotorbusy: false\');
                  end;
                  
                  
                  procedure tform1.button_test_setcubepositionclick(sender: tobject);
                  var
                    x, y, z : longint;
                  begin
                    if (assigned(fserialmanager)) then
                    begin
                      x := strtoint(edit_x.text);
                      y := strtoint(edit_y.text);
                      z := strtoint(edit_z.text);
                  
                      fserialmanager.setcubeposition(x, y, z);
                  
                    end;
                  end;
                  
                  procedure tform1.button_test_setminuspositionclick(sender: tobject);
                  begin
                      fserialmanager.setcubeposition(-10000, -10000, -10000);
                  end;
                  
                  procedure tform1.button_test_setzeropositionclick(sender: tobject);
                  begin
                      fserialmanager.setcubeposition(0, 0, 0);
                  end;
                  
                  procedure tform1.button_test_setpluspositionclick(sender: tobject);
                  begin
                      fserialmanager.setcubeposition(10000, 10000, 10000);
                  end;
                  
                  procedure tform1.button_test_gsensorclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.getgsensorinput();
                  end;
                  
                  procedure tform1.button_findattachedcube_startclick(sender: tobject);
                  begin
                    fisocoperatingmode := gcisocoperatingmodefindattachedcubeisoc;
                    fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_r90_collimator_0;
                    //zeromemory(@fisocmeasurements, sizeof(tisocmeasurements));
                    eraseisocmeasurements();
                  
                    memoconsole.lines.add(\'\>\> start attached cube isoc search\');
                  end;
                  
                  procedure tform1.button_findattachedcube_nextstepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindattachedcubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    case fisocoperatingmodeprogressattachedcube of
                      gcisocattachedcubeprogressgantry_r90_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_r90_collimator_180;
                      gcisocattachedcubeprogressgantry_r90_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_0_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_0_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_0_collimator_180;
                      gcisocattachedcubeprogressgantry_0_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_l90_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_l90_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_l90_collimator_180;
                      gcisocattachedcubeprogressgantry_l90_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_180_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_180_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_180_collimator_180;
                      gcisocattachedcubeprogressgantry_180_collimator_180:
                        begin
                          fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressshowresults;
                          showattachedcubeisocpositiondata();
                        end;
                  
                      gcisocattachedcubeprogressshowresults:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressshowresults;
                    else
                      fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_r90_collimator_0;
                    end;
                  end;
                  
                  procedure tform1.button_findattachedcube_sweepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindattachedcubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    fisocoperatingmode := gcisocoperatingmodefindattachedcubeisoc;
                  
                    if (assigned(fserialmanager)) then
                    begin
                      case fisocoperatingmodeprogressattachedcube of
                        gcisocattachedcubeprogressgantry_0_collimator_0,
                        gcisocattachedcubeprogressgantry_0_collimator_180:
                        begin
                          fserialmanager.sweepplane(gcserialmanager_sweepplane_cube_top);
                          button_maincubeisoc_sweep.enabled := false;
                          faxissweepinprogress := true;
                        end;
                  
                        gcisocattachedcubeprogressgantry_l90_collimator_0,
                        gcisocattachedcubeprogressgantry_l90_collimator_180:
                        begin
                          fserialmanager.sweepplane(gcserialmanager_sweepplane_cube_left);
                          button_maincubeisoc_sweep.enabled := false;
                          faxissweepinprogress := true;
                        end;
                  
                        gcisocattachedcubeprogressgantry_180_collimator_0,
                        gcisocattachedcubeprogressgantry_180_collimator_180:
                        begin
                          fserialmanager.sweepplane(gcserialmanager_sweepplane_cube_bottom);
                          button_maincubeisoc_sweep.enabled := false;
                          faxissweepinprogress := true;
                        end;
                  
                        gcisocattachedcubeprogressgantry_r90_collimator_0,
                        gcisocattachedcubeprogressgantry_r90_collimator_180:
                        begin
                          fserialmanager.sweepplane(gcserialmanager_sweepplane_cube_right);
                          button_maincubeisoc_sweep.enabled := false;
                          faxissweepinprogress := true;
                        end;
                      end;
                    end;
                  end;
                  
                  procedure tform1.button_findattachedcube_centercubeclick(sender: tobject);
                  var
                    x, y, z : longint;
                    divider : cardinal;
                  begin
                    if (not assigned(fserialmanager)) then
                    begin
                      system.exit;
                    end;
                  
                    x       := 0;
                    divider := 0;
                    if (fattachedcubecomputedisoccube.xl \<\> gcinvalidisocvalue) then
                    begin
                      inc(x, fattachedcubecomputedisoccube.xl);
                      inc(divider);
                    end;
                    if (fattachedcubecomputedisoccube.xr \<\> gcinvalidisocvalue) then
                    begin
                      inc(x, fattachedcubecomputedisoccube.xr);
                      inc(divider);
                    end;
                    if (divider \<\> 0) and (divider \<\> 1) then
                    begin
                      x := x div divider;
                    end;
                  
                    y       := 0;
                    divider := 0;
                    if (fattachedcubecomputedisoccube.yf \<\> gcinvalidisocvalue) then
                    begin
                      inc(y, fattachedcubecomputedisoccube.yf);
                      inc(divider);
                    end;
                    if (fattachedcubecomputedisoccube.yb \<\> gcinvalidisocvalue) then
                    begin
                      inc(y, fattachedcubecomputedisoccube.yb);
                      inc(divider);
                    end;
                    if (divider \<\> 0) and (divider \<\> 1) then
                    begin
                      y := y div divider;
                    end;
                  
                    z       := 0;
                    divider := 0;
                    if (fattachedcubecomputedisoccube.zt \<\> gcinvalidisocvalue) then
                    begin
                      inc(z, fattachedcubecomputedisoccube.zt);
                      inc(divider);
                    end;
                    if (fattachedcubecomputedisoccube.zb \<\> gcinvalidisocvalue) then
                    begin
                      inc(z, fattachedcubecomputedisoccube.zb);
                      inc(divider);
                    end;
                    if (divider \<\> 0) and (divider \<\> 1) then
                    begin
                      z := z div divider;
                    end;
                  
                    fserialmanager.setcubeposition(x, y, z);
                  
                  end;
                  
                  procedure tform1.button_findattachedcube_prevstepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindattachedcubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    case fisocoperatingmodeprogressattachedcube of
                      gcisocattachedcubeprogressgantry_r90_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_r90_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_0_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_r90_collimator_180;
                      gcisocattachedcubeprogressgantry_0_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_0_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_l90_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_0_collimator_180;
                      gcisocattachedcubeprogressgantry_l90_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_l90_collimator_0;
                  
                      gcisocattachedcubeprogressgantry_180_collimator_0:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_l90_collimator_180;
                      gcisocattachedcubeprogressgantry_180_collimator_180:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_180_collimator_0;
                      gcisocattachedcubeprogressshowresults:
                        fisocoperatingmodeprogressattachedcube := gcisocattachedcubeprogressgantry_180_collimator_180;
                    end;
                  end;
                  
                  function tform1.issystembusywithoperationifsoprintonconsole(wantedoperationmode : integer) : boolean;
                  begin
                    if (fisocoperatingmode = wantedoperationmode) then
                    begin
                      result := false;
                      system.exit();
                    end;
                  
                    if (fisocoperatingmode \<\> gcisocoperatingmodenone) then
                    begin
                      case fisocoperatingmode of
                        gcisocoperatingmodefindmaincubeisoc:
                          memoconsole.lines.add(\'!!! main cube isoc center search still in progress.\');
                        gcisocoperatingmodefindattachedcubeisoc:
                          memoconsole.lines.add(\'!!!attached cube isoc center search still in progress.\');
                        gcisocoperatingmodecalibration:
                          memoconsole.lines.add(\'!!! calibration still in progress.\');
                        else
                          memoconsole.lines.add(\'!!! unknown operation still in progress.\');
                      end;
                      result := true;
                      system.exit();
                    end;
                    result := false;
                  end;
                  
                  procedure tform1.button_calibrate_startclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodecalibration) = true) then
                    begin
                      system.exit();
                    end;
                  
                    fisocoperatingmodeprogresscalibration := gcisoccalibrationneeded;
                  
                    if (assigned(fserialmanager)) then
                    begin
                      fisocoperatingmode := gcisocoperatingmodecalibration;
                      fisocoperatingmodeprogresscalibration := gcisoccalibrationbusy;
                  
                      // first calibrate, then set position of cube to 0, 0, 0
                      fserialmanager.requestcalibration();
                  
                      button_calibrate_start.enabled := false;
                    end;
                  end;
                  
                  procedure tform1.button_maincubeisoc_centerclick(sender: tobject);
                  var
                    x, y, z : longint;
                  begin
                    if (not assigned(fserialmanager)) then
                    begin
                      system.exit;
                    end;
                  
                    x := (fmaincubecomputedisoccube.xl + fmaincubecomputedisoccube.xr) div 2;
                    y := (fmaincubecomputedisoccube.yf + fmaincubecomputedisoccube.yb) div 2;
                    z := (fmaincubecomputedisoccube.zt + fmaincubecomputedisoccube.zb) div 2;
                  
                    fserialmanager.setcubeposition(x, y, z);
                  end;
                  
                  procedure tform1.button_maincubeisoc_nextstepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindmaincubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    case fisocoperatingmodeprogressmaincube of
                      gcisocmaincubeprogressgantry_0_collimator_0:
                        fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressgantry_0_collimator_180;
                      gcisocmaincubeprogressgantry_0_collimator_180:
                      begin
                        fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressshowresults;
                        showmaincubeisocpositiondata();
                      end;
                      gcisocmaincubeprogressshowresults:
                      begin
                        fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressshowresults;
                        fisocoperatingmode := gcisocoperatingmodenone;
                      end;
                    else
                      fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressgantry_0_collimator_0;
                    end;
                  end;
                  
                  procedure tform1.button_maincubeisoc_restartclick(sender: tobject);
                  begin
                    fisocoperatingmode := gcisocoperatingmodefindmaincubeisoc;
                    fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressgantry_0_collimator_0;
                  
                    eraseisocmeasurements();
                  
                    memoconsole.lines.add(\'\>\> start main cube isoc search\');
                  end;
                  
                  procedure tform1.button_maincubeisoc_sweepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindmaincubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    fisocoperatingmode := gcisocoperatingmodefindmaincubeisoc;
                  
                    if (assigned(fserialmanager)) then
                    begin
                      fserialmanager.sweepplane(gcserialmanager_sweepplane_main_top);
                      button_maincubeisoc_sweep.enabled := false;
                      faxissweepinprogress := true;
                    end;
                  end;
                  
                  procedure tform1.button_test_ismotorbusyclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.ismotorbusy();
                  end;
                  
                  procedure tform1.button_maincubeisoc_prevstepclick(sender: tobject);
                  begin
                    if (issystembusywithoperationifsoprintonconsole(gcisocoperatingmodefindmaincubeisoc) = true) then
                    begin
                      system.exit();
                    end;
                  
                    case fisocoperatingmodeprogressmaincube of
                      gcisocmaincubeprogressgantry_0_collimator_180:
                        fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressgantry_0_collimator_0;
                      gcisocmaincubeprogressshowresults:
                        fisocoperatingmodeprogressmaincube := gcisocmaincubeprogressgantry_0_collimator_180;
                    end;
                  end;
                  
                  procedure tform1.button_test_getcubepositionclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.getcubeposition();
                  end;
                  
                  procedure tform1.button_test_getversionclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.getversion();
                  end;
                  
                  procedure tform1.button_test_sweepclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.sweepplane(gcserial_protocol_plane_main_top);
                  end;
                  
                  procedure tform1.button_test_sweepcompletedclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.issweepcompleted();
                  end;
                  
                  procedure tform1.button_test_resetisoccubeclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.resetisoccube();
                  end;
                  
                  procedure tform1.button_test_getisoccubeclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.getisoccube(gcserial_protocol_plane_main_top);
                  end;
                  
                  procedure tform1.button_test_requestcalibrationclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.requestcalibration();
                  end;
                  
                  procedure tform1.button_test_iscalibrationcompleteclick(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                      fserialmanager.iscalibrationcomplete();
                  end;
                  
                  procedure tform1.formclose(sender: tobject; var action: tcloseaction);
                  begin
                    timer_serialmaintenance.enabled := false;
                    fserialmanager.exit;
                  end;
                  
                  procedure tform1.formcreate(sender: tobject);
                  var
                    inifile     : tinifile;
                    inifilename : string;
                  
                    tempstring  : string;
                  begin
                    fserialmanager := tserialmanager.create;
                  
                    inifilename := changefileext(application.exename, \'.ini\');
                    inifile := tinifile.create(inifilename);
                  
                    fcommport := \'\';
                    fcommconnectionstring := \'\';
                  
                    if (assigned(inifile)) then
                    begin
                      fcommport := inifile.readstring(\'comportsettings\', \'port\', \'\');
                      fcommconnectionstring := inifile.readstring(\'comportsettings\', \'connectionstring\', \'\');
                  
                      freeandnil(inifile);
                    end;
                  
                    repaintgsensorbox();
                  
                    fisocoperatingmodeprogressmaincube      := gcisocmaincubeprogressgantry_0_collimator_0;
                    fisocoperatingmodeprogressattachedcube  := gcisocattachedcubeprogressgantry_r90_collimator_0;
                    fisocoperatingmodeprogresscalibration   := gcisoccalibrationneeded;
                  
                    fisocoperatingmode              := gcisocoperatingmodenone;
                  
                    faxissweepinprogress            := false;
                  
                    updatecalibrationlabels();
                    updatemaincubelabels();
                    updateattachedcubelabels();
                  
                  //  zeromemory(@fattachedcubecomputedisoccube, sizeof(tisoccube));
                  //  zeromemory(@fmaincubecomputedisoccube, sizeof(tisoccube));
                  
                    eraseisoccube(fattachedcubecomputedisoccube);
                    eraseisoccube(fmaincubecomputedisoccube);
                  end;
                  
                  procedure tform1.formdestroy(sender: tobject);
                  begin
                    freeandnil(fserialmanager);
                  end;
                  
                  procedure tform1.formresize(sender: tobject);
                  begin
                    gsensorimage.picture.bitmap.width := gsensorimage.width;
                    gsensorimage.picture.bitmap.height := gsensorimage.height;
                  end;
                  
                  procedure tform1.serialsettings1click(sender: tobject);
                  begin
                    serialsettingsform.initform(fcommport, fcommconnectionstring);
                    if (serialsettingsform.showmodal = mrok) then
                    begin
                      fcommport := serialsettingsform.getselectedcomport();
                      fcommconnectionstring := serialsettingsform.getselectedconnectionstring();
                    end;
                  end;
                  
                  procedure tform1.tabsheetgsensorhide(sender: tobject);
                  begin
                    timer_gsensor.enabled := false;
                  end;
                  
                  procedure tform1.tabsheetgsensorshow(sender: tobject);
                  begin
                    timer_gsensor.enabled := true;
                  end;
                  
                  procedure tform1.timer_serialmaintenancetimer(sender: tobject);
                  begin
                    if (assigned(fserialmanager)) then
                    begin
                      fserialmanager.maintenancefunction();
                    end;
                  end;
                  
                  procedure tform1.timer_gsensortimer(sender: tobject);
                  begin
                    if (fserialconnectiononline = false) then
                      system.exit;
                  
                    // only update g sensor if looking at g sensor tabsheet.
                    if (pagecontrol1.tabindex \<\> 3) then
                      system.exit;
                  
                    fserialmanager.getgsensorinput();
                    repaintgsensorbox();
                  end;
                  
                  procedure tform1.timer_operationtimer(sender: tobject);
                  begin
                    updateattachedcubelabels();
                    updatemaincubelabels();
                    updatecalibrationlabels();
                  
                    case fisocoperatingmode of
                      gcisocoperatingmodenone:
                        begin
                          system.exit;
                        end;
                      gcisocoperatingmodefindmaincubeisoc:
                        begin
                          if (faxissweepinprogress = true) then
                          begin
                            if (assigned(fserialmanager)) then
                            begin
                              fserialmanager.issweepcompleted();
                            end;
                          end;
                        end;
                      gcisocoperatingmodefindattachedcubeisoc:
                        begin
                          if (faxissweepinprogress = true) then
                          begin
                            if (assigned(fserialmanager)) then
                            begin
                              fserialmanager.issweepcompleted();
                            end;
                          end;
                        end;
                      gcisocoperatingmodecalibration:
                        begin
                          if (fisocoperatingmodeprogresscalibration = gcisoccalibrationbusy) then
                          begin
                            if (assigned(fserialmanager)) then
                            begin
                              fserialmanager.iscalibrationcomplete();
                            end;
                          end;
                        end;
                    else
                      fisocoperatingmode := gcisocoperatingmodenone;
                      system.exit();
                    end;
                  end;
                  
                  procedure tform1.setgsensorinputmaincube(x, y, z : single);
                  begin
                    fgsensorreadingmaincube.x := x;
                    fgsensorreadingmaincube.y := y;
                    fgsensorreadingmaincube.z := z;
                  end;
                  
                  procedure tform1.repaintgsensorbox();
                  var
                    rect      : trect;
                    textrect  : trect;
                    counter   : cardinal;
                  
                    spacerx : single;
                    spacery : single;
                  
                    systemstring : system.string;
                    axisvalue    : single;
                  
                    center        : tpoint;
                  
                    savedalignment : word;
                  
                    readingpointpositionx, readingpointpositiony : single;
                  
                  begin
                    // calc some sizes
                    rect.left := 0;
                    rect.top  := 0;
                    rect.right := gsensorimage.width;
                    rect.bottom := gsensorimage.height;
                  
                    center.x := gsensorimage.width div 2;
                    center.y := gsensorimage.height div 2;
                  
                    spacerx := rect.width / 20;
                    spacery := rect.height / 20;
                  
                    // draw main rectangle
                  
                    gsensorimage.canvas.rectangle(rect);
                  
                    // draw position of main cube reading in red
                  
                    readingpointpositionx := gsensorimage.width;
                    readingpointpositionx := readingpointpositionx / 2 +
                                             (readingpointpositionx / 2) * fgsensorreadingmaincube.x;
                  
                    readingpointpositiony := gsensorimage.height;
                    readingpointpositiony := readingpointpositiony / 2 +
                                             (readingpointpositiony / 2) * fgsensorreadingmaincube.y * -1;
                  
                  
                    gsensorimage.canvas.brush.color := clred;
                  
                    gsensorimage.canvas.ellipse(round(readingpointpositionx - 5),
                                                round(readingpointpositiony - 5),
                                                round(readingpointpositionx + 5),
                                                round(readingpointpositiony + 5));
                  
                    // draw main rectangle and axis
                  
                    gsensorimage.canvas.brush.color := clwhite;
                  
                    gsensorimage.canvas.moveto(center.x, 0);
                    gsensorimage.canvas.lineto(center.x, rect.bottom);
                  
                    gsensorimage.canvas.moveto(0, center.y);
                    gsensorimage.canvas.lineto(rect.width, center.y);
                  
                    // set axis font size
                  
                    gsensorimage.canvas.font.size := 6;
                  
                    // draw axis lines & values for x axis
                  
                    for counter := 1 to 19 do
                    begin
                      textrect.left   := round(spacerx * counter) - 10;
                      textrect.right  := round(spacerx * counter) + 10;
                      textrect.top    := center.y + 5;
                      textrect.bottom := center.y + 20;
                  
                      if (counter \<\> 10) then
                      begin
                        axisvalue := counter;
                        axisvalue := (axisvalue - 10) / 10;
                        systemstring := format(\'%.1f\', [axisvalue]);
                        gsensorimage.canvas.textrect(textrect, systemstring,
                                                     [tfcenter, tfverticalcenter, tfsingleline]);
                  
                        gsensorimage.canvas.moveto(round(spacerx * counter), center.y - 5);
                        gsensorimage.canvas.lineto(round(spacerx * counter), center.y + 5);
                      end;
                    end;
                  
                    // draw axis lines & values for y axis
                  
                    for counter := 1 to 19 do
                    begin
                      textrect.left   := center.x - 5;
                      textrect.right  := center.x - 20;
                      textrect.top    := round(spacery * counter) - 10;
                      textrect.bottom := round(spacery * counter) + 10;
                  
                      if (counter \<\> 10) then
                      begin
                        axisvalue := counter;
                        axisvalue := (axisvalue - 10) / 10;
                        systemstring := format(\'%.1f\', [axisvalue]);
                        gsensorimage.canvas.textrect(textrect, systemstring,
                                                     [tfcenter, tfverticalcenter, tfsingleline]);
                  
                        gsensorimage.canvas.moveto(center.x - 5, round(spacery * counter));
                        gsensorimage.canvas.lineto(center.x + 5, round(spacery * counter));
                      end;
                    end;
                  end;
                  
                  procedure tform1.updatecalibrationlabels();
                  begin
                    if (fisocoperatingmodeprogresscalibration = gcisoccalibrationneeded) then
                    begin
                    	label_calibrationrequired.font.color := clred;
                    	label_calibrationcompleted.font.color := clblack;
                    end
                    else if (fisocoperatingmodeprogresscalibration = gcisoccalibrationcompleted) then
                    begin
                    	label_calibrationrequired.font.color := clgreen;
                    	label_calibrationcompleted.font.color := clgreen;
                    end;
                  end;
                  
                  procedure tform1.updatemaincubelabels();
                  begin
                    if (fisocoperatingmodeprogressmaincube = gcisocmaincubeprogressgantry_0_collimator_0) then
                    begin
                      label_maincubeisoc_0_0.font.color := clred;
                      label_maincubeisoc_0_180.font.color := clblack;
                      label_maincubeisoc_results.font.color := clblack;
                    end
                    else if (fisocoperatingmodeprogressmaincube = gcisocmaincubeprogressgantry_0_collimator_180) then
                    begin
                      label_maincubeisoc_0_0.font.color := clgreen;
                      label_maincubeisoc_0_180.font.color := clred;
                      label_maincubeisoc_results.font.color := clblack;
                    end
                    else if (fisocoperatingmodeprogressmaincube = gcisocmaincubeprogressshowresults) then
                    begin
                      label_maincubeisoc_0_0.font.color := clgreen;
                      label_maincubeisoc_0_180.font.color := clgreen;
                      label_maincubeisoc_results.font.color := clgreen;
                    end
                    else
                    begin
                  
                    end;
                  end;
                  
                  procedure tform1.updateattachedcubelabels();
                  var
                    labelarray  : array[0..8] of tlabel;
                    counter     : cardinal;
                    currentindex: cardinal;
                  begin
                  
                  
                    labelarray[0] := label_attachedcubeisoc_90_0;
                    labelarray[1] := label_attachedcubeisoc_90_180;
                  
                    labelarray[2] := label_attachedcubeisoc_0_0;
                    labelarray[3] := label_attachedcubeisoc_0_180;
                  
                    labelarray[4] := label_attachedcubeisoc_m90_0;
                    labelarray[5] := label_attachedcubeisoc_m90_180;
                  
                    labelarray[6] := label_attachedcubeisoc_180_0;
                    labelarray[7] := label_attachedcubeisoc_180_180;
                  
                  
                    labelarray[8] := label_attachedcubeisoc_results;
                  
                    case fisocoperatingmodeprogressattachedcube of
                      gcisocattachedcubeprogressgantry_r90_collimator_0:
                        currentindex := 0;
                      gcisocattachedcubeprogressgantry_r90_collimator_180:
                        currentindex := 1;
                      gcisocattachedcubeprogressgantry_0_collimator_0:
                        currentindex := 2;
                      gcisocattachedcubeprogressgantry_0_collimator_180:
                        currentindex := 3;
                      gcisocattachedcubeprogressgantry_l90_collimator_0:
                        currentindex := 4;
                      gcisocattachedcubeprogressgantry_l90_collimator_180:
                        currentindex := 5;
                      gcisocattachedcubeprogressgantry_180_collimator_0:
                        currentindex := 6;
                      gcisocattachedcubeprogressgantry_180_collimator_180:
                        currentindex := 7;
                  
                      gcisocattachedcubeprogressshowresults:
                        currentindex := 8;
                    end;
                  
                    if (currentindex \<\> 8) then
                    begin
                      labelarray[currentindex].font.color := clred;
                    end
                    else
                    begin
                      labelarray[currentindex].font.color := clgreen;
                    end;
                  
                    if (currentindex \> 0) then
                    begin
                      for counter := 0 to currentindex - 1 do
                      begin
                        labelarray[counter].font.color := clgreen;
                      end;
                    end;
                  
                    if (currentindex \< 8) then
                    begin
                      for counter := 8 downto currentindex + 1 do
                      begin
                        labelarray[counter].font.color := clblack;
                      end;
                    end;
                  end;
                  
                  procedure tform1.setcalibrationcompleted();
                  begin
                    fisocoperatingmodeprogresscalibration := gcisoccalibrationcompleted;
                    fisocoperatingmode                    := gcisocoperatingmodenone;
                  
                    // center cube afterwards.
                    if (assigned(fserialmanager)) then
                    begin
                      fserialmanager.setcubeposition(0, 0, 0);
                    end;
                  
                    button_calibrate_start.enabled := true;
                  end;
                  
                  procedure tform1.setsweepcompleted();
                  begin
                    faxissweepinprogress := false;
                    button_maincubeisoc_sweep.enabled := true;
                  end;
                  
                  
                  procedure tform1.getisoccube();
                  begin
                    if (not assigned(fserialmanager)) then
                    begin
                      system.exit();
                    end;
                  
                    case fisocoperatingmode of
                      gcisocoperatingmodefindmaincubeisoc:
                      begin
                        fserialmanager.getisoccube(gcserialmanager_sweepplane_main_top);
                      end;
                      gcisocoperatingmodefindattachedcubeisoc:
                      begin
                        case fisocoperatingmodeprogressattachedcube of
                          gcisocattachedcubeprogressgantry_0_collimator_0,
                          gcisocattachedcubeprogressgantry_0_collimator_180:
                            fserialmanager.getisoccube(gcserialmanager_sweepplane_cube_top);
                  
                          gcisocattachedcubeprogressgantry_l90_collimator_0,
                          gcisocattachedcubeprogressgantry_l90_collimator_180:
                            fserialmanager.getisoccube(gcserialmanager_sweepplane_cube_left);
                  
                          gcisocattachedcubeprogressgantry_180_collimator_0,
                          gcisocattachedcubeprogressgantry_180_collimator_180:
                            fserialmanager.getisoccube(gcserialmanager_sweepplane_cube_bottom);
                  
                          gcisocattachedcubeprogressgantry_r90_collimator_0,
                          gcisocattachedcubeprogressgantry_r90_collimator_180:
                            fserialmanager.getisoccube(gcserialmanager_sweepplane_cube_right);
                  
                        end;
                      end;
                    end;
                  end;
                  
                  function tform1.formatresult(val : longint) : string;
                  begin
                    if (val = gcinvalidisocvalue) then
                    begin
                      result := \'n/a\';
                    end
                    else
                    begin
                      result := format(\'%d\', [val]);
                    end;
                  end;
                  
                  procedure tform1.storesweepresult(plane : byte; xl, xr, yf, yb, zt, zb : longint);
                  var
                    isoccubeptr : ^tisoccube;
                    cubestored  : boolean;
                  
                    resultstring : string;
                  begin
                    cubestored := false;
                  
                    case fisocoperatingmode of
                      gcisocoperatingmodefindmaincubeisoc:
                      begin
                        case fisocoperatingmodeprogressmaincube of
                          gcisocmaincubeprogressgantry_0_collimator_0:
                            begin
                              if (plane = gcsweepplanemaintop) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_0]);
                                cubestored := true;
                              end;
                            end;
                          gcisocmaincubeprogressgantry_0_collimator_180:
                            begin
                              if (plane = gcsweepplanemaintop) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_180]);
                                cubestored := true;
                              end;
                            end;
                          gcisocmaincubeprogressshowresults:
                          begin
                          end;
                        end;
                      end;
                      gcisocoperatingmodefindattachedcubeisoc:
                      begin
                        case fisocoperatingmodeprogressattachedcube of
                          gcisocattachedcubeprogressgantry_0_collimator_0:
                            begin
                              if (plane = gcsweepplaneattachedtop) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_0]);
                                cubestored := true;
                              end;
                            end;
                          gcisocattachedcubeprogressgantry_0_collimator_180:
                            begin
                              if (plane = gcsweepplaneattachedtop) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_180]);
                                cubestored := true;
                              end;
                            end;
                  
                          gcisocattachedcubeprogressgantry_l90_collimator_0:
                            begin
                              if (plane = gcsweepplaneattachedleft) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_0]);
                                cubestored := true;
                              end;
                            end;
                          gcisocattachedcubeprogressgantry_l90_collimator_180:
                            begin
                              if (plane = gcsweepplaneattachedleft) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_180]);
                                cubestored := true;
                              end;
                            end;
                  
                          gcisocattachedcubeprogressgantry_180_collimator_0:
                            begin
                              if (plane = gcsweepplaneattachedbottom) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_0]);
                                cubestored := true;
                              end;
                            end;
                  
                          gcisocattachedcubeprogressgantry_180_collimator_180:
                            begin
                              if (plane = gcsweepplaneattachedbottom) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_180]);
                                cubestored := true;
                              end;
                            end;
                  
                          gcisocattachedcubeprogressgantry_r90_collimator_0:
                            begin
                              if (plane = gcsweepplaneattachedright) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_0]);
                                cubestored := true;
                              end;
                            end;
                  
                          gcisocattachedcubeprogressgantry_r90_collimator_180:
                            begin
                              if (plane = gcsweepplaneattachedright) then
                              begin
                                isoccubeptr := addr(fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_180]);
                                cubestored := true;
                              end;
                            end;
                        end;
                      end;
                    end;
                  
                    if (cubestored = false) then
                    begin
                      memoconsole.lines.add(\'cube not stored...\');
                    end
                    else
                    begin
                      memoconsole.lines.add(\'cube downloaded and stored...\');
                  
                      resultstring := format(\'%u | \', [plane]);
                  
                      resultstring := resultstring + formatresult(xl) + \' \';
                      resultstring := resultstring + formatresult(xr) + \' | \';
                  
                      resultstring := resultstring + formatresult(yf) + \' \';
                      resultstring := resultstring + formatresult(yb) + \' | \';
                  
                      resultstring := resultstring + formatresult(zt) + \' \';
                      resultstring := resultstring + formatresult(zb) + \' | \';
                  
                      memoconsole.lines.add(resultstring);
                  
                      isoccubeptr^.xl := xl;
                      isoccubeptr^.xr := xr;
                  
                      isoccubeptr^.yf := yf;
                      isoccubeptr^.yb := yb;
                  
                      isoccubeptr^.zt := zt;
                      isoccubeptr^.zb := zb;
                    end;
                  end;
                  
                  procedure tform1.showmaincubeisocpositiondata();
                  var
                    isoccube : tisoccube;
                  begin
                    findisocmaincubememo.lines.add(\'isoc readings.\');
                  
                    findisocattachedcubememo.lines.add(\'raw position measurements: -------------------\');
                    findisocattachedcubememo.lines.add(\'per sensor position and average\');
                  
                  
                    findisocmaincubememo.lines.add(\'collimator 0 degrees\');
                    printisocreadings(findisocmaincubememo,
                                fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_0], true);
                    findisocmaincubememo.lines.add(\'collimator 180 degrees\');
                    printisocreadings(findisocmaincubememo,
                                fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_180], true);
                  
                    computeisocmaincube(isoccube);
                  
                    findisocattachedcubememo.lines.add(\'isoc size measurements: -------------------\');
                    findisocattachedcubememo.lines.add(\'(min and max average position found per axis followed by size\');
                  
                    printisocreadings(findisocmaincubememo, isoccube, false);
                  
                    fmaincubecomputedisoccube := isoccube;
                  
                    findisocmaincubememo.lines.add(\'\');
                  end;
                  
                  procedure tform1.showattachedcubeisocpositiondata();
                  var
                    isoccube : tisoccube;
                  begin
                    findisocattachedcubememo.lines.add(\'isoc readings.\');
                  
                    findisocattachedcubememo.lines.add(\'raw position measurements: -------------------\');
                    findisocattachedcubememo.lines.add(\'per sensor position and average\');
                  
                  
                    findisocattachedcubememo.lines.add(\'gantry 0 degrees collimator 0 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_0], true);
                    findisocattachedcubememo.lines.add(\'gantry 0 degrees collimator 180 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_180], true);
                  
                    findisocattachedcubememo.lines.add(\'gantry 90 degrees collimator 0 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_0], true);
                    findisocattachedcubememo.lines.add(\'gantry 90 degrees collimator 180 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_180], true);
                  
                    findisocattachedcubememo.lines.add(\'gantry 180 degrees collimator 0 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_0], true);
                    findisocattachedcubememo.lines.add(\'gantry 180 degrees collimator 180 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_180], true);
                  
                    findisocattachedcubememo.lines.add(\'gantry -90 degrees collimator 0 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_0], true);
                    findisocattachedcubememo.lines.add(\'gantry -90 degrees collimator 180 degrees\');
                    printisocreadings(findisocattachedcubememo,
                                fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_180], true);
                  
                  
                    findisocattachedcubememo.lines.add(\'isoc size measurements: -------------------\');
                    findisocattachedcubememo.lines.add(\'(min and max average position found per axis followed by size\');
                  
                    computeisocattachedcube(isoccube);
                  
                    findisocattachedcubememo.lines.add(\'isoc size attached cube\');
                    printisocreadings(findisocattachedcubememo, isoccube, false);
                  
                    fattachedcubecomputedisoccube := isoccube;
                  
                    findisocattachedcubememo.lines.add(\'\');
                  
                  end;
                  
                  function tform1.printisocvalue(value : longint) : string;
                  begin
                    if (value = gcinvalidisocvalue) then
                    begin
                      result := \'n/a\';
                    end
                    else
                    begin
                      result := format(\'%d\', [value]);
                    end;
                  end;
                  
                  procedure tform1.printisocreadings(memo : tmemo; isoc : tisoccube; avginsteadofdiff : boolean);
                  var
                    resultstringx, resultstringy, resultstringz : string;
                  begin
                    resultstringx := \'\';
                    resultstringx := resultstringx + \'x1: \' + printisocvalue(isoc.xl) + \'  \';
                    resultstringx := resultstringx + \'x2: \' + printisocvalue(isoc.xr) + \'  \';
                    if (avginsteadofdiff = true) then
                    begin
                      resultstringx := resultstringx + \'avg: \';
                    end
                    else
                    begin
                      resultstringx := resultstringx + \'diff: \';
                    end;
                  
                    if (isoc.xl = gcinvalidisocvalue) or (isoc.xr = gcinvalidisocvalue) then
                    begin
                      if (isoc.xl \<\> gcinvalidisocvalue) then
                      begin
                        resultstringx := resultstringx + printisocvalue(isoc.xl);
                      end
                      else if (isoc.xr \<\> gcinvalidisocvalue) then
                      begin
                        resultstringx := resultstringx + printisocvalue(isoc.xr);
                      end
                      else
                      begin
                        resultstringx := resultstringx + \'n/a\';
                      end;
                    end
                    else
                    begin
                      if (avginsteadofdiff) then
                      begin
                        resultstringx := resultstringx + printisocvalue((isoc.xl + isoc.xr) div 2);
                      end
                      else
                      begin
                        resultstringx := resultstringx + printisocvalue(isoc.xr - isoc.xl);
                      end;
                  
                    end;
                  
                    resultstringy := \'\';
                    resultstringy := resultstringy + \'y1: \' + printisocvalue(isoc.yf) + \'  \';
                    resultstringy := resultstringy + \'y2: \' + printisocvalue(isoc.yb) + \'  \';
                    if (avginsteadofdiff = true) then
                    begin
                      resultstringy := resultstringy + \'avg: \';
                    end
                    else
                    begin
                      resultstringy := resultstringy + \'diff: \';
                    end;
                  
                  
                    if (isoc.yf = gcinvalidisocvalue) or (isoc.yb = gcinvalidisocvalue) then
                    begin
                      if (isoc.yf \<\> gcinvalidisocvalue) then
                      begin
                        resultstringy := resultstringy + printisocvalue(isoc.yf);
                      end
                      else if (isoc.yb \<\> gcinvalidisocvalue) then
                      begin
                        resultstringy := resultstringy + printisocvalue(isoc.yb);
                      end
                      else
                      begin
                        resultstringy := resultstringy + \'n/a\';
                      end;
                    end
                    else
                    begin
                      if (avginsteadofdiff) then
                      begin
                        resultstringy := resultstringy + printisocvalue((isoc.yf + isoc.yb) div 2);
                      end
                      else
                      begin
                        resultstringy := resultstringy + printisocvalue(isoc.yb - isoc.yf);
                      end;
                    end;
                  
                  
                    resultstringz := \'\';
                    resultstringz := resultstringz + \'z1: \' + printisocvalue(isoc.zt) + \'  \';
                    resultstringz := resultstringz + \'z2: \' + printisocvalue(isoc.zb) + \'  \';
                    if (avginsteadofdiff = true) then
                    begin
                      resultstringz := resultstringz + \'avg: \';
                    end
                    else
                    begin
                      resultstringz := resultstringz + \'diff: \';
                    end;
                  
                  
                    if (isoc.zt = gcinvalidisocvalue) or (isoc.zb = gcinvalidisocvalue) then
                    begin
                      if (isoc.zt \<\> gcinvalidisocvalue) then
                      begin
                        resultstringz := resultstringz + printisocvalue(isoc.zt);
                      end
                      else if (isoc.zb \<\> gcinvalidisocvalue) then
                      begin
                        resultstringz := resultstringz + printisocvalue(isoc.zb);
                      end
                      else
                      begin
                        resultstringz := resultstringz + \'n/a\';
                      end;
                    end
                    else
                    begin
                      if (avginsteadofdiff) then
                      begin
                        resultstringz := resultstringz + printisocvalue((isoc.zt + isoc.zb) div 2);
                      end
                      else
                      begin
                        resultstringz := resultstringz + printisocvalue(isoc.zb - isoc.zt);
                      end;
                    end;
                  
                  
                    memo.lines.add(resultstringx);
                    memo.lines.add(resultstringy);
                    memo.lines.add(resultstringz);
                  end;
                  
                  procedure tform1.getxyzfromisoccube(angle : tisoccube; var x, y, z : longint);
                  var
                    counter : cardinal;
                  begin
                    x := 0;
                    y := 0;
                    z := 0;
                  
                    // x
                    counter := 0;
                    if (angle.xl \<\> gcinvalidisocvalue) then
                    begin
                      x := x + angle.xl;
                      inc(counter);
                    end;
                    if (angle.xr \<\> gcinvalidisocvalue) then
                    begin
                      x := x + angle.xr;
                      inc(counter);
                    end;
                  
                    if (counter \<\> 0) then
                    begin
                      x:= x div counter;
                    end
                    else
                    begin
                      x := gcinvalidisocvalue;
                    end;
                  
                    // y
                    counter := 0;
                    if (angle.yf \<\> gcinvalidisocvalue) then
                    begin
                      y := y + angle.yf;
                      inc(counter);
                    end;
                    if (angle.yb \<\> gcinvalidisocvalue) then
                    begin
                      y := y + angle.yb;
                      inc(counter);
                    end;
                  
                    if (counter \<\> 0) then
                    begin
                      y:= y div counter;
                    end
                    else
                    begin
                      y := gcinvalidisocvalue;
                    end;
                  
                    // z
                    counter := 0;
                    if (angle.zt \<\> gcinvalidisocvalue) then
                    begin
                      z := z + angle.zt;
                      inc(counter);
                    end;
                    if (angle.zb \<\> gcinvalidisocvalue) then
                    begin
                      z := z + angle.zb;
                      inc(counter);
                    end;
                  
                    if (counter \<\> 0) then
                    begin
                      z := z div counter;
                    end
                    else
                    begin
                      z := gcinvalidisocvalue;
                    end;
                  end;
                  
                  procedure tform1.getisocfromisoccube(angle : tisoccube; var isoc : tisoccube);
                  var
                    x, y, z : longint;
                  begin
                    // get averaged line measurements. (two measurement bottom and top are
                    // added and averaged to get one single position per plane axis
                  
                    getxyzfromisoccube(angle, x, y, z);
                  
                    isoc.xl := x;
                    isoc.xr := x;
                  
                    isoc.yf := y;
                    isoc.yb := y;
                  
                    isoc.zt := z;
                    isoc.zb := z;
                  end;
                  
                  procedure tform1.mergeisocsizefromisoccube(angle : tisoccube; var isoc : tisoccube);
                  var
                    x, y, z : longint;
                  begin
                    // get averaged line measurements. (two measurement bottom and top are
                    // added and averaged to get one single position per plane axis
                  
                    // merge them with existing cube. if no value is available, do nothing.
                  
                    getxyzfromisoccube(angle, x, y, z);
                  
                    if (x \<\> gcinvalidisocvalue) then
                    begin
                      if (isoc.xl = gcinvalidisocvalue) then
                      begin
                        isoc.xl := x;
                      end
                      else
                      begin
                        isoc.xl := min(isoc.xl, x);
                      end;
                  
                      if (isoc.xr = gcinvalidisocvalue) then
                      begin
                        isoc.xr := x;
                      end
                      else
                      begin
                        isoc.xr := max(isoc.xr, x);
                      end;
                    end;
                  
                    if (y \<\> gcinvalidisocvalue) then
                    begin
                      if (isoc.yf = gcinvalidisocvalue) then
                      begin
                        isoc.yf := y;
                      end
                      else
                      begin
                        isoc.yf := min(isoc.yf, y);
                      end;
                  
                      if (isoc.yb = gcinvalidisocvalue) then
                      begin
                        isoc.yb := y;
                      end
                      else
                      begin
                        isoc.yb := max(isoc.yb, y);
                      end;
                    end;
                  
                    if (z \<\> gcinvalidisocvalue) then
                    begin
                      if (isoc.zt = gcinvalidisocvalue) then
                      begin
                        isoc.zt := z;
                      end
                      else
                      begin
                        isoc.zt := min(isoc.zt, z);
                      end;
                  
                      if (isoc.zb = gcinvalidisocvalue) then
                      begin
                        isoc.zb := z;
                      end
                      else
                      begin
                        isoc.zb := max(isoc.zb, z);
                      end;
                    end;
                  end;
                  
                  procedure tform1.computeisocmaincube(var isoccube : tisoccube);
                  var
                    angle0ptr   : ^tisoccube;
                    angle180ptr : ^tisoccube;
                  
                    x, y, z     : longint;
                  begin
                  //  zeromemory(@isoccube, sizeof(tisoccube));
                    eraseisoccube(isoccube);
                  
                    angle0ptr   := addr(fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_0]);
                    angle180ptr := addr(fisocmeasurements.plane[gcsweepplanemaintop].collimatorangle[gccollimatorangle_180]);
                  
                    getisocfromisoccube(angle0ptr^, isoccube);
                    mergeisocsizefromisoccube(angle180ptr^, isoccube);
                  end;
                  
                  procedure tform1.computeisocattachedcube(var isoccube : tisoccube);
                  var
                    angle0ptr   : ^tisoccube;
                    angle180ptr : ^tisoccube;
                  begin
                  //  zeromemory(@isoccube, sizeof(tisoccube));
                    eraseisoccube(isoccube);
                  
                    angle0ptr   := addr(fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_0]);
                    getisocfromisoccube(angle0ptr^, isoccube);
                    angle180ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedtop].collimatorangle[gccollimatorangle_180]);
                    mergeisocsizefromisoccube(angle180ptr^, isoccube);
                  
                    angle0ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_0]);
                    mergeisocsizefromisoccube(angle0ptr^, isoccube);
                    angle180ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedbottom].collimatorangle[gccollimatorangle_180]);
                    mergeisocsizefromisoccube(angle180ptr^, isoccube);
                  
                    angle0ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_0]);
                    mergeisocsizefromisoccube(angle0ptr^, isoccube);
                    angle180ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedleft].collimatorangle[gccollimatorangle_180]);
                    mergeisocsizefromisoccube(angle180ptr^, isoccube);
                  
                    angle0ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_0]);
                    mergeisocsizefromisoccube(angle0ptr^, isoccube);
                    angle180ptr := addr(fisocmeasurements.plane[gcsweepplaneattachedright].collimatorangle[gccollimatorangle_180]);
                    mergeisocsizefromisoccube(angle180ptr^, isoccube);
                  end;
                  
                  procedure tform1.unionisoccubes(var isoccube : tisoccube; unioncube : tisoccube);
                  begin
                    if (unioncube.xl \< isoccube.xl) then
                      isoccube.xl := unioncube.xl;
                    if (unioncube.xr \> isoccube.xr) then
                      isoccube.xr := unioncube.xr;
                  
                    if (unioncube.yf \< isoccube.yf) then
                      isoccube.yf := unioncube.yf;
                    if (unioncube.yb \> isoccube.yb) then
                      isoccube.yb := unioncube.yb;
                  
                    if (unioncube.zt \< isoccube.zt) then
                      isoccube.zt := unioncube.zt;
                    if (unioncube.zb \> isoccube.zb) then
                      isoccube.zb := unioncube.zb;
                  end;
                  
                  
                  end.
                  ",

		  "SENTENCE OMITTED HERE BECAUSE IT IS CLOSED SOURCE
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..3])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::Unit, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::Unit, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::Unit, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_VarDecl_000()
{
    return parse(#DelphiGrammar::VarDecl, "a,b,c : cardinal;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_VarDecl_001()
{
    return parse(#DelphiGrammar::VarDecl, "a,b,c : tobjec deprecated = 10;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_VarDecl_002()
{
    return parse(#DelphiGrammar::VarDecl, "a,b,c : tobjec deprecated;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_VarDecl_003()
{
    return parse(#DelphiGrammar::VarDecl, "a,b,c : tobjec;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_VarDecl_004()
{
    return parse(#DelphiGrammar::VarDecl, "a,b:integer;");
}

test bool Test_TestCases_1_VarDecl()
{
    print("Running 5 tests for construction \'VarDecl\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "a,b,c : cardinal;",
// Sentence 001
                  "a,b,c : tobjec deprecated = 10;",
// Sentence 002
                  "a,b,c : tobjec deprecated;",
// Sentence 003
                  "a,b,c : tobjec;",
// Sentence 004
                  "a,b:integer;"
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..5])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::VarDecl, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::VarDecl, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::VarDecl, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_VarSection_000()
{
    return parse(#DelphiGrammar::VarSection, "var a,b : integer;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_VarSection_001()
{
    return parse(#DelphiGrammar::VarSection, "var a,b : integer;  c,d: cardinal;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_VarSection_002()
{
    return parse(#DelphiGrammar::VarSection, "var a,b : integer;");
}

Tree Test_CreateTree_ShouldSucceed_TestCases_1_VarSection_003()
{
    return parse(#DelphiGrammar::VarSection, "var a,b : integer;  c,d: cardinal;");
}

test bool Test_TestCases_1_VarSection()
{
    print("Running 4 tests for construction \'VarSection\'\n");     // Patterns that must succeed

    successSet = [
// Sentence 000
                  "var a,b : integer;",
// Sentence 001
                  "var a,b : integer;  c,d: cardinal;",
// Sentence 002
                  "var a,b : integer;",
// Sentence 003
                  "var a,b : integer;  c,d: cardinal;"
                 ];

    // Patterns that must fail
    failSet = [
              ];

    // Test code

    bool globalTestResult  = true;
    bool lastTestResult  = true;
    bool parseResult = false;
    int failCounter = 0; 
    

    Tree tree;

    for (testIndex <- [0..4])
    {
        lastTestResult = true;
        try
        {
            testText = successSet[testIndex];
            tree = parse(#DelphiGrammar::VarSection, testText);
        }
        catch: 
        {
            print("Test that should succeed failed on sentence number: ");
            println(testIndex);
            globalTestResult = false;
            lastTestResult = false;
            failCounter = failCounter + 1;
        }

        if (lastTestResult == true)
        {
            parseResult = /amb(_) := tree;
            if (parseResult == true)
            {
                print("Parse succeeded but tree is ambiguous for sentence number: "); 
                println(testIndex);
                failCounter = failCounter + 1;
            }
            try
            {
                implode(#DelphiAst::VarSection, tree);
            }
            catch:
            {
                println("Implode failed for sentence number <testIndex>");
                failCounter = failCounter + 1;
            }
        }
    }
    bool currentSentenceHasFailed = false;

    for (testIndex <- [0..0])
    {
        currentSentenceHasFailed = false;
        try
        {
            testText = failSet[testIndex];
            parse(#DelphiGrammar::VarSection, testText);
        }
        catch:
        {
            currentSentenceHasFailed = true;
        }

        if (currentSentenceHasFailed == false)
        {
            println("Test that should fail succeeded for sentence number: "); 
            println(testIndex);
            globalTestResult = false;
            failCounter = failCounter + 1;
        }
    }

    if (failCounter != 0)
    {

        print("Number of problems encountered:");
         println(failCounter);
     }

    return globalTestResult;
}
